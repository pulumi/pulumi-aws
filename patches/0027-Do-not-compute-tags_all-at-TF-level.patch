From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Anton Tayanovskyy <anton@pulumi.com>
Date: Mon, 6 Nov 2023 11:17:16 -0500
Subject: [PATCH] Do not compute tags_all at TF level


diff --git a/internal/framework/resource_with_configure.go b/internal/framework/resource_with_configure.go
index 7c33a2aae0..3c17d64604 100644
--- a/internal/framework/resource_with_configure.go
+++ b/internal/framework/resource_with_configure.go
@@ -30,6 +30,11 @@ func (r *ResourceWithConfigure) Configure(_ context.Context, request resource.Co
 
 // SetTagsAll calculates the new value for the `tags_all` attribute.
 func (r *ResourceWithConfigure) SetTagsAll(ctx context.Context, request resource.ModifyPlanRequest, response *resource.ModifyPlanResponse) {
+	// Skip SetTagsAll in Pulumi because it is handled at Pulumi provider level.
+	if 1+1 == 2 {
+		return
+	}
+
 	// If the entire plan is null, the resource is planned for destruction.
 	if request.Plan.Raw.IsNull() {
 		return
diff --git a/internal/provider/fwprovider/provider.go b/internal/provider/fwprovider/provider.go
index 6415ce2355..00818e8325 100644
--- a/internal/provider/fwprovider/provider.go
+++ b/internal/provider/fwprovider/provider.go
@@ -417,8 +417,7 @@ func (p *fwprovider) Resources(ctx context.Context) []func() resource.Resource {
 			if v.Tags != nil {
 				// The resource has opted in to transparent tagging.
 				// Ensure that the schema look OK.
-				schemaResponse := resource.SchemaResponse{}
-				inner.Schema(ctx, resource.SchemaRequest{}, &schemaResponse)
+				schemaResponse := schemaResponseForTagsChecking(ctx, inner)
 
 				if v, ok := schemaResponse.Schema.Attributes[names.AttrTags]; ok {
 					if v.IsComputed() {
@@ -429,12 +428,7 @@ func (p *fwprovider) Resources(ctx context.Context) []func() resource.Resource {
 					errs = append(errs, fmt.Errorf("no `%s` attribute defined in schema: %s", names.AttrTags, typeName))
 					continue
 				}
-				if v, ok := schemaResponse.Schema.Attributes[names.AttrTagsAll]; ok {
-					if !v.IsComputed() {
-						errs = append(errs, fmt.Errorf("`%s` attribute must be Computed: %s", names.AttrTagsAll, typeName))
-						continue
-					}
-				} else {
+				if _, ok := schemaResponse.Schema.Attributes[names.AttrTagsAll]; !ok {
 					errs = append(errs, fmt.Errorf("no `%s` attribute defined in schema: %s", names.AttrTagsAll, typeName))
 					continue
 				}
diff --git a/internal/provider/fwprovider/provider_tagscheck.go b/internal/provider/fwprovider/provider_tagscheck.go
new file mode 100644
index 0000000000..f790acb4e2
--- /dev/null
+++ b/internal/provider/fwprovider/provider_tagscheck.go
@@ -0,0 +1,43 @@
+package fwprovider
+
+import (
+	"context"
+
+	"github.com/hashicorp/terraform-plugin-framework/resource"
+	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
+
+	"github.com/hashicorp/terraform-provider-aws/names"
+)
+
+type disableTagsSchemaCheckKey struct{}
+
+func DisableTagSchemaCheck(ctx context.Context) context.Context {
+	return context.WithValue(ctx, disableTagsSchemaCheckKey{}, true)
+}
+
+func schemaResponseForTagsChecking(
+	ctx context.Context,
+	r resource.ResourceWithConfigure,
+) *resource.SchemaResponse {
+	flag := ctx.Value(disableTagsSchemaCheckKey{})
+	switch flag := flag.(type) {
+	case bool:
+		if flag {
+			return &resource.SchemaResponse{
+				Schema: schema.Schema{
+					Attributes: map[string]schema.Attribute{
+						names.AttrTags: schema.MapAttribute{
+							Computed: true,
+						},
+						names.AttrTagsAll: schema.MapAttribute{
+							Computed: false,
+						},
+					},
+				},
+			}
+		}
+	}
+	var resp resource.SchemaResponse
+	r.Schema(ctx, resource.SchemaRequest{}, &resp)
+	return &resp
+}
diff --git a/internal/verify/diff.go b/internal/verify/diff.go
index 0bc956a747..e0636e99ce 100644
--- a/internal/verify/diff.go
+++ b/internal/verify/diff.go
@@ -5,101 +5,12 @@ package verify
 
 import (
 	"context"
-	"fmt"
 	"time"
 
 	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
-	"github.com/hashicorp/terraform-provider-aws/internal/conns"
-	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
 )
 
-// Find JSON diff functions in the json.go file.
-
-// SetTagsDiff sets the new plan difference with the result of
-// merging resource tags on to those defined at the provider-level;
-// returns an error if unsuccessful or if the resource tags are identical
-// to those configured at the provider-level to avoid non-empty plans
-// after resource READ operations as resource and provider-level tags
-// will be indistinguishable when returned from an AWS API.
 func SetTagsDiff(ctx context.Context, diff *schema.ResourceDiff, meta interface{}) error {
-	defaultTagsConfig := meta.(*conns.AWSClient).DefaultTagsConfig
-	ignoreTagsConfig := meta.(*conns.AWSClient).IgnoreTagsConfig
-
-	resourceTags := tftags.New(ctx, diff.Get("tags").(map[string]interface{}))
-
-	allTags := defaultTagsConfig.MergeTags(resourceTags).IgnoreConfig(ignoreTagsConfig)
-	// To ensure "tags_all" is correctly computed, we explicitly set the attribute diff
-	// when the merger of resource-level tags onto provider-level tags results in n > 0 tags,
-	// otherwise we mark the attribute as "Computed" only when there is a known diff (excluding an empty map)
-	// or a change for "tags_all".
-	// Reference: https://github.com/hashicorp/terraform-provider-aws/issues/18366
-	// Reference: https://github.com/hashicorp/terraform-provider-aws/issues/19005
-
-	if !diff.GetRawPlan().GetAttr("tags").IsWhollyKnown() {
-		if err := diff.SetNewComputed("tags_all"); err != nil {
-			return fmt.Errorf("setting tags_all to computed: %w", err)
-		}
-		return nil
-	}
-
-	if diff.HasChange("tags") {
-		_, n := diff.GetChange("tags")
-		newTags := tftags.New(ctx, n.(map[string]interface{}))
-
-		if newTags.HasZeroValue() {
-			if err := diff.SetNewComputed("tags_all"); err != nil {
-				return fmt.Errorf("setting tags_all to computed: %w", err)
-			}
-		}
-
-		if len(allTags) > 0 && (!newTags.HasZeroValue() || !allTags.HasZeroValue()) {
-			if err := diff.SetNew("tags_all", allTags.Map()); err != nil {
-				return fmt.Errorf("setting new tags_all diff: %w", err)
-			}
-		}
-
-		if len(allTags) == 0 {
-			if err := diff.SetNew("tags_all", allTags.Map()); err != nil {
-				return fmt.Errorf("setting new tags_all diff: %w", err)
-			}
-		}
-	} else if !diff.HasChange("tags") {
-		if len(allTags) > 0 && !allTags.HasZeroValue() {
-			if err := diff.SetNew("tags_all", allTags.Map()); err != nil {
-				return fmt.Errorf("setting new tags_all diff: %w", err)
-			}
-			return nil
-		}
-
-		var ta tftags.KeyValueTags
-		if tagsAll, ok := diff.Get("tags_all").(map[string]interface{}); ok {
-			ta = tftags.New(ctx, tagsAll)
-		}
-		if len(allTags) > 0 && !ta.DeepEqual(allTags) && allTags.HasZeroValue() {
-			if err := diff.SetNewComputed("tags_all"); err != nil {
-				return fmt.Errorf("setting tags_all to computed: %w", err)
-			}
-			return nil
-		}
-	} else if tagsAll, ok := diff.Get("tags_all").(map[string]interface{}); ok {
-		ta := tftags.New(ctx, tagsAll)
-		if !ta.DeepEqual(allTags) {
-			if allTags.HasZeroValue() {
-				if err := diff.SetNewComputed("tags_all"); err != nil {
-					return fmt.Errorf("setting tags_all to computed: %w", err)
-				}
-			}
-		}
-	} else if len(diff.Get("tags_all").(map[string]interface{})) > 0 {
-		if err := diff.SetNewComputed("tags_all"); err != nil {
-			return fmt.Errorf("setting tags_all to computed: %w", err)
-		}
-	} else if diff.HasChange("tags_all") {
-		if err := diff.SetNewComputed("tags_all"); err != nil {
-			return fmt.Errorf("setting tags_all to computed: %w", err)
-		}
-	}
-
 	return nil
 }
 
diff --git a/shim/pf.go b/shim/pf.go
new file mode 100644
index 0000000000..65f8ffaeb5
--- /dev/null
+++ b/shim/pf.go
@@ -0,0 +1,142 @@
+package shim
+
+import (
+	"context"
+
+	"github.com/hashicorp/terraform-plugin-framework/function"
+	"github.com/hashicorp/terraform-plugin-framework/provider"
+	"github.com/hashicorp/terraform-plugin-framework/resource"
+	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
+)
+
+type transformedFrameworkProvider struct {
+	provider.Provider
+}
+
+var _ provider.Provider = (*transformedFrameworkProvider)(nil)
+var _ provider.ProviderWithFunctions = (*transformedFrameworkProvider)(nil)
+
+func (t *transformedFrameworkProvider) Functions(ctx context.Context) []func() function.Function {
+	if pf, ok := t.Provider.(provider.ProviderWithFunctions); ok {
+		return pf.Functions(ctx)
+	}
+	return nil
+}
+
+func (t *transformedFrameworkProvider) Resources(ctx context.Context) []func() resource.Resource {
+	r := t.Provider.Resources(ctx)
+	result := []func() resource.Resource{}
+	for i := range r {
+		i := i
+		result = append(result, func() resource.Resource {
+			return &transformedFrameworkResource{r[i]()}
+		})
+	}
+	return result
+}
+
+type transformedFrameworkResource struct {
+	resource.Resource
+}
+
+func (r *transformedFrameworkResource) Schema(
+	ctx context.Context,
+	req resource.SchemaRequest,
+	resp *resource.SchemaResponse,
+) {
+	r.Resource.Schema(ctx, req, resp)
+	attrs := resp.Schema.Attributes
+	if attrs == nil {
+		return
+	}
+	t := attrs["tags_all"]
+	if t != nil && t.IsComputed() {
+		attrs["tags_all"] = &transformedAttr{t}
+	}
+}
+
+var _ resource.Resource = &transformedFrameworkResource{}
+var _ resource.ResourceWithConfigValidators = &transformedFrameworkResource{}
+var _ resource.ResourceWithConfigure = &transformedFrameworkResource{}
+var _ resource.ResourceWithImportState = &transformedFrameworkResource{}
+var _ resource.ResourceWithModifyPlan = &transformedFrameworkResource{}
+var _ resource.ResourceWithMoveState = &transformedFrameworkResource{}
+var _ resource.ResourceWithUpgradeState = &transformedFrameworkResource{}
+var _ resource.ResourceWithValidateConfig = &transformedFrameworkResource{}
+
+func (r *transformedFrameworkResource) ConfigValidators(ctx context.Context) []resource.ConfigValidator {
+	if v, ok := r.Resource.(resource.ResourceWithConfigValidators); ok {
+		return v.ConfigValidators(ctx)
+	}
+	return nil
+}
+
+func (r *transformedFrameworkResource) Configure(
+	ctx context.Context,
+	req resource.ConfigureRequest,
+	resp *resource.ConfigureResponse,
+) {
+	if v, ok := r.Resource.(resource.ResourceWithConfigure); ok {
+		v.Configure(ctx, req, resp)
+	}
+}
+
+func (r *transformedFrameworkResource) ImportState(
+	ctx context.Context,
+	req resource.ImportStateRequest,
+	resp *resource.ImportStateResponse,
+) {
+	if v, ok := r.Resource.(resource.ResourceWithImportState); ok {
+		v.ImportState(ctx, req, resp)
+	}
+	return
+}
+
+func (r *transformedFrameworkResource) ModifyPlan(
+	ctx context.Context,
+	req resource.ModifyPlanRequest,
+	resp *resource.ModifyPlanResponse,
+) {
+	if v, ok := r.Resource.(resource.ResourceWithModifyPlan); ok {
+		v.ModifyPlan(ctx, req, resp)
+	}
+	return
+}
+
+func (r *transformedFrameworkResource) MoveState(ctx context.Context) []resource.StateMover {
+	if v, ok := r.Resource.(resource.ResourceWithMoveState); ok {
+		return v.MoveState(ctx)
+	}
+	return nil
+}
+
+func (r *transformedFrameworkResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
+	if v, ok := r.Resource.(resource.ResourceWithUpgradeState); ok {
+		return v.UpgradeState(ctx)
+	}
+	return nil
+}
+
+func (r *transformedFrameworkResource) ValidateConfig(
+	ctx context.Context,
+	req resource.ValidateConfigRequest,
+	resp *resource.ValidateConfigResponse,
+) {
+	if v, ok := r.Resource.(resource.ResourceWithValidateConfig); ok {
+		v.ValidateConfig(ctx, req, resp)
+	}
+}
+
+type transformedAttr struct {
+	schema.Attribute
+}
+
+func (*transformedAttr) IsComputed() bool {
+	return false
+}
+
+func (*transformedAttr) IsOptional() bool {
+	return true
+}
+
+var _ schema.Attribute = (*transformedAttr)(nil)
diff --git a/shim/shim.go b/shim/shim.go
index 2af7c06925..3fd8dc90f0 100644
--- a/shim/shim.go
+++ b/shim/shim.go
@@ -2,6 +2,7 @@ package shim
 
 import (
 	"context"
+	"fmt"
 
 	pfprovider "github.com/hashicorp/terraform-plugin-framework/provider"
 	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
@@ -16,11 +17,15 @@ type UpstreamProvider struct {
 }
 
 func NewUpstreamProvider(ctx context.Context) (UpstreamProvider, error) {
-	primary, err := provider.New(ctx)
+	ctx = fwprovider.DisableTagSchemaCheck(ctx)
+	primary, err := provider.New(provider.DisableTagSchemaCheck(ctx))
 	if err != nil {
 		return UpstreamProvider{}, err
 	}
-	pf := fwprovider.New(primary)
+	if primary != nil {
+		markTagsAllNotComputedForResources(primary)
+	}
+	pf := &transformedFrameworkProvider{fwprovider.New(primary)}
 	return UpstreamProvider{
 		SDKV2Provider:           primary,
 		PluginFrameworkProvider: pf,
@@ -34,3 +39,50 @@ type TagIgnoreConfig = tags.IgnoreConfig
 func NewTagConfig(ctx context.Context, i interface{}) TagConfig {
 	return TagConfig{Tags: tags.New(ctx, i)}
 }
+
+// For resources with tags_all attribute, ensures that the schema of tags_all matches the schema of
+// tags. In particular, this makes sure tags_all is not computed and is ForceNew if necessary. The
+// rationale for this is that Pulumi copies tags to tags_all before it hits the TF layer, so these
+// attributes must match in schema.
+func markTagsAllNotComputedForResources(sdkV2Provider *schema.Provider) {
+
+	updateSchema := func(rn string, s map[string]*schema.Schema) map[string]*schema.Schema {
+		updatedSchema := map[string]*schema.Schema{}
+		for k, v := range s {
+			if k == "tags_all" {
+				if tagsSchema, ok := s["tags"]; ok {
+					tagsAll := *tagsSchema
+					updatedSchema[k] = &tagsAll
+				} else {
+					panic(fmt.Sprintf("Unable to edit tagsAll schema for %q", rn))
+				}
+			} else {
+				updatedSchema[k] = v
+			}
+		}
+		return updatedSchema
+	}
+
+	updatedResource := func(rn string, r *schema.Resource) *schema.Resource {
+		if _, ok := r.SchemaMap()["tags_all"]; !ok {
+			return r
+		}
+
+		u := *r
+		if r.SchemaFunc != nil {
+			old := r.SchemaFunc
+			u.SchemaFunc = func() map[string]*schema.Schema {
+				return updateSchema(rn, old())
+			}
+		} else {
+			u.Schema = updateSchema(rn, r.Schema)
+		}
+		return &u
+	}
+
+	updatedResourcesMap := map[string]*schema.Resource{}
+	for rn, r := range sdkV2Provider.ResourcesMap {
+		updatedResourcesMap[rn] = updatedResource(rn, r)
+	}
+	sdkV2Provider.ResourcesMap = updatedResourcesMap
+}
