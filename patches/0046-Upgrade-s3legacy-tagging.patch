From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: corymhall <43035978+corymhall@users.noreply.github.com>
Date: Fri, 12 Jul 2024 10:39:40 -0400
Subject: [PATCH] Upgrade s3legacy tagging

This upgrades the s3legacy tagging implementation to match the s3
implementation. This fixes a bunch of issues with `tags` & `tagsAll`

diff --git a/internal/service/s3legacy/bucket_legacy.go b/internal/service/s3legacy/bucket_legacy.go
index ef32f52250..0d0a2de7e1 100644
--- a/internal/service/s3legacy/bucket_legacy.go
+++ b/internal/service/s3legacy/bucket_legacy.go
@@ -742,25 +742,16 @@ func resourceBucketLegacyCreate(ctx context.Context, d *schema.ResourceData, met
 
 	// Assign the bucket name as the resource ID
 	d.SetId(bucket)
+	if err := bucketCreateTags(ctx, conn, d.Id(), getTagsIn(ctx)); err != nil {
+		return diag.Errorf("setting S3 Bucket (%s) tags: %s", d.Id(), err)
+	}
+
 	return resourceBucketLegacyUpdate(ctx, d, meta)
 }
 
 func resourceBucketLegacyUpdate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
 	conn := meta.(*conns.AWSClient).S3Conn(ctx)
 
-	if d.HasChange("tags_all") {
-		o, n := d.GetChange("tags_all")
-
-		// Retry due to S3 eventual consistency
-		_, err := retryOnAWSCode(s3.ErrCodeNoSuchBucket, func() (interface{}, error) {
-			terr := BucketUpdateTags(conn, d.Id(), o, n)
-			return nil, terr
-		})
-		if err != nil {
-			return diag.Errorf("error updating S3 Bucket (%s) tags: %s", d.Id(), err)
-		}
-	}
-
 	if d.HasChange("policy") {
 		if err := resourceBucketLegacyPolicyUpdate(ctx, conn, d); err != nil {
 			return err
@@ -815,7 +806,7 @@ func resourceBucketLegacyUpdate(ctx context.Context, d *schema.ResourceData, met
 	}
 
 	if d.HasChange("lifecycle_rule") {
-		if err := resourceBucketLegacyLifecycleUpdate(conn, d); err != nil {
+		if err := resourceBucketLegacyLifecycleUpdate(ctx, conn, d); err != nil {
 			return diag.FromErr(err)
 		}
 	}
@@ -833,7 +824,7 @@ func resourceBucketLegacyUpdate(ctx context.Context, d *schema.ResourceData, met
 	}
 
 	if d.HasChange("replication_configuration") {
-		if err := resourceBucketLegacyInternalReplicationConfigurationUpdate(conn, d); err != nil {
+		if err := resourceBucketLegacyInternalReplicationConfigurationUpdate(ctx, conn, d); err != nil {
 			return diag.FromErr(err)
 		}
 	}
@@ -855,8 +846,6 @@ func resourceBucketLegacyUpdate(ctx context.Context, d *schema.ResourceData, met
 
 func resourceBucketLegacyRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
 	conn := meta.(*conns.AWSClient).S3Conn(ctx)
-	defaultTagsConfig := meta.(*conns.AWSClient).DefaultTagsConfig
-	ignoreTagsConfig := meta.(*conns.AWSClient).IgnoreTagsConfig
 
 	input := &s3.HeadBucketInput{
 		Bucket: aws.String(d.Id()),
@@ -1171,7 +1160,7 @@ func resourceBucketLegacyRead(ctx context.Context, d *schema.ResourceData, meta
 					}
 					// Tag
 					if len(filter.And.Tags) > 0 {
-						rule["tags"] = KeyValueTags(filter.And.Tags).IgnoreAWS().Map()
+						rule["tags"] = keyValueTags(ctx, filter.And.Tags).IgnoreAWS().Map()
 					}
 				} else {
 					// Prefix
@@ -1180,7 +1169,7 @@ func resourceBucketLegacyRead(ctx context.Context, d *schema.ResourceData, meta
 					}
 					// Tag
 					if filter.Tag != nil {
-						rule["tags"] = KeyValueTags([]*s3.Tag{filter.Tag}).IgnoreAWS().Map()
+						rule["tags"] = keyValueTags(ctx, []*s3.Tag{filter.Tag}).IgnoreAWS().Map()
 					}
 				}
 			} else {
@@ -1281,7 +1270,7 @@ func resourceBucketLegacyRead(ctx context.Context, d *schema.ResourceData, meta
 
 	replicationConfiguration := make([]map[string]interface{}, 0)
 	if replication, ok := replicationResponse.(*s3.GetBucketReplicationOutput); ok {
-		replicationConfiguration = flattenBucketReplicationConfigurationLegacy(replication.ReplicationConfiguration)
+		replicationConfiguration = flattenBucketReplicationConfigurationLegacy(ctx, replication.ReplicationConfiguration)
 	}
 	if err := d.Set("replication_configuration", replicationConfiguration); err != nil {
 		return diag.Errorf("error setting replication_configuration: %s", err)
@@ -1378,32 +1367,6 @@ func resourceBucketLegacyRead(ctx context.Context, d *schema.ResourceData, meta
 		}
 	}
 
-	// Retry due to S3 eventual consistency
-	tagsRaw, err := retryOnAWSCode(s3.ErrCodeNoSuchBucket, func() (interface{}, error) {
-		return BucketListTags(conn, d.Id())
-	})
-
-	if err != nil {
-		return diag.Errorf("error listing tags for S3 Bucket (%s): %s", d.Id(), err)
-	}
-
-	tags, ok := tagsRaw.(tftags.KeyValueTags)
-
-	if !ok {
-		return diag.Errorf("error listing tags for S3 Bucket (%s): unable to convert tags", d.Id())
-	}
-
-	tags = tags.IgnoreAWS().IgnoreConfig(ignoreTagsConfig)
-
-	//lintignore:AWSR002
-	if err := d.Set("tags", tags.RemoveDefaultConfig(defaultTagsConfig).Map()); err != nil {
-		return diag.Errorf("error setting tags: %w", err)
-	}
-
-	if err := d.Set("tags_all", tags.Map()); err != nil {
-		return diag.Errorf("error setting tags_all: %w", err)
-	}
-
 	arn := arn.ARN{
 		Partition: meta.(*conns.AWSClient).Partition,
 		Service:   "s3",
@@ -2035,7 +1998,7 @@ func resourceBucketLegacyObjectLockConfigurationUpdate(conn *s3.S3, d *schema.Re
 	return nil
 }
 
-func resourceBucketLegacyInternalReplicationConfigurationUpdate(conn *s3.S3, d *schema.ResourceData) error {
+func resourceBucketLegacyInternalReplicationConfigurationUpdate(ctx context.Context, conn *s3.S3, d *schema.ResourceData) error {
 	bucket := d.Get("bucket").(string)
 	replicationConfiguration := d.Get("replication_configuration").([]interface{})
 
@@ -2162,7 +2125,7 @@ func resourceBucketLegacyInternalReplicationConfigurationUpdate(conn *s3.S3, d *
 			rcRule.Priority = aws.Int64(int64(rr["priority"].(int)))
 			rcRule.Filter = &s3.ReplicationRuleFilter{}
 			filter := f[0].(map[string]interface{})
-			tags := Tags(tftags.New(context.Background(), filter["tags"]).IgnoreAWS())
+			tags := Tags(tftags.New(ctx, filter["tags"]).IgnoreAWS())
 			if len(tags) > 0 {
 				rcRule.Filter.And = &s3.ReplicationRuleAndOperator{
 					Prefix: aws.String(filter["prefix"].(string)),
@@ -2216,7 +2179,7 @@ func resourceBucketLegacyInternalReplicationConfigurationUpdate(conn *s3.S3, d *
 	return nil
 }
 
-func resourceBucketLegacyLifecycleUpdate(conn *s3.S3, d *schema.ResourceData) error {
+func resourceBucketLegacyLifecycleUpdate(ctx context.Context, conn *s3.S3, d *schema.ResourceData) error {
 	bucket := d.Get("bucket").(string)
 
 	lifecycleRules := d.Get("lifecycle_rule").([]interface{})
@@ -2241,7 +2204,7 @@ func resourceBucketLegacyLifecycleUpdate(conn *s3.S3, d *schema.ResourceData) er
 		rule := &s3.LifecycleRule{}
 
 		// Filter
-		tags := Tags(tftags.New(context.Background(), r["tags"]).IgnoreAWS())
+		tags := Tags(tftags.New(ctx, r["tags"]).IgnoreAWS())
 		filter := &s3.LifecycleRuleFilter{}
 		if len(tags) > 0 {
 			lifecycleRuleAndOp := &s3.LifecycleRuleAndOperator{}
@@ -2395,7 +2358,7 @@ func flattenServerSideEncryptionConfigurationLegacy(c *s3.ServerSideEncryptionCo
 	return encryptionConfiguration
 }
 
-func flattenBucketReplicationConfigurationLegacy(r *s3.ReplicationConfiguration) []map[string]interface{} {
+func flattenBucketReplicationConfigurationLegacy(ctx context.Context, r *s3.ReplicationConfiguration) []map[string]interface{} {
 	replication_configuration := make([]map[string]interface{}, 0, 1)
 
 	if r == nil {
@@ -2485,11 +2448,11 @@ func flattenBucketReplicationConfigurationLegacy(r *s3.ReplicationConfiguration)
 				m["prefix"] = aws.StringValue(f.Prefix)
 			}
 			if t := f.Tag; t != nil {
-				m["tags"] = KeyValueTags([]*s3.Tag{t}).IgnoreAWS().Map()
+				m["tags"] = keyValueTags(ctx, []*s3.Tag{t}).IgnoreAWS().Map()
 			}
 			if a := f.And; a != nil {
 				m["prefix"] = aws.StringValue(a.Prefix)
-				m["tags"] = KeyValueTags(a.Tags).IgnoreAWS().Map()
+				m["tags"] = keyValueTags(ctx, a.Tags).IgnoreAWS().Map()
 			}
 			t["filter"] = []interface{}{m}
 
diff --git a/internal/service/s3legacy/object_arn.go b/internal/service/s3legacy/object_arn.go
new file mode 100644
index 0000000000..30e811d65b
--- /dev/null
+++ b/internal/service/s3legacy/object_arn.go
@@ -0,0 +1,64 @@
+// Copyright (c) HashiCorp, Inc.
+// SPDX-License-Identifier: MPL-2.0
+
+package s3legacy
+
+import (
+	"fmt"
+	"strings"
+
+	"github.com/YakDriver/regexache"
+	"github.com/aws/aws-sdk-go-v2/aws/arn"
+)
+
+func newObjectARN(partition string, bucket, key string) (arn.ARN, error) {
+	if arn.IsARN(bucket) {
+		bucketARN, err := arn.Parse(bucket)
+		if err != nil {
+			return arn.ARN{}, fmt.Errorf("S3 Object ARN: unexpected bucket ARN: %s", bucket)
+		}
+		bucketARN.Resource = fmt.Sprintf("%s/%s", bucketARN.Resource, key)
+		return bucketARN, nil
+	}
+	return arn.ARN{
+		Partition: partition,
+		Service:   "s3",
+		Resource:  fmt.Sprintf("%s/%s", bucket, key),
+	}, nil
+}
+
+type objectARN struct {
+	arn.ARN
+	Bucket string
+	Key    string
+}
+
+func parseObjectARN(s string) (objectARN, error) {
+	arn, err := arn.Parse(s)
+	if err != nil {
+		return objectARN{}, err
+	}
+
+	result := objectARN{
+		ARN: arn,
+	}
+
+	if strings.HasPrefix(arn.Resource, "accesspoint/") {
+		re := regexache.MustCompile(`^(arn:[^:]+:[^:]+:[^:]*:[^:]*:accesspoint/[^/]+)/(.+)$`)
+		m := re.FindStringSubmatch(s)
+		if len(m) == 3 {
+			result.Bucket = m[1]
+			result.Key = m[2]
+			return result, nil
+		}
+	}
+
+	parts := strings.SplitN(arn.Resource, "/", 2)
+	if len(parts) != 2 {
+		return objectARN{}, fmt.Errorf("S3 Object ARN: unexpected resource section: %s", arn.Resource)
+	}
+	result.Bucket = parts[0]
+	result.Key = parts[1]
+
+	return result, nil
+}
diff --git a/internal/service/s3legacy/tags.go b/internal/service/s3legacy/tags.go
index 669813747b..1ae5d31710 100644
--- a/internal/service/s3legacy/tags.go
+++ b/internal/service/s3legacy/tags.go
@@ -13,19 +13,29 @@ import (
 	"github.com/aws/aws-sdk-go/service/s3"
 	"github.com/hashicorp/aws-sdk-go-base/tfawserr"
 	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
+	"github.com/hashicorp/terraform-provider-aws/internal/conns"
 	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
 	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
+	"github.com/hashicorp/terraform-provider-aws/internal/types/option"
 )
 
 const (
 	ErrCodeNoSuchTagSet = "NoSuchTagSet"
 )
 
+// Custom S3 tag service update functions using the same format as generated code.
+func bucketCreateTags(ctx context.Context, conn *s3.S3, identifier string, tags []*s3.Tag) error {
+	if len(tags) == 0 {
+		return nil
+	}
+	return bucketUpdateTags(ctx, conn, identifier, nil, keyValueTags(ctx, tags))
+}
+
 // Custom S3 tag service update functions using the same format as generated code.
 
 // BucketListTags lists S3 bucket tags.
 // The identifier is the bucket name.
-func BucketListTags(conn *s3.S3, identifier string) (tftags.KeyValueTags, error) {
+func bucketListTags(ctx context.Context, conn *s3.S3, identifier string) (tftags.KeyValueTags, error) {
 	input := &s3.GetBucketTaggingInput{
 		Bucket: aws.String(identifier),
 	}
@@ -36,24 +46,24 @@ func BucketListTags(conn *s3.S3, identifier string) (tftags.KeyValueTags, error)
 	// lists the special error as NoSuchTagSetError, however the existing logic used NoSuchTagSet
 	// and the AWS Go SDK has neither as a constant.
 	if tfawserr.ErrCodeEquals(err, ErrCodeNoSuchTagSet) {
-		return tftags.New(context.Background(), nil), nil
+		return tftags.New(ctx, nil), nil
 	}
 
 	if err != nil {
-		return tftags.New(context.Background(), nil), err
+		return tftags.New(ctx, nil), err
 	}
 
-	return KeyValueTags(output.TagSet), nil
+	return keyValueTags(ctx, output.TagSet), nil
 }
 
 // BucketUpdateTags updates S3 bucket tags.
 // The identifier is the bucket name.
-func BucketUpdateTags(conn *s3.S3, identifier string, oldTagsMap interface{}, newTagsMap interface{}) error {
-	oldTags := tftags.New(context.Background(), oldTagsMap)
-	newTags := tftags.New(context.Background(), newTagsMap)
+func bucketUpdateTags(ctx context.Context, conn *s3.S3, identifier string, oldTagsMap interface{}, newTagsMap interface{}) error {
+	oldTags := tftags.New(ctx, oldTagsMap)
+	newTags := tftags.New(ctx, newTagsMap)
 
 	// We need to also consider any existing ignored tags.
-	allTags, err := BucketListTags(conn, identifier)
+	allTags, err := bucketListTags(ctx, conn, identifier)
 
 	if err != nil {
 		return fmt.Errorf("error listing resource tags (%s): %w", identifier, err)
@@ -90,7 +100,7 @@ func BucketUpdateTags(conn *s3.S3, identifier string, oldTagsMap interface{}, ne
 }
 
 // ObjectListTags lists S3 object tags.
-func ObjectListTags(conn *s3.S3, bucket, key string) (tftags.KeyValueTags, error) {
+func objectListTags(ctx context.Context, conn *s3.S3, bucket, key string) (tftags.KeyValueTags, error) {
 	input := &s3.GetObjectTaggingInput{
 		Bucket: aws.String(bucket),
 		Key:    aws.String(key),
@@ -119,23 +129,23 @@ func ObjectListTags(conn *s3.S3, bucket, key string) (tftags.KeyValueTags, error
 	}
 
 	if tfawserr.ErrCodeEquals(err, ErrCodeNoSuchTagSet) {
-		return tftags.New(context.Background(), nil), nil
+		return tftags.New(ctx, nil), nil
 	}
 
 	if err != nil {
-		return tftags.New(context.Background(), nil), err
+		return tftags.New(ctx, nil), err
 	}
 
-	return KeyValueTags(output.TagSet), nil
+	return keyValueTags(ctx, output.TagSet), nil
 }
 
 // ObjectUpdateTags updates S3 object tags.
-func ObjectUpdateTags(conn *s3.S3, bucket, key string, oldTagsMap interface{}, newTagsMap interface{}) error {
-	oldTags := tftags.New(context.Background(), oldTagsMap)
-	newTags := tftags.New(context.Background(), newTagsMap)
+func objectUpdateTags(ctx context.Context, conn *s3.S3, bucket, key string, oldTagsMap interface{}, newTagsMap interface{}) error {
+	oldTags := tftags.New(ctx, oldTagsMap)
+	newTags := tftags.New(ctx, newTagsMap)
 
 	// We need to also consider any existing ignored tags.
-	allTags, err := ObjectListTags(conn, bucket, key)
+	allTags, err := objectListTags(ctx, conn, bucket, key)
 
 	if err != nil {
 		return fmt.Errorf("error listing resource tags (%s/%s): %w", bucket, key, err)
@@ -172,3 +182,56 @@ func ObjectUpdateTags(conn *s3.S3, bucket, key string, oldTagsMap interface{}, n
 
 	return nil
 }
+
+// ListTags lists s3 service tags and set them in Context.
+// It is called from outside this package.
+func (p *servicePackage) ListTags(ctx context.Context, meta any, identifier, resourceType string) error {
+	var (
+		tags tftags.KeyValueTags
+		err  error
+	)
+	switch resourceType {
+	case "Bucket":
+		tags, err = bucketListTags(ctx, meta.(*conns.AWSClient).S3Conn(ctx), identifier)
+
+	case "Object", "ObjectCopy", "BucketObject":
+		var objectARN objectARN
+		objectARN, err = parseObjectARN(identifier)
+		if err != nil {
+			return err
+		}
+		tags, err = objectListTags(ctx, meta.(*conns.AWSClient).S3Conn(ctx), objectARN.Bucket, objectARN.Key)
+
+	default:
+		return nil
+	}
+
+	if err != nil {
+		return err
+	}
+
+	if inContext, ok := tftags.FromContext(ctx); ok {
+		inContext.TagsOut = option.Some(tags)
+	}
+
+	return nil
+}
+
+// UpdateTags updates s3 service tags.
+// It is called from outside this package.
+func (p *servicePackage) UpdateTags(ctx context.Context, meta any, identifier, resourceType string, oldTags, newTags any) error {
+	switch resourceType {
+	case "Bucket":
+		return bucketUpdateTags(ctx, meta.(*conns.AWSClient).S3Conn(ctx), identifier, oldTags, newTags)
+
+	case "Object", "ObjectCopy", "BucketObject":
+		objectARN, err := parseObjectARN(identifier)
+		if err != nil {
+			return err
+		}
+		return objectUpdateTags(ctx, meta.(*conns.AWSClient).S3Conn(ctx), objectARN.Bucket, objectARN.Key, oldTags, newTags)
+
+	default:
+		return nil
+	}
+}
diff --git a/internal/service/s3legacy/tags_gen.go b/internal/service/s3legacy/tags_gen.go
index c65bacf65d..4585316b08 100644
--- a/internal/service/s3legacy/tags_gen.go
+++ b/internal/service/s3legacy/tags_gen.go
@@ -6,6 +6,7 @@ import (
 	"github.com/aws/aws-sdk-go/aws"
 	"github.com/aws/aws-sdk-go/service/s3"
 	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
+	"github.com/hashicorp/terraform-provider-aws/internal/types/option"
 )
 
 // []*SERVICE.Tag handling
@@ -26,13 +27,32 @@ func Tags(tags tftags.KeyValueTags) []*s3.Tag {
 	return result
 }
 
-// KeyValueTags creates tftags.KeyValueTags from s3 service tags.
-func KeyValueTags(tags []*s3.Tag) tftags.KeyValueTags {
+// keyValueTags creates tftags.KeyValueTags from s3 service tags.
+func keyValueTags(ctx context.Context, tags []*s3.Tag) tftags.KeyValueTags {
 	m := make(map[string]*string, len(tags))
 
 	for _, tag := range tags {
 		m[aws.StringValue(tag.Key)] = tag.Value
 	}
 
-	return tftags.New(context.Background(), m)
+	return tftags.New(ctx, m)
+}
+
+// getTagsIn returns s3 service tags from Context.
+// nil is returned if there are no input tags.
+func getTagsIn(ctx context.Context) []*s3.Tag {
+	if inContext, ok := tftags.FromContext(ctx); ok {
+		if tags := Tags(inContext.TagsIn.UnwrapOrDefault()); len(tags) > 0 {
+			return tags
+		}
+	}
+
+	return nil
+}
+
+// setTagsOut sets s3 service tags in Context.
+func setTagsOut(ctx context.Context, tags []*s3.Tag) {
+	if inContext, ok := tftags.FromContext(ctx); ok {
+		inContext.TagsOut = option.Some(keyValueTags(ctx, tags))
+	}
 }
