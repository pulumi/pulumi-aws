From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: corymhall <43035978+corymhall@users.noreply.github.com>
Date: Fri, 1 Aug 2025 14:29:38 -0400
Subject: [PATCH] aws_eks_cluster: implement default_addons_to_remove


diff --git a/internal/service/eks/cluster.go b/internal/service/eks/cluster.go
index 05b52c0686a..a80fdf40141 100644
--- a/internal/service/eks/cluster.go
+++ b/internal/service/eks/cluster.go
@@ -170,6 +170,14 @@ func resourceCluster() *schema.Resource {
 				Optional: true,
 				Computed: true,
 			},
+			"default_addons_to_remove": {
+				Type:       schema.TypeList,
+				Deprecated: "Configure bootstrap_self_managed_addons instead. This attribute will be removed in the next major version of the provider",
+				Optional:   true,
+				Elem: &schema.Schema{
+					Type: schema.TypeString,
+				},
+			},
 			"enabled_cluster_log_types": {
 				Type:     schema.TypeSet,
 				Optional: true,
@@ -599,6 +607,10 @@ func resourceClusterCreate(ctx context.Context, d *schema.ResourceData, meta any
 		return sdkdiag.AppendErrorf(diags, "waiting for EKS Cluster (%s) create: %s", d.Id(), err)
 	}
 
+	if err := removeAddons(d, conn); err != nil {
+		return sdkdiag.AppendErrorf(diags, "removing addons (%s): %s", d.Id(), err)
+	}
+
 	return append(diags, resourceClusterRead(ctx, d, meta)...)
 }
 
diff --git a/internal/service/eks/cluster_addon_removal.go b/internal/service/eks/cluster_addon_removal.go
new file mode 100644
index 00000000000..82c6f9c0d33
--- /dev/null
+++ b/internal/service/eks/cluster_addon_removal.go
@@ -0,0 +1,134 @@
+package eks
+
+import (
+	"context"
+	"fmt"
+	"log"
+	"sync"
+	"time"
+
+	"github.com/aws/aws-sdk-go-v2/aws"
+	"github.com/aws/aws-sdk-go-v2/service/eks"
+	"github.com/aws/aws-sdk-go-v2/service/eks/types"
+
+	"github.com/hashicorp/go-multierror"
+	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
+	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
+	"github.com/hashicorp/terraform-provider-aws/internal/errs"
+
+	"github.com/hashicorp/terraform-provider-aws/internal/flex"
+	"github.com/hashicorp/terraform-provider-aws/internal/retry"
+	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
+)
+
+const (
+	addonCreatedTimeout = 20 * time.Minute
+	addonUpdatedTimeout = 20 * time.Minute
+	addonDeletedTimeout = 40 * time.Minute
+)
+
+func removeAddons(d *schema.ResourceData, conn *eks.Client) error {
+	if v, ok := d.GetOk("default_addons_to_remove"); ok && len(v.([]interface{})) > 0 {
+		ctx := context.Background()
+		var wg sync.WaitGroup
+		var removalErrors *multierror.Error
+
+		for _, addon := range flex.ExpandStringList(v.([]interface{})) {
+			if addon == nil {
+				return fmt.Errorf("addonName cannot be dereferenced")
+			}
+			addonName := *addon
+			wg.Add(1)
+
+			go func() {
+				defer wg.Done()
+				removalErrors = multierror.Append(removalErrors, removeAddon(d, conn, addonName, ctx))
+			}()
+		}
+		wg.Wait()
+		return removalErrors.ErrorOrNil()
+	}
+	return nil
+}
+
+func removeAddon(d *schema.ResourceData, conn *eks.Client, addonName string, ctx context.Context) error {
+	log.Printf("[DEBUG] Creating EKS Add-On: %s", addonName)
+	createAddonInput := &eks.CreateAddonInput{
+		AddonName:          aws.String(addonName),
+		ClientRequestToken: aws.String(id.UniqueId()),
+		ClusterName:        aws.String(d.Id()),
+		ResolveConflicts:   types.ResolveConflictsOverwrite,
+	}
+
+	_, err := tfresource.RetryWhen(ctx, propagationTimeout,
+		func(ctx context.Context) (any, error) {
+			return conn.CreateAddon(ctx, createAddonInput)
+		},
+		func(err error) (bool, error) {
+			if errs.IsAErrorMessageContains[*types.InvalidParameterException](err, "CREATE_FAILED") {
+				return true, err
+			}
+
+			if errs.IsAErrorMessageContains[*types.InvalidParameterException](err, "does not exist") {
+				return true, err
+			}
+
+			return false, err
+		},
+	)
+
+	if err != nil {
+		return fmt.Errorf("error creating EKS Add-On (%s): %w", addonName, err)
+	}
+
+	_, err = waitAddonCreatedAllowDegraded(ctx, conn, d.Id(), addonName)
+
+	if err != nil {
+		return fmt.Errorf("unexpected EKS Add-On (%s) state returned during creation: %w", addonName, err)
+	}
+	log.Printf("[DEBUG] Created EKS Add-On: %s", addonName)
+
+	deleteAddonInput := &eks.DeleteAddonInput{
+		AddonName:   aws.String(addonName),
+		ClusterName: aws.String(d.Id()),
+	}
+
+	log.Printf("[DEBUG] Deleting EKS Add-On: %s", addonName)
+	_, err = conn.DeleteAddon(ctx, deleteAddonInput)
+
+	if err != nil {
+		return fmt.Errorf("error deleting EKS Add-On (%s): %w", addonName, err)
+	}
+
+	_, err = waitAddonDeleted(ctx, conn, d.Id(), addonName, addonDeletedTimeout)
+
+	if err != nil {
+		return fmt.Errorf("error waiting for EKS Add-On (%s) to delete: %w", addonName, err)
+	}
+	log.Printf("[DEBUG] Deleted EKS Add-On: %s", addonName)
+	return nil
+}
+
+func waitAddonCreatedAllowDegraded(ctx context.Context, conn *eks.Client, clusterName, addonName string) (*types.Addon, error) {
+	// We do not care about the addons actually being created successfully here. We only want them to be adopted by
+	// Terraform to be able to fully remove them afterwards again.
+
+	stateConf := retry.StateChangeConf{
+		Pending: []string{string(types.AddonStatusCreating)},
+		Target:  []string{string(types.AddonStatusActive), string(types.AddonStatusDegraded)},
+		Refresh: statusAddon(conn, clusterName, addonName),
+		Timeout: addonCreatedTimeout,
+	}
+
+	outputRaw, err := stateConf.WaitForStateContext(ctx)
+
+	if output, ok := outputRaw.(*types.Addon); ok {
+		if status, health := output.Status, output.Health; status == types.AddonStatusCreateFailed && health != nil {
+			tfresource.SetLastError(err, addonIssuesError(health.Issues))
+		}
+
+		return output, err
+	}
+
+	return nil, err
+}
