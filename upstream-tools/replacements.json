{
  "website/docs/d/backup_framework.html.markdown": [
    {
      "old": "  name = \"tf_example_backup_framework_name\"",
      "new": "  name = \"my_example_backup_framework_name\""
    }
  ],
  "website/docs/d/backup_plan.html.markdown": [
    {
      "old": "  plan_id = \"tf_example_backup_plan_id\"",
      "new": "  plan_id = \"my_example_backup_plan_id\""
    }
  ],
  "website/docs/d/backup_report_plan.html.markdown": [
    {
      "old": "  name = \"tf_example_backup_report_plan_name\"",
      "new": "  name = \"my_example_backup_report_plan_name\""
    }
  ],
  "website/docs/d/default_tags.markdown": [
    {
      "old": "With this data source, you can apply default tags to resources not _directly_ managed by a Terraform resource, such as the instances underneath an Auto Scaling group or the volumes created for an EC2 instance.",
      "new": "With this data source, you can apply default tags to resources not _directly_ managed by a resource, such as the instances underneath an Auto Scaling group or the volumes created for an EC2 instance."
    }
  ],
  "website/docs/d/ec2_transit_gateway_attachments.html.markdown": [
    {
      "old": "[2]: https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/ec2_transit_gateway_attachment",
      "new": ""
    }
  ],
  "website/docs/d/ec2_transit_gateway_vpc_attachments.html.markdown": [
    {
      "old": "[2]: https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/ec2_transit_gateway_vpc_attachment"
    }
  ],
  "website/docs/d/ecs_task_execution.html.markdown": [
    {
      "old": "~> **NOTE on plan operations:** This data source calls the `RunTask` API on every read operation, which means new task(s) may be created from a `terraform plan` command if all attributes are known. Placing this functionality behind a data source is an intentional trade off to enable use cases requiring a one-time task execution without relying on provisioners. Caution should be taken to ensure the data source is only executed once, or that the resulting tasks can safely run in parallel.",
      "new": "~> **NOTE on preview operations:** This data source calls the `RunTask` API on every read operation, which means new task(s) may be created from a `pulumi preview` command if all attributes are known. Placing this functionality behind a data source is an intentional trade off to enable use cases requiring a one-time task execution without relying on provisioners. Caution should be taken to ensure the data source is only executed once, or that the resulting tasks can safely run in parallel."
    }
  ],
  "website/docs/d/iam_session_context.markdown": [
    {
      "old": "### Find the Terraform Runner's Source Role",
      "new": "### Find the Provider's Source Role"
    },
    {
      "old": "~> If `arn` is a non-role ARN, Terraform gives no error and `issuer_arn` will be equal to the `arn` value. For STS assumed-role ARNs, Terraform gives an error if the identified IAM role does not exist.",
      "new": "~> If `arn` is a non-role ARN, the provider gives no error and `issuer_arn` will be equal to the `arn` value. For STS assumed-role ARNs, the provider gives an error if the identified IAM role does not exist."
    }
  ],
  "website/docs/d/instances.html.markdown": [
    {
      "old": "**use `terraform_remote_state`"
    },
    {
      "old": "and remote state and"
    },
    {
      "old": "data source instead** if you manage referenced instances via Terraform."
    }
  ],
  "website/docs/d/kms_ciphertext.html.markdown": [
    {
      "old": "Read more about sensitive data in state.\n"
    }
  ],
  "website/docs/d/kms_secret.html.markdown": [
    {
      "old": "!> **WARNING:** This data source was removed in version 2.0.0 of the Terraform AWS Provider. You can migrate existing configurations to the `aws_kms_secrets` data source following instructions available in the Version 2 Upgrade Guide."
    }
  ],
  "website/docs/d/kms_secrets.html.markdown": [
    {
      "old": "That encrypted output can now be inserted into Terraform configurations without exposing the plaintext secret directly.",
      "new": "That encrypted output can now be inserted into provider configurations without exposing the plaintext secret directly."
    }
  ],
  "website/docs/d/lambda_functions.html.markdown": [
    {
      "old": "  Terraform data resource to get a list of Lambda Functions.",
      "new": "  Data resource to get a list of Lambda Functions."
    },
    {
      "old": "Terraform data resource to get a list of Lambda Functions.",
      "new": "Data resource to get a list of Lambda Functions."
    }
  ],
  "website/docs/d/lambda_invocation.html.markdown": [
    {
      "old": "~> **NOTE:** If you get a `KMSAccessDeniedException: Lambda was unable to decrypt the environment variables because KMS access was denied` error when invoking an `aws_lambda_function` with environment variables, the IAM role associated with the function may have been deleted and recreated _after_ the function was created. You can fix the problem two ways: 1) updating the function's role to another role and then updating it back again to the recreated role, or 2) by using Terraform to `taint` the function and `apply` your configuration again to recreate the function. (When you create a function, Lambda grants permissions on the KMS key to the function's IAM role. If the IAM role is recreated, the grant is no longer valid. Changing the function's role or recreating the function causes Lambda to update the grant.)",
      "new": "~> **NOTE:** If you get a `KMSAccessDeniedException: Lambda was unable to decrypt the environment variables because KMS access was denied` error when invoking an `aws_lambda_function` with environment variables, the IAM role associated with the function may have been deleted and recreated _after_ the function was created. You can fix the problem two ways: 1) updating the function's role to another role and then updating it back again to the recreated role, or 2) by using Pulumi to `taint` the function and `apply` your configuration again to recreate the function. (When you create a function, Lambda grants permissions on the KMS key to the function's IAM role. If the IAM role is recreated, the grant is no longer valid. Changing the function's role or recreating the function causes Lambda to update the grant.)"
    }
  ],
  "website/docs/d/lb_listener.html.markdown": [
    {
      "old": "\n## Timeouts\n\nConfiguration options:\n\n- `read` - (Default `20m`)"
    }
  ],
  "website/docs/d/networkfirewall_firewall_policy.html.markdown": [
    {
      "old": "[1]: https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ram_resource_share"
    },
    {
      "old": "[2]: https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/networkfirewall_firewall_policy"
    }
  ],
  "website/docs/d/networkfirewall_resource_policy.html.markdown": [
    {
      "old": "[1]: https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/networkfirewall_resource_policy"
    }
  ],
  "website/docs/d/networkmanager_core_network_policy_document.html.markdown": [
    {
      "old": "-> For more information about building AWS Core Network policy documents with Terraform, see the Using AWS & AWSCC Provider Together Guide"
    }
  ],
  "website/docs/d/partition.html.markdown": [
    {
      "old": "which Terraform is working.",
      "new": "which the provider is working."
    }
  ],
  "website/docs/d/s3_account_public_access_block.html.markdown": [
    {
      "old": "* `account_id` - (Optional) AWS account ID to configure. Defaults to automatically determined account ID of the Terraform AWS provider.",
      "new": "* `account_id` - (Optional) AWS account ID to configure. Defaults to automatically determined account ID of the AWS provider."
    }
  ],
  "website/docs/d/s3_object.html.markdown": [
    {
      "old": "-> **Note:** Terraform ignores all leading `/`s in the object's `key` and treats multiple `/`s in the rest of the object's `key` as a single `/`, so values of `/index.html` and `index.html` correspond to the same S3 object as do `first//second///third//` and `first/second/third/`.",
      "new": "-> **Note:** The provider ignores all leading `/`s in the object's `key` and treats multiple `/`s in the rest of the object's `key` as a single `/`, so values of `/index.html` and `index.html` correspond to the same S3 object as do `first//second///third//` and `first/second/third/`."
    }
  ],
  "website/docs/d/s3_objects.html.markdown": [
    {
      "old": "The following example retrieves a list of all object keys in an S3 bucket and creates corresponding Terraform object data sources:",
      "new": "The following example retrieves a list of all object keys in an S3 bucket and creates corresponding object data sources:"
    },
    {
      "old": "~> **NOTE on `max_keys`:** Retrieving very large numbers of keys can adversely affect Terraform's performance.",
      "new": "~> **NOTE on `max_keys`:** Retrieving very large numbers of keys can adversely affect the provider's performance."
    }
  ],
  "website/docs/d/s3control_multi_region_access_point.html.markdown": [
    {
      "old": "Defaults to automatically determined account ID of the Terraform AWS provider.",
      "new": "Defaults to automatically determined account ID of the AWS provider."
    }
  ],
  "website/docs/d/secretsmanager_secret_version.html.markdown": [
    {
      "regExp": true,
      "regExpFlags": "gi",
      "old": "### Handling Key-Value Secret Strings in JSON\n[^#]+"
    }
  ],
  "website/docs/d/ssm_parameter.html.markdown": [
    {
      "old": "* `value` - Value of the parameter. This value is always marked as sensitive in the Terraform plan output, regardless of `type`. In Terraform CLI version 0.15 and later, this may require additional configuration handling for certain scenarios. For more information, see the Terraform v0.15 Upgrade Guide.",
      "new": "* `value` - Value of the parameter. This value is always marked as sensitive in the plan output, regardless of `type`."
    },
    {
      "old": "~> **Note:** The unencrypted value of a SecureString will be stored in the raw state as plain-text.\nRead more about sensitive data in state.\n\n"
    }
  ],
  "website/docs/d/ssm_parameters_by_path.html.markdown": [
    {
      "old": "~> **Note:** The unencrypted value of a SecureString will be stored in the raw state as plain-text.\nRead more about sensitive data in state.\n"
    }
  ],
  "website/docs/d/ssmincidents_replication_set.html.markdown": [
    {
      "old": "Use this Terraform data source to manage a replication set in AWS Systems Manager Incident Manager.",
      "new": "Use this data source to manage a replication set in AWS Systems Manager Incident Manager."
    },
    {
      "old": "~> **NOTE:** The AWS Region specified by a Terraform provider must always be one of the Regions specified for the replication set.",
      "new": "~> **NOTE:** The AWS Region specified by a provider must always be one of the Regions specified for the replication set."
    }
  ],
  "website/docs/d/ssmincidents_response_plan.html.markdown": [
    {
      "old": "Use this Terraform data source to manage a response plan in AWS Systems Manager Incident Manager.",
      "new": "Use this data source to manage a response plan in AWS Systems Manager Incident Manager."
    }
  ],
  "website/docs/d/vpc_ipam_preview_next_cidr.html.markdown": [
    {
      "old": "~> **NOTE:** This functionality is also encapsulated in a resource sharing the same name. The data source can be used when you need to use the cidr in a calculation of the same Root module, `count` for example. However, once a cidr range has been allocated that was previewed, the next refresh will find a **new** cidr and may force new resources downstream. Make sure to use Terraform's lifecycle `ignore_changes` policy if this is undesirable.",
      "new": "~> **NOTE:** This functionality is also encapsulated in a resource sharing the same name. The data source can be used when you need to use the cidr in a calculation of the same Root module, `count` for example. However, once a cidr range has been allocated that was previewed, the next refresh will find a **new** cidr and may force new resources downstream. Make sure to use `ignore_changes` if this is undesirable."
    }
  ],
  "website/docs/d/vpc_peering_connections.html.markdown": [
    {
      "old": "the data source, as noted in issue 4149",
      "new": "the data source."
    }
  ],
  "website/docs/r/acm_certificate.html.markdown": [
    {
      "old": "    * `subject_alternative_names` - (Optional) Set of domains that should be SANs in the issued certificate. To remove all elements of a previously configured list, set this value equal to an empty list (`[]`) or use the `terraform taint` command to trigger recreation.",
      "new": "    * `subject_alternative_names` - (Optional) Set of domains that should be SANs in the issued certificate. To remove all elements of a previously configured list, set this value equal to an empty list (`[]`)."
    },
    {
      "old": "    * `validation_method` - (Optional) Which method to use for validation. `DNS` or `EMAIL` are valid. This parameter must not be set for certificates that were imported into ACM and then into Terraform.",
      "new": "    * `validation_method` - (Optional) Which method to use for validation. `DNS` or `EMAIL` are valid. This parameter must not be set for certificates that were imported into ACM and then into Pulumi."
    },
    {
      "old": "    * `validation_method` - (Required) Which method to use for validation. `DNS` or `EMAIL` are valid, `NONE` can be used for certificates that were imported into ACM and then into Terraform.",
      "new": "    * `validation_method` - (Required) Which method to use for validation. `DNS` or `EMAIL` are valid, `NONE` can be used for certificates that were imported into ACM and then into the provider."
    },
    {
      "old": "  or use the `terraform taint` command to trigger recreation."
    },
    {
      "old": "It's recommended to specify `create_before_destroy = true` in a [lifecycle][1] block to replace a certificate\nwhich is currently in use (eg, by `aws_lb_listener`).\n"
    },
    {
      "old": "[1]: https://www.terraform.io/docs/configuration/meta-arguments/lifecycle.html"
    }
  ],
  "website/docs/r/amplify_app.html.markdown": [
    {
      "old": "~> **Note:** When you create/update an Amplify App from Terraform, you may end up with the error \"BadRequestException: You should at least provide one valid token\" because of authentication issues. See the section \"Repository with Tokens\" below.",
      "new": "~> **Note:** When you create/update an Amplify App from the provider, you may end up with the error \"BadRequestException: You should at least provide one valid token\" because of authentication issues. See the section \"Repository with Tokens\" below."
    }
  ],
  "website/docs/r/api_gateway_base_path_mapping.html.markdown": [
    {
      "old": "An end-to-end example of a REST API configured with OpenAPI can be found in the `/examples/api-gateway-rest-api-openapi` directory within the GitHub repository.\n"
    }
  ],
  "website/docs/r/api_gateway_deployment.html.markdown": [
    {
      "old": "* `triggers` - (Optional) Map of arbitrary keys and values that, when changed, will trigger a redeployment. To force a redeployment without changing these keys/values, use the `-replace` option with `terraform plan` or `terraform apply`.",
      "new": "* `triggers` - (Optional) Map of arbitrary keys and values that, when changed, will trigger a redeployment."
    },
    {
      "old": "* `triggers` - (Optional) Map of arbitrary keys and values that, when changed, will trigger a redeployment. To force a redeployment without changing these keys/values, use the `terraform taint` command.",
      "new": "* `triggers` - (Optional) Map of arbitrary keys and values that, when changed, will trigger a redeployment."
    }
  ],
  "website/docs/r/api_gateway_method_settings.html.markdown": [
    {
      "old": "An end-to-end example of a REST API configured with OpenAPI can be found in the `/examples/api-gateway-rest-api-openapi` directory within the GitHub repository.\n"
    }
  ],
  "website/docs/r/api_gateway_rest_api.html.markdown": [
    {
      "old": "    #       Terraform configuration file(s) or removing the .id references to",
      "new": "    #       configuration file(s) or removing the .id references to"
    },
    {
      "old": "### Terraform Resources",
      "new": "### Resources"
    },
    {
      "old": "* `policy` - (Optional) JSON formatted policy document that controls access to the API Gateway. For more information about building AWS IAM policy documents with Terraform, see the AWS IAM Policy Document Guide. Terraform will only perform drift detection of its value when present in a configuration. We recommend using the `aws_api_gateway_rest_api_policy` resource instead. If importing an OpenAPI specification via the `body` argument, this corresponds to the [`x-amazon-apigateway-policy` extension](https://docs.aws.amazon.com/apigateway/latest/developerguide/openapi-extensions-policy.html). If the argument value is provided and is different than the OpenAPI value, the argument value will override the OpenAPI value.",
      "new": "* `policy` - (Optional) JSON formatted policy document that controls access to the API Gateway. For more information about building AWS IAM policy documents with Pulumi, see the AWS IAM Policy Document Guide. The provider will only perform drift detection of its value when present in a configuration. We recommend using the `aws_api_gateway_rest_api_policy` resource instead. If importing an OpenAPI specification via the `body` argument, this corresponds to the [`x-amazon-apigateway-policy` extension](https://docs.aws.amazon.com/apigateway/latest/developerguide/openapi-extensions-policy.html). If the argument value is provided and is different than the OpenAPI value, the argument value will override the OpenAPI value."
    }
  ],
  "website/docs/r/apigatewayv2_deployment.html.markdown": [
    {
      "old": "* `triggers` - (Optional) Map of arbitrary keys and values that, when changed, will trigger a redeployment. To force a redeployment without changing these keys/values, use the `terraform taint` command.",
      "new": "* `triggers` - (Optional) Map of arbitrary keys and values that, when changed, will trigger a redeployment."
    },
    {
      "old": "-> Enable the resource `lifecycle` configuration block `create_before_destroy` argument in this resource configuration to properly order redeployments in Terraform.",
      "new": "-> Enable the resource `lifecycle` configuration block `create_before_destroy` argument in this resource configuration to properly order redeployments."
    },
    {
      "old": "-> Enable the resource `lifecycle` configuration block `create_before_destroy` argument in this resource configuration to properly order redeployments.\n"
    }
  ],
  "website/docs/r/appautoscaling_target.html.markdown": [
    {
      "old": "~> **NOTE:** Scalable targets created before 2023-03-20 may not have an assigned `arn`. These resource cannot use `tags` or participate in `default_tags`. To prevent `terraform plan` showing differences that can never be reconciled, use the `lifecycle.ignore_changes` meta-argument. See the example below.",
      "new": "~> **NOTE:** Scalable targets created before 2023-03-20 may not have an assigned `arn`. These resource cannot use `tags` or participate in `default_tags`. To prevent `pulumi preview` showing differences that can never be reconciled, use the `lifecycle.ignore_changes` meta-argument. See the example below."
    }
  ],
  "website/docs/r/appmesh_gateway_route.html.markdown": [
    {
      "old": "\n[1]: /docs/providers/aws/index.html"
    },
    {
      "old": "* `mesh_owner` - (Optional) AWS account ID of the service mesh's owner. Defaults to the account ID the [AWS provider][1] is currently connected to.",
      "new": "* `mesh_owner` - (Optional) AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to."
    }
  ],
  "website/docs/r/appmesh_route.html.markdown": [
    {
      "old": "\n[1]: /docs/providers/aws/index.html"
    },
    {
      "old": "* `mesh_owner` - (Optional) AWS account ID of the service mesh's owner. Defaults to the account ID the [AWS provider][1] is currently connected to.",
      "new": "* `mesh_owner` - (Optional) AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to."
    }
  ],
  "website/docs/r/appmesh_virtual_gateway.html.markdown": [
    {
      "old": "\n[1]: /docs/providers/aws/index.html"
    },
    {
      "old": "* `mesh_owner` - (Optional) AWS account ID of the service mesh's owner. Defaults to the account ID the [AWS provider][1] is currently connected to.",
      "new": "* `mesh_owner` - (Optional) AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to."
    }
  ],
  "website/docs/r/appmesh_virtual_node.html.markdown": [
    {
      "old": "\n[1]: /docs/providers/aws/index.html"
    },
    {
      "old": "* `mesh_owner` - (Optional) AWS account ID of the service mesh's owner. Defaults to the account ID the [AWS provider][1] is currently connected to.",
      "new": "* `mesh_owner` - (Optional) AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to."
    }
  ],
  "website/docs/r/appmesh_virtual_router.html.markdown": [
    {
      "old": "\n[1]: /docs/providers/aws/index.html"
    },
    {
      "old": "* `mesh_owner` - (Optional) AWS account ID of the service mesh's owner. Defaults to the account ID the [AWS provider][1] is currently connected to.",
      "new": "* `mesh_owner` - (Optional) AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to."
    }
  ],
  "website/docs/r/appmesh_virtual_service.html.markdown": [
    {
      "old": "\n[1]: /docs/providers/aws/index.html"
    },
    {
      "old": "* `mesh_owner` - (Optional) AWS account ID of the service mesh's owner. Defaults to the account ID the [AWS provider][1] is currently connected to.",
      "new": "* `mesh_owner` - (Optional) AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to."
    }
  ],
  "website/docs/r/appstream_stack.html.markdown": [
    {
      "old": "If provided, the terraform configuration should include a block for each configurable action.",
      "new": "If provided, the configuration should include a block for each configurable action."
    }
  ],
  "website/docs/r/appsync_datasource.html.markdown": [
    {
      "old": "  name                = \"tf_appsync_example\"",
      "new": "  name                = \"my_appsync_example\""
    },
    {
      "old": "  name             = \"tf_appsync_example\"",
      "new": "  name             = \"my_appsync_example\""
    }
  ],
  "website/docs/r/appsync_resolver.html.markdown": [
    {
      "old": "  name   = \"tf_example\"",
      "new": "  name   = \"my_example\""
    }
  ],
  "website/docs/r/athena_database.html.markdown": [
    {
      "old": "Certain resource arguments, like `encryption_configuration` and `bucket`, do not have an API method for reading the information after creation. If the argument is set in the Terraform configuration on an imported resource, Terraform will always show a difference. To workaround this behavior, either omit the argument from the Terraform configuration or use `ignore_changes` to hide the difference, e.g.,",
      "new": "Certain resource arguments, like `encryption_configuration` and `bucket`, do not have an API method for reading the information after creation. If the argument is set in the configuration on an imported resource, the provider will always show a difference. To workaround this behavior, either omit the argument from the configuration or use `ignore_changes` to hide the difference, e.g.,"
    }
  ],
  "website/docs/r/autoscaling_attachment.html.markdown": [
    {
      "old": "~> **NOTE on Auto Scaling Groups, Attachments and Traffic Source Attachments:** Terraform provides standalone Attachment (for attaching Classic Load Balancers and Application Load Balancer, Gateway Load Balancer, or Network Load Balancer target groups) and Traffic Source Attachment (for attaching Load Balancers and VPC Lattice target groups) resources and an Auto Scaling Group resource with `load_balancers`, `target_group_arns` and `traffic_source` attributes. Do not use the same traffic source in more than one of these resources. Doing so will cause a conflict of attachments. A `lifecycle` configuration block can be used to suppress differences if necessary.",
      "new": "~> **NOTE on Auto Scaling Groups, Attachments and Traffic Source Attachments:** Pulumi provides standalone Attachment (for attaching Classic Load Balancers and Application Load Balancer, Gateway Load Balancer, or Network Load Balancer target groups) and Traffic Source Attachment (for attaching Load Balancers and VPC Lattice target groups) resources and an Auto Scaling Group resource with `load_balancers`, `target_group_arns` and `traffic_source` attributes. Do not use the same traffic source in more than one of these resources. Doing so will cause a conflict of attachments. A `lifecycle` configuration block can be used to suppress differences if necessary."
    }
  ],
  "website/docs/r/autoscaling_group.html.markdown": [
    {
      "old": "  Terraform to skip all Capacity Waiting behavior.",
      "new": "  the provider to skip all Capacity Waiting behavior."
    },
    {
      "old": "* `min_elb_capacity` - (Optional) Setting this causes Terraform to wait for",
      "new": "* `min_elb_capacity` - (Optional) Setting this causes the provider to wait for"
    },
    {
      "old": "- `min_elb_capacity` - (Optional) Setting this causes Terraform to wait for",
      "new": "- `min_elb_capacity` - (Optional) Setting this causes Pulumi to wait for"
    },
    {
      "old": "- `name` - (Optional) Name of the Auto Scaling Group. By default generated by Terraform. Conflicts with `name_prefix`.",
      "new": "- `name` - (Optional) Name of the Auto Scaling Group. By default generated by Pulumi. Conflicts with `name_prefix`."
    },
    {
      "old": "- `wait_for_elb_capacity` - (Optional) Setting this will cause Terraform to wait",
      "new": "- `wait_for_elb_capacity` - (Optional) Setting this will cause Pulumi to wait"
    },
    {
      "old": "> **Hands-on:** Try the Manage AWS Auto Scaling Groups tutorial on HashiCorp Learn."
    },
    {
      "old": "As with ASG Capacity, Terraform will wait for up to `wait_for_capacity_timeout`",
      "new": "As with ASG Capacity, the provider will wait for up to `wait_for_capacity_timeout`"
    },
    {
      "old": "Terraform moves on. If new instances don't pass the ELB's health checks for any",
      "new": "the provider moves on. If new instances don't pass the ELB's health checks for any"
    },
    {
      "old": "The `min_elb_capacity` parameter causes Terraform to wait for at least the",
      "new": "The `min_elb_capacity` parameter causes the provider to wait for at least the"
    },
    {
      "old": "~> **NOTE on Auto Scaling Groups, Attachments and Traffic Source Attachments:** Terraform provides standalone Attachment (for attaching Classic Load Balancers and Application Load Balancer, Gateway Load Balancer, or Network Load Balancer target groups) and Traffic Source Attachment (for attaching Load Balancers and VPC Lattice target groups) resources and an Auto Scaling Group resource with `load_balancers`, `target_group_arns` and `traffic_source` attributes. Do not use the same traffic source in more than one of these resources. Doing so will cause a conflict of attachments. A `lifecycle` configuration block can be used to suppress differences if necessary.",
      "new": "~> **NOTE on Auto Scaling Groups, Attachments and Traffic Source Attachments:** Pulumi provides standalone Attachment (for attaching Classic Load Balancers and Application Load Balancer, Gateway Load Balancer, or Network Load Balancer target groups) and Traffic Source Attachment (for attaching Load Balancers and VPC Lattice target groups) resources and an Auto Scaling Group resource with `load_balancers`, `target_group_arns` and `traffic_source` attributes. Do not use the same traffic source in more than one of these resources. Doing so will cause a conflict of attachments. A `lifecycle` configuration block can be used to suppress differences if necessary."
    },
    {
      "old": "~> **NOTE:** Other AWS APIs may automatically add special tags to their associated Auto Scaling Group for management purposes, such as ECS Capacity Providers adding the `AmazonECSManaged` tag. These generally should be included in the configuration so Terraform does not attempt to remove them and so if the `min_size` was greater than zero on creation, that these tag(s) are applied to any initial EC2 Instances in the Auto Scaling Group. If these tag(s) were missing in the Auto Scaling Group configuration on creation, affected EC2 Instances missing the tags may require manual intervention of adding the tags to ensure they work properly with the other AWS service.",
      "new": "~> **NOTE:** Other AWS APIs may automatically add special tags to their associated Auto Scaling Group for management purposes, such as ECS Capacity Providers adding the `AmazonECSManaged` tag. These generally should be included in the configuration so the provider does not attempt to remove them and so if the `min_size` was greater than zero on creation, that these tag(s) are applied to any initial EC2 Instances in the Auto Scaling Group. If these tag(s) were missing in the Auto Scaling Group configuration on creation, affected EC2 Instances missing the tags may require manual intervention of adding the tags to ensure they work properly with the other AWS service."
    }
  ],
  "website/docs/r/autoscaling_group_tag.html.markdown": [
    {
      "old": "Manages an individual Autoscaling Group (ASG) tag. This resource should only be used in cases where ASGs are created outside Terraform (e.g., ASGs implicitly created by EKS Node Groups).",
      "new": "Manages an individual Autoscaling Group (ASG) tag. This resource should only be used in cases where ASGs are created outside the provider (e.g., ASGs implicitly created by EKS Node Groups)."
    },
    {
      "old": "~> **NOTE:** This tagging resource should not be combined with the Terraform resource for managing the parent resource. For example, using `aws_autoscaling_group` and `aws_autoscaling_group_tag` to manage tags of the same ASG will cause a perpetual difference where the `aws_autoscaling_group` resource will try to remove the tag being added by the `aws_autoscaling_group_tag` resource.",
      "new": "~> **NOTE:** This tagging resource should not be combined with the resource for managing the parent resource. For example, using `aws_autoscaling_group` and `aws_autoscaling_group_tag` to manage tags of the same ASG will cause a perpetual difference where the `aws_autoscaling_group` resource will try to remove the tag being added by the `aws_autoscaling_group_tag` resource."
    }
  ],
  "website/docs/r/autoscaling_policy.html.markdown": [
    {
      "old": "> **Hands-on:** Try the Manage AWS Auto Scaling Groups tutorial on HashiCorp Learn."
    }
  ],
  "website/docs/r/autoscaling_traffic_source_attachment.html.markdown": [
    {
      "old": "~> **NOTE on Auto Scaling Groups, Attachments and Traffic Source Attachments:** Terraform provides standalone Attachment (for attaching Classic Load Balancers and Application Load Balancer, Gateway Load Balancer, or Network Load Balancer target groups) and Traffic Source Attachment (for attaching Load Balancers and VPC Lattice target groups) resources and an Auto Scaling Group resource with `load_balancers`, `target_group_arns` and `traffic_source` attributes. Do not use the same traffic source in more than one of these resources. Doing so will cause a conflict of attachments. A `lifecycle` configuration block can be used to suppress differences if necessary.",
      "new": "~> **NOTE on Auto Scaling Groups, Attachments and Traffic Source Attachments:** Pulumi provides standalone Attachment (for attaching Classic Load Balancers and Application Load Balancer, Gateway Load Balancer, or Network Load Balancer target groups) and Traffic Source Attachment (for attaching Load Balancers and VPC Lattice target groups) resources and an Auto Scaling Group resource with `load_balancers`, `target_group_arns` and `traffic_source` attributes. Do not use the same traffic source in more than one of these resources. Doing so will cause a conflict of attachments. A `lifecycle` configuration block can be used to suppress differences if necessary."
    }
  ],
  "website/docs/r/backup_plan.html.markdown": [
    {
      "old": "    rule_name         = \"tf_example_backup_rule\"",
      "new": "    rule_name         = \"my_example_backup_rule\""
    },
    {
      "old": "  name = \"tf_example_backup_plan\"",
      "new": "  name = \"my_example_backup_plan\""
    }
  ],
  "website/docs/r/backup_selection.html.markdown": [
    {
      "old": "  name         = \"tf_example_backup_selection\"",
      "new": "  name         = \"my_example_backup_selection\""
    }
  ],
  "website/docs/r/batch_job_definition.html.markdown": [
    {
      "old": "  name               = \"tf_test_batch_exec_role\"",
      "new": "  name               = \"my_test_batch_exec_role\""
    },
    {
      "old": "  name = \"tf_test_batch_job_definition\"",
      "new": "  name = \"my_test_batch_job_definition\""
    }
  ],
  "website/docs/r/budgets_budget.html.markdown": [
    {
      "old": "Create a cost_filter using resource tags, obtaining the tag value from a terraform variable",
      "new": "Create a cost_filter using resource tags, obtaining the tag value from a variable"
    }
  ],
  "website/docs/r/cloudcontrolapi_resource.html.markdown": [
    {
      "old": "* `desired_state` - (Required) JSON string matching the CloudFormation resource type schema with desired configuration. Terraform configuration expressions can be converted into JSON using the `jsonencode()` function.",
      "new": "* `desired_state` - (Required) JSON string matching the CloudFormation resource type schema with desired configuration."
    }
  ],
  "website/docs/r/cloudformation_type.html.markdown": [
    {
      "old": "~> **NOTE:** The destroy operation of this resource marks the version as deprecated. If this was the only `LIVE` version, the type is marked as deprecated. Enable the resource `lifecycle` configuration block `create_before_destroy` argument in this resource configuration to properly order redeployments in Terraform."
    }
  ],
  "website/docs/r/cloudfront_distribution.html.markdown": [
    {
      "old": "* `origin_access_identity` (Required) - The [CloudFront origin access identity][5] to associate with the origin.",
      "new": "* `origin_access_identity` (Required) - The CloudFront origin access identity to associate with the origin."
    },
    {
      "old": "* `retain_on_delete` (Optional) - Disables the distribution instead of deleting it when destroying the resource through Terraform. If this is set, the distribution needs to be deleted manually afterwards. Default: `false`.",
      "new": "* `retain_on_delete` (Optional) - Disables the distribution instead of deleting it when destroying the resource through the provider. If this is set, the distribution needs to be deleted manually afterwards. Default: `false`."
    },
    {
      "old": "[3]: http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html"
    },
    {
      "old": "[5]: /docs/providers/aws/r/cloudfront_origin_access_identity.html"
    },
    {
      "old": "[8]: /docs/providers/aws/r/cloudfront_origin_access_control.html"
    }
  ],
  "website/docs/r/cloudfront_origin_access_control.html.markdown": [
    {
      "old": "* `description` - (Optional) The description of the Origin Access Control. Defaults to \"Managed by Terraform\" if omitted.",
      "new": "* `description` - (Optional) The description of the Origin Access Control. Defaults to \"Managed by Pulumi\" if omitted."
    }
  ],
  "website/docs/r/cloudfront_origin_access_identity.html.markdown": [
    {
      "old": "[3]: /docs/providers/aws/r/cloudfront_distribution.html\n[4]: /docs/providers/aws/r/s3_bucket.html"
    },
    {
      "old": "[`aws_cloudfront_distribution`][3] resource:",
      "new": "`aws_cloudfront_distribution` resource:"
    }
  ],
  "website/docs/r/cloudfront_public_key.html.markdown": [
    {
      "old": "**NOTE:** When setting `encoded_key` value, there needs a newline at the end of string. Otherwise, multiple runs of terraform will want to recreate the `aws_cloudfront_public_key` resource.",
      "new": "**NOTE:** When setting `encoded_key` value, there needs a newline at the end of string. Otherwise, multiple runs of pulumi will want to recreate the `aws_cloudfront_public_key` resource."
    }
  ],
  "website/docs/r/cloudsearch_domain.html.markdown": [
    {
      "old": "Terraform waits for the domain to become `Active` when applying a configuration.",
      "new": "The provider waits for the domain to become `Active` when applying a configuration."
    }
  ],
  "website/docs/r/cloudsearch_domain_service_access_policy.html.markdown": [
    {
      "old": "Terraform waits for the domain service access policy to become `Active` when applying a configuration.",
      "new": "The provider waits for the domain service access policy to become `Active` when applying a configuration."
    }
  ],
  "website/docs/r/cloudtrail.html.markdown": [
    {
      "old": "  bucket        = \"tf-test-trail\"",
      "new": "  bucket        = \"my-test-trail\""
    },
    {
      "old": "  name                          = \"tf-trail-foobar\"",
      "new": "  name                          = \"my-trail-foobar\""
    }
  ],
  "website/docs/r/cloudwatch_event_bus_policy.html.markdown": [
    {
      "old": "* `policy` - (Required) The text of the policy. For more information about building AWS IAM policy documents with Terraform, see the AWS IAM Policy Document Guide.",
      "new": "* `policy` - (Required) The text of the policy."
    }
  ],
  "website/docs/r/cloudwatch_event_target.html.markdown": [
    {
      "old": "* `input_template` - (Required) Template to customize data sent to the target. Must be valid JSON. To send a string value, the string value must include double quotes. Values must be escaped for both JSON and Terraform, e.g., `\"\\\"Your string goes here.\\\\nA new line.\\\"\"`",
      "new": "* `input_template` - (Required) Template to customize data sent to the target. Must be valid JSON. To send a string value, the string value must include double quotes."
    }
  ],
  "website/docs/r/cloudwatch_log_group.html.markdown": [
    {
      "old": "* `skip_destroy` - (Optional) Set to true if you do not wish the log group (and any logs it may contain) to be deleted at destroy time, and instead just remove the log group from the Terraform state.",
      "new": "* `skip_destroy` - (Optional) Set to true if you do not wish the log group (and any logs it may contain) to be deleted at destroy time, and instead just remove the log group from the state."
    }
  ],
  "website/docs/r/codebuild_project.html.markdown": [
    {
      "old": "* `id` - Name (if imported via `name`) or ARN (if created via Terraform or imported via ARN) of the CodeBuild project.",
      "new": "* `id` - Name (if imported via `name`) or ARN (if created via the provider or imported via ARN) of the CodeBuild project."
    }
  ],
  "website/docs/r/codecommit_trigger.html.markdown": [
    {
      "old": "~> **NOTE:** Terraform currently can create only one trigger per repository, even if multiple aws_codecommit_trigger resources are defined. Moreover, creating triggers with Terraform will delete all other triggers in the repository (also manually-created triggers)."
    }
  ],
  "website/docs/r/codepipeline_custom_action_type.html.markdown": [
    {
      "old": "* `id` - Composed of category, provider and version. For example, `Build:terraform:1`",
      "new": "* `id` - Composed of category, provider and version. For example, `Build:example:1`"
    }
  ],
  "website/docs/r/cognito_user.html.markdown": [
    {
      "old": "    email          = \"no-reply@hashicorp.com\"",
      "new": "    email          = \"no-reply@domain.example\""
    },
    {
      "old": "    name                     = \"terraform\"",
      "new": "    name                     = \"example\""
    },
    {
      "old": "    terraform      = true",
      "new": "    example        = true"
    }
  ],
  "website/docs/r/comprehend_document_classifier.html.markdown": [
    {
      "old": "  If omitted, Terraform will assign a random, unique version name.",
      "new": "  If omitted, the provider will assign a random, unique version name."
    }
  ],
  "website/docs/r/comprehend_entity_recognizer.html.markdown": [
    {
      "old": "  If omitted, Terraform will assign a random, unique version name.",
      "new": "  If omitted, the provider will assign a random, unique version name."
    }
  ],
  "website/docs/r/connect_contact_flow.html.markdown": [
    {
      "old": "    \"Application\" = \"Terraform\"",
      "new": "    \"Application\" = \"Example\""
    },
    {
      "old": "    \"Application\" = \"Terraform\",",
      "new": "    \"Application\" = \"Example\","
    },
    {
      "old": "* `content_hash` - (Optional) Used to trigger updates. Must be set to a base64-encoded SHA256 hash of the Contact Flow source specified with `filename`. The usual way to set this is filebase64sha256(\"mycontact_flow.json\") (Terraform 0.11.12 and later) or base64sha256(file(\"mycontact_flow.json\")) (Terraform 0.11.11 and earlier), where \"mycontact_flow.json\" is the local filename of the Contact Flow source.",
      "new": "* `content_hash` - (Optional) Used to trigger updates. Must be set to a base64-encoded SHA256 hash of the Contact Flow source specified with `filename`."
    }
  ],
  "website/docs/r/connect_contact_flow_module.html.markdown": [
    {
      "old": "    \"Application\" = \"Terraform\",",
      "new": "    \"Application\" = \"Example\","
    },
    {
      "old": "* `content_hash` - (Optional) Used to trigger updates. Must be set to a base64-encoded SHA256 hash of the Contact Flow Module source specified with `filename`. The usual way to set this is filebase64sha256(\"contact_flow_module.json\") (Terraform 0.11.12 and later) or base64sha256(file(\"contact_flow_module.json\")) (Terraform 0.11.11 and earlier), where \"contact_flow_module.json\" is the local filename of the Contact Flow Module source.",
      "new": "* `content_hash` - (Optional) Used to trigger updates. Must be set to a base64-encoded SHA256 hash of the Contact Flow Module source specified with `filename`."
    }
  ],
  "website/docs/r/db_instance.html.markdown": [
    {
      "old": "> **Hands-on:** Try the Manage AWS RDS Instances tutorial on HashiCorp Learn."
    },
    {
      "old": "Replicate database managed by Terraform will promote the database to a fully",
      "new": "Replicate database managed by the provider will promote the database to a fully"
    },
    {
      "old": "To enable Storage Autoscaling with instances that support the feature, define the `max_allocated_storage` argument higher than the `allocated_storage` argument. Terraform will automatically hide differences with the `allocated_storage` argument value if autoscaling occurs.",
      "new": "To enable Storage Autoscaling with instances that support the feature, define the `max_allocated_storage` argument higher than the `allocated_storage` argument. This provider will automatically hide differences with the `allocated_storage` argument value if autoscaling occurs."
    },
    {
      "old": "if omitted, Terraform will assign a random, unique identifier. Required if `restore_to_point_in_time` is specified.",
      "new": "if omitted, this provider will assign a random, unique identifier. Required if `restore_to_point_in_time` is specified."
    }
  ],
  "website/docs/r/db_parameter_group.html.markdown": [
    {
      "old": "> **Hands-on:** For an example of the `aws_db_parameter_group` in use, follow the Manage AWS RDS Instances tutorial on HashiCorp Learn."
    },
    {
      "old": "~> **NOTE:** After applying your changes, you may encounter a perpetual diff in your Terraform plan",
      "new": "~> **NOTE:** After applying your changes, you may encounter a perpetual diff in your preview"
    }
  ],
  "website/docs/r/db_security_group.html.markdown": [
    {
      "old": "!> **WARNING:** With the retirement of EC2-Classic the `aws_db_security_group` resource has been deprecated and will be removed in a future version. Any existing resources can be removed from Terraform state using the `terraform state rm` command.",
      "new": "!> **WARNING:** With the retirement of EC2-Classic the `aws_db_security_group` resource has been deprecated and will be removed in a future version."
    }
  ],
  "website/docs/r/db_subnet_group.html.markdown": [
    {
      "old": "* `description` - (Optional) The description of the DB subnet group. Defaults to \"Managed by Terraform\".",
      "new": "* `description` - (Optional) The description of the DB subnet group. Defaults to \"Managed by Pulumi\"."
    }
  ],
  "website/docs/r/default_route_table.html.markdown": [
    {
      "old": "\n[aws-route-tables]: http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Route_Tables.html#Route_Replacing_Main_Table\n[tf-route-tables]: /docs/providers/aws/r/route_table.html\n[tf-main-route-table-association]: /docs/providers/aws/r/main_route_table_association.html"
    }
  ],
  "website/docs/r/default_vpc.html.markdown": [
    {
      "old": "If no default VPC exists, Terraform creates a new default VPC, which leads to the implicit creation of [other resources](https://docs.aws.amazon.com/vpc/latest/userguide/default-vpc.html#default-vpc-components).",
      "new": "If no default VPC exists, the provider creates a new default VPC, which leads to the implicit creation of [other resources](https://docs.aws.amazon.com/vpc/latest/userguide/default-vpc.html#default-vpc-components)."
    }
  ],
  "website/docs/r/dms_s3_endpoint.html.markdown": [
    {
      "old": "~> **Note:** AWS is deprecating `extra_connection_attributes`, such as used with `aws_dms_endpoint`. This resource is an alternative to `aws_dms_endpoint` and does not use `extra_connection_attributes`. (AWS currently includes `extra_connection_attributes` in the raw responses to the AWS Provider requests and so they may be visible in Terraform logs.)",
      "new": "~> **Note:** AWS is deprecating `extra_connection_attributes`, such as used with `aws_dms_endpoint`. This resource is an alternative to `aws_dms_endpoint` and does not use `extra_connection_attributes`. (AWS currently includes `extra_connection_attributes` in the raw responses to the AWS Provider requests and so they may be visible in the logs.)"
    },
    {
      "old": "~> **Note:** Some of this resource's arguments have default values that come from the AWS Provider. Other default values are provided by AWS and subject to change without notice. When relying on AWS defaults, the Terraform state will often have a zero value. For example, the AWS Provider does not provide a default for `cdc_max_batch_interval` but the AWS default is `60` (seconds). However, the Terraform state will show `0` since this is the value return by AWS when no value is present. Below, we aim to flag the defaults that come from AWS (_e.g._, \"AWS default...\").",
      "new": "~> **Note:** Some of this resource's arguments have default values that come from the AWS Provider. Other default values are provided by AWS and subject to change without notice. When relying on AWS defaults, the provider state will often have a zero value. For example, the AWS Provider does not provide a default for `cdc_max_batch_interval` but the AWS default is `60` (seconds). However, the provider state will show `0` since this is the value return by AWS when no value is present. Below, we aim to flag the defaults that come from AWS (_e.g._, \"AWS default...\")."
    }
  ],
  "website/docs/r/docdb_cluster.html.markdown": [
    {
      "old": "* `cluster_identifier` - (Optional, Forces new resources) The cluster identifier. If omitted, Terraform will assign a random, unique identifier.",
      "new": "* `cluster_identifier` - (Optional, Forces new resources) The cluster identifier. If omitted, the provider will assign a random, unique identifier."
    }
  ],
  "website/docs/r/docdb_cluster_instance.html.markdown": [
    {
      "old": "* `identifier` - (Optional, Forces new resource) The identifier for the DocumentDB instance, if omitted, Terraform will assign a random, unique identifier.",
      "new": "* `identifier` - (Optional, Forces new resource) The identifier for the DocumentDB instance, if omitted, the provider will assign a random, unique identifier."
    },
    {
      "old": "[1]: /docs/providers/aws/r/docdb_cluster.html"
    },
    {
      "old": "[3]: https://www.terraform.io/docs/configuration/meta-arguments/count.html"
    }
  ],
  "website/docs/r/docdb_cluster_parameter_group.html.markdown": [
    {
      "old": "* `description` - (Optional, Forces new resource) The description of the DocumentDB cluster parameter group. Defaults to \"Managed by Terraform\".",
      "new": "* `description` - (Optional, Forces new resource) The description of the DocumentDB cluster parameter group. Defaults to \"Managed by Pulumi\"."
    }
  ],
  "website/docs/r/docdb_event_subscription.html.markdown": [
    {
      "old": "* `name` - (Optional) The name of the DocumentDB event subscription. By default generated by Terraform.",
      "new": "* `name` - (Optional) The name of the DocumentDB event subscription. By default generated by this provider."
    }
  ],
  "website/docs/r/docdb_global_cluster.html.markdown": [
    {
      "old": "  # Terraform will begin showing it as a difference. Do not configure:",
      "new": "  # The provider will begin showing it as a difference. Do not configure:"
    },
    {
      "old": "* `engine` - (Optional, Forces new resources) Name of the database engine to be used for this DB cluster. Terraform will only perform drift detection if a configuration value is provided. Current Valid values: `docdb`. Defaults to `docdb`. Conflicts with `source_db_cluster_identifier`.",
      "new": "* `engine` - (Optional, Forces new resources) Name of the database engine to be used for this DB cluster. The provider will only perform drift detection if a configuration value is provided. Current Valid values: `docdb`. Defaults to `docdb`. Conflicts with `source_db_cluster_identifier`."
    },
    {
      "old": "* `source_db_cluster_identifier` - (Optional) Amazon Resource Name (ARN) to use as the primary DB Cluster of the Global Cluster on creation. Terraform cannot perform drift detection of this value.",
      "new": "* `source_db_cluster_identifier` - (Optional) Amazon Resource Name (ARN) to use as the primary DB Cluster of the Global Cluster on creation. The provider cannot perform drift detection of this value."
    },
    {
      "old": "* `storage_encrypted` - (Optional, Forces new resources) Specifies whether the DB cluster is encrypted. The default is `false` unless `source_db_cluster_identifier` is specified and encrypted. Terraform will only perform drift detection if a configuration value is provided.",
      "new": "* `storage_encrypted` - (Optional, Forces new resources) Specifies whether the DB cluster is encrypted. The default is `false` unless `source_db_cluster_identifier` is specified and encrypted. The provider will only perform drift detection if a configuration value is provided."
    },
    {
      "old": "Certain resource arguments, like `source_db_cluster_identifier`, do not have an API method for reading the information after creation. If the argument is set in the Terraform configuration on an imported resource, Terraform will always show a difference. To workaround this behavior, either omit the argument from the Terraform configuration or use `ignore_changes` to hide the difference, e.g.",
      "new": "Certain resource arguments, like `source_db_cluster_identifier`, do not have an API method for reading the information after creation. If the argument is set in the the provider configuration on an imported resource, the provider will always show a difference. To workaround this behavior, either omit the argument from the the provider configuration or use `ignore_changes` to hide the difference, e.g."
    }
  ],
  "website/docs/r/dx_connection.html.markdown": [
    {
      "old": "instead just removed from the Terraform state.",
      "new": "instead just removed from the state."
    }
  ],
  "website/docs/r/dx_gateway_association.html.markdown": [
    {
      "old": "A full example of how to create a VPN Gateway in one AWS account, create a Direct Connect Gateway in a second AWS account, and associate the VPN Gateway with the Direct Connect Gateway via the `aws_dx_gateway_association_proposal` and `aws_dx_gateway_association` resources can be found in the `./examples/dx-gateway-cross-account-vgw-association` directory within the Github Repository.\n"
    }
  ],
  "website/docs/r/dx_gateway_association_proposal.html.markdown": [
    {
      "old": "A full example of how to create a VPN Gateway in one AWS account, create a Direct Connect Gateway in a second AWS account, and associate the VPN Gateway with the Direct Connect Gateway via the `aws_dx_gateway_association_proposal` and `aws_dx_gateway_association` resources can be found in the `./examples/dx-gateway-cross-account-vgw-association` directory within the Github Repository.\n"
    }
  ],
  "website/docs/r/dx_macsec_key_association.html.markdown": [
    {
      "old": "import this resource into your Terraform state",
      "new": "import this resource into your state"
    }
  ],
  "website/docs/r/dynamodb_tag.html.markdown": [
    {
      "old": "Manages an individual DynamoDB resource tag. This resource should only be used in cases where DynamoDB resources are created outside Terraform (e.g., Table replicas in other regions).",
      "new": "Manages an individual DynamoDB resource tag. This resource should only be used in cases where DynamoDB resources are created outside the provider (e.g., Table replicas in other regions)."
    },
    {
      "old": "~> **NOTE:** This tagging resource should not be combined with the Terraform resource for managing the parent resource. For example, using `aws_dynamodb_table` and `aws_dynamodb_tag` to manage tags of the same DynamoDB Table in the same region will cause a perpetual difference where the `aws_dynamodb_cluster` resource will try to remove the tag being added by the `aws_dynamodb_tag` resource.",
      "new": "~> **NOTE:** This tagging resource should not be combined with the resource for managing the parent resource. For example, using `aws_dynamodb_table` and `aws_dynamodb_tag` to manage tags of the same DynamoDB Table in the same region will cause a perpetual difference where the `aws_dynamodb_cluster` resource will try to remove the tag being added by the `aws_dynamodb_tag` resource."
    }
  ],
  "website/docs/r/ebs_snapshot_copy.html.markdown": [
    {
      "old": "* `tags` - A map of tags for the snapshot. If configured with a provider `default_tags` configuration block](https://www.terraform.io/docs/providers/aws/index.html#default_tags-configuration-block present, tags with matching keys will overwrite those defined at the provider-level.",
      "new": "* `tags` - A map of tags for the snapshot."
    }
  ],
  "website/docs/r/ebs_volume.html.markdown": [
    {
      "old": "* `kms_key_id` - (Optional) The ARN for the KMS encryption key. When specifying `kms_key_id`, `encrypted` needs to be set to true. Note: Terraform must be running with credentials which have the `GenerateDataKeyWithoutPlaintext` permission on the specified KMS key as required by the [EBS KMS CMK volume provisioning process](https://docs.aws.amazon.com/kms/latest/developerguide/services-ebs.html#ebs-cmk) to prevent a volume from being created and almost immediately deleted.",
      "new": "* `kms_key_id` - (Optional) The ARN for the KMS encryption key. When specifying `kms_key_id`, `encrypted` needs to be set to true. Note: The provider must be running with credentials which have the `GenerateDataKeyWithoutPlaintext` permission on the specified KMS key as required by the [EBS KMS CMK volume provisioning process](https://docs.aws.amazon.com/kms/latest/developerguide/services-ebs.html#ebs-cmk) to prevent a volume from being created and almost immediately deleted."
    }
  ],
  "website/docs/r/ec2_client_vpn_network_association.html.markdown": [
    {
      "old": "~> **NOTE on Client VPN endpoint target network security groups:** Terraform provides both a standalone Client VPN endpoint network association resource with a (deprecated) `security_groups` argument and a Client VPN endpoint resource with a `security_group_ids` argument. Do not specify security groups in both resources. Doing so will cause a conflict and will overwrite the target network security group association.",
      "new": "~> **NOTE on Client VPN endpoint target network security groups:** The provider provides both a standalone Client VPN endpoint network association resource with a (deprecated) `security_groups` argument and a Client VPN endpoint resource with a `security_group_ids` argument. Do not specify security groups in both resources. Doing so will cause a conflict and will overwrite the target network security group association."
    }
  ],
  "website/docs/r/ec2_managed_prefix_list.html.markdown": [
    {
      "old": "~> **NOTE on Managed Prefix Lists and Managed Prefix List Entries:** Terraform",
      "new": "~> **NOTE on Managed Prefix Lists and Managed Prefix List Entries:** The provider"
    }
  ],
  "website/docs/r/ec2_managed_prefix_list_entry.html.markdown": [
    {
      "old": "~> **NOTE on Managed Prefix Lists and Managed Prefix List Entries:** Terraform",
      "new": "~> **NOTE on Managed Prefix Lists and Managed Prefix List Entries:** The provider"
    }
  ],
  "website/docs/r/ec2_serial_console_access.html.markdown": [
    {
      "old": "~> **NOTE:** Removing this Terraform resource disables serial console access.",
      "new": "~> **NOTE:** Removing this resource disables serial console access."
    }
  ],
  "website/docs/r/ec2_transit_gateway_peering_attachment.html.markdown": [
    {
      "old": "\n[1]: /docs/providers/aws/index.html"
    },
    {
      "old": "* `peer_account_id` - (Optional) Account ID of EC2 Transit Gateway to peer with. Defaults to the account ID the [AWS provider][1] is currently connected to.",
      "new": "* `peer_account_id` - (Optional) Account ID of EC2 Transit Gateway to peer with. Defaults to the account ID the AWS provider is currently connected to."
    }
  ],
  "website/docs/r/ecr_registry_policy.html.markdown": [
    {
      "old": "* `policy` - (Required) The policy document. This is a JSON formatted string. For more information about building IAM policy documents with Terraform, see the AWS IAM Policy Document Guide",
      "new": "* `policy` - (Required) The policy document. This is a JSON formatted string."
    }
  ],
  "website/docs/r/ecrpublic_repository_policy.html.markdown": [
    {
      "old": "* `policy` - (Required) The policy document. This is a JSON formatted string. For more information about building IAM policy documents with Terraform, see the AWS IAM Policy Document Guide",
      "new": "* `policy` - (Required) The policy document. This is a JSON formatted string."
    }
  ],
  "website/docs/r/ecs_cluster_capacity_providers.html.markdown": [
    {
      "old": "~> **NOTE on Clusters and Cluster Capacity Providers:** Terraform provides both a standalone `aws_ecs_cluster_capacity_providers` resource, as well as allowing the capacity providers and default strategies to be managed in-line by the `aws_ecs_cluster` resource. You cannot use a Cluster with in-line capacity providers in conjunction with the Capacity Providers resource, nor use more than one Capacity Providers resource with a single Cluster, as doing so will cause a conflict and will lead to mutual overwrites.",
      "new": "~> **NOTE on Clusters and Cluster Capacity Providers:** The provider provides both a standalone `aws_ecs_cluster_capacity_providers` resource, as well as allowing the capacity providers and default strategies to be managed in-line by the `aws_ecs_cluster` resource. You cannot use a Cluster with in-line capacity providers in conjunction with the Capacity Providers resource, nor use more than one Capacity Providers resource with a single Cluster, as doing so will cause a conflict and will lead to mutual overwrites."
    }
  ],
  "website/docs/r/ecs_tag.html.markdown": [
    {
      "old": "Manages an individual ECS resource tag. This resource should only be used in cases where ECS resources are created outside Terraform (e.g., ECS Clusters implicitly created by Batch Compute Environments).",
      "new": "Manages an individual ECS resource tag. This resource should only be used in cases where ECS resources are created outside the provider (e.g., ECS Clusters implicitly created by Batch Compute Environments)."
    },
    {
      "old": "~> **NOTE:** This tagging resource should not be combined with the Terraform resource for managing the parent resource. For example, using `aws_ecs_cluster` and `aws_ecs_tag` to manage tags of the same ECS Cluster will cause a perpetual difference where the `aws_ecs_cluster` resource will try to remove the tag being added by the `aws_ecs_tag` resource.",
      "new": "~> **NOTE:** This tagging resource should not be combined with the resource for managing the parent resource. For example, using `aws_ecs_cluster` and `aws_ecs_tag` to manage tags of the same ECS Cluster will cause a perpetual difference where the `aws_ecs_cluster` resource will try to remove the tag being added by the `aws_ecs_tag` resource."
    }
  ],
  "website/docs/r/ecs_task_set.html.markdown": [
    {
      "old": "  # Optional: Allow external changes without Terraform plan difference",
      "new": "  # Optional: Allow external changes without preview difference"
    },
    {
      "old": "* `force_delete` - (Optional) Whether to allow deleting the task set without waiting for scaling down to 0. You can force a task set to delete even if it's in the process of scaling a resource. Normally, Terraform drains all the tasks before deleting the task set. This bypasses that behavior and potentially leaves resources dangling.",
      "new": "* `force_delete` - (Optional) Whether to allow deleting the task set without waiting for scaling down to 0. You can force a task set to delete even if it's in the process of scaling a resource. Normally, the provider drains all the tasks before deleting the task set. This bypasses that behavior and potentially leaves resources dangling."
    },
    {
      "old": "* `wait_until_stable` - (Optional) Whether `terraform` should wait until the task set has reached `STEADY_STATE`.",
      "new": "* `wait_until_stable` - (Optional) Whether the provider should wait until the task set has reached `STEADY_STATE`."
    },
    {
      "old": "You can utilize the generic Terraform resource lifecycle configuration block with `ignore_changes` to create an ECS service with an initial count of running instances, then ignore any changes to that count caused externally (e.g. Application Autoscaling).",
      "new": "You can utilize the generic resource lifecycle configuration block with `ignore_changes` to create an ECS service with an initial count of running instances, then ignore any changes to that count caused externally (e.g. Application Autoscaling)."
    }
  ],
  "website/docs/r/eip.html.markdown": [
    {
      "old": "  subnet_id  = aws_subnet.tf_test_subnet.id",
      "new": "  subnet_id  = aws_subnet.my_test_subnet.id"
    },
    {
      "old": "[1]: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_AssociateAddress.html"
    },
    {
      "old": "resource \"aws_subnet\" \"tf_test_subnet\" {",
      "new": "resource \"aws_subnet\" \"my_test_subnet\" {"
    }
  ],
  "website/docs/r/eks_cluster.html.markdown": [
    {
      "old": "* `kubernetes_network_config` - (Optional) Configuration block with kubernetes network configuration for the cluster. Detailed below. If removed, Terraform will only perform drift detection if a configuration value is provided.",
      "new": "* `kubernetes_network_config` - (Optional) Configuration block with kubernetes network configuration for the cluster. Detailed below. If removed, this provider will only perform drift detection if a configuration value is provided."
    },
    {
      "old": "* `public_access_cidrs` - (Optional) List of CIDR blocks. Indicates which CIDR blocks can access the Amazon EKS public API server endpoint when enabled. EKS defaults this to a list with `0.0.0.0/0`. Terraform will only perform drift detection of its value when present in a configuration.",
      "new": "* `public_access_cidrs` - (Optional) List of CIDR blocks. Indicates which CIDR blocks can access the Amazon EKS public API server endpoint when enabled. EKS defaults this to a list with `0.0.0.0/0`. The provider will only perform drift detection of its value when present in a configuration."
    }
  ],
  "website/docs/r/eks_node_group.html.markdown": [
    {
      "old": "* `ami_type` - (Optional) Type of Amazon Machine Image (AMI) associated with the EKS Node Group. See the [AWS documentation](https://docs.aws.amazon.com/eks/latest/APIReference/API_Nodegroup.html#AmazonEKS-Type-Nodegroup-amiType) for valid values. Terraform will only perform drift detection if a configuration value is provided.",
      "new": "* `ami_type` - (Optional) Type of Amazon Machine Image (AMI) associated with the EKS Node Group. See the [AWS documentation](https://docs.aws.amazon.com/eks/latest/APIReference/API_Nodegroup.html#AmazonEKS-Type-Nodegroup-amiType) for valid values. This provider will only perform drift detection if a configuration value is provided."
    },
    {
      "old": "* `capacity_type` - (Optional) Type of capacity associated with the EKS Node Group. Valid values: `ON_DEMAND`, `SPOT`. Terraform will only perform drift detection if a configuration value is provided.",
      "new": "* `capacity_type` - (Optional) Type of capacity associated with the EKS Node Group. Valid values: `ON_DEMAND`, `SPOT`. This provider will only perform drift detection if a configuration value is provided."
    },
    {
      "old": "* `instance_types` - (Optional) List of instance types associated with the EKS Node Group. Defaults to `[\"t3.medium\"]`. Terraform will only perform drift detection if a configuration value is provided.",
      "new": "* `instance_types` - (Optional) List of instance types associated with the EKS Node Group. Defaults to `[\"t3.medium\"]`. The provider will only perform drift detection if a configuration value is provided."
    },
    {
      "old": "* `version` - (Required) EC2 Launch Template version number. While the API accepts values like `$Default` and `$Latest`, the API will convert the value to the associated version number (e.g., `1`) on read and Terraform will show a difference on next plan. Using the `default_version` or `latest_version` attribute of the `aws_launch_template` resource or data source is recommended for this argument.",
      "new": "* `version` - (Required) EC2 Launch Template version number. While the API accepts values like `$Default` and `$Latest`, the API will convert the value to the associated version number (e.g., `1`) on read and the provider will show a difference on next plan. Using the `default_version` or `latest_version` attribute of the `aws_launch_template` resource or data source is recommended for this argument."
    },
    {
      "old": "* `version` – (Optional) Kubernetes version. Defaults to EKS Cluster Kubernetes version. Terraform will only perform drift detection if a configuration value is provided.",
      "new": "* `version` – (Optional) Kubernetes version. Defaults to EKS Cluster Kubernetes version. The provider will only perform drift detection if a configuration value is provided."
    },
    {
      "old": "Terraform will only perform drift detection if a configuration value is provided.",
      "new": "The provider will only perform drift detection if a configuration value is provided."
    }
  ],
  "website/docs/r/elastic_beanstalk_application.html.markdown": [
    {
      "old": "$ terraform import aws_elastic_beanstalk_application.tf_test tf-test-name",
      "new": "$ terraform import aws_elastic_beanstalk_application.my_test tf-test-name"
    }
  ],
  "website/docs/r/elastic_beanstalk_configuration_template.html.markdown": [
    {
      "old": "[1]: https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/concepts.platforms.html"
    },
    {
      "old": "resource \"aws_elastic_beanstalk_configuration_template\" \"tf_template\" {",
      "new": "resource \"aws_elastic_beanstalk_configuration_template\" \"my_template\" {"
    }
  ],
  "website/docs/r/elasticache_global_replication_group.html.markdown": [
    {
      "old": "The member replication groups must have [`lifecycle.ignore_changes[engine_version]`](https://www.terraform.io/language/meta-arguments/lifecycle) set,",
      "new": "The member replication groups must have `lifecycle.ignore_changes[engine_version]` set,"
    },
    {
      "old": "or Terraform will always return a diff.",
      "new": "or the provider will always return a diff."
    }
  ],
  "website/docs/r/elasticache_security_group.html.markdown": [
    {
      "old": "!> **WARNING:** With the retirement of EC2-Classic the `aws_elasticache_security_group` resource has been deprecated and will be removed in a future version. Any existing resources can be removed from Terraform state using the `terraform state rm` command.",
      "new": "!> **WARNING:** With the retirement of EC2-Classic the `aws_elasticache_security_group` resource has been deprecated and will be removed in a future version."
    }
  ],
  "website/docs/r/elasticache_user.html.markdown": [
    {
      "old": "~> **Note:** All arguments including the username and passwords will be stored in the raw state as plain-text.\nRead more about sensitive data in state.\n"
    }
  ],
  "website/docs/r/elasticache_user_group_association.html.markdown": [
    {
      "old": "~> **NOTE:** Terraform will detect changes in the `aws_elasticache_user_group` since `aws_elasticache_user_group_association` changes the user IDs associated with the user group. You can ignore these changes with the `lifecycle` `ignore_changes` meta argument as shown in the example.",
      "new": "~> **NOTE:** The provider will detect changes in the `aws_elasticache_user_group` since `aws_elasticache_user_group_association` changes the user IDs associated with the user group. You can ignore these changes with the `ignore_changes` option as shown in the example."
    }
  ],
  "website/docs/r/elasticsearch_domain.html.markdown": [
    {
      "old": "* `advanced_options` - (Optional) Key-value string pairs to specify advanced configuration options. Note that the values for these configuration options must be strings (wrapped in quotes) or they may be wrong and cause a perpetual diff, causing Terraform to want to recreate your Elasticsearch domain on every apply.",
      "new": "* `advanced_options` - (Optional) Key-value string pairs to specify advanced configuration options. Note that the values for these configuration options must be strings (wrapped in quotes) or they may be wrong and cause a perpetual diff, causing the provider to want to recreate your Elasticsearch domain on every apply."
    },
    {
      "old": "* `kms_key_id` - (Optional) KMS key ARN to encrypt the Elasticsearch domain with. If not specified then it defaults to using the `aws/es` service KMS key. Note that KMS will accept a KMS key ID but will return the key ARN. To prevent Terraform detecting unwanted changes, use the key ARN instead.",
      "new": "* `kms_key_id` - (Optional) KMS key ARN to encrypt the Elasticsearch domain with. If not specified then it defaults to using the `aws/es` service KMS key. Note that KMS will accept a KMS key ID but will return the key ARN. To prevent the provider detecting unwanted changes, use the key ARN instead."
    },
    {
      "old": "* `tls_security_policy` - (Optional) Name of the TLS security policy that needs to be applied to the HTTPS endpoint. Valid values:  `Policy-Min-TLS-1-0-2019-07` and `Policy-Min-TLS-1-2-2019-07`. Terraform will only perform drift detection if a configuration value is provided.",
      "new": "* `tls_security_policy` - (Optional) Name of the TLS security policy that needs to be applied to the HTTPS endpoint. Valid values:  `Policy-Min-TLS-1-0-2019-07` and `Policy-Min-TLS-1-2-2019-07`. The provider will only perform drift detection if a configuration value is provided."
    },
    {
      "old": "~> **Note:** You can enable `encrypt_at_rest` _in place_ for an existing, unencrypted domain only if your Elasticsearch version is 6.7 or greater. For lower versions, if you enable `encrypt_at_rest`, Terraform with recreate the domain, potentially causing data loss. For any version, if you disable `encrypt_at_rest` for an existing, encrypted domain, Terraform will recreate the domain, potentially causing data loss. If you change the `kms_key_id`, Terraform will also recreate the domain, potentially causing data loss.",
      "new": "~> **Note:** You can enable `encrypt_at_rest` _in place_ for an existing, unencrypted domain only if your Elasticsearch version is 6.7 or greater. For lower versions, if you enable `encrypt_at_rest`, the provider will recreate the domain, potentially causing data loss. For any version, if you disable `encrypt_at_rest` for an existing, encrypted domain, the provider will recreate the domain, potentially causing data loss. If you change the `kms_key_id`, the provider will also recreate the domain, potentially causing data loss."
    },
    {
      "old": "~> **Note:** You can enable `node_to_node_encryption` _in place_ for an existing, unencrypted domain only if your Elasticsearch version is 6.7 or greater. For lower versions, if you enable `node_to_node_encryption`, Terraform will recreate the domain, potentially causing data loss. For any version, if you disable `node_to_node_encryption` for an existing, node-to-node encrypted domain, Terraform will recreate the domain, potentially causing data loss.",
      "new": "~> **Note:** You can enable `node_to_node_encryption` _in place_ for an existing, unencrypted domain only if your Elasticsearch version is 6.7 or greater. For lower versions, if you enable `node_to_node_encryption`, the provider will recreate the domain, potentially causing data loss. For any version, if you disable `node_to_node_encryption` for an existing, node-to-node encrypted domain, the provider will recreate the domain, potentially causing data loss."
    }
  ],
  "website/docs/r/elastictranscoder_pipeline.html.markdown": [
    {
      "old": "  name         = \"aws_elastictranscoder_pipeline_tf_test_\"",
      "new": "  name         = \"aws_elastictranscoder_pipeline_my_test_\""
    }
  ],
  "website/docs/r/emr_block_public_access_configuration.html.markdown": [
    {
      "old": "By default, each AWS region is equipped with a block public access configuration that prevents EMR clusters from being launched if they have security group rules permitting public access on any port except for port 22. The default configuration can be managed using this Terraform resource.",
      "new": "By default, each AWS region is equipped with a block public access configuration that prevents EMR clusters from being launched if they have security group rules permitting public access on any port except for port 22. The default configuration can be managed using this resource."
    },
    {
      "old": "To permit EMR clusters to be launched in the configured region regardless of associated security group rules, the Block Public Access feature can be disabled using this Terraform resource.",
      "new": "To permit EMR clusters to be launched in the configured region regardless of associated security group rules, the Block Public Access feature can be disabled using this resource."
    },
    {
      "old": "~> **NOTE:** If an `aws_emr_block_public_access_configuration` Terraform resource is destroyed, the configuration will reset to this default configuration.",
      "new": "~> **NOTE:** If an `aws_emr_block_public_access_configuration` resource is destroyed, the configuration will reset to this default configuration."
    }
  ],
  "website/docs/r/emr_cluster.html.markdown": [
    {
      "old": "* `additional_info` - (Optional) JSON string for selecting additional features such as adding proxy information. Note: Currently there is no API to retrieve the value of this argument after EMR cluster creation from provider, therefore Terraform cannot detect drift from the actual EMR cluster if its value is changed outside Terraform.",
      "new": "* `additional_info` - (Optional) JSON string for selecting additional features such as adding proxy information. Note: Currently there is no API to retrieve the value of this argument after EMR cluster creation from provider, therefore the provider cannot detect drift from the actual EMR cluster if its value is changed outside the provider."
    },
    {
      "old": "Since the API does not return the actual values for Kerberos configurations, environments with those Terraform configurations will need to use the `lifecycle` configuration block `ignore_changes` argument available to all Terraform resources to prevent perpetual differences, e.g.,",
      "new": "Since the API does not return the actual values for Kerberos configurations, environments with those configurations will need to use the  `ignore_changes` option available to all resources to prevent perpetual differences, e.g.,"
    },
    {
      "old": "The default AWS managed EMR service role is called `EMR_DefaultRole` with Amazon managed policy `AmazonEMRServicePolicy_v2` attached. The name of default instance profile role is `EMR_EC2_DefaultRole` with default managed policy `AmazonElasticMapReduceforEC2Role` attached, but it is on the path to deprecation and will not be replaced with another default managed policy. You'll need to create and specify an instance profile to replace the deprecated role and default policy. See the [Configure IAM service roles for Amazon EMR](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-iam-roles.html) guide for more information on these IAM roles. There is also a fully-bootable example Terraform configuration at the bottom of this page.",
      "new": "The default AWS managed EMR service role is called `EMR_DefaultRole` with Amazon managed policy `AmazonEMRServicePolicy_v2` attached. The name of default instance profile role is `EMR_EC2_DefaultRole` with default managed policy `AmazonElasticMapReduceforEC2Role` attached, but it is on the path to deprecation and will not be replaced with another default managed policy. You'll need to create and specify an instance profile to replace the deprecated role and default policy. See the [Configure IAM service roles for Amazon EMR](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-iam-roles.html) guide for more information on these IAM roles. There is also a fully-bootable example Pulumi configuration at the bottom of this page."
    }
  ],
  "website/docs/r/emr_security_configuration.html.markdown": [
    {
      "old": "        \"AwsKmsKey\": \"arn:aws:kms:us-west-2:187416307283:alias/tf_emr_test_key\"",
      "new": "        \"AwsKmsKey\": \"arn:aws:kms:us-west-2:187416307283:alias/my_emr_test_key\""
    }
  ],
  "website/docs/r/fsx_file_cache.html.markdown": [
    {
      "old": "Terraform resource for managing",
      "new": "Resource for managing"
    }
  ],
  "website/docs/r/fsx_ontap_file_system.html.markdown": [
    {
      "old": "Certain resource arguments, like `security_group_ids`, do not have a FSx API method for reading the information after creation. If the argument is set in the Terraform configuration on an imported resource, Terraform will always show a difference. To workaround this behavior, either omit the argument from the Terraform configuration or use `ignore_changes` to hide the difference, e.g.,",
      "new": "Certain resource arguments, like `security_group_ids`, do not have a FSx API method for reading the information after creation. If the argument is set in the the provider configuration on an imported resource, the provider will always show a difference. To workaround this behavior, either omit the argument from the provider configuration or use `ignore_changes` to hide the difference, e.g.,"
    }
  ],
  "website/docs/r/fsx_ontap_storage_virtual_machine.html.markdown": [
    {
      "old": "Certain resource arguments, like `svm_admin_password` and the `self_managed_active_directory` configuation block `password`, do not have a FSx API method for reading the information after creation. If these arguments are set in the Terraform configuration on an imported resource, Terraform will always show a difference. To workaround this behavior, either omit the argument from the Terraform configuration or use `ignore_changes` to hide the difference, e.g.,",
      "new": "Certain resource arguments, like `svm_admin_password` and the `self_managed_active_directory` configuation block `password`, do not have a FSx API method for reading the information after creation. If these arguments are set in the provider configuration on an imported resource, the provider will always show a difference. To workaround this behavior, either omit the argument from the provider configuration or use `ignore_changes` to hide the difference, e.g.,"
    }
  ],
  "website/docs/r/fsx_openzfs_file_system.html.markdown": [
    {
      "old": "Certain resource arguments, like `security_group_ids`, do not have a FSx API method for reading the information after creation. If the argument is set in the Terraform configuration on an imported resource, Terraform will always show a difference. To workaround this behavior, either omit the argument from the Terraform configuration or use `ignore_changes` to hide the difference, e.g.,",
      "new": "Certain resource arguments, like `security_group_ids`, do not have a FSx API method for reading the information after creation. If the argument is set in the provider configuration on an imported resource, the provider will always show a difference. To workaround this behavior, either omit the argument from the provider configuration or use `ignore_changes` to hide the difference, e.g.,"
    }
  ],
  "website/docs/r/glue_resource_policy.html.markdown": [
    {
      "old": "* `enable_hybrid` - (Optional) Indicates that you are using both methods to grant cross-account. Valid values are `TRUE` and `FALSE`. Note the terraform will not perform drift detetction on this field as its not return on read.",
      "new": "* `enable_hybrid` - (Optional) Indicates that you are using both methods to grant cross-account. Valid values are `TRUE` and `FALSE`. Note the provider will not perform drift detetction on this field as its not return on read."
    }
  ],
  "website/docs/r/iam_access_key.html.markdown": [
    {
      "old": "* `encrypted_secret` - Encrypted secret, base64 encoded, if `pgp_key` was specified. This attribute is not available for imported resources. The encrypted secret may be decrypted using the command line, for example: `terraform output -raw encrypted_secret | base64 --decode | keybase pgp decrypt`.",
      "new": "* `encrypted_secret` - Encrypted secret, base64 encoded, if `pgp_key` was specified. This attribute is not available for imported resources. The encrypted secret may be decrypted using the command line."
    },
    {
      "old": "* `encrypted_ses_smtp_password_v4` - Encrypted SES SMTP password, base64 encoded, if `pgp_key` was specified. This attribute is not available for imported resources. The encrypted password may be decrypted using the command line, for example: `terraform output -raw encrypted_ses_smtp_password_v4 | base64 --decode | keybase pgp decrypt`.",
      "new": "* `encrypted_ses_smtp_password_v4` - Encrypted SES SMTP password, base64 encoded, if `pgp_key` was specified. This attribute is not available for imported resources. The encrypted password may be decrypted using the command line."
    }
  ],
  "website/docs/r/iam_group.html.markdown": [
    {
      "old": "~> **NOTE on user management:** Using `aws_iam_group_membership` or `aws_iam_user_group_membership` resources in addition to manually managing user/group membership using the console may lead to configuration drift or conflicts. For this reason, it's recommended to either manage membership entirely with Terraform or entirely within the AWS console.",
      "new": "~> **NOTE on user management:** Using `aws_iam_group_membership` or `aws_iam_user_group_membership` resources in addition to manually managing user/group membership using the console may lead to configuration drift or conflicts. For this reason, it's recommended to either manage membership entirely with the provider or entirely within the AWS console."
    }
  ],
  "website/docs/r/iam_group_membership.html.markdown": [
    {
      "old": "\n[1]: /docs/providers/aws/r/iam_group.html\n[2]: /docs/providers/aws/r/iam_user.html\n[3]: /docs/providers/aws/r/iam_user_group_membership.html"
    },
    {
      "old": "[IAM Users][2]",
      "new": "IAM Users"
    },
    {
      "old": "[`aws_iam_user_group_membership` resource][3].",
      "new": "`aws_iam_user_group_membership` resource."
    },
    {
      "old": "more information on managing IAM Groups or IAM Users, see [IAM Groups][1] or",
      "new": "more information on managing IAM Groups or IAM Users, see IAM Groups or"
    }
  ],
  "website/docs/r/iam_group_policy.html.markdown": [
    {
      "old": "* `name` - (Optional) The name of the policy. If omitted, Terraform will",
      "new": "* `name` - (Optional) The name of the policy. If omitted, the provider will"
    },
    {
      "old": "* `policy` - (Required) The policy document. This is a JSON formatted string. For more information about building IAM policy documents with Terraform, see the AWS IAM Policy Document Guide",
      "new": "* `policy` - (Required) The policy document. This is a JSON formatted string."
    }
  ],
  "website/docs/r/iam_policy.html.markdown": [
    {
      "old": "* `policy` - (Required) The policy document. This is a JSON formatted string. For more information about building AWS IAM policy documents with Terraform, see the AWS IAM Policy Document Guide",
      "new": "* `policy` - (Required) The policy document. This is a JSON formatted string."
    }
  ],
  "website/docs/r/iam_role.html.markdown": [
    {
      "old": "* `inline_policy` - (Optional) Configuration block defining an exclusive set of IAM inline policies associated with the IAM role. See below. If no blocks are configured, Terraform will not manage any inline policies in this resource. Configuring one empty block (i.e., `inline_policy {}`) will cause Terraform to remove _all_ inline policies added out of band on `apply`.",
      "new": "* `inline_policy` - (Optional) Configuration block defining an exclusive set of IAM inline policies associated with the IAM role. See below. If no blocks are configured, the provider will not manage any inline policies in this resource. Configuring one empty block (i.e., `inline_policy {}`) will cause the provider to remove _all_ inline policies added out of band on `apply`."
    },
    {
      "old": "* `policy` - (Required) Policy document as a JSON formatted string. For more information about building IAM policy documents with Terraform, see the AWS IAM Policy Document Guide.",
      "new": "* `policy` - (Required) Policy document as a JSON formatted string."
    },
    {
      "old": "This example creates an IAM role and attaches two managed IAM policies. If someone attaches another managed policy out-of-band, on the next apply, Terraform will detach that policy. If someone detaches these policies out-of-band, Terraform will attach them again.",
      "new": "This example creates an IAM role and attaches two managed IAM policies. If someone attaches another managed policy out-of-band, on the next apply, this provider will detach that policy. If someone detaches these policies out-of-band, this provider will attach them again."
    },
    {
      "old": "This example creates an IAM role with an empty `managed_policy_arns` argument. If someone attaches a policy out-of-band, on the next apply, Terraform will detach that policy.",
      "new": "This example creates an IAM role with an empty `managed_policy_arns` argument. If someone attaches a policy out-of-band, on the next apply, this provider will detach that policy."
    },
    {
      "old": "This example creates an IAM role with two inline IAM policies. If someone adds another inline policy out-of-band, on the next apply, Terraform will remove that policy. If someone deletes these policies out-of-band, Terraform will recreate them.",
      "new": "This example creates an IAM role with two inline IAM policies. If someone adds another inline policy out-of-band, on the next apply, this provider will remove that policy. If someone deletes these policies out-of-band, this provider will recreate them."
    },
    {
      "old": "This example creates an IAM role with what appears to be empty IAM `inline_policy` argument instead of using `inline_policy` as a configuration block. The result is that if someone were to add an inline policy out-of-band, on the next apply, Terraform will remove that policy.",
      "new": "This example creates an IAM role with what appears to be empty IAM `inline_policy` argument instead of using `inline_policy` as a configuration block. The result is that if someone were to add an inline policy out-of-band, on the next apply, this provider will remove that policy."
    },
    {
      "old": "~> **NOTE:** Since one empty block (i.e., `inline_policy {}`) is valid syntactically to remove out of band policies on `apply`, `name` and `policy` are technically _optional_. However, they are both _required_ in order to manage actual inline policies. Not including one or the other may not result in Terraform errors but will result in unpredictable and incorrect behavior.",
      "new": "~> **NOTE:** Since one empty block (i.e., `inline_policy {}`) is valid syntactically to remove out of band policies on `apply`, `name` and `policy` are technically _optional_. However, they are both _required_ in order to manage actual inline policies. Not including one or the other may not result in provider errors but will result in unpredictable and incorrect behavior."
    }
  ],
  "website/docs/r/iam_role_policy.html.markdown": [
    {
      "old": "* `name` - (Optional) The name of the role policy. If omitted, Terraform will",
      "new": "* `name` - (Optional) The name of the role policy. If omitted, this provider will"
    },
    {
      "old": "* `policy` - (Required) The inline policy document. This is a JSON formatted string. For more information about building IAM policy documents with Terraform, see the AWS IAM Policy Document Guide",
      "new": "* `policy` - (Required) The inline policy document. This is a JSON formatted string. For more information about building IAM policy documents with the provider, see the AWS IAM Policy Document Guide"
    }
  ],
  "website/docs/r/iam_server_certificate.html.markdown": [
    {
      "old": "[lifecycle]: /docs/configuration/resources.html"
    },
    {
      "old": "in use. In order for Terraform to effectively manage a Certificate in this situation, it is",
      "new": "in use. In order for the provider to effectively manage a Certificate in this situation, it is"
    },
    {
      "old": "~> **NOTE:** AWS performs behind-the-scenes modifications to some certificate files if they do not adhere to a specific format. These modifications will result in terraform forever believing that it needs to update the resources since the local and AWS file contents will not match after theses modifications occur. In order to prevent this from happening you must ensure that all your PEM-encoded files use UNIX line-breaks and that `certificate_body` contains only one certificate. All other certificates should go in `certificate_chain`. It is common for some Certificate Authorities to issue certificate files that have DOS line-breaks and that are actually multiple certificates concatenated together in order to form a full certificate chain.",
      "new": "~> **NOTE:** AWS performs behind-the-scenes modifications to some certificate files if they do not adhere to a specific format. These modifications will result in this provider forever believing that it needs to update the resources since the local and AWS file contents will not match after theses modifications occur. In order to prevent this from happening you must ensure that all your PEM-encoded files use UNIX line-breaks and that `certificate_body` contains only one certificate. All other certificates should go in `certificate_chain`. It is common for some Certificate Authorities to issue certificate files that have DOS line-breaks and that are actually multiple certificates concatenated together in order to form a full certificate chain."
    }
  ],
  "website/docs/r/iam_signing_certificate.html.markdown": [
    {
      "old": "~> **Note:** All arguments including the certificate body will be stored in the raw state as plain-text.\nRead more about sensitive data in state.\n"
    }
  ],
  "website/docs/r/iam_user_group_membership.html.markdown": [
    {
      "old": "* `groups` - (Required) A list of [IAM Groups][1] to add the user to",
      "new": "* `groups` - (Required) A list of IAM Groups to add the user to"
    },
    {
      "old": "* `user` - (Required) The name of the [IAM User][2] to add to groups",
      "new": "* `user` - (Required) The name of the IAM User to add to groups"
    },
    {
      "old": "Provides a resource for adding an [IAM User][2] to [IAM Groups][1]. This",
      "new": "Provides a resource for adding an IAM User to IAM Groups. This"
    },
    {
      "old": "[1]: /docs/providers/aws/r/iam_group.html\n[2]: /docs/providers/aws/r/iam_user.html\n[3]: /docs/providers/aws/r/iam_group_membership.html\n"
    },
    {
      "old": "[`aws_iam_group_membership` resource][3].",
      "new": "`aws_iam_group_membership` resource."
    }
  ],
  "website/docs/r/iam_user_login_profile.html.markdown": [
    {
      "old": "* `encrypted_password` - The encrypted password, base64 encoded. Only available if password was handled on Terraform resource creation, not import.",
      "new": "* `encrypted_password` - The encrypted password, base64 encoded. Only available if password was handled on resource creation, not import."
    }
  ],
  "website/docs/r/iam_user_policy.html.markdown": [
    {
      "old": "  # Terraform expression result to valid JSON syntax."
    },
    {
      "old": "* `policy` - (Required) The policy document. This is a JSON formatted string. For more information about building AWS IAM policy documents with Terraform, see the AWS IAM Policy Document Guide.",
      "new": "* `policy` - (Required) The policy document. This is a JSON formatted string."
    }
  ],
  "website/docs/r/iam_virtual_mfa_device.html.markdown": [
    {
      "old": "~> **Note:** All attributes will be stored in the raw state as plain-text.\nRead more about sensitive data in state.\n"
    }
  ],
  "website/docs/r/inspector2_enabler.html.markdown": [
    {
      "old": "* `resource_types` - (Required) Type of resources to scan. Valid values are `EC2`, `ECR`, and `LAMBDA`. If you only use one type, Terraform will ignore the status of the other type.",
      "new": "* `resource_types` - (Required) Type of resources to scan. Valid values are `EC2`, `ECR`, and `LAMBDA`. If you only use one type, the provider will ignore the status of the other type."
    }
  ],
  "website/docs/r/iot_policy.html.markdown": [
    {
      "old": "* `policy` - (Required) The policy document. This is a JSON formatted string. Use the [IoT Developer Guide](http://docs.aws.amazon.com/iot/latest/developerguide/iot-policies.html) for more information on IoT Policies. For more information about building AWS IAM policy documents with Terraform, see the AWS IAM Policy Document Guide.",
      "new": "* `policy` - (Required) The policy document. This is a JSON formatted string. Use the [IoT Developer Guide](http://docs.aws.amazon.com/iot/latest/developerguide/iot-policies.html) for more information on IoT Policies."
    }
  ],
  "website/docs/r/iot_thing_group.html.markdown": [
    {
      "old": "    terraform = \"true\"",
      "new": "    managed = \"true\""
    }
  ],
  "website/docs/r/ivschat_logging_configuration.html.markdown": [
    {
      "old": "  name        = \"terraform-kinesis-firehose-extended-s3-example-stream\"",
      "new": "  name        = \"kinesis-firehose-extended-s3-example-stream\""
    }
  ],
  "website/docs/r/kendra_experience.html.markdown": [
    {
      "old": "* `configuration` - (Optional) Configuration information for your Amazon Kendra experience. Terraform will only perform drift detection of its value when present in a configuration. [Detailed below](#configuration).",
      "new": "* `configuration` - (Optional) Configuration information for your Amazon Kendra experience. The provider will only perform drift detection of its value when present in a configuration. [Detailed below](#configuration)."
    },
    {
      "old": "* `content_source_configuration` - (Optional, Required if `user_identity_configuration` not provided) The identifiers of your data sources and FAQs. Or, you can specify that you want to use documents indexed via the `BatchPutDocument API`. Terraform will only perform drift detection of its value when present in a configuration. [Detailed below](#content_source_configuration).",
      "new": "* `content_source_configuration` - (Optional, Required if `user_identity_configuration` not provided) The identifiers of your data sources and FAQs. Or, you can specify that you want to use documents indexed via the `BatchPutDocument API`. The provider will only perform drift detection of its value when present in a configuration. [Detailed below](#content_source_configuration)."
    }
  ],
  "website/docs/r/key_pair.html.markdown": [
    {
      "old": "* `key_name_prefix` - (Optional) Creates a unique name beginning with the specified prefix. Conflicts with `key_name`. If neither `key_name` nor `key_name_prefix` is provided, Terraform will create a unique key name using the prefix `terraform-`.",
      "new": "* `key_name_prefix` - (Optional) Creates a unique name beginning with the specified prefix. Conflicts with `key_name`. If neither `key_name` nor `key_name_prefix` is provided, the provider will create a unique key name."
    },
    {
      "old": "* `key_name` - (Optional) The name for the key pair. If neither `key_name` nor `key_name_prefix` is provided, Terraform will create a unique key name using the prefix `terraform-`.",
      "new": "* `key_name` - (Optional) The name for the key pair. If neither `key_name` nor `key_name_prefix` is provided, the provider will create a unique key name."
    },
    {
      "old": "~> **NOTE:** The AWS API does not include the public key in the response, so `terraform apply` will attempt to replace the key pair. There is currently no supported workaround for this limitation.",
      "new": "~> **NOTE:** The AWS API does not include the public key in the response, so `pulumi up` will attempt to replace the key pair. There is currently no supported workaround for this limitation."
    }
  ],
  "website/docs/r/kinesis_firehose_delivery_stream.html.markdown": [
    {
      "old": "  name        = \"terraform-kinesis-firehose-os\"",
      "new": "  name        = \"pulumi-kinesis-firehose-os\""
    },
    {
      "old": "~> **NOTE:** Parameters with default values, including `NumberOfRetries`(default: 3), `RoleArn`(default: firehose role ARN), `BufferSizeInMBs`(default: 3), and `BufferIntervalInSeconds`(default: 60), are not stored in terraform state. To prevent perpetual differences, it is therefore recommended to only include parameters with non-default values.",
      "new": "~> **NOTE:** Parameters with default values, including `NumberOfRetries`(default: 3), `RoleArn`(default: firehose role ARN), `BufferSizeInMBs`(default: 3), and `BufferIntervalInSeconds`(default: 60), are not stored in state. To prevent perpetual differences, it is therefore recommended to only include parameters with non-default values."
    },
    {
      "old": "~> **NOTE:** You can enable dynamic partitioning only when you create a new delivery stream. Once you enable dynamic partitioning on a delivery stream, it cannot be disabled on this delivery stream. Therefore, Terraform will recreate the resource whenever dynamic partitioning is enabled or disabled.",
      "new": "~> **NOTE:** You can enable dynamic partitioning only when you create a new delivery stream. Once you enable dynamic partitioning on a delivery stream, it cannot be disabled on this delivery stream. Therefore, the provider will recreate the resource whenever dynamic partitioning is enabled or disabled."
    }
  ],
  "website/docs/r/kms_ciphertext.html.markdown": [
    {
      "old": "Read more about sensitive data in state.\n"
    }
  ],
  "website/docs/r/kms_key_policy.html.markdown": [
    {
      "old": "* `policy` - (Required) A valid policy JSON document. Although this is a key policy, not an IAM policy, an `aws_iam_policy_document`, in the form that designates a principal, can be used. For more information about building policy documents with Terraform, see the AWS IAM Policy Document Guide.",
      "new": "* `policy` - (Required) A valid policy JSON document. Although this is a key policy, not an IAM policy, an `aws_iam_policy_document`, in the form that designates a principal, can be used. For more information about building policy documents, see the AWS IAM Policy Document Guide."
    }
  ],
  "website/docs/r/kms_replica_external_key.html.markdown": [
    {
      "old": "For more information about building policy documents with Terraform, see the AWS IAM Policy Document Guide."
    }
  ],
  "website/docs/r/kms_replica_key.html.markdown": [
    {
      "old": "For more information about building policy documents with Terraform, see the AWS IAM Policy Document Guide."
    }
  ],
  "website/docs/r/lakeformation_permissions.html.markdown": [
    {
      "old": "* `excluded_column_names` - (Optional) Set of column names for the table to exclude. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid Terraform reporting a difference.",
      "new": "* `excluded_column_names` - (Optional) Set of column names for the table to exclude. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference."
    },
    {
      "old": "* `wildcard` - (Required, at least one of `column_names` or `wildcard`) Whether to use a column wildcard. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid Terraform reporting a difference.",
      "new": "* `wildcard` - (Required, at least one of `column_names` or `wildcard`) Whether to use a column wildcard. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference."
    },
    {
      "old": "~> **NOTE:** In general, the `principal` should _NOT_ be a Lake Formation administrator or the entity (e.g., IAM role) that is running Terraform. Administrators have implicit permissions. These should be managed by granting or not granting administrator rights using `aws_lakeformation_data_lake_settings`, _not_ with this resource.",
      "new": "~> **NOTE:** In general, the `principal` should _NOT_ be a Lake Formation administrator or the entity (e.g., IAM role) that is running the deployment. Administrators have implicit permissions. These should be managed by granting or not granting administrator rights using `aws_lakeformation_data_lake_settings`, _not_ with this resource."
    },
    {
      "old": "~> **NOTE:** We highly recommend that the `principal` _NOT_ be a Lake Formation administrator (granted using `aws_lakeformation_data_lake_settings`). The entity (e.g., IAM role) running Terraform will most likely need to be a Lake Formation administrator. As such, the entity will have implicit permissions and does not need permissions granted through this resource.",
      "new": "~> **NOTE:** We highly recommend that the `principal` _NOT_ be a Lake Formation administrator (granted using `aws_lakeformation_data_lake_settings`). The entity (e.g., IAM role) running the deployment will most likely need to be a Lake Formation administrator. As such, the entity will have implicit permissions and does not need permissions granted through this resource."
    }
  ],
  "website/docs/r/lakeformation_resource_lf_tags.html.markdown": [
    {
      "old": "* `excluded_column_names` - (Optional) Set of column names for the table to exclude. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid Terraform reporting a difference.",
      "new": "* `excluded_column_names` - (Optional) Set of column names for the table to exclude. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference."
    },
    {
      "old": "* `wildcard` - (Required, at least one of `column_names` or `wildcard`) Whether to use a column wildcard. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid Terraform reporting a difference.",
      "new": "* `wildcard` - (Required, at least one of `column_names` or `wildcard`) Whether to use a column wildcard. If `excluded_column_names` is included, `wildcard` must be set to `true` to avoid the provider reporting a difference."
    }
  ],
  "website/docs/r/lambda_function.html.markdown": [
    {
      "old": "* `kms_key_arn` - (Optional) Amazon Resource Name (ARN) of the AWS Key Management Service (KMS) key that is used to encrypt environment variables. If this configuration is not provided when environment variables are in use, AWS Lambda uses a default service key. If this configuration is provided when environment variables are not in use, the AWS Lambda API does not save this configuration and Terraform will show a perpetual difference of adding the key. To fix the perpetual difference, remove this configuration.",
      "new": "* `kms_key_arn` - (Optional) Amazon Resource Name (ARN) of the AWS Key Management Service (KMS) key that is used to encrypt environment variables. If this configuration is not provided when environment variables are in use, AWS Lambda uses a default service key. If this configuration is provided when environment variables are not in use, the AWS Lambda API does not save this configuration and the provider will show a perpetual difference of adding the key. To fix the perpetual difference, remove this configuration."
    },
    {
      "old": "* `skip_destroy` - (Optional) Set to true if you do not wish the function to be deleted at destroy time, and instead just remove the function from the Terraform state.",
      "new": "* `skip_destroy` - (Optional) Set to true if you do not wish the function to be deleted at destroy time, and instead just remove the function from the Pulumi state."
    },
    {
      "old": "* `source_code_hash` - (Optional) Used to trigger updates. Must be set to a base64-encoded SHA256 hash of the package file specified with either `filename` or `s3_key`. The usual way to set this is `filebase64sha256(\"file.zip\")` (Terraform 0.11.12 and later) or `base64sha256(file(\"file.zip\"))` (Terraform 0.11.11 and earlier), where \"file.zip\" is the local filename of the lambda function source archive.",
      "new": "* `source_code_hash` - (Optional) Used to trigger updates. Must be set to a base64-encoded SHA256 hash of the package file specified with either `filename` or `s3_key`."
    },
    {
      "old": "For a detailed example of setting up Lambda and API Gateway, see [Serverless Applications with AWS Lambda and API Gateway.][11]\n"
    },
    {
      "old": "~> **NOTE:** If you get a `KMSAccessDeniedException: Lambda was unable to decrypt the environment variables because KMS access was denied` error when invoking an `aws_lambda_function` with environment variables, the IAM role associated with the function may have been deleted and recreated _after_ the function was created. You can fix the problem two ways: 1) updating the function's role to another role and then updating it back again to the recreated role, or 2) by using Terraform to `taint` the function and `apply` your configuration again to recreate the function. (When you create a function, Lambda grants permissions on the KMS key to the function's IAM role. If the IAM role is recreated, the grant is no longer valid. Changing the function's role or recreating the function causes Lambda to update the grant.)",
      "new": "~> **NOTE:** If you get a `KMSAccessDeniedException: Lambda was unable to decrypt the environment variables because KMS access was denied` error when invoking an `aws_lambda_function` with environment variables, the IAM role associated with the function may have been deleted and recreated _after_ the function was created. You can fix the problem two ways: 1) updating the function's role to another role and then updating it back again to the recreated role, or 2) by using Pulumi to `taint` the function and `apply` your configuration again to recreate the function. (When you create a function, Lambda grants permissions on the KMS key to the function's IAM role. If the IAM role is recreated, the grant is no longer valid. Changing the function's role or recreating the function causes Lambda to update the grant.)"
    }
  ],
  "website/docs/r/lambda_invocation.html.markdown": [
    {
      "old": "* `action` - Action Terraform performs on the resource. Values are `create`, `update`, or `delete`.",
      "new": "* `action` - Action Pulumi performs on the resource. Values are `create`, `update`, or `delete`."
    },
    {
      "old": "* `terraform_key` - (Optional) The JSON key used to store lifecycle information in the input JSON payload. Defaults to `tf`. This additional key is only included when `lifecycle_scope` is set to `CRUD`.",
      "new": "* `pulumi_key` - (Optional) The JSON key used to store lifecycle information in the input JSON payload. Defaults to `tf`. This additional key is only included when `lifecycle_scope` is set to `CRUD`."
    },
    {
      "old": "* `triggers` - (Optional) Map of arbitrary keys and values that, when changed, will trigger a re-invocation. To force a re-invocation without changing these keys/values, use the `terraform taint` command.",
      "new": "* `triggers` - (Optional) Map of arbitrary keys and values that, when changed, will trigger a re-invocation."
    },
    {
      "old": "~> **NOTE:** By default this resource _only_ invokes the function when the arguments call for a create or replace. In other words, after an initial invocation on _apply_, if the arguments do not change, a subsequent _apply_ does not invoke the function again. To dynamically invoke the function, see the `triggers` example below. To always invoke a function on each _apply_, see the `aws_lambda_invocation` data source. To invoke the lambda function when the terraform resource is updated and deleted, see the [CRUD Lifecycle Scope](#crud-lifecycle-scope) example below.",
      "new": "~> **NOTE:** By default this resource _only_ invokes the function when the arguments call for a create or replace. In other words, after an initial invocation on _apply_, if the arguments do not change, a subsequent _apply_ does not invoke the function again. To dynamically invoke the function, see the `triggers` example below. To always invoke a function on each _apply_, see the `aws_lambda_invocation` data source. To invoke the lambda function when the Pulumi resource is updated and deleted, see the [CRUD Lifecycle Scope](#crud-lifecycle-scope) example below."
    },
    {
      "old": "~> **NOTE:** If you get a `KMSAccessDeniedException: Lambda was unable to decrypt the environment variables because KMS access was denied` error when invoking an `aws_lambda_function` with environment variables, the IAM role associated with the function may have been deleted and recreated _after_ the function was created. You can fix the problem two ways: 1) updating the function's role to another role and then updating it back again to the recreated role, or 2) by using Terraform to `taint` the function and `apply` your configuration again to recreate the function. (When you create a function, Lambda grants permissions on the KMS key to the function's IAM role. If the IAM role is recreated, the grant is no longer valid. Changing the function's role or recreating the function causes Lambda to update the grant.)",
      "new": "~> **NOTE:** If you get a `KMSAccessDeniedException: Lambda was unable to decrypt the environment variables because KMS access was denied` error when invoking an `aws_lambda_function` with environment variables, the IAM role associated with the function may have been deleted and recreated _after_ the function was created. You can fix the problem two ways: 1) updating the function's role to another role and then updating it back again to the recreated role, or 2) by using Pulumi to `taint` the function and `apply` your configuration again to recreate the function. (When you create a function, Lambda grants permissions on the KMS key to the function's IAM role. If the IAM role is recreated, the grant is no longer valid. Changing the function's role or recreating the function causes Lambda to update the grant.)"
    },
    {
      "old": "~> **NOTE:** `lifecycle_scope = \"CRUD\"` will inject a key `tf` in the input event to pass lifecycle information! This allows the lambda function to handle different lifecycle transitions uniquely.  If you need to use a key `tf` in your own input JSON, the default key name can be overridden with the `terraform_key` argument.",
      "new": "~> **NOTE:** `lifecycle_scope = \"CRUD\"` will inject a key `tf` in the input event to pass lifecycle information! This allows the lambda function to handle different lifecycle transitions uniquely.  If you need to use a key `tf` in your own input JSON, the default key name can be overridden with the `pulumi_key` argument."
    }
  ],
  "website/docs/r/lambda_layer_version.html.markdown": [
    {
      "old": "* `source_code_hash` - (Optional) Used to trigger updates. Must be set to a base64-encoded SHA256 hash of the package file specified with either `filename` or `s3_key`. The usual way to set this is `${filebase64sha256(\"file.zip\")}` (Terraform 0.11.12 or later) or `${base64sha256(file(\"file.zip\"))}` (Terraform 0.11.11 and earlier), where \"file.zip\" is the local filename of the lambda layer source archive.",
      "new": "* `source_code_hash` - (Optional) Used to trigger updates. Must be set to a base64-encoded SHA256 hash of the package file specified with either `filename` or `s3_key`."
    },
    {
      "old": "~> **NOTE:** Setting `skip_destroy` to `true` means that the AWS Provider will _not_ destroy any layer version, even when running `terraform destroy`. Layer versions are thus intentional dangling resources that are _not_ managed by Terraform and may incur extra expense in your AWS account.",
      "new": "~> **NOTE:** Setting `skip_destroy` to `true` means that the AWS Provider will _not_ destroy any layer version, even when running destroy. Layer versions are thus intentional dangling resources that are _not_ managed by the provider and may incur extra expense in your AWS account."
    }
  ],
  "website/docs/r/lambda_layer_version_permission.html.markdown": [
    {
      "old": "~> **NOTE:** Setting `skip_destroy` to `true` means that the AWS Provider will _not_ destroy any layer version permission, even when running `terraform destroy`. Layer version permissions are thus intentional dangling resources that are _not_ managed by Terraform and may incur extra expense in your AWS account.",
      "new": "~> **NOTE:** Setting `skip_destroy` to `true` means that the AWS Provider will _not_ destroy any layer version permission, even when running `pulumi destroy`. Layer version permissions are thus intentional dangling resources that are _not_ managed by Pulumi and may incur extra expense in your AWS account."
    }
  ],
  "website/docs/r/lambda_permission.html.markdown": [
    {
      "old": "* `statement_id_prefix` - (Optional) A statement identifier prefix. Terraform will generate a unique suffix. Conflicts with `statement_id`.",
      "new": "* `statement_id_prefix` - (Optional) A statement identifier prefix. The provider will generate a unique suffix. Conflicts with `statement_id`."
    },
    {
      "old": "* `statement_id` - (Optional) A unique statement identifier. By default generated by Terraform.",
      "new": "* `statement_id` - (Optional) A unique statement identifier. By default generated by the provider."
    }
  ],
  "website/docs/r/lambda_provisioned_concurrency_config.html.markdown": [
    {
      "old": "~> **NOTE:** Setting `skip_destroy` to `true` means that the AWS Provider will _not_ destroy a provisioned concurrency configuration, even when running `terraform destroy`. The configuration is thus an intentional dangling resource that is _not_ managed by Terraform and may incur extra expense in your AWS account.",
      "new": "~> **NOTE:** Setting `skip_destroy` to `true` means that the AWS Provider will _not_ destroy a provisioned concurrency configuration, even when running `pulumi destroy`. The configuration is thus an intentional dangling resource that is _not_ managed by Pulumi and may incur extra expense in your AWS account."
    }
  ],
  "website/docs/r/launch_configuration.html.markdown": [
    {
      "old": "-> **Note** When using `aws_launch_configuration` with `aws_autoscaling_group`, it is recommended to use the `name_prefix` (Optional) instead of the `name` (Optional) attribute. This will allow Terraform lifecycles to detect changes to the launch configuration and update the autoscaling group correctly.",
      "new": "-> **Note** When using `aws_launch_configuration` with `aws_autoscaling_group`, it is recommended to use the `name_prefix` (Optional) instead of the `name` (Optional) attribute."
    },
    {
      "old": "[1]: /docs/providers/aws/r/autoscaling_group.html"
    },
    {
      "old": "[2]: https://www.terraform.io/docs/configuration/meta-arguments/lifecycle.html"
    },
    {
      "old": "[3]: /docs/providers/aws/r/spot_instance_request.html"
    },
    {
      "old": "it's recommended to specify `create_before_destroy` in a [lifecycle][2] block.",
      "new": "it's recommended to specify `create_before_destroy` in a lifecycle block."
    },
    {
      "old": "use a Launch Configuration resource with an [AutoScaling Group resource][1],",
      "new": "use a Launch Configuration resource with an AutoScaling Group resource,"
    }
  ],
  "website/docs/r/launch_template.html.markdown": [
    {
      "old": "* `name` - (Optional) The name of the launch template. If you leave this blank, Terraform will auto-generate a unique name.",
      "new": "* `name` - (Optional) The name of the launch template. If you leave this blank, the provider will auto-generate a unique name."
    }
  ],
  "website/docs/r/lb_ssl_negotiation_policy.html.markdown": [
    {
      "old": "* `triggers` - (Optional) Map of arbitrary keys and values that, when changed, will trigger a redeployment. To force a redeployment without changing these keys/values, use the `terraform taint` command.",
      "new": "* `triggers` - (Optional) Map of arbitrary keys and values that, when changed, will trigger a redeployment."
    }
  ],
  "website/docs/r/lightsail_container_service_deployment_version.html.markdown": [
    {
      "old": "~> **NOTE:** This resource allows you to manage an Amazon Lightsail container service deployment version but Terraform cannot destroy it. Removing this resource from your configuration will remove it from your statefile and Terraform management.",
      "new": "~> **NOTE:** This resource allows you to manage an Amazon Lightsail container service deployment version but the provider cannot destroy it. Removing this resource from your configuration will remove it from your statefile."
    }
  ],
  "website/docs/r/lightsail_instance.html.markdown": [
    {
      "old": "  user_data         = \"sudo yum install -y httpd && sudo systemctl start httpd && sudo systemctl enable httpd && echo '<h1>Deployed via Terraform</h1>' | sudo tee /var/www/html/index.html\"",
      "new": "  user_data         = \"sudo yum install -y httpd && sudo systemctl start httpd && sudo systemctl enable httpd && echo '<h1>Deployed via Pulumi</h1>' | sudo tee /var/www/html/index.html\""
    }
  ],
  "website/docs/r/load_balancer_listener_policy.html.markdown": [
    {
      "old": "* `triggers` - (Optional) Map of arbitrary keys and values that, when changed, will trigger an update. To force an update without changing these keys/values, use the `terraform taint` command.",
      "new": "* `triggers` - (Optional) Map of arbitrary keys and values that, when changed, will trigger an update."
    }
  ],
  "website/docs/r/main_route_table_association.html.markdown": [
    {
      "old": "\n[aws-route-tables]: http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Route_Tables.html#Route_Replacing_Main_Table\n[tf-route-tables]: /docs/providers/aws/r/route_table.html\n[tf-default-route-table]: /docs/providers/aws/r/default_route_table.html"
    },
    {
      "old": "* `original_route_table_id` - Used internally, see __Notes__ below",
      "new": "* `original_route_table_id` - Used internally, see **Notes** below"
    },
    {
      "old": "For more information, see the Amazon VPC User Guide on [Route Tables](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Route_Tables.html). For information about managing normal route tables in Terraform, see `aws_route_table`.",
      "new": "For more information, see the Amazon VPC User Guide on [Route Tables](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Route_Tables.html). For information about managing normal route tables in the provider, see `aws_route_table`."
    },
    {
      "old": "~> **NOTE:** **Do not** use both `aws_default_route_table` to manage a default route table **and** `aws_main_route_table_association` with the same VPC due to possible route conflicts. See [aws_default_route_table][tf-default-route-table] documentation for more details.",
      "new": "~> **NOTE:** **Do not** use both `aws_default_route_table` to manage a default route table **and** `aws_main_route_table_association` with the same VPC due to possible route conflicts. See aws_default_route_table documentation for more details."
    }
  ],
  "website/docs/r/memorydb_cluster.html.markdown": [
    {
      "old": "* `description` - (Optional) Description for the cluster. Defaults to `\"Managed by Terraform\"`.",
      "new": "* `description` - (Optional) Description for the cluster."
    }
  ],
  "website/docs/r/memorydb_parameter_group.html.markdown": [
    {
      "old": "* `description` - (Optional, Forces new resource) Description for the parameter group. Defaults to `\"Managed by Terraform\"`.",
      "new": "* `description` - (Optional, Forces new resource) Description for the parameter group."
    }
  ],
  "website/docs/r/memorydb_subnet_group.html.markdown": [
    {
      "old": "* `description` - (Optional) Description for the subnet group. Defaults to `\"Managed by Terraform\"`.",
      "new": "* `description` - (Optional) Description for the subnet group."
    }
  ],
  "website/docs/r/memorydb_user.html.markdown": [
    {
      "old": "~> **Note:** All arguments including the username and passwords will be stored in the raw state as plain-text.\nRead more about sensitive data in state.\n"
    }
  ],
  "website/docs/r/msk_scram_secret_association.html.markdown": [
    {
      "old": "however, this policy will not be in terraform and as such, will present a diff on plan/apply. For that reason, you must use the `aws_secretsmanager_secret_policy`",
      "new": "however, this policy will not be in the state and as such, will present a diff on plan/apply. For that reason, you must use the `aws_secretsmanager_secret_policy`"
    }
  ],
  "website/docs/r/neptune_cluster_instance.html.markdown": [
    {
      "old": "You can simply add neptune instances and Neptune manages the replication. You can use the [count][1]",
      "new": "You can simply add neptune instances and Neptune manages the replication. You can use the count"
    },
    {
      "old": "[1]: https://www.terraform.io/docs/configuration/meta-arguments/count.html"
    }
  ],
  "website/docs/r/neptune_global_cluster.html.markdown": [
    {
      "old": "  # Terraform will begin showing it as a difference. Do not configure:",
      "new": "  # the provider will begin showing it as a difference. Do not configure:"
    },
    {
      "old": "* `engine` - (Optional, Forces new resources) Name of the database engine to be used for this DB cluster. Terraform will only perform drift detection if a configuration value is provided. Current Valid values: `neptune`. Conflicts with `source_db_cluster_identifier`.",
      "new": "* `engine` - (Optional, Forces new resources) Name of the database engine to be used for this DB cluster. The provider will only perform drift detection if a configuration value is provided. Current Valid values: `neptune`. Conflicts with `source_db_cluster_identifier`."
    },
    {
      "old": "* `source_db_cluster_identifier` - (Optional) Amazon Resource Name (ARN) to use as the primary DB Cluster of the Global Cluster on creation. Terraform cannot perform drift detection of this value.",
      "new": "* `source_db_cluster_identifier` - (Optional) Amazon Resource Name (ARN) to use as the primary DB Cluster of the Global Cluster on creation. The provider cannot perform drift detection of this value."
    },
    {
      "old": "* `storage_encrypted` - (Optional, Forces new resources) Specifies whether the DB cluster is encrypted. The default is `false` unless `source_db_cluster_identifier` is specified and encrypted. Terraform will only perform drift detection if a configuration value is provided.",
      "new": "* `storage_encrypted` - (Optional, Forces new resources) Specifies whether the DB cluster is encrypted. The default is `false` unless `source_db_cluster_identifier` is specified and encrypted. The provider will only perform drift detection if a configuration value is provided."
    },
    {
      "old": "Certain resource arguments, like `source_db_cluster_identifier`, do not have an API method for reading the information after creation. If the argument is set in the Terraform configuration on an imported resource, Terraform will always show a difference. To workaround this behavior, either omit the argument from the Terraform configuration or use `ignore_changes` to hide the difference, e.g.",
      "new": "Certain resource arguments, like `source_db_cluster_identifier`, do not have an API method for reading the information after creation. If the argument is set in configuration on an imported resource, the provider will always show a difference. To workaround this behavior, either omit the argument from configuration or use `ignore_changes` to hide the difference, e.g."
    }
  ],
  "website/docs/r/network_acl.html.markdown": [
    {
      "old": "  This argument is processed in attribute-as-blocks mode."
    },
    {
      "old": "~> **NOTE on Network ACLs and Network ACL Associations:** Terraform provides both a standalone network ACL association",
      "new": "~> **NOTE on Network ACLs and Network ACL Associations:** the provider provides both a standalone network ACL association"
    }
  ],
  "website/docs/r/network_acl_association.html.markdown": [
    {
      "old": "~> **NOTE on Network ACLs and Network ACL Associations:** Terraform provides both a standalone network ACL association resource",
      "new": "~> **NOTE on Network ACLs and Network ACL Associations:** the provider provides both a standalone network ACL association resource"
    }
  ],
  "website/docs/r/networkmanager_core_network.html.markdown": [
    {
      "old": "* `create_base_policy` - (Optional) Specifies whether to create a base policy when a core network is created or updated. A base policy is created and set to `LIVE` to allow attachments to the core network (e.g. VPC Attachments) before applying a policy document provided using the `aws_networkmanager_core_network_policy_attachment` resource. This base policy is needed if your core network does not have any `LIVE` policies (e.g. a core network resource created without the `policy_document` argument) and your policy document has static routes pointing to VPC attachments and you want to attach your VPCs to the core network before applying the desired policy document. Valid values are `true` or `false`. Conflicts with `policy_document`. An example of this Terraform snippet can be found above [for VPC Attachment in a single region](#with-vpc-attachment-single-region) and [for VPC Attachment multi-region](#with-vpc-attachment-multi-region). An example base policy is shown below. This base policy is overridden with the policy that you specify in the `aws_networkmanager_core_network_policy_attachment` resource.",
      "new": "* `create_base_policy` - (Optional) Specifies whether to create a base policy when a core network is created or updated. A base policy is created and set to `LIVE` to allow attachments to the core network (e.g. VPC Attachments) before applying a policy document provided using the `aws_networkmanager_core_network_policy_attachment` resource. This base policy is needed if your core network does not have any `LIVE` policies (e.g. a core network resource created without the `policy_document` argument) and your policy document has static routes pointing to VPC attachments and you want to attach your VPCs to the core network before applying the desired policy document. Valid values are `true` or `false`. Conflicts with `policy_document`. An example of this snippet can be found above [for VPC Attachment in a single region](#with-vpc-attachment-single-region) and [for VPC Attachment multi-region](#with-vpc-attachment-multi-region). An example base policy is shown below. This base policy is overridden with the policy that you specify in the `aws_networkmanager_core_network_policy_attachment` resource."
    },
    {
      "old": "* `create_base_policy` - (Optional) Specifies whether to create a base policy when a core network is created or updated. A base policy is created and set to `LIVE` to allow attachments to the core network (e.g. VPC Attachments) before applying a policy document provided using the `aws_networkmanager_core_network_policy_attachment` resource. This base policy is needed if your core network does not have any `LIVE` policies and your policy document has static routes pointing to VPC attachments and you want to attach your VPCs to the core network before applying the desired policy document. Valid values are `true` or `false`. An example of this Terraform snippet can be found above [for VPC Attachment in a single region](#with-vpc-attachment-single-region) and [for VPC Attachment multi-region](#with-vpc-attachment-multi-region). An example base policy is shown below. This base policy is overridden with the policy that you specify in the `aws_networkmanager_core_network_policy_attachment` resource.",
      "new": "* `create_base_policy` - (Optional) Specifies whether to create a base policy when a core network is created or updated. A base policy is created and set to `LIVE` to allow attachments to the core network (e.g. VPC Attachments) before applying a policy document provided using the `aws_networkmanager_core_network_policy_attachment` resource. This base policy is needed if your core network does not have any `LIVE` policies and your policy document has static routes pointing to VPC attachments and you want to attach your VPCs to the core network before applying the desired policy document. Valid values are `true` or `false`. An example of this Pulumi snippet can be found above [for VPC Attachment in a single region](#with-vpc-attachment-single-region) and [for VPC Attachment multi-region](#with-vpc-attachment-multi-region). An example base policy is shown below. This base policy is overridden with the policy that you specify in the `aws_networkmanager_core_network_policy_attachment` resource."
    },
    {
      "old": "The example below illustrates the scenario where your policy document has static routes pointing to VPC attachments and you want to attach your VPCs to the core network before applying the desired policy document. Set the `create_base_policy` argument of the `aws_networkmanager_core_network` resource to `true` if your core network does not currently have any `LIVE` policies (e.g. this is the first `terraform apply` with the core network resource), since a `LIVE` policy is required before VPCs can be attached to the core network. Otherwise, if your core network already has a `LIVE` policy, you may exclude the `create_base_policy` argument. For multi-region in a core network that does not yet have a `LIVE` policy, pass a list of regions to the `aws_networkmanager_core_network` `base_policy_regions` argument. In the example below, `us-west-2` and `us-east-1` are specified in the base policy.",
      "new": "The example below illustrates the scenario where your policy document has static routes pointing to VPC attachments and you want to attach your VPCs to the core network before applying the desired policy document. Set the `create_base_policy` argument of the `aws_networkmanager_core_network` resource to `true` if your core network does not currently have any `LIVE` policies (e.g. this is the first `pulumi up` with the core network resource), since a `LIVE` policy is required before VPCs can be attached to the core network. Otherwise, if your core network already has a `LIVE` policy, you may exclude the `create_base_policy` argument. For multi-region in a core network that does not yet have a `LIVE` policy, pass a list of regions to the `aws_networkmanager_core_network` `base_policy_regions` argument. In the example below, `us-west-2` and `us-east-1` are specified in the base policy."
    },
    {
      "old": "The example below illustrates the scenario where your policy document has static routes pointing to VPC attachments and you want to attach your VPCs to the core network before applying the desired policy document. Set the `create_base_policy` argument to `true` if your core network does not currently have any `LIVE` policies (e.g. this is the first `terraform apply` with the core network resource), since a `LIVE` policy is required before VPCs can be attached to the core network. Otherwise, if your core network already has a `LIVE` policy, you may exclude the `create_base_policy` argument.",
      "new": "The example below illustrates the scenario where your policy document has static routes pointing to VPC attachments and you want to attach your VPCs to the core network before applying the desired policy document. Set the `create_base_policy` argument to `true` if your core network does not currently have any `LIVE` policies (e.g. this is the first `pulumi up` with the core network resource), since a `LIVE` policy is required before VPCs can be attached to the core network. Otherwise, if your core network already has a `LIVE` policy, you may exclude the `create_base_policy` argument."
    },
    {
      "old": "~> **NOTE on Core Networks and Policy Attachments:** For a given core network, this resource's `policy_document` argument is incompatible with using the `aws_networkmanager_core_network_policy_attachment` resource. When using this resource's `policy_document` argument and the `aws_networkmanager_core_network_policy_attachment` resource, both will attempt to manage the core network's policy document and Terraform will show a permanent difference.",
      "new": "~> **NOTE on Core Networks and Policy Attachments:** For a given core network, this resource's `policy_document` argument is incompatible with using the `aws_networkmanager_core_network_policy_attachment` resource. When using this resource's `policy_document` argument and the `aws_networkmanager_core_network_policy_attachment` resource, both will attempt to manage the core network's policy document and Pulumi will show a permanent difference."
    }
  ],
  "website/docs/r/networkmanager_core_network_policy_attachment.html.markdown": [
    {
      "old": "The example below illustrates the scenario where your policy document has static routes pointing to VPC attachments and you want to attach your VPCs to the core network before applying the desired policy document. Set the `create_base_policy` argument of the `aws_networkmanager_core_network` resource to `true` if your core network does not currently have any `LIVE` policies (e.g. this is the first `terraform apply` with the core network resource), since a `LIVE` policy is required before VPCs can be attached to the core network. Otherwise, if your core network already has a `LIVE` policy, you may exclude the `create_base_policy` argument.",
      "new": "The example below illustrates the scenario where your policy document has static routes pointing to VPC attachments and you want to attach your VPCs to the core network before applying the desired policy document. Set the `create_base_policy` argument of the `aws_networkmanager_core_network` resource to `true` if your core network does not currently have any `LIVE` policies (e.g. this is the first `pulumi up` with the core network resource), since a `LIVE` policy is required before VPCs can be attached to the core network. Otherwise, if your core network already has a `LIVE` policy, you may exclude the `create_base_policy` argument."
    },
    {
      "old": "~> **NOTE on Core Networks and Policy Attachments:** For a given policy attachment, this resource is incompatible with using the `aws_networkmanager_core_network` resource `policy_document` argument. When using that argument and this resource, both will attempt to manage the core network's policy document and Terraform will show a permanent difference.",
      "new": "~> **NOTE on Core Networks and Policy Attachments:** For a given policy attachment, this resource is incompatible with using the `aws_networkmanager_core_network` resource `policy_document` argument. When using that argument and this resource, both will attempt to manage the core network's policy document and Pulumi will show a permanent difference."
    }
  ],
  "website/docs/r/opensearch_domain.html.markdown": [
    {
      "old": "  description = \"Managed by Terraform\"",
      "new": "  description = \"Managed by Pulumi\""
    },
    {
      "old": "* `advanced_options` - (Optional) Key-value string pairs to specify advanced configuration options. Note that the values for these configuration options must be strings (wrapped in quotes) or they may be wrong and cause a perpetual diff, causing Terraform to want to recreate your OpenSearch domain on every apply.",
      "new": "* `advanced_options` - (Optional) Key-value string pairs to specify advanced configuration options. Note that the values for these configuration options must be strings (wrapped in quotes) or they may be wrong and cause a perpetual diff, causing the provider to want to recreate your OpenSearch domain on every apply."
    },
    {
      "old": "* `kms_key_id` - (Optional) KMS key ARN to encrypt the Elasticsearch domain with. If not specified then it defaults to using the `aws/es` service KMS key. Note that KMS will accept a KMS key ID but will return the key ARN. To prevent Terraform detecting unwanted changes, use the key ARN instead.",
      "new": "* `kms_key_id` - (Optional) KMS key ARN to encrypt the Elasticsearch domain with. If not specified then it defaults to using the `aws/es` service KMS key. Note that KMS will accept a KMS key ID but will return the key ARN. To prevent the provider detecting unwanted changes, use the key ARN instead."
    },
    {
      "old": "* `tls_security_policy` - (Optional) Name of the TLS security policy that needs to be applied to the HTTPS endpoint. Valid values:  `Policy-Min-TLS-1-0-2019-07` and `Policy-Min-TLS-1-2-2019-07`. Terraform will only perform drift detection if a configuration value is provided.",
      "new": "* `tls_security_policy` - (Optional) Name of the TLS security policy that needs to be applied to the HTTPS endpoint. Valid values:  `Policy-Min-TLS-1-0-2019-07` and `Policy-Min-TLS-1-2-2019-07`. The provider will only perform drift detection if a configuration value is provided."
    },
    {
      "old": "~> **Note:** You can enable `encrypt_at_rest` _in place_ for an existing, unencrypted domain only if you are using OpenSearch or your Elasticsearch version is 6.7 or greater. For other versions, if you enable `encrypt_at_rest`, Terraform with recreate the domain, potentially causing data loss. For any version, if you disable `encrypt_at_rest` for an existing, encrypted domain, Terraform will recreate the domain, potentially causing data loss. If you change the `kms_key_id`, Terraform will also recreate the domain, potentially causing data loss.",
      "new": "~> **Note:** You can enable `encrypt_at_rest` _in place_ for an existing, unencrypted domain only if you are using OpenSearch or your Elasticsearch version is 6.7 or greater. For other versions, if you enable `encrypt_at_rest`, the provider will recreate the domain, potentially causing data loss. For any version, if you disable `encrypt_at_rest` for an existing, encrypted domain, the provider will recreate the domain, potentially causing data loss. If you change the `kms_key_id`, the provider will also recreate the domain, potentially causing data loss."
    },
    {
      "old": "~> **Note:** You can enable `node_to_node_encryption` _in place_ for an existing, unencrypted domain only if you are using OpenSearch or your Elasticsearch version is 6.7 or greater. For other versions, if you enable `node_to_node_encryption`, Terraform will recreate the domain, potentially causing data loss. For any version, if you disable `node_to_node_encryption` for an existing, node-to-node encrypted domain, Terraform will recreate the domain, potentially causing data loss.",
      "new": "~> **Note:** You can enable `node_to_node_encryption` _in place_ for an existing, unencrypted domain only if you are using OpenSearch or your Elasticsearch version is 6.7 or greater. For other versions, if you enable `node_to_node_encryption`, the provider will recreate the domain, potentially causing data loss. For any version, if you disable `node_to_node_encryption` for an existing, node-to-node encrypted domain, the provider will recreate the domain, potentially causing data loss."
    }
  ],
  "website/docs/r/opsworks_rds_db_instance.html.markdown": [
    {
      "old": "Read more about sensitive data in state.\n"
    }
  ],
  "website/docs/r/opsworks_stack.html.markdown": [
    {
      "old": "* `password` - (Optional) Password to use when authenticating to the source. Terraform cannot perform drift detection of this configuration.",
      "new": "* `password` - (Optional) Password to use when authenticating to the source. The provider cannot perform drift detection of this configuration."
    },
    {
      "old": "* `ssh_key` - (Optional) SSH key to use when authenticating to the source. Terraform cannot perform drift detection of this configuration.",
      "new": "* `ssh_key` - (Optional) SSH key to use when authenticating to the source. This provider cannot perform drift detection of this configuration."
    }
  ],
  "website/docs/r/organizations_account.html.markdown": [
    {
      "old": "* `create_govcloud` - (Optional) Whether to also create a GovCloud account. The GovCloud account is tied to the main (commercial) account this resource creates. If `true`, the GovCloud account ID is available in the `govcloud_id` attribute. The only way to manage the GovCloud account with Terraform is to subsequently import the account using this resource.",
      "new": "* `create_govcloud` - (Optional) Whether to also create a GovCloud account. The GovCloud account is tied to the main (commercial) account this resource creates. If `true`, the GovCloud account ID is available in the `govcloud_id` attribute. The only way to manage the GovCloud account with the provider is to subsequently import the account using this resource."
    }
  ],
  "website/docs/r/qldb_ledger.html.markdown": [
    {
      "old": "* `deletion_protection` - (Optional) The deletion protection for the QLDB Ledger instance. By default it is `true`. To delete this resource via Terraform, this value must be configured to `false` and applied first before attempting deletion.",
      "new": "* `deletion_protection` - (Optional) The deletion protection for the QLDB Ledger instance. By default it is `true`. To delete this resource via the provider, this value must be configured to `false` and applied first before attempting deletion."
    },
    {
      "old": "* `name` - (Optional) The friendly name for the QLDB Ledger instance. By default generated by Terraform.",
      "new": "* `name` - (Optional) The friendly name for the QLDB Ledger instance. By default generated by the provider."
    }
  ],
  "website/docs/r/quicksight_account_subscription.html.markdown": [
    {
      "old": "  account_name          = \"quicksight-terraform\"",
      "new": "  account_name          = \"quicksight-pulumi\""
    }
  ],
  "website/docs/r/rds_cluster.html.markdown": [
    {
      "old": "* `availability_zones` - (Optional) List of EC2 Availability Zones for the DB cluster storage where DB cluster instances can be created. RDS automatically assigns 3 AZs if less than 3 AZs are configured, which will show as a difference requiring resource recreation next Terraform apply. We recommend specifying 3 AZs or using the `lifecycle` configuration block `ignore_changes` argument if necessary.",
      "new": "* `availability_zones` - (Optional) List of EC2 Availability Zones for the DB cluster storage where DB cluster instances can be created. RDS automatically assigns 3 AZs if less than 3 AZs are configured, which will show as a difference requiring resource recreation next apply. We recommend specifying 3 AZs or using the `lifecycle` configuration block `ignore_changes` argument if necessary."
    },
    {
      "old": "* `cluster_identifier` - (Optional, Forces new resources) The cluster identifier. If omitted, Terraform will assign a random, unique identifier.",
      "new": "* `cluster_identifier` - (Optional, Forces new resources) The cluster identifier. If omitted, this provider will assign a random, unique identifier."
    },
    {
      "old": "* `replication_source_identifier` - (Optional) ARN of a source DB cluster or DB instance if this DB cluster is to be created as a Read Replica. If DB Cluster is part of a Global Cluster, use the `lifecycle` configuration block `ignore_changes` argument to prevent Terraform from showing differences for this argument instead of configuring this value.",
      "new": "* `replication_source_identifier` - (Optional) ARN of a source DB cluster or DB instance if this DB cluster is to be created as a Read Replica. If DB Cluster is part of a Global Cluster, use the `lifecycle` configuration block `ignore_changes` argument to prevent this provider from showing differences for this argument instead of configuring this value."
    },
    {
      "old": "* `storage_encrypted` - (Optional) Specifies whether the DB cluster is encrypted. The default is `false` for `provisioned` `engine_mode` and `true` for `serverless` `engine_mode`. When restoring an unencrypted `snapshot_identifier`, the `kms_key_id` argument must be provided to encrypt the restored cluster. Terraform will only perform drift detection if a configuration value is provided.",
      "new": "* `storage_encrypted` - (Optional) Specifies whether the DB cluster is encrypted. The default is `false` for `provisioned` `engine_mode` and `true` for `serverless` `engine_mode`. When restoring an unencrypted `snapshot_identifier`, the `kms_key_id` argument must be provided to encrypt the restored cluster. The provider will only perform drift detection if a configuration value is provided."
    },
    {
      "old": "[1]: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Overview.Replication.html"
    },
    {
      "old": "[3]: /docs/providers/aws/r/rds_cluster_instance.html"
    }
  ],
  "website/docs/r/rds_cluster_activity_stream.html.markdown": [
    {
      "old": "~> **Note:** This resource always calls the RDS [`StartActivityStream`][2] API with the `ApplyImmediately` parameter set to `true`. This is because the Terraform needs the activity stream to be started in order for it to get the associated attributes.",
      "new": "~> **Note:** This resource always calls the RDS [`StartActivityStream`][2] API with the `ApplyImmediately` parameter set to `true`. This is because the provider needs the activity stream to be started in order for it to get the associated attributes."
    }
  ],
  "website/docs/r/rds_cluster_instance.html.markdown": [
    {
      "old": "* `identifier` - (Optional, Forces new resource) Identifier for the RDS instance, if omitted, Terraform will assign a random, unique identifier.",
      "new": "* `identifier` - (Optional, Forces new resource) Identifier for the RDS instance, if omitted, Pulumi will assign a random, unique identifier."
    },
    {
      "old": "[3]: /docs/providers/aws/r/rds_cluster.html"
    },
    {
      "old": "[5]: https://www.terraform.io/docs/configuration/meta-arguments/count.html"
    },
    {
      "old": "attributes that are specific to a single instance in a [RDS Cluster][3],",
      "new": "attributes that are specific to a single instance in a RDS Cluster,"
    }
  ],
  "website/docs/r/rds_global_cluster.html.markdown": [
    {
      "old": "* `engine_version` - (Optional) Engine version of the Aurora global database. The `engine`, `engine_version`, and `instance_class` (on the `aws_rds_cluster_instance`) must together support global databases. See [Using Amazon Aurora global databases](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-global-database.html) for more information. By upgrading the engine version, Terraform will upgrade cluster members. **NOTE:** To avoid an `inconsistent final plan` error while upgrading, use the `lifecycle` `ignore_changes` for `engine_version` meta argument on the associated `aws_rds_cluster` resource as shown above in [Upgrading Engine Versions](#upgrading-engine-versions) example.",
      "new": "* `engine_version` - (Optional) Engine version of the Aurora global database. The `engine`, `engine_version`, and `instance_class` (on the `aws_rds_cluster_instance`) must together support global databases. See [Using Amazon Aurora global databases](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-global-database.html) for more information. By upgrading the engine version, the provider will upgrade cluster members. **NOTE:** To avoid an `inconsistent final plan` error while upgrading, use the `lifecycle` `ignore_changes` for `engine_version` meta argument on the associated `aws_rds_cluster` resource as shown above in [Upgrading Engine Versions](#upgrading-engine-versions) example."
    },
    {
      "old": "* `engine` - (Optional, Forces new resources) Name of the database engine to be used for this DB cluster. Terraform will only perform drift detection if a configuration value is provided. Valid values: `aurora`, `aurora-mysql`, `aurora-postgresql`. Defaults to `aurora`. Conflicts with `source_db_cluster_identifier`.",
      "new": "* `engine` - (Optional, Forces new resources) Name of the database engine to be used for this DB cluster. The provider will only perform drift detection if a configuration value is provided. Valid values: `aurora`, `aurora-mysql`, `aurora-postgresql`. Defaults to `aurora`. Conflicts with `source_db_cluster_identifier`."
    },
    {
      "old": "When you upgrade the version of an `aws_rds_global_cluster`, Terraform will attempt to in-place upgrade the engine versions of all associated clusters. Since the `aws_rds_cluster` resource is being updated through the `aws_rds_global_cluster`, you are likely to get an error (`Provider produced inconsistent final plan`). To avoid this, use the `lifecycle` `ignore_changes` meta argument as shown below on the `aws_rds_cluster`.",
      "new": "When you upgrade the version of an `aws_rds_global_cluster`, the provider will attempt to in-place upgrade the engine versions of all associated clusters. Since the `aws_rds_cluster` resource is being updated through the `aws_rds_global_cluster`, you are likely to get an error (`Provider produced inconsistent final plan`). To avoid this, use the `lifecycle` `ignore_changes` meta argument as shown below on the `aws_rds_cluster`."
    }
  ],
  "website/docs/r/redshift_security_group.html.markdown": [
    {
      "old": "!> **WARNING:** With the retirement of EC2-Classic the `aws_redshift_security_group` resource has been deprecated and will be removed in a future version. Any existing resources can be removed from Terraform state using the `terraform state rm` command.",
      "new": "!> **WARNING:** With the retirement of EC2-Classic the `aws_redshift_security_group` resource has been deprecated and will be removed in a future version. Any existing resources can be removed from state manually."
    }
  ],
  "website/docs/r/route.html.markdown": [
    {
      "old": "~> **NOTE on Route Tables and Routes:** Terraform currently provides both a standalone Route resource and a Route Table resource with routes defined in-line. At this time you cannot use a Route Table with in-line routes in conjunction with any Route resources. Doing so will cause a conflict of rule settings and will overwrite rules.",
      "new": "~> **NOTE on Route Tables and Routes:** This provider currently provides both a standalone Route resource and a Route Table resource with routes defined in-line. At this time you cannot use a Route Table with in-line routes in conjunction with any Route resources. Doing so will cause a conflict of rule settings and will overwrite rules."
    },
    {
      "old": "~> **NOTE on `gateway_id` attribute:** The AWS API is very forgiving with the resource ID passed in the `gateway_id` attribute. For example an `aws_route` resource can be created with an `aws_nat_gateway` or `aws_egress_only_internet_gateway` ID specified for the `gateway_id` attribute. Specifying anything other than an `aws_internet_gateway` or `aws_vpn_gateway` ID will lead to Terraform reporting a permanent diff between your configuration and recorded state, as the AWS API returns the more-specific attribute. If you are experiencing constant diffs with an `aws_route` resource, the first thing to check is that the correct attribute is being specified.",
      "new": "~> **NOTE on `gateway_id` attribute:** The AWS API is very forgiving with the resource ID passed in the `gateway_id` attribute. For example an `aws_route` resource can be created with an `aws_nat_gateway` or `aws_egress_only_internet_gateway` ID specified for the `gateway_id` attribute. Specifying anything other than an `aws_internet_gateway` or `aws_vpn_gateway` ID will lead to this provider reporting a permanent diff between your configuration and recorded state, as the AWS API returns the more-specific attribute. If you are experiencing constant diffs with an `aws_route` resource, the first thing to check is that the correct attribute is being specified."
    }
  ],
  "website/docs/r/route53_record.html.markdown": [
    {
      "old": "* `records` - (Required for non-alias records) A string list of records. To specify a single record value longer than 255 characters such as a TXT record for DKIM, add `\\\"\\\"` inside the Terraform configuration string (e.g., `\"first255characters\\\"\\\"morecharacters\"`).",
      "new": "* `records` - (Required for non-alias records) A string list of records. To specify a single record value longer than 255 characters such as a TXT record for DKIM, add `\\\"\\\"` inside the provider configuration string (e.g., `\"first255characters\\\"\\\"morecharacters\"`)."
    }
  ],
  "website/docs/r/route53domains_registered_domain.html.markdown": [
    {
      "old": "The `aws_route53domains_registered_domain` resource behaves differently from normal resources in that if a domain has been registered, Terraform does not _register_ this domain, but instead \"adopts\" it into management. `terraform destroy` does not delete the domain but does remove the resource from Terraform state.",
      "new": "The `aws_route53domains_registered_domain` resource behaves differently from normal resources in that if a domain has been registered, the provider does not _register_ this domain, but instead \"adopts\" it into management. A destroy does not delete the domain but does remove the resource from state."
    }
  ],
  "website/docs/r/s3_bucket.html.markdown": [
    {
      "old": "  Terraform wil only perform drift detection if a configuration value is provided.",
      "new": "  The provider wil only perform drift detection if a configuration value is provided."
    },
    {
      "old": "  Terraform will only perform drift detection if a configuration value is provided.",
      "new": "  The provider will only perform drift detection if a configuration value is provided."
    },
    {
      "old": "* `acceleration_status` - (Optional, **Deprecated**) Sets the accelerate configuration of an existing bucket. Can be `Enabled` or `Suspended`. Cannot be used in `cn-north-1` or `us-gov-west-1`. Terraform will only perform drift detection if a configuration value is provided.",
      "new": "* `acceleration_status` - (Optional, **Deprecated**) Sets the accelerate configuration of an existing bucket. Can be `Enabled` or `Suspended`. Cannot be used in `cn-north-1` or `us-gov-west-1`. This provider will only perform drift detection if a configuration value is provided."
    },
    {
      "old": "* `acl` - (Optional, **Deprecated**) The [canned ACL](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl) to apply. Valid values are `private`, `public-read`, `public-read-write`, `aws-exec-read`, `authenticated-read`, and `log-delivery-write`. Defaults to `private`.  Conflicts with `grant`. Terraform will only perform drift detection if a configuration value is provided. Use the resource `aws_s3_bucket_acl` instead.",
      "new": "* `acl` - (Optional, **Deprecated**) The [canned ACL](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl) to apply. Valid values are `private`, `public-read`, `public-read-write`, `aws-exec-read`, `authenticated-read`, and `log-delivery-write`. Defaults to `private`.  Conflicts with `grant`. The provider will only perform drift detection if a configuration value is provided. Use the resource `aws_s3_bucket_acl` instead."
    },
    {
      "old": "* `cors_rule` - (Optional, **Deprecated**) Rule of [Cross-Origin Resource Sharing](https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html). See [CORS rule](#cors-rule) below for details. Terraform will only perform drift detection if a configuration value is provided. Use the resource `aws_s3_bucket_cors_configuration` instead.",
      "new": "* `cors_rule` - (Optional, **Deprecated**) Rule of [Cross-Origin Resource Sharing](https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html). See [CORS rule](#cors-rule) below for details. This provider will only perform drift detection if a configuration value is provided. Use the resource `aws_s3_bucket_cors_configuration` instead."
    },
    {
      "old": "* `force_destroy` - (Optional, Default:`false`) Boolean that indicates all objects (including any [locked objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock-overview.html)) should be deleted from the bucket *when the bucket is destroyed* so that the bucket can be destroyed without error. These objects are *not* recoverable. This only deletes objects when the bucket is destroyed, *not* when setting this parameter to `true`. Once this parameter is set to `true`, there must be a successful `terraform apply` run before a destroy is required to update this value in the resource state. Without a successful `terraform apply` after this parameter is set, this flag will have no effect. If setting this field in the same operation that would require replacing the bucket or destroying the bucket, this flag will not work. Additionally when importing a bucket, a successful `terraform apply` is required to set this value in state before it will take effect on a destroy operation.",
      "new": "* `force_destroy` - (Optional, Default:`false`) Boolean that indicates all objects (including any [locked objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock-overview.html)) should be deleted from the bucket *when the bucket is destroyed* so that the bucket can be destroyed without error. These objects are *not* recoverable. This only deletes objects when the bucket is destroyed, *not* when setting this parameter to `true`. Once this parameter is set to `true`, there must be a successful `pulumi up` run before a destroy is required to update this value in the resource state. Without a successful `pulumi up` after this parameter is set, this flag will have no effect. If setting this field in the same operation that would require replacing the bucket or destroying the bucket, this flag will not work. Additionally when importing a bucket, a successful `pulumi up` is required to set this value in state before it will take effect on a destroy operation."
    },
    {
      "old": "* `grant` - (Optional, **Deprecated**) An [ACL policy grant](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#sample-acl). See [Grant](#grant) below for details. Conflicts with `acl`. Terraform will only perform drift detection if a configuration value is provided. Use the resource `aws_s3_bucket_acl` instead.",
      "new": "* `grant` - (Optional, **Deprecated**) An [ACL policy grant](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#sample-acl). See [Grant](#grant) below for details. Conflicts with `acl`. The provider will only perform drift detection if a configuration value is provided. Use the resource `aws_s3_bucket_acl` instead."
    },
    {
      "old": "* `lifecycle_rule` - (Optional, **Deprecated**) Configuration of [object lifecycle management](http://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html). See [Lifecycle Rule](#lifecycle-rule) below for details. Terraform will only perform drift detection if a configuration value is provided.",
      "new": "* `lifecycle_rule` - (Optional, **Deprecated**) Configuration of [object lifecycle management](http://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html). See [Lifecycle Rule](#lifecycle-rule) below for details. The provider will only perform drift detection if a configuration value is provided."
    },
    {
      "old": "* `logging` - (Optional, **Deprecated**) Configuration of [S3 bucket logging](https://docs.aws.amazon.com/AmazonS3/latest/UG/ManagingBucketLogging.html) parameters. See [Logging](#logging) below for details. Terraform will only perform drift detection if a configuration value is provided.",
      "new": "* `logging` - (Optional, **Deprecated**) Configuration of [S3 bucket logging](https://docs.aws.amazon.com/AmazonS3/latest/UG/ManagingBucketLogging.html) parameters. See [Logging](#logging) below for details. The provider will only perform drift detection if a configuration value is provided."
    },
    {
      "old": "* `policy` - (Optional, **Deprecated**) Valid [bucket policy](https://docs.aws.amazon.com/AmazonS3/latest/dev/example-bucket-policies.html) JSON document. Note that if the policy document is not specific enough (but still valid), Terraform may view the policy as constantly changing in a `terraform plan`. In this case, please make sure you use the verbose/specific version of the policy. For more information about building AWS IAM policy documents with Terraform, see the AWS IAM Policy Document Guide.",
      "new": "* `policy` - (Optional, **Deprecated**) Valid [bucket policy](https://docs.aws.amazon.com/AmazonS3/latest/dev/example-bucket-policies.html) JSON document. Note that if the policy document is not specific enough (but still valid), this provider may view the policy as constantly changing. In this case, please make sure you use the verbose/specific version of the policy. For more information about building AWS IAM policy documents with this provider, see the AWS IAM Policy Document Guide."
    },
    {
      "old": "* `replication_configuration` - (Optional, **Deprecated**) Configuration of [replication configuration](http://docs.aws.amazon.com/AmazonS3/latest/dev/crr.html). See [Replication Configuration](#replication-configuration) below for details. Terraform will only perform drift detection if a configuration value is provided.",
      "new": "* `replication_configuration` - (Optional, **Deprecated**) Configuration of [replication configuration](http://docs.aws.amazon.com/AmazonS3/latest/dev/crr.html). See [Replication Configuration](#replication-configuration) below for details. The provider will only perform drift detection if a configuration value is provided."
    },
    {
      "old": "* `versioning` - (Optional, **Deprecated**) Configuration of the [S3 bucket versioning state](https://docs.aws.amazon.com/AmazonS3/latest/dev/Versioning.html). See [Versioning](#versioning) below for details. Terraform will only perform drift detection if a configuration value is provided. Use the resource `aws_s3_bucket_versioning` instead.",
      "new": "* `versioning` - (Optional, **Deprecated**) Configuration of the [S3 bucket versioning state](https://docs.aws.amazon.com/AmazonS3/latest/dev/Versioning.html). See [Versioning](#versioning) below for details. The provider will only perform drift detection if a configuration value is provided. Use the resource `aws_s3_bucket_versioning` instead."
    },
    {
      "old": "* `website` - (Optional, **Deprecated**) Configuration of the [S3 bucket website](https://docs.aws.amazon.com/AmazonS3/latest/userguide/WebsiteHosting.html). See [Website](#website) below for details. Terraform will only perform drift detection if a configuration value is provided.",
      "new": "* `website` - (Optional, **Deprecated**) Configuration of the [S3 bucket website](https://docs.aws.amazon.com/AmazonS3/latest/userguide/WebsiteHosting.html). See [Website](#website) below for details. The provider will only perform drift detection if a configuration value is provided."
    },
    {
      "old": "~> **NOTE:** Currently, changes to the `cors_rule` configuration of *existing* resources cannot be automatically detected by Terraform. To manage changes of CORS rules to an S3 bucket, use the `aws_s3_bucket_cors_configuration` resource instead. If you use `cors_rule` on an `aws_s3_bucket`, Terraform will assume management over the full set of CORS rules for the S3 bucket, treating additional CORS rules as drift. For this reason, `cors_rule` cannot be mixed with the external `aws_s3_bucket_cors_configuration` resource for a given S3 bucket.",
      "new": "~> **NOTE:** Currently, changes to the `cors_rule` configuration of *existing* resources cannot be automatically detected by this provider. To manage changes of CORS rules to an S3 bucket, use the `aws_s3_bucket_cors_configuration` resource instead. If you use `cors_rule` on an `aws_s3_bucket`, the provider will assume management over the full set of CORS rules for the S3 bucket, treating additional CORS rules as drift. For this reason, `cors_rule` cannot be mixed with the external `aws_s3_bucket_cors_configuration` resource for a given S3 bucket."
    },
    {
      "old": "~> **NOTE:** Currently, changes to the `grant` configuration of *existing* resources cannot be automatically detected by Terraform. To manage changes of ACL grants to an S3 bucket, use the `aws_s3_bucket_acl` resource instead. If you use `grant` on an `aws_s3_bucket`, Terraform will assume management over the full set of ACL grants for the S3 bucket, treating additional ACL grants as drift. For this reason, `grant` cannot be mixed with the external `aws_s3_bucket_acl` resource for a given S3 bucket.",
      "new": "~> **NOTE:** Currently, changes to the `grant` configuration of *existing* resources cannot be automatically detected by this provider. To manage changes of ACL grants to an S3 bucket, use the `aws_s3_bucket_acl` resource instead. If you use `grant` on an `aws_s3_bucket`, the provider will assume management over the full set of ACL grants for the S3 bucket, treating additional ACL grants as drift. For this reason, `grant` cannot be mixed with the external `aws_s3_bucket_acl` resource for a given S3 bucket."
    },
    {
      "old": "~> **NOTE:** Currently, changes to the `lifecycle_rule` configuration of *existing* resources cannot be automatically detected by Terraform. To manage changes of Lifecycle rules to an S3 bucket, use the `aws_s3_bucket_lifecycle_configuration` resource instead. If you use `lifecycle_rule` on an `aws_s3_bucket`, Terraform will assume management over the full set of Lifecycle rules for the S3 bucket, treating additional Lifecycle rules as drift. For this reason, `lifecycle_rule` cannot be mixed with the external `aws_s3_bucket_lifecycle_configuration` resource for a given S3 bucket.",
      "new": "~> **NOTE:** Currently, changes to the `lifecycle_rule` configuration of *existing* resources cannot be automatically detected by this provider. To manage changes of Lifecycle rules to an S3 bucket, use the `aws_s3_bucket_lifecycle_configuration` resource instead. If you use `lifecycle_rule` on an `aws_s3_bucket`, the provider will assume management over the full set of Lifecycle rules for the S3 bucket, treating additional Lifecycle rules as drift. For this reason, `lifecycle_rule` cannot be mixed with the external `aws_s3_bucket_lifecycle_configuration` resource for a given S3 bucket."
    },
    {
      "old": "~> **NOTE:** Currently, changes to the `logging` configuration of *existing* resources cannot be automatically detected by Terraform. To manage changes of logging parameters to an S3 bucket, use the `aws_s3_bucket_logging` resource instead. If you use `logging` on an `aws_s3_bucket`, Terraform will assume management over the full set of logging parameters for the S3 bucket, treating additional logging parameters as drift. For this reason, `logging` cannot be mixed with the external `aws_s3_bucket_logging` resource for a given S3 bucket.",
      "new": "~> **NOTE:** Currently, changes to the `logging` configuration of *existing* resources cannot be automatically detected by this provider. To manage changes of logging parameters to an S3 bucket, use the `aws_s3_bucket_logging` resource instead. If you use `logging` on an `aws_s3_bucket`, the provider will assume management over the full set of logging parameters for the S3 bucket, treating additional logging parameters as drift. For this reason, `logging` cannot be mixed with the external `aws_s3_bucket_logging` resource for a given S3 bucket."
    },
    {
      "old": "~> **NOTE:** Currently, changes to the `object_lock_configuration` configuration of *existing* resources cannot be automatically detected by Terraform. To manage changes of Object Lock settings to an S3 bucket, use the `aws_s3_bucket_object_lock_configuration` resource instead. If you use `object_lock_configuration` on an `aws_s3_bucket`, Terraform will assume management over the full set of Object Lock configuration parameters for the S3 bucket, treating additional Object Lock configuration parameters as drift. For this reason, `object_lock_configuration` cannot be mixed with the external `aws_s3_bucket_object_lock_configuration` resource for a given S3 bucket.",
      "new": "~> **NOTE:** Currently, changes to the `object_lock_configuration` configuration of *existing* resources cannot be automatically detected by this provider. To manage changes of Object Lock settings to an S3 bucket, use the `aws_s3_bucket_object_lock_configuration` resource instead. If you use `object_lock_configuration` on an `aws_s3_bucket`, the provider will assume management over the full set of Object Lock configuration parameters for the S3 bucket, treating additional Object Lock configuration parameters as drift. For this reason, `object_lock_configuration` cannot be mixed with the external `aws_s3_bucket_object_lock_configuration` resource for a given S3 bucket."
    },
    {
      "old": "~> **NOTE:** Currently, changes to the `replication_configuration` configuration of *existing* resources cannot be automatically detected by Terraform. To manage replication configuration changes to an S3 bucket, use the `aws_s3_bucket_replication_configuration` resource instead. If you use `replication_configuration` on an `aws_s3_bucket`, Terraform will assume management over the full replication configuration for the S3 bucket, treating additional replication configuration rules as drift. For this reason, `replication_configuration` cannot be mixed with the external `aws_s3_bucket_replication_configuration` resource for a given S3 bucket.",
      "new": "~> **NOTE:** Currently, changes to the `replication_configuration` configuration of *existing* resources cannot be automatically detected by this provider. To manage replication configuration changes to an S3 bucket, use the `aws_s3_bucket_replication_configuration` resource instead. If you use `replication_configuration` on an `aws_s3_bucket`, the provider will assume management over the full replication configuration for the S3 bucket, treating additional replication configuration rules as drift. For this reason, `replication_configuration` cannot be mixed with the external `aws_s3_bucket_replication_configuration` resource for a given S3 bucket."
    },
    {
      "old": "~> **NOTE:** Currently, changes to the `server_side_encryption_configuration` configuration of *existing* resources cannot be automatically detected by Terraform. To manage changes in encryption of an S3 bucket, use the `aws_s3_bucket_server_side_encryption_configuration` resource instead. If you use `server_side_encryption_configuration` on an `aws_s3_bucket`, Terraform will assume management over the encryption configuration for the S3 bucket, treating additional encryption changes as drift. For this reason, `server_side_encryption_configuration` cannot be mixed with the external `aws_s3_bucket_server_side_encryption_configuration` resource for a given S3 bucket.",
      "new": "~> **NOTE:** Currently, changes to the `server_side_encryption_configuration` configuration of *existing* resources cannot be automatically detected by this provider. To manage changes in encryption of an S3 bucket, use the `aws_s3_bucket_server_side_encryption_configuration` resource instead. If you use `server_side_encryption_configuration` on an `aws_s3_bucket`, the provider will assume management over the encryption configuration for the S3 bucket, treating additional encryption changes as drift. For this reason, `server_side_encryption_configuration` cannot be mixed with the external `aws_s3_bucket_server_side_encryption_configuration` resource for a given S3 bucket."
    },
    {
      "old": "~> **NOTE:** Currently, changes to the `versioning` configuration of *existing* resources cannot be automatically detected by Terraform. To manage changes of versioning state to an S3 bucket, use the `aws_s3_bucket_versioning` resource instead. If you use `versioning` on an `aws_s3_bucket`, Terraform will assume management over the versioning state of the S3 bucket, treating additional versioning state changes as drift. For this reason, `versioning` cannot be mixed with the external `aws_s3_bucket_versioning` resource for a given S3 bucket.",
      "new": "~> **NOTE:** Currently, changes to the `versioning` configuration of *existing* resources cannot be automatically detected by this provider. To manage changes of versioning state to an S3 bucket, use the `aws_s3_bucket_versioning` resource instead. If you use `versioning` on an `aws_s3_bucket`, the provider will assume management over the versioning state of the S3 bucket, treating additional versioning state changes as drift. For this reason, `versioning` cannot be mixed with the external `aws_s3_bucket_versioning` resource for a given S3 bucket."
    },
    {
      "old": "~> **NOTE:** Currently, changes to the `website` configuration of *existing* resources cannot be automatically detected by Terraform. To manage changes to the website configuration of an S3 bucket, use the `aws_s3_bucket_website_configuration` resource instead. If you use `website` on an `aws_s3_bucket`, Terraform will assume management over the configuration of the website of the S3 bucket, treating additional website configuration changes as drift. For this reason, `website` cannot be mixed with the external `aws_s3_bucket_website_configuration` resource for a given S3 bucket.",
      "new": "~> **NOTE:** Currently, changes to the `website` configuration of *existing* resources cannot be automatically detected by this provider. To manage changes to the website configuration of an S3 bucket, use the `aws_s3_bucket_website_configuration` resource instead. If you use `website` on an `aws_s3_bucket`, the provider will assume management over the configuration of the website of the S3 bucket, treating additional website configuration changes as drift. For this reason, `website` cannot be mixed with the external `aws_s3_bucket_website_configuration` resource for a given S3 bucket."
    }
  ],
  "website/docs/r/s3_bucket_accelerate_configuration.html.markdown": [
    {
      "old": "If the owner (account ID) of the source bucket differs from the account used to configure the Terraform AWS Provider,",
      "new": "If the owner (account ID) of the source bucket differs from the account used to configure the AWS Provider,"
    },
    {
      "old": "If the owner (account ID) of the source bucket is the same account used to configure the Terraform AWS Provider,",
      "new": "If the owner (account ID) of the source bucket is the same account used to configure the AWS Provider,"
    }
  ],
  "website/docs/r/s3_bucket_acl.html.markdown": [
    {
      "old": "If the owner (account ID) of the source bucket _differs_ from the account used to configure the Terraform AWS Provider, and the source bucket is **configured** with a",
      "new": "If the owner (account ID) of the source bucket _differs_ from the account used to configure the AWS Provider, and the source bucket is **configured** with a"
    },
    {
      "old": "If the owner (account ID) of the source bucket _differs_ from the account used to configure the Terraform AWS Provider, and the source bucket is **not configured** with a",
      "new": "If the owner (account ID) of the source bucket _differs_ from the account used to configure the AWS Provider, and the source bucket is **not configured** with a"
    },
    {
      "old": "If the owner (account ID) of the source bucket is the _same_ account used to configure the Terraform AWS Provider, and the source bucket is **configured** with a",
      "new": "If the owner (account ID) of the source bucket is the _same_ account used to configure the AWS Provider, and the source bucket is **configured** with a"
    },
    {
      "old": "If the owner (account ID) of the source bucket is the _same_ account used to configure the Terraform AWS Provider, and the source bucket is **not configured** with a",
      "new": "If the owner (account ID) of the source bucket is the _same_ account used to configure the AWS Provider, and the source bucket is **not configured** with a"
    },
    {
      "old": "~> **Note:** `terraform destroy` does not delete the S3 Bucket ACL but does remove the resource from Terraform state.",
      "new": "~> **Note:** destroy does not delete the S3 Bucket ACL but does remove the resource from state."
    }
  ],
  "website/docs/r/s3_bucket_cors_configuration.html.markdown": [
    {
      "old": "    allowed_origins = [\"https://s3-website-test.hashicorp.com\"]",
      "new": "    allowed_origins = [\"https://s3-website-test.domain.example\"]"
    },
    {
      "old": "If the owner (account ID) of the source bucket differs from the account used to configure the Terraform AWS Provider,",
      "new": "If the owner (account ID) of the source bucket differs from the account used to configure the AWS Provider,"
    },
    {
      "old": "If the owner (account ID) of the source bucket is the same account used to configure the Terraform AWS Provider,",
      "new": "If the owner (account ID) of the source bucket is the same account used to configure the AWS Provider,"
    }
  ],
  "website/docs/r/s3_bucket_lifecycle_configuration.html.markdown": [
    {
      "old": "If the owner (account ID) of the source bucket differs from the account used to configure the Terraform AWS Provider,",
      "new": "If the owner (account ID) of the source bucket differs from the account used to configure the AWS Provider,"
    },
    {
      "old": "If the owner (account ID) of the source bucket is the same account used to configure the Terraform AWS Provider,",
      "new": "If the owner (account ID) of the source bucket is the same account used to configure the AWS Provider,"
    },
    {
      "old": "Since `prefix` is deprecated by Amazon S3 and will be removed in the next major version of the Terraform AWS Provider, we recommend users either specify `filter` or leave both `filter` and `prefix` unspecified.",
      "new": "Since `prefix` is deprecated by Amazon S3 and will be removed in the next major version of the AWS Provider, we recommend users either specify `filter` or leave both `filter` and `prefix` unspecified."
    },
    {
      "old": "parameter in the Terraform AWS Provider `aws_s3_bucket` resource prior to `v4.0`.",
      "new": "parameter in the AWS Provider `aws_s3_bucket` resource prior to `v4.0`."
    },
    {
      "old": "~> **NOTE** Terraform cannot distinguish a difference between configurations that use `rule.filter {}` and configurations that neither use `rule.filter` nor `rule.prefix`, so a rule cannot be updated from applying to all objects in the bucket via `rule.filter {}` to applying to a subset of objects based on the key prefix `\"\"` and vice versa.",
      "new": "~> **NOTE** The provider cannot distinguish a difference between configurations that use `rule.filter {}` and configurations that neither use `rule.filter` nor `rule.prefix`, so a rule cannot be updated from applying to all objects in the bucket via `rule.filter {}` to applying to a subset of objects based on the key prefix `\"\"` and vice versa."
    }
  ],
  "website/docs/r/s3_bucket_logging.html.markdown": [
    {
      "old": "If the owner (account ID) of the source bucket differs from the account used to configure the Terraform AWS Provider,",
      "new": "If the owner (account ID) of the source bucket differs from the account used to configure the AWS Provider,"
    },
    {
      "old": "If the owner (account ID) of the source bucket is the same account used to configure the Terraform AWS Provider,",
      "new": "If the owner (account ID) of the source bucket is the same account used to configure the AWS Provider,"
    }
  ],
  "website/docs/r/s3_bucket_notification.html.markdown": [
    {
      "old": "For Terraform's JSON syntax, use an array instead of defining the `queue` key twice.",
      "new": "For JSON syntax, use an array instead of defining the `queue` key twice."
    }
  ],
  "website/docs/r/s3_bucket_object.html.markdown": [
    {
      "old": "  # For Terraform 0.11.11 and earlier, use the md5() function and the file() function:"
    },
    {
      "old": "  # The filemd5() function is available in Terraform 0.11.12 and later"
    },
    {
      "old": "* `etag` - (Optional) Triggers updates when the value changes. The only meaningful value is `filemd5(\"path/to/file\")` (Terraform 0.11.12 or later) or `${md5(file(\"path/to/file\"))}` (Terraform 0.11.11 or earlier). This attribute is not compatible with KMS encryption, `kms_key_id` or `server_side_encryption = \"aws:kms\"` (see `source_hash` instead).",
      "new": "* `etag` - (Optional) Triggers updates when the value changes. This attribute is not compatible with KMS encryption, `kms_key_id` or `server_side_encryption = \"aws:kms\"` (see `source_hash` instead)."
    },
    {
      "old": "* `source_hash` - (Optional) Triggers updates like `etag` but useful to address `etag` encryption limitations. Set using `filemd5(\"path/to/source\")` (Terraform 0.11.12 or later). (The value is only stored in state and not saved by AWS.)",
      "new": "* `source_hash` - (Optional) Triggers updates like `etag` but useful to address `etag` encryption limitations."
    }
  ],
  "website/docs/r/s3_bucket_object_lock_configuration.html.markdown": [
    {
      "old": "If the owner (account ID) of the source bucket differs from the account used to configure the Terraform AWS Provider,",
      "new": "If the owner (account ID) of the source bucket differs from the account used to configure the AWS Provider,"
    },
    {
      "old": "If the owner (account ID) of the source bucket is the same account used to configure the Terraform AWS Provider,",
      "new": "If the owner (account ID) of the source bucket is the same account used to configure the AWS Provider,"
    }
  ],
  "website/docs/r/s3_bucket_policy.html.markdown": [
    {
      "old": "* `policy` - (Required) Text of the policy. Although this is a bucket policy rather than an IAM policy, the `aws_iam_policy_document` data source may be used, so long as it specifies a principal. For more information about building AWS IAM policy documents with Terraform, see the AWS IAM Policy Document Guide. Note: Bucket policies are limited to 20 KB in size.",
      "new": "* `policy` - (Required) Text of the policy. Although this is a bucket policy rather than an IAM policy, the `aws_iam_policy_document` data source may be used, so long as it specifies a principal. For more information about building AWS IAM policy documents, see the AWS IAM Policy Document Guide. Note: Bucket policies are limited to 20 KB in size."
    }
  ],
  "website/docs/r/s3_bucket_request_payment_configuration.html.markdown": [
    {
      "old": "If the owner (account ID) of the source bucket differs from the account used to configure the Terraform AWS Provider,",
      "new": "If the owner (account ID) of the source bucket differs from the account used to configure the AWS Provider,"
    },
    {
      "old": "If the owner (account ID) of the source bucket is the same account used to configure the Terraform AWS Provider,",
      "new": "If the owner (account ID) of the source bucket is the same account used to configure the AWS Provider,"
    }
  ],
  "website/docs/r/s3_bucket_server_side_encryption_configuration.html.markdown": [
    {
      "old": "If the owner (account ID) of the source bucket differs from the account used to configure the Terraform AWS Provider,",
      "new": "If the owner (account ID) of the source bucket differs from the account used to configure the AWS Provider,"
    },
    {
      "old": "If the owner (account ID) of the source bucket is the same account used to configure the Terraform AWS Provider,",
      "new": "If the owner (account ID) of the source bucket is the same account used to configure the AWS Provider,"
    }
  ],
  "website/docs/r/s3_bucket_versioning.html.markdown": [
    {
      "old": "If the owner (account ID) of the source bucket differs from the account used to configure the Terraform AWS Provider,",
      "new": "If the owner (account ID) of the source bucket differs from the account used to configure the AWS Provider,"
    },
    {
      "old": "If the owner (account ID) of the source bucket is the same account used to configure the Terraform AWS Provider,",
      "new": "If the owner (account ID) of the source bucket is the same account used to configure the AWS Provider,"
    },
    {
      "old": "simply remove the resource from Terraform state if the associated S3 bucket is unversioned.",
      "new": "simply remove the resource from state if the associated S3 bucket is unversioned."
    }
  ],
  "website/docs/r/s3_bucket_website_configuration.html.markdown": [
    {
      "old": "If the owner (account ID) of the source bucket differs from the account used to configure the Terraform AWS Provider,",
      "new": "If the owner (account ID) of the source bucket differs from the account used to configure the AWS Provider,"
    },
    {
      "old": "If the owner (account ID) of the source bucket is the same account used to configure the Terraform AWS Provider,",
      "new": "If the owner (account ID) of the source bucket is the same account used to configure the AWS Provider,"
    }
  ],
  "website/docs/r/s3_object.html.markdown": [
    {
      "old": "  # For Terraform 0.11.11 and earlier, use the md5() function and the file() function:"
    },
    {
      "old": "  # The filemd5() function is available in Terraform 0.11.12 and later"
    },
    {
      "old": "* `etag` - (Optional) Triggers updates when the value changes. The only meaningful value is `filemd5(\"path/to/file\")` (Terraform 0.11.12 or later) or `${md5(file(\"path/to/file\"))}` (Terraform 0.11.11 or earlier). This attribute is not compatible with KMS encryption, `kms_key_id` or `server_side_encryption = \"aws:kms\"`, also if an object is larger than 16 MB, the AWS Management Console will upload or copy that object as a Multipart Upload, and therefore the ETag will not be an MD5 digest (see `source_hash` instead).",
      "new": "* `etag` - (Optional) Triggers updates when the value changes. This attribute is not compatible with KMS encryption, `kms_key_id` or `server_side_encryption = \"aws:kms\"`, also if an object is larger than 16 MB, the AWS Management Console will upload or copy that object as a Multipart Upload, and therefore the ETag will not be an MD5 digest (see `source_hash` instead)."
    },
    {
      "old": "* `kms_key_id` - (Optional) ARN of the KMS Key to use for object encryption. If the S3 Bucket has server-side encryption enabled, that value will automatically be used. If referencing the `aws_kms_key` resource, use the `arn` attribute. If referencing the `aws_kms_alias` data source or resource, use the `target_key_arn` attribute. Terraform will only perform drift detection if a configuration value is provided.",
      "new": "* `kms_key_id` - (Optional) ARN of the KMS Key to use for object encryption. If the S3 Bucket has server-side encryption enabled, that value will automatically be used. If referencing the `aws_kms_key` resource, use the `arn` attribute. If referencing the `aws_kms_alias` data source or resource, use the `target_key_arn` attribute. The provider will only perform drift detection if a configuration value is provided."
    },
    {
      "old": "* `source_hash` - (Optional) Triggers updates like `etag` but useful to address `etag` encryption limitations. Set using `filemd5(\"path/to/source\")` (Terraform 0.11.12 or later). (The value is only stored in state and not saved by AWS.)",
      "new": "* `source_hash` - (Optional) Triggers updates like `etag` but useful to address `etag` encryption limitations. (The value is only stored in state and not saved by AWS.)"
    },
    {
      "old": "-> **Note:** Terraform ignores all leading `/`s in the object's `key` and treats multiple `/`s in the rest of the object's `key` as a single `/`, so values of `/index.html` and `index.html` correspond to the same S3 object as do `first//second///third//` and `first/second/third/`.",
      "new": "-> **Note:** The provider ignores all leading `/`s in the object's `key` and treats multiple `/`s in the rest of the object's `key` as a single `/`, so values of `/index.html` and `index.html` correspond to the same S3 object as do `first//second///third//` and `first/second/third/`."
    }
  ],
  "website/docs/r/s3control_access_point_policy.html.markdown": [
    {
      "old": "~> **NOTE on Access Points and Access Point Policies:** Terraform provides both a standalone Access Point Policy resource and an Access Point resource with a resource policy defined in-line. You cannot use an Access Point with in-line resource policy in conjunction with an Access Point Policy resource. Doing so will cause a conflict of policies and will overwrite the access point's resource policy.",
      "new": "~> **NOTE on Access Points and Access Point Policies:** The provider provides both a standalone Access Point Policy resource and an Access Point resource with a resource policy defined in-line. You cannot use an Access Point with in-line resource policy in conjunction with an Access Point Policy resource. Doing so will cause a conflict of policies and will overwrite the access point's resource policy."
    }
  ],
  "website/docs/r/s3control_multi_region_access_point_policy.html.markdown": [
    {
      "old": "* `account_id` - (Optional) The AWS account ID for the owner of the Multi-Region Access Point. Defaults to automatically determined account ID of the Terraform AWS provider.",
      "new": "* `account_id` - (Optional) The AWS account ID for the owner of the Multi-Region Access Point. Defaults to automatically determined account ID of the AWS provider."
    }
  ],
  "website/docs/r/s3control_object_lambda_access_point.html.markdown": [
    {
      "old": "* `account_id` - (Optional) The AWS account ID for the owner of the bucket for which you want to create an Object Lambda Access Point. Defaults to automatically determined account ID of the Terraform AWS provider.",
      "new": "* `account_id` - (Optional) The AWS account ID for the owner of the bucket for which you want to create an Object Lambda Access Point. Defaults to automatically determined account ID of the AWS provider."
    }
  ],
  "website/docs/r/s3control_object_lambda_access_point_policy.html.markdown": [
    {
      "old": "* `account_id` - (Optional) The AWS account ID for the account that owns the Object Lambda Access Point. Defaults to automatically determined account ID of the Terraform AWS provider.",
      "new": "* `account_id` - (Optional) The AWS account ID for the account that owns the Object Lambda Access Point. Defaults to automatically determined account ID of the AWS provider."
    }
  ],
  "website/docs/r/s3control_storage_lens_configuration.html.markdown": [
    {
      "old": "* `account_id` - (Optional) The AWS account ID for the S3 Storage Lens configuration. Defaults to automatically determined account ID of the Terraform AWS provider.",
      "new": "* `account_id` - (Optional) The AWS account ID for the S3 Storage Lens configuration. Defaults to automatically determined account ID of the AWS provider."
    }
  ],
  "website/docs/r/sagemaker_code_repository.html.markdown": [
    {
      "old": "    repository_url = \"https://github.com/hashicorp/terraform-provider-aws.git\"",
      "new": "    repository_url = \"https://github.com/github/docs.git\""
    }
  ],
  "website/docs/r/sagemaker_notebook_instance.html.markdown": [
    {
      "old": "    repository_url = \"https://github.com/hashicorp/terraform-provider-aws.git\"",
      "new": "    repository_url = \"https://github.com/github/docs.git\""
    }
  ],
  "website/docs/r/secretsmanager_secret_version.html.markdown": [
    {
      "old": "Reading key-value pairs from JSON back into a native Terraform map can be accomplished in Terraform 0.12 and later with the `jsondecode()` function:",
      "new": "Reading key-value pairs from JSON back into a native map"
    },
    {
      "old": "~> **NOTE:** If `version_stages` is configured, you must include the `AWSCURRENT` staging label if this secret version is the only version or if the label is currently present on this secret version, otherwise Terraform will show a perpetual difference.",
      "new": "~> **NOTE:** If `version_stages` is configured, you must include the `AWSCURRENT` staging label if this secret version is the only version or if the label is currently present on this secret version, otherwise this provider will show a perpetual difference."
    }
  ],
  "website/docs/r/security_group.html.markdown": [
    {
      "old": "* `description` - (Optional, Forces new resource) Security group description. Defaults to `Managed by Terraform`. Cannot be `\"\"`. **NOTE**: This field maps to the AWS `GroupDescription` attribute, for which there is no Update API. If you'd like to classify your security groups in a way that can be updated, use `tags`.",
      "new": "* `description` - (Optional, Forces new resource) Security group description. Defaults to `Managed by Pulumi`. Cannot be `\"\"`. **NOTE**: This field maps to the AWS `GroupDescription` attribute, for which there is no Update API. If you'd like to classify your security groups in a way that can be updated, use `tags`."
    },
    {
      "old": "* `protocol` - (Required) Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to 0.  The supported values are defined in the `IpProtocol` argument in the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference. This argument is normalized to a lowercase value to match the AWS API requirement when using Terraform 0.12.x and above. Please make sure that the value of the protocol is specified as lowercase when used with older version of Terraform to avoid issues during upgrade.",
      "new": "* `protocol` - (Required) Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to 0.  The supported values are defined in the `IpProtocol` argument in the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference."
    },
    {
      "old": "* `protocol` - (Required) Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to 0.  The supported values are defined in the `IpProtocol` argument on the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference. This argument is normalized to a lowercase value to match the AWS API requirement when using with Terraform 0.12.x and above, please make sure that the value of the protocol is specified as lowercase when using with older version of Terraform to avoid an issue during upgrade.",
      "new": "* `protocol` - (Required) Protocol. If you select a protocol of `-1` (semantically equivalent to `all`, which is not a valid value here), you must specify a `from_port` and `to_port` equal to 0.  The supported values are defined in the `IpProtocol` argument on the [IpPermission](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html) API reference."
    },
    {
      "old": "* `revoke_rules_on_delete` - (Optional) Instruct Terraform to revoke all of the Security Groups attached ingress and egress rules before deleting the rule itself. This is normally not needed, however certain AWS services such as Elastic Map Reduce may automatically add required rules to security groups used with the service, and those rules may contain a cyclic dependency that prevent the security groups from being destroyed without removing the dependency first. Default `false`.",
      "new": "* `revoke_rules_on_delete` - (Optional) Instruct the provider to revoke all of the Security Groups attached ingress and egress rules before deleting the rule itself. This is normally not needed, however certain AWS services such as Elastic Map Reduce may automatically add required rules to security groups used with the service, and those rules may contain a cyclic dependency that prevent the security groups from being destroyed without removing the dependency first. Default `false`."
    },
    {
      "old": "**DISCLAIMER:** We **_HIGHLY_** recommend using one of the above approaches and _NOT_ using local provisioners. Provisioners, like the one shown below, should be considered a **last resort** since they are _not readable_, _require skills outside standard Terraform configuration_, are _error prone_ and _difficult to maintain_, are not compatible with cloud environments and upgrade tools, require AWS CLI installation, and are subject to AWS CLI and Terraform changes outside the AWS Provider.",
      "new": "**DISCLAIMER:** We **_HIGHLY_** recommend using one of the above approaches and _NOT_ using local provisioners. Provisioners, like the one shown below, should be considered a **last resort** since they are _not readable_, _require skills outside standard configuration_, are _error prone_ and _difficult to maintain_, are not compatible with cloud environments and upgrade tools, require AWS CLI installation, and are subject to changes outside the AWS Provider."
    },
    {
      "old": "A simple security group `name` change \"forces new\" the security group--Terraform destroys the security group and creates a new one. (Likewise, `description`, `name_prefix`, or `vpc_id` [cannot be changed](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/working-with-security-groups.html#creating-security-group).) Attempting to recreate the security group leads to a variety of complications depending on how it is used.",
      "new": "A simple security group `name` change \"forces new\" the security group--the provider destroys the security group and creates a new one. (Likewise, `description`, `name_prefix`, or `vpc_id` [cannot be changed](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/working-with-security-groups.html#creating-security-group).) Attempting to recreate the security group leads to a variety of complications depending on how it is used."
    },
    {
      "old": "If destroying a security group takes a long time, it may be because Terraform cannot distinguish between a dependent object (_e.g._, a security group rule or EC2 instance) that is _in the process of being deleted_ and one that is not. In other words, it may be waiting for a train that isn't scheduled to arrive. To fail faster, shorten the `delete` timeout from the default timeout:",
      "new": "If destroying a security group takes a long time, it may be because the provider cannot distinguish between a dependent object (_e.g._, a security group rule or EC2 instance) that is _in the process of being deleted_ and one that is not. In other words, it may be waiting for a train that isn't scheduled to arrive. To fail faster, shorten the `delete` timeout from the default timeout:"
    },
    {
      "old": "Normally, Terraform first deletes the existing security group resource and then creates a new one. When a security group is associated with a resource, the delete won't succeed. You can invert the default behavior using the `create_before_destroy` meta argument:",
      "new": "Normally, the provider first deletes the existing security group resource and then creates a new one. When a security group is associated with a resource, the delete won't succeed. You can invert the default behavior using the `create_before_destroy` meta argument:"
    },
    {
      "old": "Security groups are generally associated with other resources--**more than 100** AWS Provider resources reference security groups. Referencing a resource from another resource creates a one-way dependency. For example, if you create an EC2 `aws_instance` that has a `vpc_security_group_ids` argument that refers to an `aws_security_group` resource, the `aws_security_group` is a dependent of the `aws_instance`. Because of this, Terraform will create the security group first so that it can then be associated with the EC2 instance.",
      "new": "Security groups are generally associated with other resources--**more than 100** AWS Provider resources reference security groups. Referencing a resource from another resource creates a one-way dependency. For example, if you create an EC2 `aws_instance` that has a `vpc_security_group_ids` argument that refers to an `aws_security_group` resource, the `aws_security_group` is a dependent of the `aws_instance`. Because of this, the provider will create the security group first so that it can then be associated with the EC2 instance."
    },
    {
      "old": "Terraform does not model bi-directional dependencies like this, but, even if it did, simply knowing the dependency situation would not be enough to solve it. For example, some resources must always have an associated security group while others don't need to. In addition, when the `aws_security_group` resource attempts to recreate, it receives a dependent object error, which does not provide information on whether the dependent object is a security group rule or, for example, an associated EC2 instance. Within Terraform, the associated resource (_e.g._, `aws_instance`) does not receive an error when the `aws_security_group` is trying to recreate even though that is where changes to the associated resource would need to take place (_e.g._, removing the security group association).",
      "new": "The provider does not model bi-directional dependencies like this, but, even if it did, simply knowing the dependency situation would not be enough to solve it. For example, some resources must always have an associated security group while others don't need to. In addition, when the `aws_security_group` resource attempts to recreate, it receives a dependent object error, which does not provide information on whether the dependent object is a security group rule or, for example, an associated EC2 instance. Within the provider, the associated resource (_e.g._, `aws_instance`) does not receive an error when the `aws_security_group` is trying to recreate even though that is where changes to the associated resource would need to take place (_e.g._, removing the security group association)."
    }
  ],
  "website/docs/r/securityhub_standards_control.markdown": [
    {
      "old": "Terraform does not _create_ this resource, but instead \"adopts\" it",
      "new": "The provider does not _create_ this resource, but instead \"adopts\" it"
    },
    {
      "old": "into management. When you _delete_ this resource configuration, Terraform \"abandons\" resource as is and just removes it from the state.",
      "new": "into management. When you _delete_ this resource configuration, the provider \"abandons\" resource as is and just removes it from the state."
    }
  ],
  "website/docs/r/service_discovery_instance.html.markdown": [
    {
      "old": "  name        = \"example.terraform.com\"",
      "new": "  name        = \"example.domain.test\""
    },
    {
      "old": "  name        = \"example.terraform.local\"",
      "new": "  name        = \"example.domain.local\""
    }
  ],
  "website/docs/r/sns_topic.html.markdown": [
    {
      "old": "* `policy` - (Optional) The fully-formed AWS policy as JSON. For more information about building AWS IAM policy documents with Terraform, see the AWS IAM Policy Document Guide.",
      "new": "* `policy` - (Optional) The fully-formed AWS policy as JSON."
    }
  ],
  "website/docs/r/sns_topic_data_protection_policy.html.markdown": [
    {
      "old": "* `policy` - (Required) The fully-formed AWS policy as JSON. For more information about building AWS IAM policy documents with Terraform, see the AWS IAM Policy Document Guide.",
      "new": "* `policy` - (Required) The fully-formed AWS policy as JSON. For more information about building AWS IAM policy documents with this provider, see the AWS IAM Policy Document Guide."
    }
  ],
  "website/docs/r/sqs_queue.html.markdown": [
    {
      "old": "    sourceQueueArns   = [aws_sqs_queue.terraform_queue.arn]",
      "new": "    sourceQueueArns   = [aws_sqs_queue.example_queue.arn]"
    },
    {
      "old": "  name                    = \"terraform-example-queue\"",
      "new": "  name                    = \"example-queue\""
    },
    {
      "old": "  name                  = \"terraform-example-queue.fifo\"",
      "new": "  name                  = \"example-queue.fifo\""
    },
    {
      "old": "  name = \"terraform-example-deadletter-queue\"",
      "new": "  name = \"example-deadletter-queue\""
    },
    {
      "old": "* `sqs_managed_sse_enabled` - (Optional) Boolean to enable server-side encryption (SSE) of message content with SQS-owned encryption keys. See [Encryption at rest](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html). Terraform will only perform drift detection of its value when present in a configuration.",
      "new": "* `sqs_managed_sse_enabled` - (Optional) Boolean to enable server-side encryption (SSE) of message content with SQS-owned encryption keys. See [Encryption at rest](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html). The provider will only perform drift detection of its value when present in a configuration."
    },
    {
      "old": "resource \"aws_sqs_queue\" \"terraform_queue_deadletter\" {",
      "new": "resource \"aws_sqs_queue\" \"example_queue_deadletter\" {"
    }
  ],
  "website/docs/r/ssm_parameter.html.markdown": [
    {
      "old": "* `insecure_value` - (Optional, exactly one of `value` or `insecure_value` is required) Value of the parameter. **Use caution:** This value is _never_ marked as sensitive in the Terraform plan output. This argument is not valid with a `type` of `SecureString`.",
      "new": "* `insecure_value` - (Optional, exactly one of `value` or `insecure_value` is required) Value of the parameter. **Use caution:** This value is _never_ marked as sensitive in the preview. This argument is not valid with a `type` of `SecureString`."
    },
    {
      "old": "* `overwrite` - (Optional) Overwrite an existing parameter. If not specified, will default to `false` if the resource has not been created by terraform to avoid overwrite of existing resource and will default to `true` otherwise (terraform lifecycle rules should then be used to manage the update behavior).",
      "new": "* `overwrite` - (Optional) Overwrite an existing parameter. If not specified, will default to `false` if the resource has not been created by this provider to avoid overwrite of existing resource and will default to `true` otherwise."
    },
    {
      "old": "* `overwrite` - (Optional, **Deprecated**) Overwrite an existing parameter. If not specified, will default to `false` if the resource has not been created by terraform to avoid overwrite of existing resource and will default to `true` otherwise (terraform lifecycle rules should then be used to manage the update behavior).",
      "new": "* `overwrite` - (Optional, **Deprecated**) Overwrite an existing parameter. If not specified, will default to `false` if the resource has not been created by Pulumi to avoid overwrite of existing resource and will default to `true` otherwise (Pulumi lifecycle rules should then be used to manage the update behavior)."
    },
    {
      "old": "* `value` - (Optional, exactly one of `value` or `insecure_value` is required) Value of the parameter. This value is always marked as sensitive in the Terraform plan output, regardless of `type`. In Terraform CLI version 0.15 and later, this may require additional configuration handling for certain scenarios. For more information, see the Terraform v0.15 Upgrade Guide.",
      "new": "* `value` - (Optional, exactly one of `value` or `insecure_value` is required) Value of the parameter. This value is always marked as sensitive in the plan output, regardless of `type`."
    },
    {
      "old": "~> **Note:** `overwrite` also makes it possible to overwrite an existing SSM Parameter that's not created by Terraform before.",
      "new": "~> **Note:** `overwrite` also makes it possible to overwrite an existing SSM Parameter that's not created by the provider before."
    }
  ],
  "website/docs/r/ssmcontacts_contact.html.markdown": [
    {
      "old": "~> **NOTE:** A contact implicitly depends on a replication set. If you configured your replication set in Terraform, we recommend you add it to the `depends_on` argument for the Terraform Contact Resource.",
      "new": "~> **NOTE:** A contact implicitly depends on a replication set. If you configured your replication set in Pulumi, we recommend you add it to the `depends_on` argument for the Contact Resource."
    }
  ],
  "website/docs/r/ssmincidents_replication_set.html.markdown": [
    {
      "old": "~> **NOTE:** If possible, create all the customer managed keys you need (using the `terraform apply` command) before you create the replication set, or create the keys and replication set in the same `terraform apply` command. Otherwise, to delete a replication set, you must run one `terraform apply` command to delete the replication set and another to delete the AWS KMS keys used by the replication set. Deleting the AWS KMS keys before deleting the replication set results in an error. In that case, you must manually reenable the deleted key using the AWS Management Console before you can delete the replication set.",
      "new": "~> **NOTE:** If possible, create all the customer managed keys you need (using the deploy command) before you create the replication set, or create the keys and replication set in the same deploy command. Otherwise, to delete a replication set, you must run one deploy command to delete the replication set and another to delete the AWS KMS keys used by the replication set. Deleting the AWS KMS keys before deleting the replication set results in an error. In that case, you must manually reenable the deleted key using the AWS Management Console before you can delete the replication set."
    },
    {
      "old": "~> **NOTE:** Incident Manager does not support updating the customer managed key associated with a replication set. Instead, for a replication set with multiple Regions, you must first delete a Region from the replication set, then re-add it with a different customer managed key in separate `terraform apply` operations. For a replication set with only one Region, the entire replication set must be deleted and recreated. To do this, comment out the replication set and all response plans, and then run the `terraform apply` command to recreate the replication set with the new customer managed key.",
      "new": "~> **NOTE:** Incident Manager does not support updating the customer managed key associated with a replication set. Instead, for a replication set with multiple Regions, you must first delete a Region from the replication set, then re-add it with a different customer managed key in separate deploy operations. For a replication set with only one Region, the entire replication set must be deleted and recreated. To do this, comment out the replication set and all response plans, and then run the deploy command to recreate the replication set with the new customer managed key."
    },
    {
      "old": "~> **NOTE:** The Region specified by a Terraform provider must always be one of the Regions specified for the replication set. This is especially important when you perform complex update operations.",
      "new": "~> **NOTE:** The Region specified by a provider must always be one of the Regions specified for the replication set. This is especially important when you perform complex update operations."
    }
  ],
  "website/docs/r/ssmincidents_response_plan.html.markdown": [
    {
      "old": "Provides a Terraform resource to manage response plans in AWS Systems Manager Incident Manager.",
      "new": "Provides a resource to manage response plans in AWS Systems Manager Incident Manager."
    },
    {
      "old": "we recommend you add it to the `depends_on` argument for the Terraform ResponsePlan Resource.",
      "new": "we recommend you add it to the `depends_on` argument for the ResponsePlan Resource."
    },
    {
      "old": "~> NOTE: A response plan implicitly depends on a replication set. If you configured your replication set in Terraform,",
      "new": "~> NOTE: A response plan implicitly depends on a replication set. If you configured your replication set in Pulumi,"
    }
  ],
  "website/docs/r/transfer_access.html.markdown": [
    {
      "old": "* `policy` - (Optional) An IAM JSON policy document that scopes down user access to portions of their Amazon S3 bucket. IAM variables you can use inside this policy include `${Transfer:UserName}`, `${Transfer:HomeDirectory}`, and `${Transfer:HomeBucket}`. Since the IAM variable syntax matches Terraform's interpolation syntax, they must be escaped inside Terraform configuration strings (`$${Transfer:UserName}`).  These are evaluated on-the-fly when navigating the bucket.",
      "new": "* `policy` - (Optional) An IAM JSON policy document that scopes down user access to portions of their Amazon S3 bucket. IAM variables you can use inside this policy include `${Transfer:UserName}`, `${Transfer:HomeDirectory}`, and `${Transfer:HomeBucket}`. These are evaluated on-the-fly when navigating the bucket."
    }
  ],
  "website/docs/r/transfer_tag.html.markdown": [
    {
      "old": "Manages an individual Transfer Family resource tag. This resource should only be used in cases where Transfer Family resources are created outside Terraform (e.g., Servers without AWS Management Console) or the tag key has the `aws:` prefix.",
      "new": "Manages an individual Transfer Family resource tag. This resource should only be used in cases where Transfer Family resources are created outside the provider (e.g., Servers without AWS Management Console) or the tag key has the `aws:` prefix."
    },
    {
      "old": "~> **NOTE:** This tagging resource should not be combined with the Terraform resource for managing the parent resource. For example, using `aws_transfer_server` and `aws_transfer_tag` to manage tags of the same server will cause a perpetual difference where the `aws_transfer_server` resource will try to remove the tag being added by the `aws_transfer_tag` resource.",
      "new": "~> **NOTE:** This tagging resource should not be combined with the resource for managing the parent resource. For example, using `aws_transfer_server` and `aws_transfer_tag` to manage tags of the same server will cause a perpetual difference where the `aws_transfer_server` resource will try to remove the tag being added by the `aws_transfer_tag` resource."
    }
  ],
  "website/docs/r/vpc_endpoint.html.markdown": [
    {
      "old": "~> **NOTE on VPC Endpoints and VPC Endpoint Associations:** Terraform provides both standalone VPC Endpoint Associations for",
      "new": "~> **NOTE on VPC Endpoints and VPC Endpoint Associations:** The provider provides both standalone VPC Endpoint Associations for"
    }
  ],
  "website/docs/r/vpc_endpoint_policy.html.markdown": [
    {
      "old": "* `policy` - (Optional) A policy to attach to the endpoint that controls access to the service. Defaults to full access. All `Gateway` and some `Interface` endpoints support policies - see the [relevant AWS documentation](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-endpoints-access.html) for more details. For more information about building AWS IAM policy documents with Terraform, see the AWS IAM Policy Document Guide.",
      "new": "* `policy` - (Optional) A policy to attach to the endpoint that controls access to the service. Defaults to full access. All `Gateway` and some `Interface` endpoints support policies - see the [relevant AWS documentation](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-endpoints-access.html) for more details."
    }
  ],
  "website/docs/r/vpc_endpoint_security_group_association.html.markdown": [
    {
      "old": "~> **NOTE on VPC Endpoints and VPC Endpoint Security Group Associations:** Terraform provides",
      "new": "~> **NOTE on VPC Endpoints and VPC Endpoint Security Group Associations:** The provider provides"
    }
  ],
  "website/docs/r/vpc_ipam_pool_cidr.html.markdown": [
    {
      "old": "* `ipam_pool_cidr_id` - The unique ID generated by AWS for the pool cidr. Typically this is the resource `id` but this attribute was added to the API calls after the fact and is therefore not used as the terraform resource id.",
      "new": "* `ipam_pool_cidr_id` - The unique ID generated by AWS for the pool cidr. Typically this is the resource `id` but this attribute was added to the API calls after the fact and is therefore not used as the resource id."
    }
  ],
  "website/docs/r/vpc_peering_connection.html.markdown": [
    {
      "old": "\n[1]: /docs/providers/aws/index.html"
    },
    {
      "old": "   Defaults to the account ID the [AWS provider][1] is currently connected to.",
      "new": "   Defaults to the account ID the AWS provider is currently connected to."
    }
  ],
  "website/docs/r/vpc_security_group_egress_rule.html.markdown": [
    {
      "old": "~> **NOTE on Security Groups and Security Group Rules:** Terraform currently provides a Security Group resource with `ingress` and `egress` rules defined in-line and a Security Group Rule resource which manages one or more `ingress` or",
      "new": "~> **NOTE on Security Groups and Security Group Rules:** this provider currently provides a Security Group resource with `ingress` and `egress` rules defined in-line and a Security Group Rule resource which manages one or more `ingress` or"
    }
  ],
  "website/docs/r/vpc_security_group_ingress_rule.html.markdown": [
    {
      "old": "~> **NOTE on Security Groups and Security Group Rules:** Terraform currently provides a Security Group resource with `ingress` and `egress` rules defined in-line and a Security Group Rule resource which manages one or more `ingress` or",
      "new": "~> **NOTE on Security Groups and Security Group Rules:** this provider currently provides a Security Group resource with `ingress` and `egress` rules defined in-line and a Security Group Rule resource which manages one or more `ingress` or"
    }
  ],
  "website/docs/r/vpn_connection.html.markdown": [
    {
      "old": "    Name = \"terraform_ipsec_vpn_example\"",
      "new": "    Name = \"example_ipsec_vpn_example\""
    },
    {
      "old": "  description     = \"terraform_ipsec_vpn_example\"",
      "new": "  description     = \"example_ipsec_vpn_example\""
    },
    {
      "old": "  name            = \"terraform_ipsec_vpn_example\"",
      "new": "  name            = \"example_ipsec_vpn_example\""
    }
  ],
  "website/docs/r/waf_byte_match_set.html.markdown": [
    {
      "old": "  name = \"tf_waf_byte_match_set\"",
      "new": "  name = \"my_waf_byte_match_set\""
    }
  ],
  "website/docs/r/waf_regex_pattern_set.html.markdown": [
    {
      "old": "  name                  = \"tf_waf_regex_pattern_set\"",
      "new": "  name                  = \"my_waf_regex_pattern_set\""
    }
  ],
  "website/docs/r/wafregional_byte_match_set.html.markdown": [
    {
      "old": "  name = \"tf_waf_byte_match_set\"",
      "new": "  name = \"my_waf_byte_match_set\""
    }
  ],
  "website/docs/r/wafv2_web_acl_association.html.markdown": [
    {
      "old": "[2]: /docs/providers/aws/r/cloudfront_distribution.html#web_acl_id"
    },
    {
      "old": "~> **NOTE on associating a WAFv2 Web ACL with a Cloudfront distribution:** Do not use this resource to associate a WAFv2 Web ACL with a Cloudfront Distribution. The [AWS API call backing this resource][1] notes that you should use the [`web_acl_id`][2] property on the [`cloudfront_distribution`][2] instead.",
      "new": "~> **NOTE on associating a WAFv2 Web ACL with a Cloudfront distribution:** Do not use this resource to associate a WAFv2 Web ACL with a Cloudfront Distribution. The [AWS API call backing this resource][1] notes that you should use the `web_acl_id` property on the `cloudfront_distribution` instead."
    }
  ]
}
