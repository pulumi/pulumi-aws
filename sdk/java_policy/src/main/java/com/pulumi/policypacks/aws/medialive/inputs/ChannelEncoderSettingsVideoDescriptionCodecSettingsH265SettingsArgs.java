// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.policypacks.aws.medialive.inputs;

import com.pulumi.core.UndeferrableValue;
import com.pulumi.policypacks.aws.medialive.inputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsArgs;
import com.pulumi.policypacks.aws.medialive.inputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsArgs;
import com.pulumi.policypacks.aws.medialive.inputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettingsArgs;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import javax.annotation.Nullable;


public final class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs {

    /**
     * Enables or disables adaptive quantization.
     * 
     */
    private UndeferrableValue<String> adaptiveQuantization;

    public String adaptiveQuantization() {
        if (adaptiveQuantization == null) return null;
        return adaptiveQuantization.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.adaptiveQuantization");
    }

    /**
     * Indicates that AFD values will be written into the output stream.
     * 
     */
    private UndeferrableValue<String> afdSignaling;

    public String afdSignaling() {
        if (afdSignaling == null) return null;
        return afdSignaling.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.afdSignaling");
    }

    /**
     * Whether or not EML should insert an Alternative Transfer Function SEI message.
     * 
     */
    private UndeferrableValue<String> alternativeTransferFunction;

    public String alternativeTransferFunction() {
        if (alternativeTransferFunction == null) return null;
        return alternativeTransferFunction.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.alternativeTransferFunction");
    }

    /**
     * Average bitrate in bits/second.
     * 
     */
    private UndeferrableValue<Integer> bitrate;

    public Integer bitrate() {
        if (bitrate == null) return null;
        return bitrate.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.bitrate");
    }

    /**
     * Size of buffer in bits.
     * 
     */
    private UndeferrableValue<Integer> bufSize;

    public Integer bufSize() {
        if (bufSize == null) return null;
        return bufSize.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.bufSize");
    }

    /**
     * Includes color space metadata in the output.
     * 
     */
    private UndeferrableValue<String> colorMetadata;

    public String colorMetadata() {
        if (colorMetadata == null) return null;
        return colorMetadata.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.colorMetadata");
    }

    /**
     * Define the color metadata for the output. H265 Color Space Settings for more details.
     * 
     */
    private UndeferrableValue<ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsArgs> colorSpaceSettings;

    public ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsArgs colorSpaceSettings() {
        if (colorSpaceSettings == null) return null;
        return colorSpaceSettings.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.colorSpaceSettings");
    }

    /**
     * Filters to apply to an encode. See H265 Filter Settings for more details.
     * 
     */
    private UndeferrableValue<ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsArgs> filterSettings;

    public ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsArgs filterSettings() {
        if (filterSettings == null) return null;
        return filterSettings.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.filterSettings");
    }

    /**
     * Four bit AFD value to write on all frames of video in the output stream.
     * 
     */
    private UndeferrableValue<String> fixedAfd;

    public String fixedAfd() {
        if (fixedAfd == null) return null;
        return fixedAfd.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.fixedAfd");
    }

    private UndeferrableValue<String> flickerAq;

    public String flickerAq() {
        if (flickerAq == null) return null;
        return flickerAq.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.flickerAq");
    }

    /**
     * Framerate denominator.
     * 
     */
    private UndeferrableValue<Integer> framerateDenominator;

    public Integer framerateDenominator() {
        if (framerateDenominator == null) return null;
        return framerateDenominator.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.framerateDenominator");
    }

    /**
     * Framerate numerator.
     * 
     */
    private UndeferrableValue<Integer> framerateNumerator;

    public Integer framerateNumerator() {
        if (framerateNumerator == null) return null;
        return framerateNumerator.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.framerateNumerator");
    }

    /**
     * Frequency of closed GOPs.
     * 
     */
    private UndeferrableValue<Integer> gopClosedCadence;

    public Integer gopClosedCadence() {
        if (gopClosedCadence == null) return null;
        return gopClosedCadence.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.gopClosedCadence");
    }

    /**
     * GOP size in units of either frames of seconds per `gop_size_units`.
     * 
     */
    private UndeferrableValue<Double> gopSize;

    public Double gopSize() {
        if (gopSize == null) return null;
        return gopSize.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.gopSize");
    }

    /**
     * Indicates if the `gop_size` is specified in frames or seconds.
     * 
     */
    private UndeferrableValue<String> gopSizeUnits;

    public String gopSizeUnits() {
        if (gopSizeUnits == null) return null;
        return gopSizeUnits.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.gopSizeUnits");
    }

    /**
     * H265 level.
     * 
     */
    private UndeferrableValue<String> level;

    public String level() {
        if (level == null) return null;
        return level.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.level");
    }

    /**
     * Amount of lookahead.
     * 
     */
    private UndeferrableValue<String> lookAheadRateControl;

    public String lookAheadRateControl() {
        if (lookAheadRateControl == null) return null;
        return lookAheadRateControl.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.lookAheadRateControl");
    }

    /**
     * Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
     * 
     */
    private UndeferrableValue<Integer> maxBitrate;

    public Integer maxBitrate() {
        if (maxBitrate == null) return null;
        return maxBitrate.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.maxBitrate");
    }

    /**
     * Min interval.
     * 
     */
    private UndeferrableValue<Integer> minIInterval;

    public Integer minIInterval() {
        if (minIInterval == null) return null;
        return minIInterval.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.minIInterval");
    }

    /**
     * Set the minimum QP.
     * 
     */
    private UndeferrableValue<Integer> minQp;

    public Integer minQp() {
        if (minQp == null) return null;
        return minQp.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.minQp");
    }

    /**
     * Enables or disables motion vector over picture boundaries.
     * 
     */
    private UndeferrableValue<String> mvOverPictureBoundaries;

    public String mvOverPictureBoundaries() {
        if (mvOverPictureBoundaries == null) return null;
        return mvOverPictureBoundaries.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.mvOverPictureBoundaries");
    }

    /**
     * Enables or disables the motion vector temporal predictor.
     * 
     */
    private UndeferrableValue<String> mvTemporalPredictor;

    public String mvTemporalPredictor() {
        if (mvTemporalPredictor == null) return null;
        return mvTemporalPredictor.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.mvTemporalPredictor");
    }

    /**
     * Pixel Aspect Ratio denominator.
     * 
     */
    private UndeferrableValue<Integer> parDenominator;

    public Integer parDenominator() {
        if (parDenominator == null) return null;
        return parDenominator.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.parDenominator");
    }

    /**
     * Pixel Aspect Ratio numerator.
     * 
     */
    private UndeferrableValue<Integer> parNumerator;

    public Integer parNumerator() {
        if (parNumerator == null) return null;
        return parNumerator.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.parNumerator");
    }

    /**
     * H265 profile.
     * 
     */
    private UndeferrableValue<String> profile;

    public String profile() {
        if (profile == null) return null;
        return profile.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.profile");
    }

    /**
     * Controls the target quality for the video encode.
     * 
     */
    private UndeferrableValue<Integer> qvbrQualityLevel;

    public Integer qvbrQualityLevel() {
        if (qvbrQualityLevel == null) return null;
        return qvbrQualityLevel.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.qvbrQualityLevel");
    }

    /**
     * Rate control mode.
     * 
     */
    private UndeferrableValue<String> rateControlMode;

    public String rateControlMode() {
        if (rateControlMode == null) return null;
        return rateControlMode.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.rateControlMode");
    }

    /**
     * Sets the scan type of the output.
     * 
     */
    private UndeferrableValue<String> scanType;

    public String scanType() {
        if (scanType == null) return null;
        return scanType.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.scanType");
    }

    /**
     * Scene change detection.
     * 
     */
    private UndeferrableValue<String> sceneChangeDetect;

    public String sceneChangeDetect() {
        if (sceneChangeDetect == null) return null;
        return sceneChangeDetect.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.sceneChangeDetect");
    }

    /**
     * Number of slices per picture.
     * 
     */
    private UndeferrableValue<Integer> slices;

    public Integer slices() {
        if (slices == null) return null;
        return slices.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.slices");
    }

    /**
     * Set the H265 tier in the output.
     * 
     */
    private UndeferrableValue<String> tier;

    public String tier() {
        if (tier == null) return null;
        return tier.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.tier");
    }

    /**
     * Sets the height of tiles.
     * 
     */
    private UndeferrableValue<Integer> tileHeight;

    public Integer tileHeight() {
        if (tileHeight == null) return null;
        return tileHeight.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.tileHeight");
    }

    /**
     * Enables or disables padding of tiles.
     * 
     */
    private UndeferrableValue<String> tilePadding;

    public String tilePadding() {
        if (tilePadding == null) return null;
        return tilePadding.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.tilePadding");
    }

    /**
     * Sets the width of tiles.
     * 
     */
    private UndeferrableValue<Integer> tileWidth;

    public Integer tileWidth() {
        if (tileWidth == null) return null;
        return tileWidth.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.tileWidth");
    }

    /**
     * Apply a burned in timecode. See H265 Timecode Burnin Settings for more details.
     * 
     */
    private UndeferrableValue<ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettingsArgs> timecodeBurninSettings;

    public ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettingsArgs timecodeBurninSettings() {
        if (timecodeBurninSettings == null) return null;
        return timecodeBurninSettings.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.timecodeBurninSettings");
    }

    /**
     * Determines how timecodes should be inserted into the video elementary stream.
     * 
     */
    private UndeferrableValue<String> timecodeInsertion;

    public String timecodeInsertion() {
        if (timecodeInsertion == null) return null;
        return timecodeInsertion.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.timecodeInsertion");
    }

    /**
     * Sets the size of the treeblock.
     * 
     */
    private UndeferrableValue<String> treeblockSize;

    public String treeblockSize() {
        if (treeblockSize == null) return null;
        return treeblockSize.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs.treeblockSize");
    }

}
