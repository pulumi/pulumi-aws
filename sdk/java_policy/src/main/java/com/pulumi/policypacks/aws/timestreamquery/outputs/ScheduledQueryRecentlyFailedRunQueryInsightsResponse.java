// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.policypacks.aws.timestreamquery.outputs;

import com.pulumi.core.UndeferrableValue;
import com.pulumi.policypacks.aws.timestreamquery.outputs.ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverage;
import com.pulumi.policypacks.aws.timestreamquery.outputs.ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRange;
import java.lang.Integer;
import java.util.List;
import javax.annotation.Nullable;


public final class ScheduledQueryRecentlyFailedRunQueryInsightsResponse {

    /**
     * Size of query result set in bytes. You can use this data to validate if the result set has changed as part of the query tuning exercise.
     * 
     */
    private @Nullable UndeferrableValue<Integer> outputBytes;

    public @Nullable Integer outputBytes() {
        if (outputBytes == null) return null;
        return outputBytes.getValue("ScheduledQueryRecentlyFailedRunQueryInsightsResponse.outputBytes");
    }

    /**
     * Total number of rows returned as part of the query result set. You can use this data to validate if the number of rows in the result set have changed as part of the query tuning exercise.
     * 
     */
    private @Nullable UndeferrableValue<Integer> outputRows;

    public @Nullable Integer outputRows() {
        if (outputRows == null) return null;
        return outputRows.getValue("ScheduledQueryRecentlyFailedRunQueryInsightsResponse.outputRows");
    }

    /**
     * Insights into the spatial coverage of the query, including the table with sub-optimal (max) spatial pruning. This information can help you identify areas for improvement in your partitioning strategy to enhance spatial pruning.
     * 
     */
    private @Nullable UndeferrableValue<List<ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverage>> querySpatialCoverages;

    public @Nullable List<ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverage> querySpatialCoverages() {
        if (querySpatialCoverages == null) return null;
        return querySpatialCoverages.getValue("ScheduledQueryRecentlyFailedRunQueryInsightsResponse.querySpatialCoverages");
    }

    /**
     * Number of tables in the query.
     * 
     */
    private @Nullable UndeferrableValue<Integer> queryTableCount;

    public @Nullable Integer queryTableCount() {
        if (queryTableCount == null) return null;
        return queryTableCount.getValue("ScheduledQueryRecentlyFailedRunQueryInsightsResponse.queryTableCount");
    }

    /**
     * Insights into the temporal range of the query, including the table with the largest (max) time range. Following are some of the potential options for optimizing time-based pruning: add missing time-predicates, remove functions around the time predicates, add time predicates to all the sub-queries.
     * 
     */
    private @Nullable UndeferrableValue<List<ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRange>> queryTemporalRanges;

    public @Nullable List<ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRange> queryTemporalRanges() {
        if (queryTemporalRanges == null) return null;
        return queryTemporalRanges.getValue("ScheduledQueryRecentlyFailedRunQueryInsightsResponse.queryTemporalRanges");
    }

}
