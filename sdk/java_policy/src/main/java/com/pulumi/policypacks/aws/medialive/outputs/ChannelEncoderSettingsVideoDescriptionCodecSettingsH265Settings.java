// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.policypacks.aws.medialive.outputs;

import com.pulumi.core.UndeferrableValue;
import com.pulumi.policypacks.aws.medialive.outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings;
import com.pulumi.policypacks.aws.medialive.outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings;
import com.pulumi.policypacks.aws.medialive.outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import javax.annotation.Nullable;


public final class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings {

    /**
     * Enables or disables adaptive quantization.
     * 
     */
    private @Nullable UndeferrableValue<String> adaptiveQuantization;

    public @Nullable String adaptiveQuantization() {
        if (adaptiveQuantization == null) return null;
        return adaptiveQuantization.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.adaptiveQuantization");
    }

    /**
     * Indicates that AFD values will be written into the output stream.
     * 
     */
    private @Nullable UndeferrableValue<String> afdSignaling;

    public @Nullable String afdSignaling() {
        if (afdSignaling == null) return null;
        return afdSignaling.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.afdSignaling");
    }

    /**
     * Whether or not EML should insert an Alternative Transfer Function SEI message.
     * 
     */
    private @Nullable UndeferrableValue<String> alternativeTransferFunction;

    public @Nullable String alternativeTransferFunction() {
        if (alternativeTransferFunction == null) return null;
        return alternativeTransferFunction.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.alternativeTransferFunction");
    }

    /**
     * Average bitrate in bits/second.
     * 
     */
    private UndeferrableValue<Integer> bitrate;

    public Integer bitrate() {
        if (bitrate == null) return null;
        return bitrate.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.bitrate");
    }

    /**
     * Size of buffer in bits.
     * 
     */
    private @Nullable UndeferrableValue<Integer> bufSize;

    public @Nullable Integer bufSize() {
        if (bufSize == null) return null;
        return bufSize.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.bufSize");
    }

    /**
     * Includes color space metadata in the output.
     * 
     */
    private @Nullable UndeferrableValue<String> colorMetadata;

    public @Nullable String colorMetadata() {
        if (colorMetadata == null) return null;
        return colorMetadata.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.colorMetadata");
    }

    /**
     * Define the color metadata for the output. H265 Color Space Settings for more details.
     * 
     */
    private @Nullable UndeferrableValue<ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings> colorSpaceSettings;

    public @Nullable ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings colorSpaceSettings() {
        if (colorSpaceSettings == null) return null;
        return colorSpaceSettings.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.colorSpaceSettings");
    }

    /**
     * Filters to apply to an encode. See H265 Filter Settings for more details.
     * 
     */
    private @Nullable UndeferrableValue<ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings> filterSettings;

    public @Nullable ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings filterSettings() {
        if (filterSettings == null) return null;
        return filterSettings.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.filterSettings");
    }

    /**
     * Four bit AFD value to write on all frames of video in the output stream.
     * 
     */
    private @Nullable UndeferrableValue<String> fixedAfd;

    public @Nullable String fixedAfd() {
        if (fixedAfd == null) return null;
        return fixedAfd.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.fixedAfd");
    }

    private @Nullable UndeferrableValue<String> flickerAq;

    public @Nullable String flickerAq() {
        if (flickerAq == null) return null;
        return flickerAq.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.flickerAq");
    }

    /**
     * Framerate denominator.
     * 
     */
    private UndeferrableValue<Integer> framerateDenominator;

    public Integer framerateDenominator() {
        if (framerateDenominator == null) return null;
        return framerateDenominator.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.framerateDenominator");
    }

    /**
     * Framerate numerator.
     * 
     */
    private UndeferrableValue<Integer> framerateNumerator;

    public Integer framerateNumerator() {
        if (framerateNumerator == null) return null;
        return framerateNumerator.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.framerateNumerator");
    }

    /**
     * Frequency of closed GOPs.
     * 
     */
    private @Nullable UndeferrableValue<Integer> gopClosedCadence;

    public @Nullable Integer gopClosedCadence() {
        if (gopClosedCadence == null) return null;
        return gopClosedCadence.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.gopClosedCadence");
    }

    /**
     * GOP size in units of either frames of seconds per `gop_size_units`.
     * 
     */
    private @Nullable UndeferrableValue<Double> gopSize;

    public @Nullable Double gopSize() {
        if (gopSize == null) return null;
        return gopSize.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.gopSize");
    }

    /**
     * Indicates if the `gop_size` is specified in frames or seconds.
     * 
     */
    private @Nullable UndeferrableValue<String> gopSizeUnits;

    public @Nullable String gopSizeUnits() {
        if (gopSizeUnits == null) return null;
        return gopSizeUnits.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.gopSizeUnits");
    }

    /**
     * H265 level.
     * 
     */
    private @Nullable UndeferrableValue<String> level;

    public @Nullable String level() {
        if (level == null) return null;
        return level.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.level");
    }

    /**
     * Amount of lookahead.
     * 
     */
    private @Nullable UndeferrableValue<String> lookAheadRateControl;

    public @Nullable String lookAheadRateControl() {
        if (lookAheadRateControl == null) return null;
        return lookAheadRateControl.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.lookAheadRateControl");
    }

    /**
     * Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
     * 
     */
    private @Nullable UndeferrableValue<Integer> maxBitrate;

    public @Nullable Integer maxBitrate() {
        if (maxBitrate == null) return null;
        return maxBitrate.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.maxBitrate");
    }

    /**
     * Min interval.
     * 
     */
    private @Nullable UndeferrableValue<Integer> minIInterval;

    public @Nullable Integer minIInterval() {
        if (minIInterval == null) return null;
        return minIInterval.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.minIInterval");
    }

    /**
     * Set the minimum QP.
     * 
     */
    private @Nullable UndeferrableValue<Integer> minQp;

    public @Nullable Integer minQp() {
        if (minQp == null) return null;
        return minQp.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.minQp");
    }

    /**
     * Enables or disables motion vector over picture boundaries.
     * 
     */
    private @Nullable UndeferrableValue<String> mvOverPictureBoundaries;

    public @Nullable String mvOverPictureBoundaries() {
        if (mvOverPictureBoundaries == null) return null;
        return mvOverPictureBoundaries.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.mvOverPictureBoundaries");
    }

    /**
     * Enables or disables the motion vector temporal predictor.
     * 
     */
    private @Nullable UndeferrableValue<String> mvTemporalPredictor;

    public @Nullable String mvTemporalPredictor() {
        if (mvTemporalPredictor == null) return null;
        return mvTemporalPredictor.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.mvTemporalPredictor");
    }

    /**
     * Pixel Aspect Ratio denominator.
     * 
     */
    private @Nullable UndeferrableValue<Integer> parDenominator;

    public @Nullable Integer parDenominator() {
        if (parDenominator == null) return null;
        return parDenominator.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.parDenominator");
    }

    /**
     * Pixel Aspect Ratio numerator.
     * 
     */
    private @Nullable UndeferrableValue<Integer> parNumerator;

    public @Nullable Integer parNumerator() {
        if (parNumerator == null) return null;
        return parNumerator.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.parNumerator");
    }

    /**
     * H265 profile.
     * 
     */
    private @Nullable UndeferrableValue<String> profile;

    public @Nullable String profile() {
        if (profile == null) return null;
        return profile.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.profile");
    }

    /**
     * Controls the target quality for the video encode.
     * 
     */
    private @Nullable UndeferrableValue<Integer> qvbrQualityLevel;

    public @Nullable Integer qvbrQualityLevel() {
        if (qvbrQualityLevel == null) return null;
        return qvbrQualityLevel.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.qvbrQualityLevel");
    }

    /**
     * Rate control mode.
     * 
     */
    private @Nullable UndeferrableValue<String> rateControlMode;

    public @Nullable String rateControlMode() {
        if (rateControlMode == null) return null;
        return rateControlMode.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.rateControlMode");
    }

    /**
     * Sets the scan type of the output.
     * 
     */
    private @Nullable UndeferrableValue<String> scanType;

    public @Nullable String scanType() {
        if (scanType == null) return null;
        return scanType.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.scanType");
    }

    /**
     * Scene change detection.
     * 
     */
    private @Nullable UndeferrableValue<String> sceneChangeDetect;

    public @Nullable String sceneChangeDetect() {
        if (sceneChangeDetect == null) return null;
        return sceneChangeDetect.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.sceneChangeDetect");
    }

    /**
     * Number of slices per picture.
     * 
     */
    private @Nullable UndeferrableValue<Integer> slices;

    public @Nullable Integer slices() {
        if (slices == null) return null;
        return slices.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.slices");
    }

    /**
     * Set the H265 tier in the output.
     * 
     */
    private @Nullable UndeferrableValue<String> tier;

    public @Nullable String tier() {
        if (tier == null) return null;
        return tier.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.tier");
    }

    /**
     * Sets the height of tiles.
     * 
     */
    private @Nullable UndeferrableValue<Integer> tileHeight;

    public @Nullable Integer tileHeight() {
        if (tileHeight == null) return null;
        return tileHeight.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.tileHeight");
    }

    /**
     * Enables or disables padding of tiles.
     * 
     */
    private @Nullable UndeferrableValue<String> tilePadding;

    public @Nullable String tilePadding() {
        if (tilePadding == null) return null;
        return tilePadding.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.tilePadding");
    }

    /**
     * Sets the width of tiles.
     * 
     */
    private @Nullable UndeferrableValue<Integer> tileWidth;

    public @Nullable Integer tileWidth() {
        if (tileWidth == null) return null;
        return tileWidth.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.tileWidth");
    }

    /**
     * Apply a burned in timecode. See H265 Timecode Burnin Settings for more details.
     * 
     */
    private @Nullable UndeferrableValue<ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings> timecodeBurninSettings;

    public @Nullable ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings timecodeBurninSettings() {
        if (timecodeBurninSettings == null) return null;
        return timecodeBurninSettings.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.timecodeBurninSettings");
    }

    /**
     * Determines how timecodes should be inserted into the video elementary stream.
     * 
     */
    private @Nullable UndeferrableValue<String> timecodeInsertion;

    public @Nullable String timecodeInsertion() {
        if (timecodeInsertion == null) return null;
        return timecodeInsertion.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.timecodeInsertion");
    }

    /**
     * Sets the size of the treeblock.
     * 
     */
    private @Nullable UndeferrableValue<String> treeblockSize;

    public @Nullable String treeblockSize() {
        if (treeblockSize == null) return null;
        return treeblockSize.getValue("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings.treeblockSize");
    }

}
