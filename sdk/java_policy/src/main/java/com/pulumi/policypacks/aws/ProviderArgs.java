// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.policypacks.aws;

import com.pulumi.core.UndeferrableValue;
import com.pulumi.core.annotations.PolicyResourceType;
import com.pulumi.policypacks.aws.inputs.ProviderAssumeRoleArgs;
import com.pulumi.policypacks.aws.inputs.ProviderAssumeRoleWithWebIdentityArgs;
import com.pulumi.policypacks.aws.inputs.ProviderDefaultTagsArgs;
import com.pulumi.policypacks.aws.inputs.ProviderEndpointArgs;
import com.pulumi.policypacks.aws.inputs.ProviderIgnoreTagsArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import javax.annotation.Nullable;


@PolicyResourceType(type="pulumi:providers:aws")
public final class ProviderArgs extends com.pulumi.resources.PolicyResourceInput {

    /**
     * The access key for API operations. You can retrieve this from the &#39;Security &amp; Credentials&#39; section of the AWS console.
     * 
     */
    private UndeferrableValue<String> accessKey;

    public String accessKey() {
        if (accessKey == null) return null;
        return accessKey.getValue("ProviderArgs.accessKey");
    }

    private UndeferrableValue<List<String>> allowedAccountIds;

    public List<String> allowedAccountIds() {
        if (allowedAccountIds == null) return null;
        return allowedAccountIds.getValue("ProviderArgs.allowedAccountIds");
    }

    private UndeferrableValue<ProviderAssumeRoleArgs> assumeRole;

    public ProviderAssumeRoleArgs assumeRole() {
        if (assumeRole == null) return null;
        return assumeRole.getValue("ProviderArgs.assumeRole");
    }

    private UndeferrableValue<ProviderAssumeRoleWithWebIdentityArgs> assumeRoleWithWebIdentity;

    public ProviderAssumeRoleWithWebIdentityArgs assumeRoleWithWebIdentity() {
        if (assumeRoleWithWebIdentity == null) return null;
        return assumeRoleWithWebIdentity.getValue("ProviderArgs.assumeRoleWithWebIdentity");
    }

    /**
     * File containing custom root and intermediate certificates. Can also be configured using the `AWS_CA_BUNDLE` environment
     * variable. (Setting `ca_bundle` in the shared config file is not supported.)
     * 
     */
    private UndeferrableValue<String> customCaBundle;

    public String customCaBundle() {
        if (customCaBundle == null) return null;
        return customCaBundle.getValue("ProviderArgs.customCaBundle");
    }

    /**
     * Configuration block with settings to default resource tags across all resources.
     * 
     */
    private UndeferrableValue<ProviderDefaultTagsArgs> defaultTags;

    public ProviderDefaultTagsArgs defaultTags() {
        if (defaultTags == null) return null;
        return defaultTags.getValue("ProviderArgs.defaultTags");
    }

    /**
     * Address of the EC2 metadata service endpoint to use. Can also be configured using the
     * `AWS_EC2_METADATA_SERVICE_ENDPOINT` environment variable.
     * 
     */
    private UndeferrableValue<String> ec2MetadataServiceEndpoint;

    public String ec2MetadataServiceEndpoint() {
        if (ec2MetadataServiceEndpoint == null) return null;
        return ec2MetadataServiceEndpoint.getValue("ProviderArgs.ec2MetadataServiceEndpoint");
    }

    /**
     * Protocol to use with EC2 metadata service endpoint.Valid values are `IPv4` and `IPv6`. Can also be configured using the
     * `AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE` environment variable.
     * 
     */
    private UndeferrableValue<String> ec2MetadataServiceEndpointMode;

    public String ec2MetadataServiceEndpointMode() {
        if (ec2MetadataServiceEndpointMode == null) return null;
        return ec2MetadataServiceEndpointMode.getValue("ProviderArgs.ec2MetadataServiceEndpointMode");
    }

    private UndeferrableValue<List<ProviderEndpointArgs>> endpoints;

    public List<ProviderEndpointArgs> endpoints() {
        if (endpoints == null) return null;
        return endpoints.getValue("ProviderArgs.endpoints");
    }

    private UndeferrableValue<List<String>> forbiddenAccountIds;

    public List<String> forbiddenAccountIds() {
        if (forbiddenAccountIds == null) return null;
        return forbiddenAccountIds.getValue("ProviderArgs.forbiddenAccountIds");
    }

    /**
     * URL of a proxy to use for HTTP requests when accessing the AWS API. Can also be set using the `HTTP_PROXY` or
     * `http_proxy` environment variables.
     * 
     */
    private UndeferrableValue<String> httpProxy;

    public String httpProxy() {
        if (httpProxy == null) return null;
        return httpProxy.getValue("ProviderArgs.httpProxy");
    }

    /**
     * URL of a proxy to use for HTTPS requests when accessing the AWS API. Can also be set using the `HTTPS_PROXY` or
     * `https_proxy` environment variables.
     * 
     */
    private UndeferrableValue<String> httpsProxy;

    public String httpsProxy() {
        if (httpsProxy == null) return null;
        return httpsProxy.getValue("ProviderArgs.httpsProxy");
    }

    /**
     * Configuration block with settings to ignore resource tags across all resources.
     * 
     */
    private UndeferrableValue<ProviderIgnoreTagsArgs> ignoreTags;

    public ProviderIgnoreTagsArgs ignoreTags() {
        if (ignoreTags == null) return null;
        return ignoreTags.getValue("ProviderArgs.ignoreTags");
    }

    /**
     * Explicitly allow the provider to perform &#34;insecure&#34; SSL requests. If omitted, default value is `false`
     * 
     */
    private UndeferrableValue<Boolean> insecure;

    public Boolean insecure() {
        if (insecure == null) return null;
        return insecure.getValue("ProviderArgs.insecure");
    }

    /**
     * The maximum number of times an AWS API request is being executed. If the API request still fails, an error is thrown.
     * 
     */
    private UndeferrableValue<Integer> maxRetries;

    public Integer maxRetries() {
        if (maxRetries == null) return null;
        return maxRetries.getValue("ProviderArgs.maxRetries");
    }

    /**
     * Comma-separated list of hosts that should not use HTTP or HTTPS proxies. Can also be set using the `NO_PROXY` or
     * `no_proxy` environment variables.
     * 
     */
    private UndeferrableValue<String> noProxy;

    public String noProxy() {
        if (noProxy == null) return null;
        return noProxy.getValue("ProviderArgs.noProxy");
    }

    /**
     * The profile for API operations. If not set, the default profile created with `aws configure` will be used.
     * 
     */
    private UndeferrableValue<String> profile;

    public String profile() {
        if (profile == null) return null;
        return profile.getValue("ProviderArgs.profile");
    }

    /**
     * The region where AWS operations will take place. Examples are us-east-1, us-west-2, etc.
     * 
     */
    private UndeferrableValue<String> region;

    public String region() {
        if (region == null) return null;
        return region.getValue("ProviderArgs.region");
    }

    /**
     * Specifies how retries are attempted. Valid values are `standard` and `adaptive`. Can also be configured using the
     * `AWS_RETRY_MODE` environment variable.
     * 
     */
    private UndeferrableValue<String> retryMode;

    public String retryMode() {
        if (retryMode == null) return null;
        return retryMode.getValue("ProviderArgs.retryMode");
    }

    /**
     * Specifies whether S3 API calls in the `us-east-1` region use the legacy global endpoint or a regional endpoint. Valid
     * values are `legacy` or `regional`. Can also be configured using the `AWS_S3_US_EAST_1_REGIONAL_ENDPOINT` environment
     * variable or the `s3_us_east_1_regional_endpoint` shared config file parameter
     * 
     */
    private UndeferrableValue<String> s3UsEast1RegionalEndpoint;

    public String s3UsEast1RegionalEndpoint() {
        if (s3UsEast1RegionalEndpoint == null) return null;
        return s3UsEast1RegionalEndpoint.getValue("ProviderArgs.s3UsEast1RegionalEndpoint");
    }

    /**
     * Set this to true to enable the request to use path-style addressing, i.e., https://s3.amazonaws.com/BUCKET/KEY. By
     * default, the S3 client will use virtual hosted bucket addressing when possible (https://BUCKET.s3.amazonaws.com/KEY).
     * Specific to the Amazon S3 service.
     * 
     */
    private UndeferrableValue<Boolean> s3UsePathStyle;

    public Boolean s3UsePathStyle() {
        if (s3UsePathStyle == null) return null;
        return s3UsePathStyle.getValue("ProviderArgs.s3UsePathStyle");
    }

    /**
     * The secret key for API operations. You can retrieve this from the &#39;Security &amp; Credentials&#39; section of the AWS console.
     * 
     */
    private UndeferrableValue<String> secretKey;

    public String secretKey() {
        if (secretKey == null) return null;
        return secretKey.getValue("ProviderArgs.secretKey");
    }

    /**
     * List of paths to shared config files. If not set, defaults to [~/.aws/config].
     * 
     */
    private UndeferrableValue<List<String>> sharedConfigFiles;

    public List<String> sharedConfigFiles() {
        if (sharedConfigFiles == null) return null;
        return sharedConfigFiles.getValue("ProviderArgs.sharedConfigFiles");
    }

    /**
     * List of paths to shared credentials files. If not set, defaults to [~/.aws/credentials].
     * 
     */
    private UndeferrableValue<List<String>> sharedCredentialsFiles;

    public List<String> sharedCredentialsFiles() {
        if (sharedCredentialsFiles == null) return null;
        return sharedCredentialsFiles.getValue("ProviderArgs.sharedCredentialsFiles");
    }

    /**
     * Skip the credentials validation via STS API. Used for AWS API implementations that do not have STS
     * available/implemented.
     * 
     */
    private UndeferrableValue<Boolean> skipCredentialsValidation;

    public Boolean skipCredentialsValidation() {
        if (skipCredentialsValidation == null) return null;
        return skipCredentialsValidation.getValue("ProviderArgs.skipCredentialsValidation");
    }

    /**
     * Skip the AWS Metadata API check. Used for AWS API implementations that do not have a metadata api endpoint.
     * 
     */
    private UndeferrableValue<Boolean> skipMetadataApiCheck;

    public Boolean skipMetadataApiCheck() {
        if (skipMetadataApiCheck == null) return null;
        return skipMetadataApiCheck.getValue("ProviderArgs.skipMetadataApiCheck");
    }

    /**
     * Skip static validation of region name. Used by users of alternative AWS-like APIs or users w/ access to regions that are
     * not public (yet).
     * 
     */
    private UndeferrableValue<Boolean> skipRegionValidation;

    public Boolean skipRegionValidation() {
        if (skipRegionValidation == null) return null;
        return skipRegionValidation.getValue("ProviderArgs.skipRegionValidation");
    }

    /**
     * Skip requesting the account ID. Used for AWS API implementations that do not have IAM/STS API and/or metadata API.
     * 
     */
    private UndeferrableValue<Boolean> skipRequestingAccountId;

    public Boolean skipRequestingAccountId() {
        if (skipRequestingAccountId == null) return null;
        return skipRequestingAccountId.getValue("ProviderArgs.skipRequestingAccountId");
    }

    /**
     * The region where AWS STS operations will take place. Examples are us-east-1 and us-west-2.
     * 
     */
    private UndeferrableValue<String> stsRegion;

    public String stsRegion() {
        if (stsRegion == null) return null;
        return stsRegion.getValue("ProviderArgs.stsRegion");
    }

    /**
     * session token. A session token is only required if you are using temporary security credentials.
     * 
     */
    private UndeferrableValue<String> token;

    public String token() {
        if (token == null) return null;
        return token.getValue("ProviderArgs.token");
    }

    /**
     * The capacity of the AWS SDK&#39;s token bucket rate limiter.
     * 
     */
    private UndeferrableValue<Integer> tokenBucketRateLimiterCapacity;

    public Integer tokenBucketRateLimiterCapacity() {
        if (tokenBucketRateLimiterCapacity == null) return null;
        return tokenBucketRateLimiterCapacity.getValue("ProviderArgs.tokenBucketRateLimiterCapacity");
    }

    /**
     * Resolve an endpoint with DualStack capability
     * 
     */
    private UndeferrableValue<Boolean> useDualstackEndpoint;

    public Boolean useDualstackEndpoint() {
        if (useDualstackEndpoint == null) return null;
        return useDualstackEndpoint.getValue("ProviderArgs.useDualstackEndpoint");
    }

    /**
     * Resolve an endpoint with FIPS capability
     * 
     */
    private UndeferrableValue<Boolean> useFipsEndpoint;

    public Boolean useFipsEndpoint() {
        if (useFipsEndpoint == null) return null;
        return useFipsEndpoint.getValue("ProviderArgs.useFipsEndpoint");
    }

}
