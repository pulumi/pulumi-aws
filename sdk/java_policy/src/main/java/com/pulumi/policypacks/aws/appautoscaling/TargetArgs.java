// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.policypacks.aws.appautoscaling;

import com.pulumi.core.UndeferrableValue;
import com.pulumi.core.annotations.PolicyResourceType;
import com.pulumi.policypacks.aws.appautoscaling.inputs.TargetSuspendedStateArgs;
import java.lang.Integer;
import java.lang.String;
import java.util.Map;
import javax.annotation.Nullable;


@PolicyResourceType(type="aws:appautoscaling/target:Target")
public final class TargetArgs extends com.pulumi.resources.PolicyResourceInput {

    /**
     * Max capacity of the scalable target.
     * 
     */
    private UndeferrableValue<Integer> maxCapacity;

    public Integer maxCapacity() {
        if (maxCapacity == null) return null;
        return maxCapacity.getValue("TargetArgs.maxCapacity");
    }

    /**
     * Min capacity of the scalable target.
     * 
     */
    private UndeferrableValue<Integer> minCapacity;

    public Integer minCapacity() {
        if (minCapacity == null) return null;
        return minCapacity.getValue("TargetArgs.minCapacity");
    }

    /**
     * Resource type and unique identifier string for the resource associated with the scaling policy. Documentation can be found in the `ResourceId` parameter at: [AWS Application Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/application/APIReference/API_RegisterScalableTarget.html#API_RegisterScalableTarget_RequestParameters)
     * 
     */
    private UndeferrableValue<String> resourceId;

    public String resourceId() {
        if (resourceId == null) return null;
        return resourceId.getValue("TargetArgs.resourceId");
    }

    /**
     * ARN of the IAM role that allows Application AutoScaling to modify your scalable target on your behalf. This defaults to an IAM Service-Linked Role for most services and custom IAM Roles are ignored by the API for those namespaces. See the [AWS Application Auto Scaling documentation](https://docs.aws.amazon.com/autoscaling/application/userguide/security_iam_service-with-iam.html#security_iam_service-with-iam-roles) for more information about how this service interacts with IAM.
     * 
     */
    private UndeferrableValue<String> roleArn;

    public String roleArn() {
        if (roleArn == null) return null;
        return roleArn.getValue("TargetArgs.roleArn");
    }

    /**
     * Scalable dimension of the scalable target. Documentation can be found in the `ScalableDimension` parameter at: [AWS Application Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/application/APIReference/API_RegisterScalableTarget.html#API_RegisterScalableTarget_RequestParameters)
     * 
     */
    private UndeferrableValue<String> scalableDimension;

    public String scalableDimension() {
        if (scalableDimension == null) return null;
        return scalableDimension.getValue("TargetArgs.scalableDimension");
    }

    /**
     * AWS service namespace of the scalable target. Documentation can be found in the `ServiceNamespace` parameter at: [AWS Application Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/application/APIReference/API_RegisterScalableTarget.html#API_RegisterScalableTarget_RequestParameters)
     * 
     */
    private UndeferrableValue<String> serviceNamespace;

    public String serviceNamespace() {
        if (serviceNamespace == null) return null;
        return serviceNamespace.getValue("TargetArgs.serviceNamespace");
    }

    /**
     * Specifies whether the scaling activities for a scalable target are in a suspended state.
     * 
     */
    private UndeferrableValue<TargetSuspendedStateArgs> suspendedState;

    public TargetSuspendedStateArgs suspendedState() {
        if (suspendedState == null) return null;
        return suspendedState.getValue("TargetArgs.suspendedState");
    }

    /**
     * Map of tags to assign to the scalable target. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    private UndeferrableValue<Map<String,String>> tags;

    public Map<String,String> tags() {
        if (tags == null) return null;
        return tags.getValue("TargetArgs.tags");
    }

}
