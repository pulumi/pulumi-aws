// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.policypacks.aws.elb;

import com.pulumi.core.UndeferrableValue;
import com.pulumi.core.annotations.PolicyResourceType;
import com.pulumi.policypacks.aws.elb.inputs.LoadBalancerAccessLogsArgs;
import com.pulumi.policypacks.aws.elb.inputs.LoadBalancerHealthCheckArgs;
import com.pulumi.policypacks.aws.elb.inputs.LoadBalancerListenerArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;


@PolicyResourceType(type="aws:elb/loadBalancer:LoadBalancer")
public final class LoadBalancerArgs extends com.pulumi.resources.PolicyResourceInput {

    /**
     * An Access Logs block. Access Logs documented below.
     * 
     */
    private UndeferrableValue<LoadBalancerAccessLogsArgs> accessLogs;

    public LoadBalancerAccessLogsArgs accessLogs() {
        if (accessLogs == null) return null;
        return accessLogs.getValue("LoadBalancerArgs.accessLogs");
    }

    /**
     * The AZ&#39;s to serve traffic in.
     * 
     */
    private UndeferrableValue<List<String>> availabilityZones;

    public List<String> availabilityZones() {
        if (availabilityZones == null) return null;
        return availabilityZones.getValue("LoadBalancerArgs.availabilityZones");
    }

    /**
     * Boolean to enable connection draining. Default: `false`
     * 
     */
    private UndeferrableValue<Boolean> connectionDraining;

    public Boolean connectionDraining() {
        if (connectionDraining == null) return null;
        return connectionDraining.getValue("LoadBalancerArgs.connectionDraining");
    }

    /**
     * The time in seconds to allow for connections to drain. Default: `300`
     * 
     */
    private UndeferrableValue<Integer> connectionDrainingTimeout;

    public Integer connectionDrainingTimeout() {
        if (connectionDrainingTimeout == null) return null;
        return connectionDrainingTimeout.getValue("LoadBalancerArgs.connectionDrainingTimeout");
    }

    /**
     * Enable cross-zone load balancing. Default: `true`
     * 
     */
    private UndeferrableValue<Boolean> crossZoneLoadBalancing;

    public Boolean crossZoneLoadBalancing() {
        if (crossZoneLoadBalancing == null) return null;
        return crossZoneLoadBalancing.getValue("LoadBalancerArgs.crossZoneLoadBalancing");
    }

    /**
     * Determines how the load balancer handles requests that might pose a security risk to an application due to HTTP desync. Valid values are `monitor`, `defensive` (default), `strictest`.
     * 
     */
    private UndeferrableValue<String> desyncMitigationMode;

    public String desyncMitigationMode() {
        if (desyncMitigationMode == null) return null;
        return desyncMitigationMode.getValue("LoadBalancerArgs.desyncMitigationMode");
    }

    /**
     * A health_check block. Health Check documented below.
     * 
     */
    private UndeferrableValue<LoadBalancerHealthCheckArgs> healthCheck;

    public LoadBalancerHealthCheckArgs healthCheck() {
        if (healthCheck == null) return null;
        return healthCheck.getValue("LoadBalancerArgs.healthCheck");
    }

    /**
     * The time in seconds that the connection is allowed to be idle. Default: `60`
     * 
     */
    private UndeferrableValue<Integer> idleTimeout;

    public Integer idleTimeout() {
        if (idleTimeout == null) return null;
        return idleTimeout.getValue("LoadBalancerArgs.idleTimeout");
    }

    /**
     * A list of instance ids to place in the ELB pool.
     * 
     */
    private UndeferrableValue<List<String>> instances;

    public List<String> instances() {
        if (instances == null) return null;
        return instances.getValue("LoadBalancerArgs.instances");
    }

    /**
     * If true, ELB will be an internal ELB.
     * 
     */
    private UndeferrableValue<Boolean> internal;

    public Boolean internal() {
        if (internal == null) return null;
        return internal.getValue("LoadBalancerArgs.internal");
    }

    /**
     * A list of listener blocks. Listeners documented below.
     * 
     */
    private UndeferrableValue<List<LoadBalancerListenerArgs>> listeners;

    public List<LoadBalancerListenerArgs> listeners() {
        if (listeners == null) return null;
        return listeners.getValue("LoadBalancerArgs.listeners");
    }

    /**
     * The name of the ELB. By default generated by this provider.
     * 
     */
    private UndeferrableValue<String> name;

    public String name() {
        if (name == null) return null;
        return name.getValue("LoadBalancerArgs.name");
    }

    /**
     * Creates a unique name beginning with the specified
     * prefix. Conflicts with `name`.
     * 
     */
    private UndeferrableValue<String> namePrefix;

    public String namePrefix() {
        if (namePrefix == null) return null;
        return namePrefix.getValue("LoadBalancerArgs.namePrefix");
    }

    /**
     * A list of security group IDs to assign to the ELB.
     * Only valid if creating an ELB within a VPC
     * 
     */
    private UndeferrableValue<List<String>> securityGroups;

    public List<String> securityGroups() {
        if (securityGroups == null) return null;
        return securityGroups.getValue("LoadBalancerArgs.securityGroups");
    }

    /**
     * The name of the security group that you can use as
     * part of your inbound rules for your load balancer&#39;s back-end application
     * instances. Use this for Classic or Default VPC only.
     * 
     */
    private UndeferrableValue<String> sourceSecurityGroup;

    public String sourceSecurityGroup() {
        if (sourceSecurityGroup == null) return null;
        return sourceSecurityGroup.getValue("LoadBalancerArgs.sourceSecurityGroup");
    }

    /**
     * A list of subnet IDs to attach to the ELB. When an update to subnets will remove all current subnets, this will force a new resource.
     * 
     */
    private UndeferrableValue<List<String>> subnets;

    public List<String> subnets() {
        if (subnets == null) return null;
        return subnets.getValue("LoadBalancerArgs.subnets");
    }

    /**
     * A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     * Exactly one of `availability_zones` or `subnets` must be specified: this
     * determines if the ELB exists in a VPC or in EC2-classic.
     * 
     */
    private UndeferrableValue<Map<String,String>> tags;

    public Map<String,String> tags() {
        if (tags == null) return null;
        return tags.getValue("LoadBalancerArgs.tags");
    }

}
