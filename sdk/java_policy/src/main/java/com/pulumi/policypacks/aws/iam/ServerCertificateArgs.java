// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.policypacks.aws.iam;

import com.pulumi.core.UndeferrableValue;
import com.pulumi.core.annotations.PolicyResourceType;
import java.lang.String;
import java.util.Map;
import javax.annotation.Nullable;


@PolicyResourceType(type="aws:iam/serverCertificate:ServerCertificate")
public final class ServerCertificateArgs extends com.pulumi.resources.PolicyResourceInput {

    /**
     * The contents of the public key certificate in
     * PEM-encoded format.
     * 
     */
    private UndeferrableValue<String> certificateBody;

    public String certificateBody() {
        if (certificateBody == null) return null;
        return certificateBody.getValue("ServerCertificateArgs.certificateBody");
    }

    /**
     * The contents of the certificate chain.
     * This is typically a concatenation of the PEM-encoded public key certificates
     * of the chain.
     * 
     */
    private UndeferrableValue<String> certificateChain;

    public String certificateChain() {
        if (certificateChain == null) return null;
        return certificateChain.getValue("ServerCertificateArgs.certificateChain");
    }

    /**
     * The name of the Server Certificate. Do not include the path in this value. If omitted, the provider will assign a random, unique name.
     * 
     */
    private UndeferrableValue<String> name;

    public String name() {
        if (name == null) return null;
        return name.getValue("ServerCertificateArgs.name");
    }

    /**
     * Creates a unique name beginning with the specified
     * prefix. Conflicts with `name`.
     * 
     */
    private UndeferrableValue<String> namePrefix;

    public String namePrefix() {
        if (namePrefix == null) return null;
        return namePrefix.getValue("ServerCertificateArgs.namePrefix");
    }

    /**
     * The IAM path for the server certificate.  If it is not
     * included, it defaults to a slash (/). If this certificate is for use with
     * AWS CloudFront, the path must be in format `/cloudfront/your_path_here`.
     * See [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) for more details on IAM Paths.
     * 
     */
    private UndeferrableValue<String> path;

    public String path() {
        if (path == null) return null;
        return path.getValue("ServerCertificateArgs.path");
    }

    /**
     * The contents of the private key in PEM-encoded format.
     * 
     */
    private UndeferrableValue<String> privateKey;

    public String privateKey() {
        if (privateKey == null) return null;
        return privateKey.getValue("ServerCertificateArgs.privateKey");
    }

    /**
     * Map of resource tags for the server certificate. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     * &gt; **NOTE:** AWS performs behind-the-scenes modifications to some certificate files if they do not adhere to a specific format. These modifications will result in this provider forever believing that it needs to update the resources since the local and AWS file contents will not match after theses modifications occur. In order to prevent this from happening you must ensure that all your PEM-encoded files use UNIX line-breaks and that `certificate_body` contains only one certificate. All other certificates should go in `certificate_chain`. It is common for some Certificate Authorities to issue certificate files that have DOS line-breaks and that are actually multiple certificates concatenated together in order to form a full certificate chain.
     * 
     */
    private UndeferrableValue<Map<String,String>> tags;

    public Map<String,String> tags() {
        if (tags == null) return null;
        return tags.getValue("ServerCertificateArgs.tags");
    }

}
