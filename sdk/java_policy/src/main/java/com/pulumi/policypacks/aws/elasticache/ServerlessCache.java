// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.policypacks.aws.elasticache;

import com.pulumi.core.UndeferrableValueException;
import com.pulumi.core.annotations.PolicyResourceProperty;
import com.pulumi.core.annotations.PolicyResourceType;
import com.pulumi.policypacks.aws.elasticache.outputs.ServerlessCacheCacheUsageLimits;
import com.pulumi.policypacks.aws.elasticache.outputs.ServerlessCacheEndpoint;
import com.pulumi.policypacks.aws.elasticache.outputs.ServerlessCacheReaderEndpoint;
import com.pulumi.policypacks.aws.elasticache.outputs.ServerlessCacheTimeouts;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;


@PolicyResourceType(type="aws:elasticache/serverlessCache:ServerlessCache")
public final class ServerlessCache extends com.pulumi.resources.PolicyResourceOutput {

    /**
     * The Amazon Resource Name (ARN) of the serverless cache.
     * 
     */
    @PolicyResourceProperty(name="arn", flag="unknown_arn")
    private String value_arn;
    private boolean unknown_arn;
    public String arn() {
        if (!unknown_arn) return value_arn;
        throw new UndeferrableValueException("Value 'ServerlessCache.arn' is not present");
    }

    /**
     * Sets the cache usage limits for storage and ElastiCache Processing Units for the cache. See `cache_usage_limits` Block for details.
     * 
     */
    @PolicyResourceProperty(name="cacheUsageLimits", flag="unknown_cacheUsageLimits")
    private @Nullable ServerlessCacheCacheUsageLimits value_cacheUsageLimits;
    private boolean unknown_cacheUsageLimits;
    public @Nullable ServerlessCacheCacheUsageLimits cacheUsageLimits() {
        if (!unknown_cacheUsageLimits) return value_cacheUsageLimits;
        throw new UndeferrableValueException("Value 'ServerlessCache.cacheUsageLimits' is not present");
    }

    /**
     * Timestamp of when the serverless cache was created.
     * 
     */
    @PolicyResourceProperty(name="createTime", flag="unknown_createTime")
    private String value_createTime;
    private boolean unknown_createTime;
    public String createTime() {
        if (!unknown_createTime) return value_createTime;
        throw new UndeferrableValueException("Value 'ServerlessCache.createTime' is not present");
    }

    /**
     * The daily time that snapshots will be created from the new serverless cache. Only supported for engine types `&#34;redis&#34;` or `&#34;valkey&#34;`. Defaults to `0`.
     * 
     */
    @PolicyResourceProperty(name="dailySnapshotTime", flag="unknown_dailySnapshotTime")
    private String value_dailySnapshotTime;
    private boolean unknown_dailySnapshotTime;
    public String dailySnapshotTime() {
        if (!unknown_dailySnapshotTime) return value_dailySnapshotTime;
        throw new UndeferrableValueException("Value 'ServerlessCache.dailySnapshotTime' is not present");
    }

    /**
     * User-provided description for the serverless cache. The default is NULL.
     * 
     */
    @PolicyResourceProperty(name="description", flag="unknown_description")
    private String value_description;
    private boolean unknown_description;
    public String description() {
        if (!unknown_description) return value_description;
        throw new UndeferrableValueException("Value 'ServerlessCache.description' is not present");
    }

    /**
     * Represents the information required for client programs to connect to a cache node. See `endpoint` Block for details.
     * 
     */
    @PolicyResourceProperty(name="endpoints", flag="unknown_endpoints")
    private List<ServerlessCacheEndpoint> value_endpoints;
    private boolean unknown_endpoints;
    public List<ServerlessCacheEndpoint> endpoints() {
        if (!unknown_endpoints) return value_endpoints;
        throw new UndeferrableValueException("Value 'ServerlessCache.endpoints' is not present");
    }

    /**
     * Name of the cache engine to be used for this cache cluster. Valid values are `memcached`, `redis` or `valkey`.
     * 
     */
    @PolicyResourceProperty(name="engine", flag="unknown_engine")
    private String value_engine;
    private boolean unknown_engine;
    public String engine() {
        if (!unknown_engine) return value_engine;
        throw new UndeferrableValueException("Value 'ServerlessCache.engine' is not present");
    }

    /**
     * The name and version number of the engine the serverless cache is compatible with.
     * 
     */
    @PolicyResourceProperty(name="fullEngineVersion", flag="unknown_fullEngineVersion")
    private String value_fullEngineVersion;
    private boolean unknown_fullEngineVersion;
    public String fullEngineVersion() {
        if (!unknown_fullEngineVersion) return value_fullEngineVersion;
        throw new UndeferrableValueException("Value 'ServerlessCache.fullEngineVersion' is not present");
    }

    /**
     * ARN of the customer managed key for encrypting the data at rest. If no KMS key is provided, a default service key is used.
     * 
     */
    @PolicyResourceProperty(name="kmsKeyId", flag="unknown_kmsKeyId")
    private @Nullable String value_kmsKeyId;
    private boolean unknown_kmsKeyId;
    public @Nullable String kmsKeyId() {
        if (!unknown_kmsKeyId) return value_kmsKeyId;
        throw new UndeferrableValueException("Value 'ServerlessCache.kmsKeyId' is not present");
    }

    /**
     * The version of the cache engine that will be used to create the serverless cache.
     * See [Describe Cache Engine Versions](https://docs.aws.amazon.com/cli/latest/reference/elasticache/describe-cache-engine-versions.html) in the AWS Documentation for supported versions.
     * 
     */
    @PolicyResourceProperty(name="majorEngineVersion", flag="unknown_majorEngineVersion")
    private String value_majorEngineVersion;
    private boolean unknown_majorEngineVersion;
    public String majorEngineVersion() {
        if (!unknown_majorEngineVersion) return value_majorEngineVersion;
        throw new UndeferrableValueException("Value 'ServerlessCache.majorEngineVersion' is not present");
    }

    /**
     * The Cluster name which serves as a unique identifier to the serverless cache
     * 
     * The following arguments are optional:
     * 
     */
    @PolicyResourceProperty(name="name", flag="unknown_name")
    private String value_name;
    private boolean unknown_name;
    public String name() {
        if (!unknown_name) return value_name;
        throw new UndeferrableValueException("Value 'ServerlessCache.name' is not present");
    }

    /**
     * Represents the information required for client programs to connect to a cache node. See `reader_endpoint` Block for details.
     * 
     */
    @PolicyResourceProperty(name="readerEndpoints", flag="unknown_readerEndpoints")
    private List<ServerlessCacheReaderEndpoint> value_readerEndpoints;
    private boolean unknown_readerEndpoints;
    public List<ServerlessCacheReaderEndpoint> readerEndpoints() {
        if (!unknown_readerEndpoints) return value_readerEndpoints;
        throw new UndeferrableValueException("Value 'ServerlessCache.readerEndpoints' is not present");
    }

    /**
     * A list of the one or more VPC security groups to be associated with the serverless cache. The security group will authorize traffic access for the VPC end-point (private-link). If no other information is given this will be the VPCâ€™s Default Security Group that is associated with the cluster VPC end-point.
     * 
     */
    @PolicyResourceProperty(name="securityGroupIds", flag="unknown_securityGroupIds")
    private List<String> value_securityGroupIds;
    private boolean unknown_securityGroupIds;
    public List<String> securityGroupIds() {
        if (!unknown_securityGroupIds) return value_securityGroupIds;
        throw new UndeferrableValueException("Value 'ServerlessCache.securityGroupIds' is not present");
    }

    /**
     * The list of ARN(s) of the snapshot that the new serverless cache will be created from. Available for Redis only.
     * 
     */
    @PolicyResourceProperty(name="snapshotArnsToRestores", flag="unknown_snapshotArnsToRestores")
    private @Nullable List<String> value_snapshotArnsToRestores;
    private boolean unknown_snapshotArnsToRestores;
    public @Nullable List<String> snapshotArnsToRestores() {
        if (!unknown_snapshotArnsToRestores) return value_snapshotArnsToRestores;
        throw new UndeferrableValueException("Value 'ServerlessCache.snapshotArnsToRestores' is not present");
    }

    /**
     * The number of snapshots that will be retained for the serverless cache that is being created. As new snapshots beyond this limit are added, the oldest snapshots will be deleted on a rolling basis. Available for Redis only.
     * 
     */
    @PolicyResourceProperty(name="snapshotRetentionLimit", flag="unknown_snapshotRetentionLimit")
    private Integer value_snapshotRetentionLimit;
    private boolean unknown_snapshotRetentionLimit;
    public Integer snapshotRetentionLimit() {
        if (!unknown_snapshotRetentionLimit) return value_snapshotRetentionLimit;
        throw new UndeferrableValueException("Value 'ServerlessCache.snapshotRetentionLimit' is not present");
    }

    /**
     * The current status of the serverless cache. The allowed values are CREATING, AVAILABLE, DELETING, CREATE-FAILED and MODIFYING.
     * 
     */
    @PolicyResourceProperty(name="status", flag="unknown_status")
    private String value_status;
    private boolean unknown_status;
    public String status() {
        if (!unknown_status) return value_status;
        throw new UndeferrableValueException("Value 'ServerlessCache.status' is not present");
    }

    /**
     * A list of the identifiers of the subnets where the VPC endpoint for the serverless cache will be deployed. All the subnetIds must belong to the same VPC.
     * 
     */
    @PolicyResourceProperty(name="subnetIds", flag="unknown_subnetIds")
    private List<String> value_subnetIds;
    private boolean unknown_subnetIds;
    public List<String> subnetIds() {
        if (!unknown_subnetIds) return value_subnetIds;
        throw new UndeferrableValueException("Value 'ServerlessCache.subnetIds' is not present");
    }

    /**
     * Map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    @PolicyResourceProperty(name="tags", flag="unknown_tags")
    private @Nullable Map<String,String> value_tags;
    private boolean unknown_tags;
    public @Nullable Map<String,String> tags() {
        if (!unknown_tags) return value_tags;
        throw new UndeferrableValueException("Value 'ServerlessCache.tags' is not present");
    }

    /**
     * @deprecated
     * Please use `tags` instead.
     * 
     */
    @Deprecated /* Please use `tags` instead. */
    @PolicyResourceProperty(name="tagsAll", flag="unknown_tagsAll")
    private Map<String,String> value_tagsAll;
    private boolean unknown_tagsAll;
    public Map<String,String> tagsAll() {
        if (!unknown_tagsAll) return value_tagsAll;
        throw new UndeferrableValueException("Value 'ServerlessCache.tagsAll' is not present");
    }

    @PolicyResourceProperty(name="timeouts", flag="unknown_timeouts")
    private @Nullable ServerlessCacheTimeouts value_timeouts;
    private boolean unknown_timeouts;
    public @Nullable ServerlessCacheTimeouts timeouts() {
        if (!unknown_timeouts) return value_timeouts;
        throw new UndeferrableValueException("Value 'ServerlessCache.timeouts' is not present");
    }

    /**
     * The identifier of the UserGroup to be associated with the serverless cache. Available for Redis only. Default is NULL.
     * 
     */
    @PolicyResourceProperty(name="userGroupId", flag="unknown_userGroupId")
    private @Nullable String value_userGroupId;
    private boolean unknown_userGroupId;
    public @Nullable String userGroupId() {
        if (!unknown_userGroupId) return value_userGroupId;
        throw new UndeferrableValueException("Value 'ServerlessCache.userGroupId' is not present");
    }

}
