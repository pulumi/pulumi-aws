// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.policypacks.aws.dynamodb;

import com.pulumi.core.UndeferrableValue;
import com.pulumi.core.annotations.PolicyResourceType;
import com.pulumi.policypacks.aws.dynamodb.inputs.TableAttributeArgs;
import com.pulumi.policypacks.aws.dynamodb.inputs.TableGlobalSecondaryIndexArgs;
import com.pulumi.policypacks.aws.dynamodb.inputs.TableImportTableArgs;
import com.pulumi.policypacks.aws.dynamodb.inputs.TableLocalSecondaryIndexArgs;
import com.pulumi.policypacks.aws.dynamodb.inputs.TableOnDemandThroughputArgs;
import com.pulumi.policypacks.aws.dynamodb.inputs.TablePointInTimeRecoveryArgs;
import com.pulumi.policypacks.aws.dynamodb.inputs.TableReplicaArgs;
import com.pulumi.policypacks.aws.dynamodb.inputs.TableServerSideEncryptionArgs;
import com.pulumi.policypacks.aws.dynamodb.inputs.TableTtlArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;


@PolicyResourceType(type="aws:dynamodb/table:Table")
public final class TableArgs extends com.pulumi.resources.PolicyResourceInput {

    /**
     * Set of nested attribute definitions. Only required for `hash_key` and `range_key` attributes. See below.
     * 
     */
    private UndeferrableValue<List<TableAttributeArgs>> attributes;

    public List<TableAttributeArgs> attributes() {
        if (attributes == null) return null;
        return attributes.getValue("TableArgs.attributes");
    }

    /**
     * Controls how you are charged for read and write throughput and how you manage capacity. The valid values are `PROVISIONED` and `PAY_PER_REQUEST`. Defaults to `PROVISIONED`.
     * 
     */
    private UndeferrableValue<String> billingMode;

    public String billingMode() {
        if (billingMode == null) return null;
        return billingMode.getValue("TableArgs.billingMode");
    }

    /**
     * Enables deletion protection for table. Defaults to `false`.
     * 
     */
    private UndeferrableValue<Boolean> deletionProtectionEnabled;

    public Boolean deletionProtectionEnabled() {
        if (deletionProtectionEnabled == null) return null;
        return deletionProtectionEnabled.getValue("TableArgs.deletionProtectionEnabled");
    }

    /**
     * Describe a GSI for the table; subject to the normal limits on the number of GSIs, projected attributes, etc. See below.
     * 
     */
    private UndeferrableValue<List<TableGlobalSecondaryIndexArgs>> globalSecondaryIndexes;

    public List<TableGlobalSecondaryIndexArgs> globalSecondaryIndexes() {
        if (globalSecondaryIndexes == null) return null;
        return globalSecondaryIndexes.getValue("TableArgs.globalSecondaryIndexes");
    }

    /**
     * Attribute to use as the hash (partition) key. Must also be defined as an `attribute`. See below.
     * 
     */
    private UndeferrableValue<String> hashKey;

    public String hashKey() {
        if (hashKey == null) return null;
        return hashKey.getValue("TableArgs.hashKey");
    }

    /**
     * Import Amazon S3 data into a new table. See below.
     * 
     */
    private UndeferrableValue<TableImportTableArgs> importTable;

    public TableImportTableArgs importTable() {
        if (importTable == null) return null;
        return importTable.getValue("TableArgs.importTable");
    }

    /**
     * Describe an LSI on the table; these can only be allocated _at creation_ so you cannot change this definition after you have created the resource. See below.
     * 
     */
    private UndeferrableValue<List<TableLocalSecondaryIndexArgs>> localSecondaryIndexes;

    public List<TableLocalSecondaryIndexArgs> localSecondaryIndexes() {
        if (localSecondaryIndexes == null) return null;
        return localSecondaryIndexes.getValue("TableArgs.localSecondaryIndexes");
    }

    /**
     * Unique within a region name of the table.
     * 
     * Optional arguments:
     * 
     */
    private UndeferrableValue<String> name;

    public String name() {
        if (name == null) return null;
        return name.getValue("TableArgs.name");
    }

    /**
     * Sets the maximum number of read and write units for the specified on-demand table. See below.
     * 
     */
    private UndeferrableValue<TableOnDemandThroughputArgs> onDemandThroughput;

    public TableOnDemandThroughputArgs onDemandThroughput() {
        if (onDemandThroughput == null) return null;
        return onDemandThroughput.getValue("TableArgs.onDemandThroughput");
    }

    /**
     * Enable point-in-time recovery options. See below.
     * 
     */
    private UndeferrableValue<TablePointInTimeRecoveryArgs> pointInTimeRecovery;

    public TablePointInTimeRecoveryArgs pointInTimeRecovery() {
        if (pointInTimeRecovery == null) return null;
        return pointInTimeRecovery.getValue("TableArgs.pointInTimeRecovery");
    }

    /**
     * Attribute to use as the range (sort) key. Must also be defined as an `attribute`, see below.
     * 
     */
    private UndeferrableValue<String> rangeKey;

    public String rangeKey() {
        if (rangeKey == null) return null;
        return rangeKey.getValue("TableArgs.rangeKey");
    }

    /**
     * Number of read units for this table. If the `billing_mode` is `PROVISIONED`, this field is required.
     * 
     */
    private UndeferrableValue<Integer> readCapacity;

    public Integer readCapacity() {
        if (readCapacity == null) return null;
        return readCapacity.getValue("TableArgs.readCapacity");
    }

    /**
     * Configuration block(s) with [DynamoDB Global Tables V2 (version 2019.11.21)](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html) replication configurations. See below.
     * 
     */
    private UndeferrableValue<List<TableReplicaArgs>> replicas;

    public List<TableReplicaArgs> replicas() {
        if (replicas == null) return null;
        return replicas.getValue("TableArgs.replicas");
    }

    /**
     * Time of the point-in-time recovery point to restore.
     * 
     */
    private UndeferrableValue<String> restoreDateTime;

    public String restoreDateTime() {
        if (restoreDateTime == null) return null;
        return restoreDateTime.getValue("TableArgs.restoreDateTime");
    }

    /**
     * Name of the table to restore. Must match the name of an existing table.
     * 
     */
    private UndeferrableValue<String> restoreSourceName;

    public String restoreSourceName() {
        if (restoreSourceName == null) return null;
        return restoreSourceName.getValue("TableArgs.restoreSourceName");
    }

    /**
     * ARN of the source table to restore. Must be supplied for cross-region restores.
     * 
     */
    private UndeferrableValue<String> restoreSourceTableArn;

    public String restoreSourceTableArn() {
        if (restoreSourceTableArn == null) return null;
        return restoreSourceTableArn.getValue("TableArgs.restoreSourceTableArn");
    }

    /**
     * If set, restores table to the most recent point-in-time recovery point.
     * 
     */
    private UndeferrableValue<Boolean> restoreToLatestTime;

    public Boolean restoreToLatestTime() {
        if (restoreToLatestTime == null) return null;
        return restoreToLatestTime.getValue("TableArgs.restoreToLatestTime");
    }

    /**
     * Encryption at rest options. AWS DynamoDB tables are automatically encrypted at rest with an AWS-owned Customer Master Key if this argument isn&#39;t specified. Must be supplied for cross-region restores. See below.
     * 
     */
    private UndeferrableValue<TableServerSideEncryptionArgs> serverSideEncryption;

    public TableServerSideEncryptionArgs serverSideEncryption() {
        if (serverSideEncryption == null) return null;
        return serverSideEncryption.getValue("TableArgs.serverSideEncryption");
    }

    /**
     * Whether Streams are enabled.
     * 
     */
    private UndeferrableValue<Boolean> streamEnabled;

    public Boolean streamEnabled() {
        if (streamEnabled == null) return null;
        return streamEnabled.getValue("TableArgs.streamEnabled");
    }

    /**
     * When an item in the table is modified, StreamViewType determines what information is written to the table&#39;s stream. Valid values are `KEYS_ONLY`, `NEW_IMAGE`, `OLD_IMAGE`, `NEW_AND_OLD_IMAGES`.
     * 
     */
    private UndeferrableValue<String> streamViewType;

    public String streamViewType() {
        if (streamViewType == null) return null;
        return streamViewType.getValue("TableArgs.streamViewType");
    }

    /**
     * Storage class of the table.
     * Valid values are `STANDARD` and `STANDARD_INFREQUENT_ACCESS`.
     * Default value is `STANDARD`.
     * 
     */
    private UndeferrableValue<String> tableClass;

    public String tableClass() {
        if (tableClass == null) return null;
        return tableClass.getValue("TableArgs.tableClass");
    }

    /**
     * A map of tags to populate on the created table. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    private UndeferrableValue<Map<String,String>> tags;

    public Map<String,String> tags() {
        if (tags == null) return null;
        return tags.getValue("TableArgs.tags");
    }

    /**
     * Configuration block for TTL. See below.
     * 
     */
    private UndeferrableValue<TableTtlArgs> ttl;

    public TableTtlArgs ttl() {
        if (ttl == null) return null;
        return ttl.getValue("TableArgs.ttl");
    }

    /**
     * Number of write units for this table. If the `billing_mode` is `PROVISIONED`, this field is required.
     * 
     */
    private UndeferrableValue<Integer> writeCapacity;

    public Integer writeCapacity() {
        if (writeCapacity == null) return null;
        return writeCapacity.getValue("TableArgs.writeCapacity");
    }

}
