// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace Pulumi.PolicyPacks.Aws.DirectoryService
{
    [PolicyResourceType("aws:directoryservice/trust:Trust")]
    public sealed class Trust : global::Pulumi.PolicyResourceOutput
    {
        /// <summary>
        /// Set of IPv4 addresses for the DNS server associated with the remote Directory.
        /// Can contain between 1 and 4 values.
        /// </summary>
        [PolicyResourceProperty("conditionalForwarderIpAddrs", "_mUnknown_ConditionalForwarderIpAddrs")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private List<string>? _mValue_ConditionalForwarderIpAddrs;
        private bool _mUnknown_ConditionalForwarderIpAddrs;
        public List<string>? ConditionalForwarderIpAddrs
        {
            get
            {
                if (!_mUnknown_ConditionalForwarderIpAddrs) return _mValue_ConditionalForwarderIpAddrs;
                throw new UndeferrableValueException("Value 'Trust.ConditionalForwarderIpAddrs' is not present");
            }
        }

        /// <summary>
        /// Date and time when the Trust was created.
        /// </summary>
        [PolicyResourceProperty("createdDateTime", "_mUnknown_CreatedDateTime")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private string? _mValue_CreatedDateTime;
        private bool _mUnknown_CreatedDateTime;
        public string? CreatedDateTime
        {
            get
            {
                if (!_mUnknown_CreatedDateTime) return _mValue_CreatedDateTime;
                throw new UndeferrableValueException("Value 'Trust.CreatedDateTime' is not present");
            }
        }

        /// <summary>
        /// Whether to delete the conditional forwarder when deleting the Trust relationship.
        /// </summary>
        [PolicyResourceProperty("deleteAssociatedConditionalForwarder", "_mUnknown_DeleteAssociatedConditionalForwarder")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private bool? _mValue_DeleteAssociatedConditionalForwarder;
        private bool _mUnknown_DeleteAssociatedConditionalForwarder;
        public bool? DeleteAssociatedConditionalForwarder
        {
            get
            {
                if (!_mUnknown_DeleteAssociatedConditionalForwarder) return _mValue_DeleteAssociatedConditionalForwarder;
                throw new UndeferrableValueException("Value 'Trust.DeleteAssociatedConditionalForwarder' is not present");
            }
        }

        /// <summary>
        /// ID of the Directory.
        /// </summary>
        [PolicyResourceProperty("directoryId", "_mUnknown_DirectoryId")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private string? _mValue_DirectoryId;
        private bool _mUnknown_DirectoryId;
        public string? DirectoryId
        {
            get
            {
                if (!_mUnknown_DirectoryId) return _mValue_DirectoryId;
                throw new UndeferrableValueException("Value 'Trust.DirectoryId' is not present");
            }
        }

        /// <summary>
        /// Date and time when the Trust was last updated.
        /// </summary>
        [PolicyResourceProperty("lastUpdatedDateTime", "_mUnknown_LastUpdatedDateTime")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private string? _mValue_LastUpdatedDateTime;
        private bool _mUnknown_LastUpdatedDateTime;
        public string? LastUpdatedDateTime
        {
            get
            {
                if (!_mUnknown_LastUpdatedDateTime) return _mValue_LastUpdatedDateTime;
                throw new UndeferrableValueException("Value 'Trust.LastUpdatedDateTime' is not present");
            }
        }

        /// <summary>
        /// Fully qualified domain name of the remote Directory.
        /// </summary>
        [PolicyResourceProperty("remoteDomainName", "_mUnknown_RemoteDomainName")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private string? _mValue_RemoteDomainName;
        private bool _mUnknown_RemoteDomainName;
        public string? RemoteDomainName
        {
            get
            {
                if (!_mUnknown_RemoteDomainName) return _mValue_RemoteDomainName;
                throw new UndeferrableValueException("Value 'Trust.RemoteDomainName' is not present");
            }
        }

        /// <summary>
        /// Whether to enable selective authentication.
        /// Valid values are `Enabled` and `Disabled`.
        /// Default value is `Disabled`.
        /// </summary>
        [PolicyResourceProperty("selectiveAuth", "_mUnknown_SelectiveAuth")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private string? _mValue_SelectiveAuth;
        private bool _mUnknown_SelectiveAuth;
        public string? SelectiveAuth
        {
            get
            {
                if (!_mUnknown_SelectiveAuth) return _mValue_SelectiveAuth;
                throw new UndeferrableValueException("Value 'Trust.SelectiveAuth' is not present");
            }
        }

        /// <summary>
        /// Date and time when the Trust state in `trust_state` was last updated.
        /// </summary>
        [PolicyResourceProperty("stateLastUpdatedDateTime", "_mUnknown_StateLastUpdatedDateTime")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private string? _mValue_StateLastUpdatedDateTime;
        private bool _mUnknown_StateLastUpdatedDateTime;
        public string? StateLastUpdatedDateTime
        {
            get
            {
                if (!_mUnknown_StateLastUpdatedDateTime) return _mValue_StateLastUpdatedDateTime;
                throw new UndeferrableValueException("Value 'Trust.StateLastUpdatedDateTime' is not present");
            }
        }

        /// <summary>
        /// The direction of the Trust relationship.
        /// Valid values are `One-Way: Outgoing`, `One-Way: Incoming`, and `Two-Way`.
        /// </summary>
        [PolicyResourceProperty("trustDirection", "_mUnknown_TrustDirection")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private string? _mValue_TrustDirection;
        private bool _mUnknown_TrustDirection;
        public string? TrustDirection
        {
            get
            {
                if (!_mUnknown_TrustDirection) return _mValue_TrustDirection;
                throw new UndeferrableValueException("Value 'Trust.TrustDirection' is not present");
            }
        }

        /// <summary>
        /// Password for the Trust.
        /// Does not need to match the passwords for either Directory.
        /// Can contain upper- and lower-case letters, numbers, and punctuation characters.
        /// May be up to 128 characters long.
        /// </summary>
        [PolicyResourceProperty("trustPassword", "_mUnknown_TrustPassword")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private string? _mValue_TrustPassword;
        private bool _mUnknown_TrustPassword;
        public string? TrustPassword
        {
            get
            {
                if (!_mUnknown_TrustPassword) return _mValue_TrustPassword;
                throw new UndeferrableValueException("Value 'Trust.TrustPassword' is not present");
            }
        }

        /// <summary>
        /// State of the Trust relationship.
        /// One of `Created`, `VerifyFailed`,`Verified`, `UpdateFailed`,`Updated`,`Deleted`, or `Failed`.
        /// </summary>
        [PolicyResourceProperty("trustState", "_mUnknown_Truststate")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private string? _mValue_Truststate;
        private bool _mUnknown_Truststate;
        public string? Truststate
        {
            get
            {
                if (!_mUnknown_Truststate) return _mValue_Truststate;
                throw new UndeferrableValueException("Value 'Trust.Truststate' is not present");
            }
        }

        /// <summary>
        /// Reason for the Trust state set in `trust_state`.
        /// </summary>
        [PolicyResourceProperty("trustStateReason", "_mUnknown_TrustStateReason")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private string? _mValue_TrustStateReason;
        private bool _mUnknown_TrustStateReason;
        public string? TrustStateReason
        {
            get
            {
                if (!_mUnknown_TrustStateReason) return _mValue_TrustStateReason;
                throw new UndeferrableValueException("Value 'Trust.TrustStateReason' is not present");
            }
        }

        /// <summary>
        /// Type of the Trust relationship.
        /// Valid values are `Forest` and `External`.
        /// Default value is `Forest`.
        /// </summary>
        [PolicyResourceProperty("trustType", "_mUnknown_TrustType")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private string? _mValue_TrustType;
        private bool _mUnknown_TrustType;
        public string? TrustType
        {
            get
            {
                if (!_mUnknown_TrustType) return _mValue_TrustType;
                throw new UndeferrableValueException("Value 'Trust.TrustType' is not present");
            }
        }
    }

    [PolicyResourceType("aws:directoryservice/trust:Trust")]
    public sealed class TrustArgs : global::Pulumi.PolicyResourceInput
    {
        /// <summary>
        /// Set of IPv4 addresses for the DNS server associated with the remote Directory.
        /// Can contain between 1 and 4 values.
        /// </summary>
        [PolicyResourceProperty("conditionalForwarderIpAddrs", "_mUnknown_ConditionalForwarderIpAddrs")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private List<string>? _mValue_ConditionalForwarderIpAddrs;
        private bool _mUnknown_ConditionalForwarderIpAddrs;
        public List<string>? ConditionalForwarderIpAddrs
        {
            get
            {
                if (!_mUnknown_ConditionalForwarderIpAddrs) return _mValue_ConditionalForwarderIpAddrs;
                throw new UndeferrableValueException("Value 'TrustArgs.ConditionalForwarderIpAddrs' is not present");
            }
        }

        /// <summary>
        /// Whether to delete the conditional forwarder when deleting the Trust relationship.
        /// </summary>
        [PolicyResourceProperty("deleteAssociatedConditionalForwarder", "_mUnknown_DeleteAssociatedConditionalForwarder")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private bool? _mValue_DeleteAssociatedConditionalForwarder;
        private bool _mUnknown_DeleteAssociatedConditionalForwarder;
        public bool? DeleteAssociatedConditionalForwarder
        {
            get
            {
                if (!_mUnknown_DeleteAssociatedConditionalForwarder) return _mValue_DeleteAssociatedConditionalForwarder;
                throw new UndeferrableValueException("Value 'TrustArgs.DeleteAssociatedConditionalForwarder' is not present");
            }
        }

        /// <summary>
        /// ID of the Directory.
        /// </summary>
        [PolicyResourceProperty("directoryId", "_mUnknown_DirectoryId")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private string? _mValue_DirectoryId;
        private bool _mUnknown_DirectoryId;
        public string? DirectoryId
        {
            get
            {
                if (!_mUnknown_DirectoryId) return _mValue_DirectoryId;
                throw new UndeferrableValueException("Value 'TrustArgs.DirectoryId' is not present");
            }
        }

        /// <summary>
        /// Fully qualified domain name of the remote Directory.
        /// </summary>
        [PolicyResourceProperty("remoteDomainName", "_mUnknown_RemoteDomainName")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private string? _mValue_RemoteDomainName;
        private bool _mUnknown_RemoteDomainName;
        public string? RemoteDomainName
        {
            get
            {
                if (!_mUnknown_RemoteDomainName) return _mValue_RemoteDomainName;
                throw new UndeferrableValueException("Value 'TrustArgs.RemoteDomainName' is not present");
            }
        }

        /// <summary>
        /// Whether to enable selective authentication.
        /// Valid values are `Enabled` and `Disabled`.
        /// Default value is `Disabled`.
        /// </summary>
        [PolicyResourceProperty("selectiveAuth", "_mUnknown_SelectiveAuth")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private string? _mValue_SelectiveAuth;
        private bool _mUnknown_SelectiveAuth;
        public string? SelectiveAuth
        {
            get
            {
                if (!_mUnknown_SelectiveAuth) return _mValue_SelectiveAuth;
                throw new UndeferrableValueException("Value 'TrustArgs.SelectiveAuth' is not present");
            }
        }

        /// <summary>
        /// The direction of the Trust relationship.
        /// Valid values are `One-Way: Outgoing`, `One-Way: Incoming`, and `Two-Way`.
        /// </summary>
        [PolicyResourceProperty("trustDirection", "_mUnknown_TrustDirection")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private string? _mValue_TrustDirection;
        private bool _mUnknown_TrustDirection;
        public string? TrustDirection
        {
            get
            {
                if (!_mUnknown_TrustDirection) return _mValue_TrustDirection;
                throw new UndeferrableValueException("Value 'TrustArgs.TrustDirection' is not present");
            }
        }

        /// <summary>
        /// Password for the Trust.
        /// Does not need to match the passwords for either Directory.
        /// Can contain upper- and lower-case letters, numbers, and punctuation characters.
        /// May be up to 128 characters long.
        /// </summary>
        [PolicyResourceProperty("trustPassword", "_mUnknown_TrustPassword")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private string? _mValue_TrustPassword;
        private bool _mUnknown_TrustPassword;
        public string? TrustPassword
        {
            get
            {
                if (!_mUnknown_TrustPassword) return _mValue_TrustPassword;
                throw new UndeferrableValueException("Value 'TrustArgs.TrustPassword' is not present");
            }
        }

        /// <summary>
        /// Type of the Trust relationship.
        /// Valid values are `Forest` and `External`.
        /// Default value is `Forest`.
        /// </summary>
        [PolicyResourceProperty("trustType", "_mUnknown_TrustType")]
        #pragma warning disable CS0649 // Field is assigned through deserializer
        private string? _mValue_TrustType;
        private bool _mUnknown_TrustType;
        public string? TrustType
        {
            get
            {
                if (!_mUnknown_TrustType) return _mValue_TrustType;
                throw new UndeferrableValueException("Value 'TrustArgs.TrustType' is not present");
            }
        }
    }
}
