// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aws.lambda;

import com.pulumi.asset.Archive;
import com.pulumi.aws.Utilities;
import com.pulumi.aws.lambda.FunctionArgs;
import com.pulumi.aws.lambda.inputs.FunctionState;
import com.pulumi.aws.lambda.outputs.FunctionDeadLetterConfig;
import com.pulumi.aws.lambda.outputs.FunctionEnvironment;
import com.pulumi.aws.lambda.outputs.FunctionEphemeralStorage;
import com.pulumi.aws.lambda.outputs.FunctionFileSystemConfig;
import com.pulumi.aws.lambda.outputs.FunctionImageConfig;
import com.pulumi.aws.lambda.outputs.FunctionLoggingConfig;
import com.pulumi.aws.lambda.outputs.FunctionSnapStart;
import com.pulumi.aws.lambda.outputs.FunctionTracingConfig;
import com.pulumi.aws.lambda.outputs.FunctionVpcConfig;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages an AWS Lambda Function. Use this resource to create serverless functions that run code in response to events without provisioning or managing servers.
 * 
 * For information about Lambda and how to use it, see [What is AWS Lambda?](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html). For a detailed example of setting up Lambda and API Gateway, see Serverless Applications with AWS Lambda and API Gateway.
 * 
 * &gt; **Note:** Due to [AWS Lambda improved VPC networking changes that began deploying in September 2019](https://aws.amazon.com/blogs/compute/announcing-improved-vpc-networking-for-aws-lambda-functions/), EC2 subnets and security groups associated with Lambda Functions can take up to 45 minutes to successfully delete. Pulumi AWS Provider version 2.31.0 and later automatically handles this increased timeout, however prior versions require setting the customizable deletion timeouts of those Pulumi resources to 45 minutes (`delete = &#34;45m&#34;`). AWS and HashiCorp are working together to reduce the amount of time required for resource deletion and updates can be tracked in this GitHub issue.
 * 
 * &gt; **Note:** If you get a `KMSAccessDeniedException: Lambda was unable to decrypt the environment variables because KMS access was denied` error when invoking an `aws.lambda.Function` with environment variables, the IAM role associated with the function may have been deleted and recreated after the function was created. You can fix the problem two ways: 1) updating the function&#39;s role to another role and then updating it back again to the recreated role. (When you create a function, Lambda grants permissions on the KMS key to the function&#39;s IAM role. If the IAM role is recreated, the grant is no longer valid. Changing the function&#39;s role or recreating the function causes Lambda to update the grant.)
 * 
 * &gt; **Tip:** To give an external source (like an EventBridge Rule, SNS, or S3) permission to access the Lambda function, use the `aws.lambda.Permission` resource. See [Lambda Permission Model](https://docs.aws.amazon.com/lambda/latest/dg/intro-permission-model.html) for more details. On the other hand, the `role` argument of this resource is the function&#39;s execution role for identity and access to AWS services and resources.
 * 
 * ## Example Usage
 * 
 * ### Container Image Function
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.aws.lambda.Function;
 * import com.pulumi.aws.lambda.FunctionArgs;
 * import com.pulumi.aws.lambda.inputs.FunctionImageConfigArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new Function("example", FunctionArgs.builder()
 *             .name("example_container_function")
 *             .role(exampleAwsIamRole.arn())
 *             .packageType("Image")
 *             .imageUri(String.format("%s:latest", exampleAwsEcrRepository.repositoryUrl()))
 *             .imageConfig(FunctionImageConfigArgs.builder()
 *                 .entryPoints("/lambda-entrypoint.sh")
 *                 .commands("app.handler")
 *                 .build())
 *             .memorySize(512)
 *             .timeout(30)
 *             .architectures("arm64")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ### Function with Lambda Layers
 * 
 * &gt; **Note:** The `aws.lambda.LayerVersion` attribute values for `arn` and `layer_arn` were swapped in version 2.0.0 of the Pulumi AWS Provider. For version 2.x, use `arn` references.
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.aws.lambda.LayerVersion;
 * import com.pulumi.aws.lambda.LayerVersionArgs;
 * import com.pulumi.aws.lambda.Function;
 * import com.pulumi.aws.lambda.FunctionArgs;
 * import com.pulumi.aws.lambda.inputs.FunctionTracingConfigArgs;
 * import com.pulumi.asset.FileArchive;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         // Common dependencies layer
 *         var example = new LayerVersion("example", LayerVersionArgs.builder()
 *             .code(new FileArchive("layer.zip"))
 *             .layerName("example_dependencies_layer")
 *             .description("Common dependencies for Lambda functions")
 *             .compatibleRuntimes(            
 *                 "nodejs20.x",
 *                 "python3.12")
 *             .compatibleArchitectures(            
 *                 "x86_64",
 *                 "arm64")
 *             .build());
 * 
 *         // Function using the layer
 *         var exampleFunction = new Function("exampleFunction", FunctionArgs.builder()
 *             .code(new FileArchive("function.zip"))
 *             .name("example_layered_function")
 *             .role(exampleAwsIamRole.arn())
 *             .handler("index.handler")
 *             .runtime("nodejs20.x")
 *             .layers(example.arn())
 *             .tracingConfig(FunctionTracingConfigArgs.builder()
 *                 .mode("Active")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ### VPC Function with Enhanced Networking
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.aws.lambda.Function;
 * import com.pulumi.aws.lambda.FunctionArgs;
 * import com.pulumi.aws.lambda.inputs.FunctionVpcConfigArgs;
 * import com.pulumi.aws.lambda.inputs.FunctionEphemeralStorageArgs;
 * import com.pulumi.aws.lambda.inputs.FunctionSnapStartArgs;
 * import com.pulumi.asset.FileArchive;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new Function("example", FunctionArgs.builder()
 *             .code(new FileArchive("function.zip"))
 *             .name("example_vpc_function")
 *             .role(exampleAwsIamRole.arn())
 *             .handler("app.handler")
 *             .runtime("python3.12")
 *             .memorySize(1024)
 *             .timeout(30)
 *             .vpcConfig(FunctionVpcConfigArgs.builder()
 *                 .subnetIds(                
 *                     examplePrivate1.id(),
 *                     examplePrivate2.id())
 *                 .securityGroupIds(exampleLambda.id())
 *                 .ipv6AllowedForDualStack(true)
 *                 .build())
 *             .ephemeralStorage(FunctionEphemeralStorageArgs.builder()
 *                 .size(5120)
 *                 .build())
 *             .snapStart(FunctionSnapStartArgs.builder()
 *                 .applyOn("PublishedVersions")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ### Function with EFS Integration
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.aws.efs.FileSystem;
 * import com.pulumi.aws.efs.FileSystemArgs;
 * import com.pulumi.aws.efs.MountTarget;
 * import com.pulumi.aws.efs.MountTargetArgs;
 * import com.pulumi.aws.efs.AccessPoint;
 * import com.pulumi.aws.efs.AccessPointArgs;
 * import com.pulumi.aws.efs.inputs.AccessPointRootDirectoryArgs;
 * import com.pulumi.aws.efs.inputs.AccessPointRootDirectoryCreationInfoArgs;
 * import com.pulumi.aws.efs.inputs.AccessPointPosixUserArgs;
 * import com.pulumi.aws.lambda.Function;
 * import com.pulumi.aws.lambda.FunctionArgs;
 * import com.pulumi.aws.lambda.inputs.FunctionVpcConfigArgs;
 * import com.pulumi.aws.lambda.inputs.FunctionFileSystemConfigArgs;
 * import com.pulumi.asset.FileArchive;
 * import com.pulumi.codegen.internal.KeyedValue;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         final var config = ctx.config();
 *         // EFS file system for Lambda
 *         var example = new FileSystem("example", FileSystemArgs.builder()
 *             .encrypted(true)
 *             .tags(Map.of("Name", "lambda-efs"))
 *             .build());
 * 
 *         final var subnetIds = config.get("subnetIds").orElse(        
 *             "subnet-12345678",
 *             "subnet-87654321");
 *         // Mount target in each subnet
 *         for (var i = 0; i < subnetIds.length(); i++) {
 *             new MountTarget("exampleMountTarget-" + i, MountTargetArgs.builder()
 *                 .fileSystemId(example.id())
 *                 .subnetId(subnetIds[range.value()])
 *                 .securityGroups(efs.id())
 *                 .build());
 * 
 *         
 * }
 *         // Access point for Lambda
 *         var exampleAccessPoint = new AccessPoint("exampleAccessPoint", AccessPointArgs.builder()
 *             .fileSystemId(example.id())
 *             .rootDirectory(AccessPointRootDirectoryArgs.builder()
 *                 .path("/lambda")
 *                 .creationInfo(AccessPointRootDirectoryCreationInfoArgs.builder()
 *                     .ownerGid(1000)
 *                     .ownerUid(1000)
 *                     .permissions("755")
 *                     .build())
 *                 .build())
 *             .posixUser(AccessPointPosixUserArgs.builder()
 *                 .gid(1000)
 *                 .uid(1000)
 *                 .build())
 *             .build());
 * 
 *         // Lambda function with EFS
 *         var exampleFunction = new Function("exampleFunction", FunctionArgs.builder()
 *             .code(new FileArchive("function.zip"))
 *             .name("example_efs_function")
 *             .role(exampleAwsIamRole.arn())
 *             .handler("index.handler")
 *             .runtime("nodejs20.x")
 *             .vpcConfig(FunctionVpcConfigArgs.builder()
 *                 .subnetIds(subnetIds)
 *                 .securityGroupIds(lambda.id())
 *                 .build())
 *             .fileSystemConfig(FunctionFileSystemConfigArgs.builder()
 *                 .arn(exampleAccessPoint.arn())
 *                 .localMountPath("/mnt/data")
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(exampleMountTarget)
 *                 .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ### Function with Advanced Logging
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.aws.cloudwatch.LogGroup;
 * import com.pulumi.aws.cloudwatch.LogGroupArgs;
 * import com.pulumi.aws.lambda.Function;
 * import com.pulumi.aws.lambda.FunctionArgs;
 * import com.pulumi.aws.lambda.inputs.FunctionLoggingConfigArgs;
 * import com.pulumi.asset.FileArchive;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new LogGroup("example", LogGroupArgs.builder()
 *             .name("/aws/lambda/example_function")
 *             .retentionInDays(14)
 *             .tags(Map.ofEntries(
 *                 Map.entry("Environment", "production"),
 *                 Map.entry("Application", "example")
 *             ))
 *             .build());
 * 
 *         var exampleFunction = new Function("exampleFunction", FunctionArgs.builder()
 *             .code(new FileArchive("function.zip"))
 *             .name("example_function")
 *             .role(exampleAwsIamRole.arn())
 *             .handler("index.handler")
 *             .runtime("nodejs20.x")
 *             .loggingConfig(FunctionLoggingConfigArgs.builder()
 *                 .logFormat("JSON")
 *                 .applicationLogLevel("INFO")
 *                 .systemLogLevel("WARN")
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(example)
 *                 .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ### Function with logging to S3 or Data Firehose
 * 
 * #### Required Resources
 * 
 * * An S3 bucket or Data Firehose delivery stream to store the logs.
 * * A CloudWatch Log Group with:
 *   
 *     * `log_group_class = &#34;DELIVERY&#34;`
 *     * A subscription filter whose `destination_arn` points to the S3 bucket or the Data Firehose delivery stream.
 * 
 * * IAM roles:
 *   
 *     * Assumed by the `logs.amazonaws.com` service to deliver logs to the S3 bucket or Data Firehose delivery stream.
 *     * Assumed by the `lambda.amazonaws.com` service to send logs to CloudWatch Logs
 * 
 * * A Lambda function:
 *   
 *     * In the `logging_configuration`, specify the name of the Log Group created above using the `log_group` field
 *     * No special configuration is required to use S3 or Firehose as the log destination
 * 
 * For more details, see [Sending Lambda function logs to Amazon S3](https://docs.aws.amazon.com/lambda/latest/dg/logging-with-s3.html).
 * 
 * ### Example: Exporting Lambda Logs to S3 Bucket
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.aws.s3.Bucket;
 * import com.pulumi.aws.s3.BucketArgs;
 * import com.pulumi.aws.cloudwatch.LogGroup;
 * import com.pulumi.aws.cloudwatch.LogGroupArgs;
 * import com.pulumi.aws.iam.IamFunctions;
 * import com.pulumi.aws.iam.inputs.GetPolicyDocumentArgs;
 * import com.pulumi.aws.iam.Role;
 * import com.pulumi.aws.iam.RoleArgs;
 * import com.pulumi.aws.iam.RolePolicy;
 * import com.pulumi.aws.iam.RolePolicyArgs;
 * import com.pulumi.aws.cloudwatch.LogSubscriptionFilter;
 * import com.pulumi.aws.cloudwatch.LogSubscriptionFilterArgs;
 * import com.pulumi.aws.lambda.Function;
 * import com.pulumi.aws.lambda.FunctionArgs;
 * import com.pulumi.aws.lambda.inputs.FunctionLoggingConfigArgs;
 * import com.pulumi.asset.FileArchive;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         final var lambdaFunctionName = "lambda-log-export-example";
 * 
 *         var lambdaLogExportBucket = new Bucket("lambdaLogExportBucket", BucketArgs.builder()
 *             .bucket(String.format("%s-bucket", lambdaFunctionName))
 *             .build());
 * 
 *         var export = new LogGroup("export", LogGroupArgs.builder()
 *             .name(String.format("/aws/lambda/%s", lambdaFunctionName))
 *             .logGroupClass("DELIVERY")
 *             .build());
 * 
 *         final var logsAssumeRole = IamFunctions.getPolicyDocument(GetPolicyDocumentArgs.builder()
 *             .statements(GetPolicyDocumentStatementArgs.builder()
 *                 .actions("sts:AssumeRole")
 *                 .effect("Allow")
 *                 .principals(GetPolicyDocumentStatementPrincipalArgs.builder()
 *                     .type("Service")
 *                     .identifiers("logs.amazonaws.com")
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *         var logsLogExport = new Role("logsLogExport", RoleArgs.builder()
 *             .name(String.format("%s-lambda-log-export-role", lambdaFunctionName))
 *             .assumeRolePolicy(logsAssumeRole.json())
 *             .build());
 * 
 *         final var lambdaLogExport = IamFunctions.getPolicyDocument(GetPolicyDocumentArgs.builder()
 *             .statements(GetPolicyDocumentStatementArgs.builder()
 *                 .actions("s3:PutObject")
 *                 .effect("Allow")
 *                 .resources(lambdaLogExportBucket.arn().applyValue(_arn -> String.format("%s/*", _arn)))
 *                 .build())
 *             .build());
 * 
 *         var lambdaLogExportRolePolicy = new RolePolicy("lambdaLogExportRolePolicy", RolePolicyArgs.builder()
 *             .policy(lambdaLogExport.applyValue(_lambdaLogExport -> _lambdaLogExport.json()))
 *             .role(logsLogExport.name())
 *             .build());
 * 
 *         var lambdaLogExportLogSubscriptionFilter = new LogSubscriptionFilter("lambdaLogExportLogSubscriptionFilter", LogSubscriptionFilterArgs.builder()
 *             .name(String.format("%s-filter", lambdaFunctionName))
 *             .logGroup(export.name())
 *             .filterPattern("")
 *             .destinationArn(lambdaLogExportBucket.arn())
 *             .roleArn(logsLogExport.arn())
 *             .build());
 * 
 *         var logExport = new Function("logExport", FunctionArgs.builder()
 *             .name(lambdaFunctionName)
 *             .handler("index.lambda_handler")
 *             .runtime("python3.13")
 *             .role(example.arn())
 *             .code(new FileArchive("function.zip"))
 *             .loggingConfig(FunctionLoggingConfigArgs.builder()
 *                 .logFormat("Text")
 *                 .logGroup(export.name())
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(export)
 *                 .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ### Function with Error Handling
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.aws.lambda.Function;
 * import com.pulumi.aws.lambda.FunctionArgs;
 * import com.pulumi.aws.lambda.inputs.FunctionDeadLetterConfigArgs;
 * import com.pulumi.aws.lambda.FunctionEventInvokeConfig;
 * import com.pulumi.aws.lambda.FunctionEventInvokeConfigArgs;
 * import com.pulumi.aws.lambda.inputs.FunctionEventInvokeConfigDestinationConfigArgs;
 * import com.pulumi.aws.lambda.inputs.FunctionEventInvokeConfigDestinationConfigOnFailureArgs;
 * import com.pulumi.aws.lambda.inputs.FunctionEventInvokeConfigDestinationConfigOnSuccessArgs;
 * import com.pulumi.asset.FileArchive;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         // Main Lambda function
 *         var example = new Function("example", FunctionArgs.builder()
 *             .code(new FileArchive("function.zip"))
 *             .name("example_function")
 *             .role(exampleAwsIamRole.arn())
 *             .handler("index.handler")
 *             .runtime("nodejs20.x")
 *             .deadLetterConfig(FunctionDeadLetterConfigArgs.builder()
 *                 .targetArn(dlq.arn())
 *                 .build())
 *             .build());
 * 
 *         // Event invoke configuration for retries
 *         var exampleFunctionEventInvokeConfig = new FunctionEventInvokeConfig("exampleFunctionEventInvokeConfig", FunctionEventInvokeConfigArgs.builder()
 *             .functionName(example.name())
 *             .maximumEventAgeInSeconds(60)
 *             .maximumRetryAttempts(2)
 *             .destinationConfig(FunctionEventInvokeConfigDestinationConfigArgs.builder()
 *                 .onFailure(FunctionEventInvokeConfigDestinationConfigOnFailureArgs.builder()
 *                     .destination(dlq.arn())
 *                     .build())
 *                 .onSuccess(FunctionEventInvokeConfigDestinationConfigOnSuccessArgs.builder()
 *                     .destination(success.arn())
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ### CloudWatch Logging and Permissions
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.aws.cloudwatch.LogGroup;
 * import com.pulumi.aws.cloudwatch.LogGroupArgs;
 * import com.pulumi.aws.iam.Role;
 * import com.pulumi.aws.iam.RoleArgs;
 * import com.pulumi.aws.iam.Policy;
 * import com.pulumi.aws.iam.PolicyArgs;
 * import com.pulumi.aws.iam.RolePolicyAttachment;
 * import com.pulumi.aws.iam.RolePolicyAttachmentArgs;
 * import com.pulumi.aws.lambda.Function;
 * import com.pulumi.aws.lambda.FunctionArgs;
 * import com.pulumi.aws.lambda.inputs.FunctionLoggingConfigArgs;
 * import com.pulumi.asset.FileArchive;
 * import static com.pulumi.codegen.internal.Serialization.*;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         final var config = ctx.config();
 *         final var functionName = config.get("functionName").orElse("example_function");
 *         // CloudWatch Log Group with retention
 *         var example = new LogGroup("example", LogGroupArgs.builder()
 *             .name(String.format("/aws/lambda/%s", functionName))
 *             .retentionInDays(14)
 *             .tags(Map.ofEntries(
 *                 Map.entry("Environment", "production"),
 *                 Map.entry("Function", functionName)
 *             ))
 *             .build());
 * 
 *         // Lambda execution role
 *         var exampleRole = new Role("exampleRole", RoleArgs.builder()
 *             .name("lambda_execution_role")
 *             .assumeRolePolicy(serializeJson(
 *                 jsonObject(
 *                     jsonProperty("Version", "2012-10-17"),
 *                     jsonProperty("Statement", jsonArray(jsonObject(
 *                         jsonProperty("Action", "sts:AssumeRole"),
 *                         jsonProperty("Effect", "Allow"),
 *                         jsonProperty("Principal", jsonObject(
 *                             jsonProperty("Service", "lambda.amazonaws.com")
 *                         ))
 *                     )))
 *                 )))
 *             .build());
 * 
 *         // CloudWatch Logs policy
 *         var lambdaLogging = new Policy("lambdaLogging", PolicyArgs.builder()
 *             .name("lambda_logging")
 *             .path("/")
 *             .description("IAM policy for logging from Lambda")
 *             .policy(serializeJson(
 *                 jsonObject(
 *                     jsonProperty("Version", "2012-10-17"),
 *                     jsonProperty("Statement", jsonArray(jsonObject(
 *                         jsonProperty("Effect", "Allow"),
 *                         jsonProperty("Action", jsonArray(
 *                             "logs:CreateLogGroup", 
 *                             "logs:CreateLogStream", 
 *                             "logs:PutLogEvents"
 *                         )),
 *                         jsonProperty("Resource", jsonArray("arn:aws:logs:*:*:*"))
 *                     )))
 *                 )))
 *             .build());
 * 
 *         // Attach logging policy to Lambda role
 *         var lambdaLogs = new RolePolicyAttachment("lambdaLogs", RolePolicyAttachmentArgs.builder()
 *             .role(exampleRole.name())
 *             .policyArn(lambdaLogging.arn())
 *             .build());
 * 
 *         // Lambda function with logging
 *         var exampleFunction = new Function("exampleFunction", FunctionArgs.builder()
 *             .code(new FileArchive("function.zip"))
 *             .name(functionName)
 *             .role(exampleRole.arn())
 *             .handler("index.handler")
 *             .runtime("nodejs20.x")
 *             .loggingConfig(FunctionLoggingConfigArgs.builder()
 *                 .logFormat("JSON")
 *                 .applicationLogLevel("INFO")
 *                 .systemLogLevel("WARN")
 *                 .build())
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(                
 *                     lambdaLogs,
 *                     example)
 *                 .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Specifying the Deployment Package
 * 
 * AWS Lambda expects source code to be provided as a deployment package whose structure varies depending on which `runtime` is in use. See [Runtimes](https://docs.aws.amazon.com/lambda/latest/dg/API_CreateFunction.html#SSS-CreateFunction-request-Runtime) for the valid values of `runtime`. The expected structure of the deployment package can be found in [the AWS Lambda documentation for each runtime](https://docs.aws.amazon.com/lambda/latest/dg/deployment-package-v2.html).
 * 
 * Once you have created your deployment package you can specify it either directly as a local file (using the `filename` argument) or indirectly via Amazon S3 (using the `s3_bucket`, `s3_key` and `s3_object_version` arguments). When providing the deployment package via S3 it may be useful to use the `aws.s3.BucketObjectv2` resource to upload it.
 * 
 * For larger deployment packages it is recommended by Amazon to upload via S3, since the S3 API has better support for uploading large files efficiently.
 * 
 * ## Import
 * 
 * Using `pulumi import`, import Lambda Functions using the `function_name`. For example:
 * 
 * ```sh
 * $ pulumi import aws:lambda/function:Function example example
 * ```
 * 
 */
@ResourceType(type="aws:lambda/function:Function")
public class Function extends com.pulumi.resources.CustomResource {
    /**
     * Instruction set architecture for your Lambda function. Valid values are `[&#34;x86_64&#34;]` and `[&#34;arm64&#34;]`. Default is `[&#34;x86_64&#34;]`. Removing this attribute, function&#39;s architecture stays the same.
     * 
     */
    @Export(name="architectures", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> architectures;

    /**
     * @return Instruction set architecture for your Lambda function. Valid values are `[&#34;x86_64&#34;]` and `[&#34;arm64&#34;]`. Default is `[&#34;x86_64&#34;]`. Removing this attribute, function&#39;s architecture stays the same.
     * 
     */
    public Output<List<String>> architectures() {
        return this.architectures;
    }
    /**
     * ARN identifying your Lambda Function.
     * 
     */
    @Export(name="arn", refs={String.class}, tree="[0]")
    private Output<String> arn;

    /**
     * @return ARN identifying your Lambda Function.
     * 
     */
    public Output<String> arn() {
        return this.arn;
    }
    /**
     * Path to the function&#39;s deployment package within the local filesystem. Conflicts with `image_uri` and `s3_bucket`. One of `filename`, `image_uri`, or `s3_bucket` must be specified.
     * 
     */
    @Export(name="code", refs={Archive.class}, tree="[0]")
    private Output</* @Nullable */ Archive> code;

    /**
     * @return Path to the function&#39;s deployment package within the local filesystem. Conflicts with `image_uri` and `s3_bucket`. One of `filename`, `image_uri`, or `s3_bucket` must be specified.
     * 
     */
    public Output<Optional<Archive>> code() {
        return Codegen.optional(this.code);
    }
    /**
     * Base64-encoded representation of raw SHA-256 sum of the zip file.
     * 
     */
    @Export(name="codeSha256", refs={String.class}, tree="[0]")
    private Output<String> codeSha256;

    /**
     * @return Base64-encoded representation of raw SHA-256 sum of the zip file.
     * 
     */
    public Output<String> codeSha256() {
        return this.codeSha256;
    }
    /**
     * ARN of a code-signing configuration to enable code signing for this function.
     * 
     */
    @Export(name="codeSigningConfigArn", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> codeSigningConfigArn;

    /**
     * @return ARN of a code-signing configuration to enable code signing for this function.
     * 
     */
    public Output<Optional<String>> codeSigningConfigArn() {
        return Codegen.optional(this.codeSigningConfigArn);
    }
    /**
     * Configuration block for dead letter queue. See below.
     * 
     */
    @Export(name="deadLetterConfig", refs={FunctionDeadLetterConfig.class}, tree="[0]")
    private Output</* @Nullable */ FunctionDeadLetterConfig> deadLetterConfig;

    /**
     * @return Configuration block for dead letter queue. See below.
     * 
     */
    public Output<Optional<FunctionDeadLetterConfig>> deadLetterConfig() {
        return Codegen.optional(this.deadLetterConfig);
    }
    /**
     * Description of what your Lambda Function does.
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    /**
     * @return Description of what your Lambda Function does.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * Configuration block for environment variables. See below.
     * 
     */
    @Export(name="environment", refs={FunctionEnvironment.class}, tree="[0]")
    private Output</* @Nullable */ FunctionEnvironment> environment;

    /**
     * @return Configuration block for environment variables. See below.
     * 
     */
    public Output<Optional<FunctionEnvironment>> environment() {
        return Codegen.optional(this.environment);
    }
    /**
     * Amount of ephemeral storage (`/tmp`) to allocate for the Lambda Function. See below.
     * 
     */
    @Export(name="ephemeralStorage", refs={FunctionEphemeralStorage.class}, tree="[0]")
    private Output<FunctionEphemeralStorage> ephemeralStorage;

    /**
     * @return Amount of ephemeral storage (`/tmp`) to allocate for the Lambda Function. See below.
     * 
     */
    public Output<FunctionEphemeralStorage> ephemeralStorage() {
        return this.ephemeralStorage;
    }
    /**
     * Configuration block for EFS file system. See below.
     * 
     */
    @Export(name="fileSystemConfig", refs={FunctionFileSystemConfig.class}, tree="[0]")
    private Output</* @Nullable */ FunctionFileSystemConfig> fileSystemConfig;

    /**
     * @return Configuration block for EFS file system. See below.
     * 
     */
    public Output<Optional<FunctionFileSystemConfig>> fileSystemConfig() {
        return Codegen.optional(this.fileSystemConfig);
    }
    /**
     * Function entry point in your code. Required if `package_type` is `Zip`.
     * 
     */
    @Export(name="handler", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> handler;

    /**
     * @return Function entry point in your code. Required if `package_type` is `Zip`.
     * 
     */
    public Output<Optional<String>> handler() {
        return Codegen.optional(this.handler);
    }
    /**
     * Container image configuration values. See below.
     * 
     */
    @Export(name="imageConfig", refs={FunctionImageConfig.class}, tree="[0]")
    private Output</* @Nullable */ FunctionImageConfig> imageConfig;

    /**
     * @return Container image configuration values. See below.
     * 
     */
    public Output<Optional<FunctionImageConfig>> imageConfig() {
        return Codegen.optional(this.imageConfig);
    }
    /**
     * ECR image URI containing the function&#39;s deployment package. Conflicts with `filename` and `s3_bucket`. One of `filename`, `image_uri`, or `s3_bucket` must be specified.
     * 
     */
    @Export(name="imageUri", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> imageUri;

    /**
     * @return ECR image URI containing the function&#39;s deployment package. Conflicts with `filename` and `s3_bucket`. One of `filename`, `image_uri`, or `s3_bucket` must be specified.
     * 
     */
    public Output<Optional<String>> imageUri() {
        return Codegen.optional(this.imageUri);
    }
    /**
     * ARN to be used for invoking Lambda Function from API Gateway - to be used in `aws.apigateway.Integration`&#39;s `uri`.
     * 
     */
    @Export(name="invokeArn", refs={String.class}, tree="[0]")
    private Output<String> invokeArn;

    /**
     * @return ARN to be used for invoking Lambda Function from API Gateway - to be used in `aws.apigateway.Integration`&#39;s `uri`.
     * 
     */
    public Output<String> invokeArn() {
        return this.invokeArn;
    }
    /**
     * ARN of the AWS Key Management Service key used to encrypt environment variables. If not provided when environment variables are in use, AWS Lambda uses a default service key. If provided when environment variables are not in use, the AWS Lambda API does not save this configuration.
     * 
     */
    @Export(name="kmsKeyArn", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> kmsKeyArn;

    /**
     * @return ARN of the AWS Key Management Service key used to encrypt environment variables. If not provided when environment variables are in use, AWS Lambda uses a default service key. If provided when environment variables are not in use, the AWS Lambda API does not save this configuration.
     * 
     */
    public Output<Optional<String>> kmsKeyArn() {
        return Codegen.optional(this.kmsKeyArn);
    }
    /**
     * Date this resource was last modified.
     * 
     */
    @Export(name="lastModified", refs={String.class}, tree="[0]")
    private Output<String> lastModified;

    /**
     * @return Date this resource was last modified.
     * 
     */
    public Output<String> lastModified() {
        return this.lastModified;
    }
    /**
     * List of Lambda Layer Version ARNs (maximum of 5) to attach to your Lambda Function.
     * 
     */
    @Export(name="layers", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> layers;

    /**
     * @return List of Lambda Layer Version ARNs (maximum of 5) to attach to your Lambda Function.
     * 
     */
    public Output<Optional<List<String>>> layers() {
        return Codegen.optional(this.layers);
    }
    /**
     * Configuration block for advanced logging settings. See below.
     * 
     */
    @Export(name="loggingConfig", refs={FunctionLoggingConfig.class}, tree="[0]")
    private Output<FunctionLoggingConfig> loggingConfig;

    /**
     * @return Configuration block for advanced logging settings. See below.
     * 
     */
    public Output<FunctionLoggingConfig> loggingConfig() {
        return this.loggingConfig;
    }
    /**
     * Amount of memory in MB your Lambda Function can use at runtime. Valid value between 128 MB to 10,240 MB (10 GB), in 1 MB increments. Defaults to 128.
     * 
     */
    @Export(name="memorySize", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> memorySize;

    /**
     * @return Amount of memory in MB your Lambda Function can use at runtime. Valid value between 128 MB to 10,240 MB (10 GB), in 1 MB increments. Defaults to 128.
     * 
     */
    public Output<Optional<Integer>> memorySize() {
        return Codegen.optional(this.memorySize);
    }
    /**
     * Unique name for your Lambda Function.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return Unique name for your Lambda Function.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Lambda deployment package type. Valid values are `Zip` and `Image`. Defaults to `Zip`.
     * 
     */
    @Export(name="packageType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> packageType;

    /**
     * @return Lambda deployment package type. Valid values are `Zip` and `Image`. Defaults to `Zip`.
     * 
     */
    public Output<Optional<String>> packageType() {
        return Codegen.optional(this.packageType);
    }
    /**
     * Whether to publish creation/change as new Lambda Function Version. Defaults to `false`.
     * 
     */
    @Export(name="publish", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> publish;

    /**
     * @return Whether to publish creation/change as new Lambda Function Version. Defaults to `false`.
     * 
     */
    public Output<Optional<Boolean>> publish() {
        return Codegen.optional(this.publish);
    }
    /**
     * ARN identifying your Lambda Function Version (if versioning is enabled via `publish = true`).
     * 
     */
    @Export(name="qualifiedArn", refs={String.class}, tree="[0]")
    private Output<String> qualifiedArn;

    /**
     * @return ARN identifying your Lambda Function Version (if versioning is enabled via `publish = true`).
     * 
     */
    public Output<String> qualifiedArn() {
        return this.qualifiedArn;
    }
    /**
     * Qualified ARN (ARN with lambda version number) to be used for invoking Lambda Function from API Gateway - to be used in `aws.apigateway.Integration`&#39;s `uri`.
     * 
     */
    @Export(name="qualifiedInvokeArn", refs={String.class}, tree="[0]")
    private Output<String> qualifiedInvokeArn;

    /**
     * @return Qualified ARN (ARN with lambda version number) to be used for invoking Lambda Function from API Gateway - to be used in `aws.apigateway.Integration`&#39;s `uri`.
     * 
     */
    public Output<String> qualifiedInvokeArn() {
        return this.qualifiedInvokeArn;
    }
    /**
     * Region where this resource will be [managed](https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints). Defaults to the Region set in the provider configuration.
     * 
     */
    @Export(name="region", refs={String.class}, tree="[0]")
    private Output<String> region;

    /**
     * @return Region where this resource will be [managed](https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints). Defaults to the Region set in the provider configuration.
     * 
     */
    public Output<String> region() {
        return this.region;
    }
    /**
     * Whether to replace the security groups on the function&#39;s VPC configuration prior to destruction. Default is `false`.
     * 
     */
    @Export(name="replaceSecurityGroupsOnDestroy", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> replaceSecurityGroupsOnDestroy;

    /**
     * @return Whether to replace the security groups on the function&#39;s VPC configuration prior to destruction. Default is `false`.
     * 
     */
    public Output<Optional<Boolean>> replaceSecurityGroupsOnDestroy() {
        return Codegen.optional(this.replaceSecurityGroupsOnDestroy);
    }
    /**
     * List of security group IDs to assign to the function&#39;s VPC configuration prior to destruction. Required if `replace_security_groups_on_destroy` is `true`.
     * 
     */
    @Export(name="replacementSecurityGroupIds", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> replacementSecurityGroupIds;

    /**
     * @return List of security group IDs to assign to the function&#39;s VPC configuration prior to destruction. Required if `replace_security_groups_on_destroy` is `true`.
     * 
     */
    public Output<Optional<List<String>>> replacementSecurityGroupIds() {
        return Codegen.optional(this.replacementSecurityGroupIds);
    }
    /**
     * Amount of reserved concurrent executions for this lambda function. A value of `0` disables lambda from being triggered and `-1` removes any concurrency limitations. Defaults to Unreserved Concurrency Limits `-1`.
     * 
     */
    @Export(name="reservedConcurrentExecutions", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> reservedConcurrentExecutions;

    /**
     * @return Amount of reserved concurrent executions for this lambda function. A value of `0` disables lambda from being triggered and `-1` removes any concurrency limitations. Defaults to Unreserved Concurrency Limits `-1`.
     * 
     */
    public Output<Optional<Integer>> reservedConcurrentExecutions() {
        return Codegen.optional(this.reservedConcurrentExecutions);
    }
    /**
     * ARN of the function&#39;s execution role. The role provides the function&#39;s identity and access to AWS services and resources.
     * 
     * The following arguments are optional:
     * 
     */
    @Export(name="role", refs={String.class}, tree="[0]")
    private Output<String> role;

    /**
     * @return ARN of the function&#39;s execution role. The role provides the function&#39;s identity and access to AWS services and resources.
     * 
     * The following arguments are optional:
     * 
     */
    public Output<String> role() {
        return this.role;
    }
    /**
     * Identifier of the function&#39;s runtime. Required if `package_type` is `Zip`. See [Runtimes](https://docs.aws.amazon.com/lambda/latest/dg/API_CreateFunction.html#SSS-CreateFunction-request-Runtime) for valid values.
     * 
     */
    @Export(name="runtime", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> runtime;

    /**
     * @return Identifier of the function&#39;s runtime. Required if `package_type` is `Zip`. See [Runtimes](https://docs.aws.amazon.com/lambda/latest/dg/API_CreateFunction.html#SSS-CreateFunction-request-Runtime) for valid values.
     * 
     */
    public Output<Optional<String>> runtime() {
        return Codegen.optional(this.runtime);
    }
    /**
     * S3 bucket location containing the function&#39;s deployment package. Conflicts with `filename` and `image_uri`. One of `filename`, `image_uri`, or `s3_bucket` must be specified.
     * 
     */
    @Export(name="s3Bucket", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> s3Bucket;

    /**
     * @return S3 bucket location containing the function&#39;s deployment package. Conflicts with `filename` and `image_uri`. One of `filename`, `image_uri`, or `s3_bucket` must be specified.
     * 
     */
    public Output<Optional<String>> s3Bucket() {
        return Codegen.optional(this.s3Bucket);
    }
    /**
     * S3 key of an object containing the function&#39;s deployment package. Required if `s3_bucket` is set.
     * 
     */
    @Export(name="s3Key", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> s3Key;

    /**
     * @return S3 key of an object containing the function&#39;s deployment package. Required if `s3_bucket` is set.
     * 
     */
    public Output<Optional<String>> s3Key() {
        return Codegen.optional(this.s3Key);
    }
    /**
     * Object version containing the function&#39;s deployment package. Conflicts with `filename` and `image_uri`.
     * 
     */
    @Export(name="s3ObjectVersion", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> s3ObjectVersion;

    /**
     * @return Object version containing the function&#39;s deployment package. Conflicts with `filename` and `image_uri`.
     * 
     */
    public Output<Optional<String>> s3ObjectVersion() {
        return Codegen.optional(this.s3ObjectVersion);
    }
    /**
     * ARN of the signing job.
     * 
     */
    @Export(name="signingJobArn", refs={String.class}, tree="[0]")
    private Output<String> signingJobArn;

    /**
     * @return ARN of the signing job.
     * 
     */
    public Output<String> signingJobArn() {
        return this.signingJobArn;
    }
    /**
     * ARN of the signing profile version.
     * 
     */
    @Export(name="signingProfileVersionArn", refs={String.class}, tree="[0]")
    private Output<String> signingProfileVersionArn;

    /**
     * @return ARN of the signing profile version.
     * 
     */
    public Output<String> signingProfileVersionArn() {
        return this.signingProfileVersionArn;
    }
    /**
     * Whether to retain the old version of a previously deployed Lambda Layer. Default is `false`.
     * 
     */
    @Export(name="skipDestroy", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> skipDestroy;

    /**
     * @return Whether to retain the old version of a previously deployed Lambda Layer. Default is `false`.
     * 
     */
    public Output<Optional<Boolean>> skipDestroy() {
        return Codegen.optional(this.skipDestroy);
    }
    /**
     * Configuration block for snap start settings. See below.
     * 
     */
    @Export(name="snapStart", refs={FunctionSnapStart.class}, tree="[0]")
    private Output</* @Nullable */ FunctionSnapStart> snapStart;

    /**
     * @return Configuration block for snap start settings. See below.
     * 
     */
    public Output<Optional<FunctionSnapStart>> snapStart() {
        return Codegen.optional(this.snapStart);
    }
    /**
     * Base64-encoded SHA256 hash of the package file. Used to trigger updates when source code changes.
     * 
     */
    @Export(name="sourceCodeHash", refs={String.class}, tree="[0]")
    private Output<String> sourceCodeHash;

    /**
     * @return Base64-encoded SHA256 hash of the package file. Used to trigger updates when source code changes.
     * 
     */
    public Output<String> sourceCodeHash() {
        return this.sourceCodeHash;
    }
    /**
     * Size in bytes of the function .zip file.
     * 
     */
    @Export(name="sourceCodeSize", refs={Integer.class}, tree="[0]")
    private Output<Integer> sourceCodeSize;

    /**
     * @return Size in bytes of the function .zip file.
     * 
     */
    public Output<Integer> sourceCodeSize() {
        return this.sourceCodeSize;
    }
    /**
     * Key-value map of tags for the Lambda function. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    @Export(name="tags", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> tags;

    /**
     * @return Key-value map of tags for the Lambda function. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    public Output<Optional<Map<String,String>>> tags() {
        return Codegen.optional(this.tags);
    }
    /**
     * Map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
     * 
     */
    @Export(name="tagsAll", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output<Map<String,String>> tagsAll;

    /**
     * @return Map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
     * 
     */
    public Output<Map<String,String>> tagsAll() {
        return this.tagsAll;
    }
    /**
     * Amount of time your Lambda Function has to run in seconds. Defaults to 3. Valid between 1 and 900.
     * 
     */
    @Export(name="timeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> timeout;

    /**
     * @return Amount of time your Lambda Function has to run in seconds. Defaults to 3. Valid between 1 and 900.
     * 
     */
    public Output<Optional<Integer>> timeout() {
        return Codegen.optional(this.timeout);
    }
    /**
     * Configuration block for X-Ray tracing. See below.
     * 
     */
    @Export(name="tracingConfig", refs={FunctionTracingConfig.class}, tree="[0]")
    private Output<FunctionTracingConfig> tracingConfig;

    /**
     * @return Configuration block for X-Ray tracing. See below.
     * 
     */
    public Output<FunctionTracingConfig> tracingConfig() {
        return this.tracingConfig;
    }
    /**
     * Latest published version of your Lambda Function.
     * 
     */
    @Export(name="version", refs={String.class}, tree="[0]")
    private Output<String> version;

    /**
     * @return Latest published version of your Lambda Function.
     * 
     */
    public Output<String> version() {
        return this.version;
    }
    /**
     * Configuration block for VPC. See below.
     * 
     */
    @Export(name="vpcConfig", refs={FunctionVpcConfig.class}, tree="[0]")
    private Output</* @Nullable */ FunctionVpcConfig> vpcConfig;

    /**
     * @return Configuration block for VPC. See below.
     * 
     */
    public Output<Optional<FunctionVpcConfig>> vpcConfig() {
        return Codegen.optional(this.vpcConfig);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Function(java.lang.String name) {
        this(name, FunctionArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Function(java.lang.String name, FunctionArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Function(java.lang.String name, FunctionArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("aws:lambda/function:Function", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Function(java.lang.String name, Output<java.lang.String> id, @Nullable FunctionState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("aws:lambda/function:Function", name, state, makeResourceOptions(options, id), false);
    }

    private static FunctionArgs makeArgs(FunctionArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? FunctionArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Function get(java.lang.String name, Output<java.lang.String> id, @Nullable FunctionState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Function(name, id, state, options);
    }
}
