// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aws.lb.inputs;

import com.pulumi.aws.lb.inputs.ListenerRuleConditionHostHeaderArgs;
import com.pulumi.aws.lb.inputs.ListenerRuleConditionHttpHeaderArgs;
import com.pulumi.aws.lb.inputs.ListenerRuleConditionHttpRequestMethodArgs;
import com.pulumi.aws.lb.inputs.ListenerRuleConditionPathPatternArgs;
import com.pulumi.aws.lb.inputs.ListenerRuleConditionQueryStringArgs;
import com.pulumi.aws.lb.inputs.ListenerRuleConditionSourceIpArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ListenerRuleConditionArgs extends com.pulumi.resources.ResourceArgs {

    public static final ListenerRuleConditionArgs Empty = new ListenerRuleConditionArgs();

    /**
     * Host header patterns to match. Host Header block fields documented below.
     * 
     */
    @Import(name="hostHeader")
    private @Nullable Output<ListenerRuleConditionHostHeaderArgs> hostHeader;

    /**
     * @return Host header patterns to match. Host Header block fields documented below.
     * 
     */
    public Optional<Output<ListenerRuleConditionHostHeaderArgs>> hostHeader() {
        return Optional.ofNullable(this.hostHeader);
    }

    /**
     * HTTP headers to match. HTTP Header block fields documented below.
     * 
     */
    @Import(name="httpHeader")
    private @Nullable Output<ListenerRuleConditionHttpHeaderArgs> httpHeader;

    /**
     * @return HTTP headers to match. HTTP Header block fields documented below.
     * 
     */
    public Optional<Output<ListenerRuleConditionHttpHeaderArgs>> httpHeader() {
        return Optional.ofNullable(this.httpHeader);
    }

    /**
     * Contains a single `values` item which is a list of HTTP request methods or verbs to match. Maximum size is 40 characters. Only allowed characters are A-Z, hyphen (-) and underscore (\_). Comparison is case sensitive. Wildcards are not supported. Only one needs to match for the condition to be satisfied. AWS recommends that GET and HEAD requests are routed in the same way because the response to a HEAD request may be cached.
     * 
     */
    @Import(name="httpRequestMethod")
    private @Nullable Output<ListenerRuleConditionHttpRequestMethodArgs> httpRequestMethod;

    /**
     * @return Contains a single `values` item which is a list of HTTP request methods or verbs to match. Maximum size is 40 characters. Only allowed characters are A-Z, hyphen (-) and underscore (\_). Comparison is case sensitive. Wildcards are not supported. Only one needs to match for the condition to be satisfied. AWS recommends that GET and HEAD requests are routed in the same way because the response to a HEAD request may be cached.
     * 
     */
    public Optional<Output<ListenerRuleConditionHttpRequestMethodArgs>> httpRequestMethod() {
        return Optional.ofNullable(this.httpRequestMethod);
    }

    /**
     * Path patterns to match against the request URL. Path Pattern block fields documented below.
     * 
     */
    @Import(name="pathPattern")
    private @Nullable Output<ListenerRuleConditionPathPatternArgs> pathPattern;

    /**
     * @return Path patterns to match against the request URL. Path Pattern block fields documented below.
     * 
     */
    public Optional<Output<ListenerRuleConditionPathPatternArgs>> pathPattern() {
        return Optional.ofNullable(this.pathPattern);
    }

    /**
     * Query strings to match. Query String block fields documented below.
     * 
     */
    @Import(name="queryStrings")
    private @Nullable Output<List<ListenerRuleConditionQueryStringArgs>> queryStrings;

    /**
     * @return Query strings to match. Query String block fields documented below.
     * 
     */
    public Optional<Output<List<ListenerRuleConditionQueryStringArgs>>> queryStrings() {
        return Optional.ofNullable(this.queryStrings);
    }

    /**
     * Contains a single `values` item which is a list of source IP CIDR notations to match. You can use both IPv4 and IPv6 addresses. Wildcards are not supported. Condition is satisfied if the source IP address of the request matches one of the CIDR blocks. Condition is not satisfied by the addresses in the `X-Forwarded-For` header, use `httpHeader` condition instead.
     * 
     * &gt; **NOTE::** Exactly one of `hostHeader`, `httpHeader`, `httpRequestMethod`, `pathPattern`, `queryString` or `sourceIp` must be set per condition.
     * 
     */
    @Import(name="sourceIp")
    private @Nullable Output<ListenerRuleConditionSourceIpArgs> sourceIp;

    /**
     * @return Contains a single `values` item which is a list of source IP CIDR notations to match. You can use both IPv4 and IPv6 addresses. Wildcards are not supported. Condition is satisfied if the source IP address of the request matches one of the CIDR blocks. Condition is not satisfied by the addresses in the `X-Forwarded-For` header, use `httpHeader` condition instead.
     * 
     * &gt; **NOTE::** Exactly one of `hostHeader`, `httpHeader`, `httpRequestMethod`, `pathPattern`, `queryString` or `sourceIp` must be set per condition.
     * 
     */
    public Optional<Output<ListenerRuleConditionSourceIpArgs>> sourceIp() {
        return Optional.ofNullable(this.sourceIp);
    }

    private ListenerRuleConditionArgs() {}

    private ListenerRuleConditionArgs(ListenerRuleConditionArgs $) {
        this.hostHeader = $.hostHeader;
        this.httpHeader = $.httpHeader;
        this.httpRequestMethod = $.httpRequestMethod;
        this.pathPattern = $.pathPattern;
        this.queryStrings = $.queryStrings;
        this.sourceIp = $.sourceIp;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ListenerRuleConditionArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ListenerRuleConditionArgs $;

        public Builder() {
            $ = new ListenerRuleConditionArgs();
        }

        public Builder(ListenerRuleConditionArgs defaults) {
            $ = new ListenerRuleConditionArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param hostHeader Host header patterns to match. Host Header block fields documented below.
         * 
         * @return builder
         * 
         */
        public Builder hostHeader(@Nullable Output<ListenerRuleConditionHostHeaderArgs> hostHeader) {
            $.hostHeader = hostHeader;
            return this;
        }

        /**
         * @param hostHeader Host header patterns to match. Host Header block fields documented below.
         * 
         * @return builder
         * 
         */
        public Builder hostHeader(ListenerRuleConditionHostHeaderArgs hostHeader) {
            return hostHeader(Output.of(hostHeader));
        }

        /**
         * @param httpHeader HTTP headers to match. HTTP Header block fields documented below.
         * 
         * @return builder
         * 
         */
        public Builder httpHeader(@Nullable Output<ListenerRuleConditionHttpHeaderArgs> httpHeader) {
            $.httpHeader = httpHeader;
            return this;
        }

        /**
         * @param httpHeader HTTP headers to match. HTTP Header block fields documented below.
         * 
         * @return builder
         * 
         */
        public Builder httpHeader(ListenerRuleConditionHttpHeaderArgs httpHeader) {
            return httpHeader(Output.of(httpHeader));
        }

        /**
         * @param httpRequestMethod Contains a single `values` item which is a list of HTTP request methods or verbs to match. Maximum size is 40 characters. Only allowed characters are A-Z, hyphen (-) and underscore (\_). Comparison is case sensitive. Wildcards are not supported. Only one needs to match for the condition to be satisfied. AWS recommends that GET and HEAD requests are routed in the same way because the response to a HEAD request may be cached.
         * 
         * @return builder
         * 
         */
        public Builder httpRequestMethod(@Nullable Output<ListenerRuleConditionHttpRequestMethodArgs> httpRequestMethod) {
            $.httpRequestMethod = httpRequestMethod;
            return this;
        }

        /**
         * @param httpRequestMethod Contains a single `values` item which is a list of HTTP request methods or verbs to match. Maximum size is 40 characters. Only allowed characters are A-Z, hyphen (-) and underscore (\_). Comparison is case sensitive. Wildcards are not supported. Only one needs to match for the condition to be satisfied. AWS recommends that GET and HEAD requests are routed in the same way because the response to a HEAD request may be cached.
         * 
         * @return builder
         * 
         */
        public Builder httpRequestMethod(ListenerRuleConditionHttpRequestMethodArgs httpRequestMethod) {
            return httpRequestMethod(Output.of(httpRequestMethod));
        }

        /**
         * @param pathPattern Path patterns to match against the request URL. Path Pattern block fields documented below.
         * 
         * @return builder
         * 
         */
        public Builder pathPattern(@Nullable Output<ListenerRuleConditionPathPatternArgs> pathPattern) {
            $.pathPattern = pathPattern;
            return this;
        }

        /**
         * @param pathPattern Path patterns to match against the request URL. Path Pattern block fields documented below.
         * 
         * @return builder
         * 
         */
        public Builder pathPattern(ListenerRuleConditionPathPatternArgs pathPattern) {
            return pathPattern(Output.of(pathPattern));
        }

        /**
         * @param queryStrings Query strings to match. Query String block fields documented below.
         * 
         * @return builder
         * 
         */
        public Builder queryStrings(@Nullable Output<List<ListenerRuleConditionQueryStringArgs>> queryStrings) {
            $.queryStrings = queryStrings;
            return this;
        }

        /**
         * @param queryStrings Query strings to match. Query String block fields documented below.
         * 
         * @return builder
         * 
         */
        public Builder queryStrings(List<ListenerRuleConditionQueryStringArgs> queryStrings) {
            return queryStrings(Output.of(queryStrings));
        }

        /**
         * @param queryStrings Query strings to match. Query String block fields documented below.
         * 
         * @return builder
         * 
         */
        public Builder queryStrings(ListenerRuleConditionQueryStringArgs... queryStrings) {
            return queryStrings(List.of(queryStrings));
        }

        /**
         * @param sourceIp Contains a single `values` item which is a list of source IP CIDR notations to match. You can use both IPv4 and IPv6 addresses. Wildcards are not supported. Condition is satisfied if the source IP address of the request matches one of the CIDR blocks. Condition is not satisfied by the addresses in the `X-Forwarded-For` header, use `httpHeader` condition instead.
         * 
         * &gt; **NOTE::** Exactly one of `hostHeader`, `httpHeader`, `httpRequestMethod`, `pathPattern`, `queryString` or `sourceIp` must be set per condition.
         * 
         * @return builder
         * 
         */
        public Builder sourceIp(@Nullable Output<ListenerRuleConditionSourceIpArgs> sourceIp) {
            $.sourceIp = sourceIp;
            return this;
        }

        /**
         * @param sourceIp Contains a single `values` item which is a list of source IP CIDR notations to match. You can use both IPv4 and IPv6 addresses. Wildcards are not supported. Condition is satisfied if the source IP address of the request matches one of the CIDR blocks. Condition is not satisfied by the addresses in the `X-Forwarded-For` header, use `httpHeader` condition instead.
         * 
         * &gt; **NOTE::** Exactly one of `hostHeader`, `httpHeader`, `httpRequestMethod`, `pathPattern`, `queryString` or `sourceIp` must be set per condition.
         * 
         * @return builder
         * 
         */
        public Builder sourceIp(ListenerRuleConditionSourceIpArgs sourceIp) {
            return sourceIp(Output.of(sourceIp));
        }

        public ListenerRuleConditionArgs build() {
            return $;
        }
    }

}
