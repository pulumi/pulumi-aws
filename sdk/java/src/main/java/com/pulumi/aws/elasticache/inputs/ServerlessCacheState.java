// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aws.elasticache.inputs;

import com.pulumi.aws.elasticache.inputs.ServerlessCacheCacheUsageLimitsArgs;
import com.pulumi.aws.elasticache.inputs.ServerlessCacheEndpointArgs;
import com.pulumi.aws.elasticache.inputs.ServerlessCacheReaderEndpointArgs;
import com.pulumi.aws.elasticache.inputs.ServerlessCacheTimeoutsArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ServerlessCacheState extends com.pulumi.resources.ResourceArgs {

    public static final ServerlessCacheState Empty = new ServerlessCacheState();

    /**
     * The Amazon Resource Name (ARN) of the serverless cache.
     * 
     */
    @Import(name="arn")
    private @Nullable Output<String> arn;

    /**
     * @return The Amazon Resource Name (ARN) of the serverless cache.
     * 
     */
    public Optional<Output<String>> arn() {
        return Optional.ofNullable(this.arn);
    }

    /**
     * Sets the cache usage limits for storage and ElastiCache Processing Units for the cache. See configuration below.
     * 
     */
    @Import(name="cacheUsageLimits")
    private @Nullable Output<ServerlessCacheCacheUsageLimitsArgs> cacheUsageLimits;

    /**
     * @return Sets the cache usage limits for storage and ElastiCache Processing Units for the cache. See configuration below.
     * 
     */
    public Optional<Output<ServerlessCacheCacheUsageLimitsArgs>> cacheUsageLimits() {
        return Optional.ofNullable(this.cacheUsageLimits);
    }

    /**
     * Timestamp of when the serverless cache was created.
     * 
     */
    @Import(name="createTime")
    private @Nullable Output<String> createTime;

    /**
     * @return Timestamp of when the serverless cache was created.
     * 
     */
    public Optional<Output<String>> createTime() {
        return Optional.ofNullable(this.createTime);
    }

    /**
     * The daily time that snapshots will be created from the new serverless cache. Only supported for engine type `&#34;redis&#34;`. Defaults to `0`.
     * 
     */
    @Import(name="dailySnapshotTime")
    private @Nullable Output<String> dailySnapshotTime;

    /**
     * @return The daily time that snapshots will be created from the new serverless cache. Only supported for engine type `&#34;redis&#34;`. Defaults to `0`.
     * 
     */
    public Optional<Output<String>> dailySnapshotTime() {
        return Optional.ofNullable(this.dailySnapshotTime);
    }

    /**
     * User-provided description for the serverless cache. The default is NULL.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return User-provided description for the serverless cache. The default is NULL.
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Represents the information required for client programs to connect to a cache node. See config below for details.
     * 
     */
    @Import(name="endpoints")
    private @Nullable Output<List<ServerlessCacheEndpointArgs>> endpoints;

    /**
     * @return Represents the information required for client programs to connect to a cache node. See config below for details.
     * 
     */
    public Optional<Output<List<ServerlessCacheEndpointArgs>>> endpoints() {
        return Optional.ofNullable(this.endpoints);
    }

    /**
     * Name of the cache engine to be used for this cache cluster. Valid values are `memcached` or `redis`.
     * 
     */
    @Import(name="engine")
    private @Nullable Output<String> engine;

    /**
     * @return Name of the cache engine to be used for this cache cluster. Valid values are `memcached` or `redis`.
     * 
     */
    public Optional<Output<String>> engine() {
        return Optional.ofNullable(this.engine);
    }

    /**
     * The name and version number of the engine the serverless cache is compatible with.
     * 
     */
    @Import(name="fullEngineVersion")
    private @Nullable Output<String> fullEngineVersion;

    /**
     * @return The name and version number of the engine the serverless cache is compatible with.
     * 
     */
    public Optional<Output<String>> fullEngineVersion() {
        return Optional.ofNullable(this.fullEngineVersion);
    }

    /**
     * ARN of the customer managed key for encrypting the data at rest. If no KMS key is provided, a default service key is used.
     * 
     */
    @Import(name="kmsKeyId")
    private @Nullable Output<String> kmsKeyId;

    /**
     * @return ARN of the customer managed key for encrypting the data at rest. If no KMS key is provided, a default service key is used.
     * 
     */
    public Optional<Output<String>> kmsKeyId() {
        return Optional.ofNullable(this.kmsKeyId);
    }

    /**
     * The version of the cache engine that will be used to create the serverless cache.
     * See [Describe Cache Engine Versions](https://docs.aws.amazon.com/cli/latest/reference/elasticache/describe-cache-engine-versions.html) in the AWS Documentation for supported versions.
     * 
     */
    @Import(name="majorEngineVersion")
    private @Nullable Output<String> majorEngineVersion;

    /**
     * @return The version of the cache engine that will be used to create the serverless cache.
     * See [Describe Cache Engine Versions](https://docs.aws.amazon.com/cli/latest/reference/elasticache/describe-cache-engine-versions.html) in the AWS Documentation for supported versions.
     * 
     */
    public Optional<Output<String>> majorEngineVersion() {
        return Optional.ofNullable(this.majorEngineVersion);
    }

    /**
     * The Cluster name which serves as a unique identifier to the serverless cache
     * 
     * The following arguments are optional:
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The Cluster name which serves as a unique identifier to the serverless cache
     * 
     * The following arguments are optional:
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Represents the information required for client programs to connect to a cache node. See config below for details.
     * 
     */
    @Import(name="readerEndpoints")
    private @Nullable Output<List<ServerlessCacheReaderEndpointArgs>> readerEndpoints;

    /**
     * @return Represents the information required for client programs to connect to a cache node. See config below for details.
     * 
     */
    public Optional<Output<List<ServerlessCacheReaderEndpointArgs>>> readerEndpoints() {
        return Optional.ofNullable(this.readerEndpoints);
    }

    /**
     * A list of the one or more VPC security groups to be associated with the serverless cache. The security group will authorize traffic access for the VPC end-point (private-link). If no other information is given this will be the VPC’s Default Security Group that is associated with the cluster VPC end-point.
     * 
     */
    @Import(name="securityGroupIds")
    private @Nullable Output<List<String>> securityGroupIds;

    /**
     * @return A list of the one or more VPC security groups to be associated with the serverless cache. The security group will authorize traffic access for the VPC end-point (private-link). If no other information is given this will be the VPC’s Default Security Group that is associated with the cluster VPC end-point.
     * 
     */
    public Optional<Output<List<String>>> securityGroupIds() {
        return Optional.ofNullable(this.securityGroupIds);
    }

    /**
     * The list of ARN(s) of the snapshot that the new serverless cache will be created from. Available for Redis only.
     * 
     */
    @Import(name="snapshotArnsToRestores")
    private @Nullable Output<List<String>> snapshotArnsToRestores;

    /**
     * @return The list of ARN(s) of the snapshot that the new serverless cache will be created from. Available for Redis only.
     * 
     */
    public Optional<Output<List<String>>> snapshotArnsToRestores() {
        return Optional.ofNullable(this.snapshotArnsToRestores);
    }

    /**
     * The number of snapshots that will be retained for the serverless cache that is being created. As new snapshots beyond this limit are added, the oldest snapshots will be deleted on a rolling basis. Available for Redis only.
     * 
     */
    @Import(name="snapshotRetentionLimit")
    private @Nullable Output<Integer> snapshotRetentionLimit;

    /**
     * @return The number of snapshots that will be retained for the serverless cache that is being created. As new snapshots beyond this limit are added, the oldest snapshots will be deleted on a rolling basis. Available for Redis only.
     * 
     */
    public Optional<Output<Integer>> snapshotRetentionLimit() {
        return Optional.ofNullable(this.snapshotRetentionLimit);
    }

    /**
     * The current status of the serverless cache. The allowed values are CREATING, AVAILABLE, DELETING, CREATE-FAILED and MODIFYING.
     * 
     */
    @Import(name="status")
    private @Nullable Output<String> status;

    /**
     * @return The current status of the serverless cache. The allowed values are CREATING, AVAILABLE, DELETING, CREATE-FAILED and MODIFYING.
     * 
     */
    public Optional<Output<String>> status() {
        return Optional.ofNullable(this.status);
    }

    /**
     * A list of the identifiers of the subnets where the VPC endpoint for the serverless cache will be deployed. All the subnetIds must belong to the same VPC.
     * 
     */
    @Import(name="subnetIds")
    private @Nullable Output<List<String>> subnetIds;

    /**
     * @return A list of the identifiers of the subnets where the VPC endpoint for the serverless cache will be deployed. All the subnetIds must belong to the same VPC.
     * 
     */
    public Optional<Output<List<String>>> subnetIds() {
        return Optional.ofNullable(this.subnetIds);
    }

    /**
     * Map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<Map<String,String>> tags;

    /**
     * @return Map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    public Optional<Output<Map<String,String>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    /**
     * @deprecated
     * Please use `tags` instead.
     * 
     */
    @Deprecated /* Please use `tags` instead. */
    @Import(name="tagsAll")
    private @Nullable Output<Map<String,String>> tagsAll;

    /**
     * @deprecated
     * Please use `tags` instead.
     * 
     */
    @Deprecated /* Please use `tags` instead. */
    public Optional<Output<Map<String,String>>> tagsAll() {
        return Optional.ofNullable(this.tagsAll);
    }

    @Import(name="timeouts")
    private @Nullable Output<ServerlessCacheTimeoutsArgs> timeouts;

    public Optional<Output<ServerlessCacheTimeoutsArgs>> timeouts() {
        return Optional.ofNullable(this.timeouts);
    }

    /**
     * The identifier of the UserGroup to be associated with the serverless cache. Available for Redis only. Default is NULL.
     * 
     */
    @Import(name="userGroupId")
    private @Nullable Output<String> userGroupId;

    /**
     * @return The identifier of the UserGroup to be associated with the serverless cache. Available for Redis only. Default is NULL.
     * 
     */
    public Optional<Output<String>> userGroupId() {
        return Optional.ofNullable(this.userGroupId);
    }

    private ServerlessCacheState() {}

    private ServerlessCacheState(ServerlessCacheState $) {
        this.arn = $.arn;
        this.cacheUsageLimits = $.cacheUsageLimits;
        this.createTime = $.createTime;
        this.dailySnapshotTime = $.dailySnapshotTime;
        this.description = $.description;
        this.endpoints = $.endpoints;
        this.engine = $.engine;
        this.fullEngineVersion = $.fullEngineVersion;
        this.kmsKeyId = $.kmsKeyId;
        this.majorEngineVersion = $.majorEngineVersion;
        this.name = $.name;
        this.readerEndpoints = $.readerEndpoints;
        this.securityGroupIds = $.securityGroupIds;
        this.snapshotArnsToRestores = $.snapshotArnsToRestores;
        this.snapshotRetentionLimit = $.snapshotRetentionLimit;
        this.status = $.status;
        this.subnetIds = $.subnetIds;
        this.tags = $.tags;
        this.tagsAll = $.tagsAll;
        this.timeouts = $.timeouts;
        this.userGroupId = $.userGroupId;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ServerlessCacheState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ServerlessCacheState $;

        public Builder() {
            $ = new ServerlessCacheState();
        }

        public Builder(ServerlessCacheState defaults) {
            $ = new ServerlessCacheState(Objects.requireNonNull(defaults));
        }

        /**
         * @param arn The Amazon Resource Name (ARN) of the serverless cache.
         * 
         * @return builder
         * 
         */
        public Builder arn(@Nullable Output<String> arn) {
            $.arn = arn;
            return this;
        }

        /**
         * @param arn The Amazon Resource Name (ARN) of the serverless cache.
         * 
         * @return builder
         * 
         */
        public Builder arn(String arn) {
            return arn(Output.of(arn));
        }

        /**
         * @param cacheUsageLimits Sets the cache usage limits for storage and ElastiCache Processing Units for the cache. See configuration below.
         * 
         * @return builder
         * 
         */
        public Builder cacheUsageLimits(@Nullable Output<ServerlessCacheCacheUsageLimitsArgs> cacheUsageLimits) {
            $.cacheUsageLimits = cacheUsageLimits;
            return this;
        }

        /**
         * @param cacheUsageLimits Sets the cache usage limits for storage and ElastiCache Processing Units for the cache. See configuration below.
         * 
         * @return builder
         * 
         */
        public Builder cacheUsageLimits(ServerlessCacheCacheUsageLimitsArgs cacheUsageLimits) {
            return cacheUsageLimits(Output.of(cacheUsageLimits));
        }

        /**
         * @param createTime Timestamp of when the serverless cache was created.
         * 
         * @return builder
         * 
         */
        public Builder createTime(@Nullable Output<String> createTime) {
            $.createTime = createTime;
            return this;
        }

        /**
         * @param createTime Timestamp of when the serverless cache was created.
         * 
         * @return builder
         * 
         */
        public Builder createTime(String createTime) {
            return createTime(Output.of(createTime));
        }

        /**
         * @param dailySnapshotTime The daily time that snapshots will be created from the new serverless cache. Only supported for engine type `&#34;redis&#34;`. Defaults to `0`.
         * 
         * @return builder
         * 
         */
        public Builder dailySnapshotTime(@Nullable Output<String> dailySnapshotTime) {
            $.dailySnapshotTime = dailySnapshotTime;
            return this;
        }

        /**
         * @param dailySnapshotTime The daily time that snapshots will be created from the new serverless cache. Only supported for engine type `&#34;redis&#34;`. Defaults to `0`.
         * 
         * @return builder
         * 
         */
        public Builder dailySnapshotTime(String dailySnapshotTime) {
            return dailySnapshotTime(Output.of(dailySnapshotTime));
        }

        /**
         * @param description User-provided description for the serverless cache. The default is NULL.
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description User-provided description for the serverless cache. The default is NULL.
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param endpoints Represents the information required for client programs to connect to a cache node. See config below for details.
         * 
         * @return builder
         * 
         */
        public Builder endpoints(@Nullable Output<List<ServerlessCacheEndpointArgs>> endpoints) {
            $.endpoints = endpoints;
            return this;
        }

        /**
         * @param endpoints Represents the information required for client programs to connect to a cache node. See config below for details.
         * 
         * @return builder
         * 
         */
        public Builder endpoints(List<ServerlessCacheEndpointArgs> endpoints) {
            return endpoints(Output.of(endpoints));
        }

        /**
         * @param endpoints Represents the information required for client programs to connect to a cache node. See config below for details.
         * 
         * @return builder
         * 
         */
        public Builder endpoints(ServerlessCacheEndpointArgs... endpoints) {
            return endpoints(List.of(endpoints));
        }

        /**
         * @param engine Name of the cache engine to be used for this cache cluster. Valid values are `memcached` or `redis`.
         * 
         * @return builder
         * 
         */
        public Builder engine(@Nullable Output<String> engine) {
            $.engine = engine;
            return this;
        }

        /**
         * @param engine Name of the cache engine to be used for this cache cluster. Valid values are `memcached` or `redis`.
         * 
         * @return builder
         * 
         */
        public Builder engine(String engine) {
            return engine(Output.of(engine));
        }

        /**
         * @param fullEngineVersion The name and version number of the engine the serverless cache is compatible with.
         * 
         * @return builder
         * 
         */
        public Builder fullEngineVersion(@Nullable Output<String> fullEngineVersion) {
            $.fullEngineVersion = fullEngineVersion;
            return this;
        }

        /**
         * @param fullEngineVersion The name and version number of the engine the serverless cache is compatible with.
         * 
         * @return builder
         * 
         */
        public Builder fullEngineVersion(String fullEngineVersion) {
            return fullEngineVersion(Output.of(fullEngineVersion));
        }

        /**
         * @param kmsKeyId ARN of the customer managed key for encrypting the data at rest. If no KMS key is provided, a default service key is used.
         * 
         * @return builder
         * 
         */
        public Builder kmsKeyId(@Nullable Output<String> kmsKeyId) {
            $.kmsKeyId = kmsKeyId;
            return this;
        }

        /**
         * @param kmsKeyId ARN of the customer managed key for encrypting the data at rest. If no KMS key is provided, a default service key is used.
         * 
         * @return builder
         * 
         */
        public Builder kmsKeyId(String kmsKeyId) {
            return kmsKeyId(Output.of(kmsKeyId));
        }

        /**
         * @param majorEngineVersion The version of the cache engine that will be used to create the serverless cache.
         * See [Describe Cache Engine Versions](https://docs.aws.amazon.com/cli/latest/reference/elasticache/describe-cache-engine-versions.html) in the AWS Documentation for supported versions.
         * 
         * @return builder
         * 
         */
        public Builder majorEngineVersion(@Nullable Output<String> majorEngineVersion) {
            $.majorEngineVersion = majorEngineVersion;
            return this;
        }

        /**
         * @param majorEngineVersion The version of the cache engine that will be used to create the serverless cache.
         * See [Describe Cache Engine Versions](https://docs.aws.amazon.com/cli/latest/reference/elasticache/describe-cache-engine-versions.html) in the AWS Documentation for supported versions.
         * 
         * @return builder
         * 
         */
        public Builder majorEngineVersion(String majorEngineVersion) {
            return majorEngineVersion(Output.of(majorEngineVersion));
        }

        /**
         * @param name The Cluster name which serves as a unique identifier to the serverless cache
         * 
         * The following arguments are optional:
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The Cluster name which serves as a unique identifier to the serverless cache
         * 
         * The following arguments are optional:
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param readerEndpoints Represents the information required for client programs to connect to a cache node. See config below for details.
         * 
         * @return builder
         * 
         */
        public Builder readerEndpoints(@Nullable Output<List<ServerlessCacheReaderEndpointArgs>> readerEndpoints) {
            $.readerEndpoints = readerEndpoints;
            return this;
        }

        /**
         * @param readerEndpoints Represents the information required for client programs to connect to a cache node. See config below for details.
         * 
         * @return builder
         * 
         */
        public Builder readerEndpoints(List<ServerlessCacheReaderEndpointArgs> readerEndpoints) {
            return readerEndpoints(Output.of(readerEndpoints));
        }

        /**
         * @param readerEndpoints Represents the information required for client programs to connect to a cache node. See config below for details.
         * 
         * @return builder
         * 
         */
        public Builder readerEndpoints(ServerlessCacheReaderEndpointArgs... readerEndpoints) {
            return readerEndpoints(List.of(readerEndpoints));
        }

        /**
         * @param securityGroupIds A list of the one or more VPC security groups to be associated with the serverless cache. The security group will authorize traffic access for the VPC end-point (private-link). If no other information is given this will be the VPC’s Default Security Group that is associated with the cluster VPC end-point.
         * 
         * @return builder
         * 
         */
        public Builder securityGroupIds(@Nullable Output<List<String>> securityGroupIds) {
            $.securityGroupIds = securityGroupIds;
            return this;
        }

        /**
         * @param securityGroupIds A list of the one or more VPC security groups to be associated with the serverless cache. The security group will authorize traffic access for the VPC end-point (private-link). If no other information is given this will be the VPC’s Default Security Group that is associated with the cluster VPC end-point.
         * 
         * @return builder
         * 
         */
        public Builder securityGroupIds(List<String> securityGroupIds) {
            return securityGroupIds(Output.of(securityGroupIds));
        }

        /**
         * @param securityGroupIds A list of the one or more VPC security groups to be associated with the serverless cache. The security group will authorize traffic access for the VPC end-point (private-link). If no other information is given this will be the VPC’s Default Security Group that is associated with the cluster VPC end-point.
         * 
         * @return builder
         * 
         */
        public Builder securityGroupIds(String... securityGroupIds) {
            return securityGroupIds(List.of(securityGroupIds));
        }

        /**
         * @param snapshotArnsToRestores The list of ARN(s) of the snapshot that the new serverless cache will be created from. Available for Redis only.
         * 
         * @return builder
         * 
         */
        public Builder snapshotArnsToRestores(@Nullable Output<List<String>> snapshotArnsToRestores) {
            $.snapshotArnsToRestores = snapshotArnsToRestores;
            return this;
        }

        /**
         * @param snapshotArnsToRestores The list of ARN(s) of the snapshot that the new serverless cache will be created from. Available for Redis only.
         * 
         * @return builder
         * 
         */
        public Builder snapshotArnsToRestores(List<String> snapshotArnsToRestores) {
            return snapshotArnsToRestores(Output.of(snapshotArnsToRestores));
        }

        /**
         * @param snapshotArnsToRestores The list of ARN(s) of the snapshot that the new serverless cache will be created from. Available for Redis only.
         * 
         * @return builder
         * 
         */
        public Builder snapshotArnsToRestores(String... snapshotArnsToRestores) {
            return snapshotArnsToRestores(List.of(snapshotArnsToRestores));
        }

        /**
         * @param snapshotRetentionLimit The number of snapshots that will be retained for the serverless cache that is being created. As new snapshots beyond this limit are added, the oldest snapshots will be deleted on a rolling basis. Available for Redis only.
         * 
         * @return builder
         * 
         */
        public Builder snapshotRetentionLimit(@Nullable Output<Integer> snapshotRetentionLimit) {
            $.snapshotRetentionLimit = snapshotRetentionLimit;
            return this;
        }

        /**
         * @param snapshotRetentionLimit The number of snapshots that will be retained for the serverless cache that is being created. As new snapshots beyond this limit are added, the oldest snapshots will be deleted on a rolling basis. Available for Redis only.
         * 
         * @return builder
         * 
         */
        public Builder snapshotRetentionLimit(Integer snapshotRetentionLimit) {
            return snapshotRetentionLimit(Output.of(snapshotRetentionLimit));
        }

        /**
         * @param status The current status of the serverless cache. The allowed values are CREATING, AVAILABLE, DELETING, CREATE-FAILED and MODIFYING.
         * 
         * @return builder
         * 
         */
        public Builder status(@Nullable Output<String> status) {
            $.status = status;
            return this;
        }

        /**
         * @param status The current status of the serverless cache. The allowed values are CREATING, AVAILABLE, DELETING, CREATE-FAILED and MODIFYING.
         * 
         * @return builder
         * 
         */
        public Builder status(String status) {
            return status(Output.of(status));
        }

        /**
         * @param subnetIds A list of the identifiers of the subnets where the VPC endpoint for the serverless cache will be deployed. All the subnetIds must belong to the same VPC.
         * 
         * @return builder
         * 
         */
        public Builder subnetIds(@Nullable Output<List<String>> subnetIds) {
            $.subnetIds = subnetIds;
            return this;
        }

        /**
         * @param subnetIds A list of the identifiers of the subnets where the VPC endpoint for the serverless cache will be deployed. All the subnetIds must belong to the same VPC.
         * 
         * @return builder
         * 
         */
        public Builder subnetIds(List<String> subnetIds) {
            return subnetIds(Output.of(subnetIds));
        }

        /**
         * @param subnetIds A list of the identifiers of the subnets where the VPC endpoint for the serverless cache will be deployed. All the subnetIds must belong to the same VPC.
         * 
         * @return builder
         * 
         */
        public Builder subnetIds(String... subnetIds) {
            return subnetIds(List.of(subnetIds));
        }

        /**
         * @param tags Map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable Output<Map<String,String>> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags Map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         * 
         * @return builder
         * 
         */
        public Builder tags(Map<String,String> tags) {
            return tags(Output.of(tags));
        }

        /**
         * @return builder
         * 
         * @deprecated
         * Please use `tags` instead.
         * 
         */
        @Deprecated /* Please use `tags` instead. */
        public Builder tagsAll(@Nullable Output<Map<String,String>> tagsAll) {
            $.tagsAll = tagsAll;
            return this;
        }

        /**
         * @return builder
         * 
         * @deprecated
         * Please use `tags` instead.
         * 
         */
        @Deprecated /* Please use `tags` instead. */
        public Builder tagsAll(Map<String,String> tagsAll) {
            return tagsAll(Output.of(tagsAll));
        }

        public Builder timeouts(@Nullable Output<ServerlessCacheTimeoutsArgs> timeouts) {
            $.timeouts = timeouts;
            return this;
        }

        public Builder timeouts(ServerlessCacheTimeoutsArgs timeouts) {
            return timeouts(Output.of(timeouts));
        }

        /**
         * @param userGroupId The identifier of the UserGroup to be associated with the serverless cache. Available for Redis only. Default is NULL.
         * 
         * @return builder
         * 
         */
        public Builder userGroupId(@Nullable Output<String> userGroupId) {
            $.userGroupId = userGroupId;
            return this;
        }

        /**
         * @param userGroupId The identifier of the UserGroup to be associated with the serverless cache. Available for Redis only. Default is NULL.
         * 
         * @return builder
         * 
         */
        public Builder userGroupId(String userGroupId) {
            return userGroupId(Output.of(userGroupId));
        }

        public ServerlessCacheState build() {
            return $;
        }
    }

}
