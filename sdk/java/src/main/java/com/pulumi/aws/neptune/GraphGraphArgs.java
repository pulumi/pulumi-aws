// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aws.neptune;

import com.pulumi.aws.neptune.inputs.GraphGraphTimeoutsArgs;
import com.pulumi.aws.neptune.inputs.GraphGraphVectorSearchConfigurationArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class GraphGraphArgs extends com.pulumi.resources.ResourceArgs {

    public static final GraphGraphArgs Empty = new GraphGraphArgs();

    /**
     * A value that indicates whether the graph has deletion protection enabled. The graph can&#39;t be deleted when deletion
     * protection is enabled.
     * 
     */
    @Import(name="deletionProtection")
    private @Nullable Output<Boolean> deletionProtection;

    /**
     * @return A value that indicates whether the graph has deletion protection enabled. The graph can&#39;t be deleted when deletion
     * protection is enabled.
     * 
     */
    public Optional<Output<Boolean>> deletionProtection() {
        return Optional.ofNullable(this.deletionProtection);
    }

    /**
     * The graph name. For example: my-graph-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first
     * character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens. If you don&#39;t specify a graph
     * name, a unique graph name is generated for you using the prefix graph-for, followed by a combination of Stack Name and a
     * UUID.
     * 
     */
    @Import(name="graphName")
    private @Nullable Output<String> graphName;

    /**
     * @return The graph name. For example: my-graph-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first
     * character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens. If you don&#39;t specify a graph
     * name, a unique graph name is generated for you using the prefix graph-for, followed by a combination of Stack Name and a
     * UUID.
     * 
     */
    public Optional<Output<String>> graphName() {
        return Optional.ofNullable(this.graphName);
    }

    /**
     * Allows user to specify name prefix and have remainder of name automatically generated.
     * 
     */
    @Import(name="graphNamePrefix")
    private @Nullable Output<String> graphNamePrefix;

    /**
     * @return Allows user to specify name prefix and have remainder of name automatically generated.
     * 
     */
    public Optional<Output<String>> graphNamePrefix() {
        return Optional.ofNullable(this.graphNamePrefix);
    }

    /**
     * Specifies a KMS key to use to encrypt data in the new graph. Value must be ARN of KMS Key.
     * 
     */
    @Import(name="kmsKeyIdentifier")
    private @Nullable Output<String> kmsKeyIdentifier;

    /**
     * @return Specifies a KMS key to use to encrypt data in the new graph. Value must be ARN of KMS Key.
     * 
     */
    public Optional<Output<String>> kmsKeyIdentifier() {
        return Optional.ofNullable(this.kmsKeyIdentifier);
    }

    /**
     * The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph.
     * 
     */
    @Import(name="provisionedMemory", required=true)
    private Output<Integer> provisionedMemory;

    /**
     * @return The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph.
     * 
     */
    public Output<Integer> provisionedMemory() {
        return this.provisionedMemory;
    }

    /**
     * Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. When
     * the graph is publicly available, its domain name system (DNS) endpoint resolves to the public IP address from the
     * internet. When the graph isn&#39;t publicly available, you need to create a PrivateGraphEndpoint in a given VPC to ensure
     * the DNS name resolves to a private IP address that is reachable from the VPC.
     * 
     */
    @Import(name="publicConnectivity")
    private @Nullable Output<Boolean> publicConnectivity;

    /**
     * @return Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. When
     * the graph is publicly available, its domain name system (DNS) endpoint resolves to the public IP address from the
     * internet. When the graph isn&#39;t publicly available, you need to create a PrivateGraphEndpoint in a given VPC to ensure
     * the DNS name resolves to a private IP address that is reachable from the VPC.
     * 
     */
    public Optional<Output<Boolean>> publicConnectivity() {
        return Optional.ofNullable(this.publicConnectivity);
    }

    /**
     * The number of replicas in other AZs. Value must be between 0 and 2.
     * 
     */
    @Import(name="replicaCount")
    private @Nullable Output<Integer> replicaCount;

    /**
     * @return The number of replicas in other AZs. Value must be between 0 and 2.
     * 
     */
    public Optional<Output<Integer>> replicaCount() {
        return Optional.ofNullable(this.replicaCount);
    }

    @Import(name="tags")
    private @Nullable Output<Map<String,String>> tags;

    public Optional<Output<Map<String,String>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    @Import(name="timeouts")
    private @Nullable Output<GraphGraphTimeoutsArgs> timeouts;

    public Optional<Output<GraphGraphTimeoutsArgs>> timeouts() {
        return Optional.ofNullable(this.timeouts);
    }

    /**
     * Vector search configuration for the Neptune Graph
     * 
     */
    @Import(name="vectorSearchConfiguration")
    private @Nullable Output<GraphGraphVectorSearchConfigurationArgs> vectorSearchConfiguration;

    /**
     * @return Vector search configuration for the Neptune Graph
     * 
     */
    public Optional<Output<GraphGraphVectorSearchConfigurationArgs>> vectorSearchConfiguration() {
        return Optional.ofNullable(this.vectorSearchConfiguration);
    }

    private GraphGraphArgs() {}

    private GraphGraphArgs(GraphGraphArgs $) {
        this.deletionProtection = $.deletionProtection;
        this.graphName = $.graphName;
        this.graphNamePrefix = $.graphNamePrefix;
        this.kmsKeyIdentifier = $.kmsKeyIdentifier;
        this.provisionedMemory = $.provisionedMemory;
        this.publicConnectivity = $.publicConnectivity;
        this.replicaCount = $.replicaCount;
        this.tags = $.tags;
        this.timeouts = $.timeouts;
        this.vectorSearchConfiguration = $.vectorSearchConfiguration;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(GraphGraphArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private GraphGraphArgs $;

        public Builder() {
            $ = new GraphGraphArgs();
        }

        public Builder(GraphGraphArgs defaults) {
            $ = new GraphGraphArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param deletionProtection A value that indicates whether the graph has deletion protection enabled. The graph can&#39;t be deleted when deletion
         * protection is enabled.
         * 
         * @return builder
         * 
         */
        public Builder deletionProtection(@Nullable Output<Boolean> deletionProtection) {
            $.deletionProtection = deletionProtection;
            return this;
        }

        /**
         * @param deletionProtection A value that indicates whether the graph has deletion protection enabled. The graph can&#39;t be deleted when deletion
         * protection is enabled.
         * 
         * @return builder
         * 
         */
        public Builder deletionProtection(Boolean deletionProtection) {
            return deletionProtection(Output.of(deletionProtection));
        }

        /**
         * @param graphName The graph name. For example: my-graph-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first
         * character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens. If you don&#39;t specify a graph
         * name, a unique graph name is generated for you using the prefix graph-for, followed by a combination of Stack Name and a
         * UUID.
         * 
         * @return builder
         * 
         */
        public Builder graphName(@Nullable Output<String> graphName) {
            $.graphName = graphName;
            return this;
        }

        /**
         * @param graphName The graph name. For example: my-graph-1. The name must contain from 1 to 63 letters, numbers, or hyphens, and its first
         * character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens. If you don&#39;t specify a graph
         * name, a unique graph name is generated for you using the prefix graph-for, followed by a combination of Stack Name and a
         * UUID.
         * 
         * @return builder
         * 
         */
        public Builder graphName(String graphName) {
            return graphName(Output.of(graphName));
        }

        /**
         * @param graphNamePrefix Allows user to specify name prefix and have remainder of name automatically generated.
         * 
         * @return builder
         * 
         */
        public Builder graphNamePrefix(@Nullable Output<String> graphNamePrefix) {
            $.graphNamePrefix = graphNamePrefix;
            return this;
        }

        /**
         * @param graphNamePrefix Allows user to specify name prefix and have remainder of name automatically generated.
         * 
         * @return builder
         * 
         */
        public Builder graphNamePrefix(String graphNamePrefix) {
            return graphNamePrefix(Output.of(graphNamePrefix));
        }

        /**
         * @param kmsKeyIdentifier Specifies a KMS key to use to encrypt data in the new graph. Value must be ARN of KMS Key.
         * 
         * @return builder
         * 
         */
        public Builder kmsKeyIdentifier(@Nullable Output<String> kmsKeyIdentifier) {
            $.kmsKeyIdentifier = kmsKeyIdentifier;
            return this;
        }

        /**
         * @param kmsKeyIdentifier Specifies a KMS key to use to encrypt data in the new graph. Value must be ARN of KMS Key.
         * 
         * @return builder
         * 
         */
        public Builder kmsKeyIdentifier(String kmsKeyIdentifier) {
            return kmsKeyIdentifier(Output.of(kmsKeyIdentifier));
        }

        /**
         * @param provisionedMemory The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph.
         * 
         * @return builder
         * 
         */
        public Builder provisionedMemory(Output<Integer> provisionedMemory) {
            $.provisionedMemory = provisionedMemory;
            return this;
        }

        /**
         * @param provisionedMemory The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph.
         * 
         * @return builder
         * 
         */
        public Builder provisionedMemory(Integer provisionedMemory) {
            return provisionedMemory(Output.of(provisionedMemory));
        }

        /**
         * @param publicConnectivity Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. When
         * the graph is publicly available, its domain name system (DNS) endpoint resolves to the public IP address from the
         * internet. When the graph isn&#39;t publicly available, you need to create a PrivateGraphEndpoint in a given VPC to ensure
         * the DNS name resolves to a private IP address that is reachable from the VPC.
         * 
         * @return builder
         * 
         */
        public Builder publicConnectivity(@Nullable Output<Boolean> publicConnectivity) {
            $.publicConnectivity = publicConnectivity;
            return this;
        }

        /**
         * @param publicConnectivity Specifies whether or not the graph can be reachable over the internet. All access to graphs is IAM authenticated. When
         * the graph is publicly available, its domain name system (DNS) endpoint resolves to the public IP address from the
         * internet. When the graph isn&#39;t publicly available, you need to create a PrivateGraphEndpoint in a given VPC to ensure
         * the DNS name resolves to a private IP address that is reachable from the VPC.
         * 
         * @return builder
         * 
         */
        public Builder publicConnectivity(Boolean publicConnectivity) {
            return publicConnectivity(Output.of(publicConnectivity));
        }

        /**
         * @param replicaCount The number of replicas in other AZs. Value must be between 0 and 2.
         * 
         * @return builder
         * 
         */
        public Builder replicaCount(@Nullable Output<Integer> replicaCount) {
            $.replicaCount = replicaCount;
            return this;
        }

        /**
         * @param replicaCount The number of replicas in other AZs. Value must be between 0 and 2.
         * 
         * @return builder
         * 
         */
        public Builder replicaCount(Integer replicaCount) {
            return replicaCount(Output.of(replicaCount));
        }

        public Builder tags(@Nullable Output<Map<String,String>> tags) {
            $.tags = tags;
            return this;
        }

        public Builder tags(Map<String,String> tags) {
            return tags(Output.of(tags));
        }

        public Builder timeouts(@Nullable Output<GraphGraphTimeoutsArgs> timeouts) {
            $.timeouts = timeouts;
            return this;
        }

        public Builder timeouts(GraphGraphTimeoutsArgs timeouts) {
            return timeouts(Output.of(timeouts));
        }

        /**
         * @param vectorSearchConfiguration Vector search configuration for the Neptune Graph
         * 
         * @return builder
         * 
         */
        public Builder vectorSearchConfiguration(@Nullable Output<GraphGraphVectorSearchConfigurationArgs> vectorSearchConfiguration) {
            $.vectorSearchConfiguration = vectorSearchConfiguration;
            return this;
        }

        /**
         * @param vectorSearchConfiguration Vector search configuration for the Neptune Graph
         * 
         * @return builder
         * 
         */
        public Builder vectorSearchConfiguration(GraphGraphVectorSearchConfigurationArgs vectorSearchConfiguration) {
            return vectorSearchConfiguration(Output.of(vectorSearchConfiguration));
        }

        public GraphGraphArgs build() {
            if ($.provisionedMemory == null) {
                throw new MissingRequiredPropertyException("GraphGraphArgs", "provisionedMemory");
            }
            return $;
        }
    }

}
