// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aws.timestreamquery.outputs;

import com.pulumi.aws.timestreamquery.outputs.ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverage;
import com.pulumi.aws.timestreamquery.outputs.ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRange;
import com.pulumi.core.annotations.CustomType;
import java.lang.Integer;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class ScheduledQueryRecentlyFailedRunQueryInsightsResponse {
    /**
     * @return Size of query result set in bytes. You can use this data to validate if the result set has changed as part of the query tuning exercise.
     * 
     */
    private @Nullable Integer outputBytes;
    /**
     * @return Total number of rows returned as part of the query result set. You can use this data to validate if the number of rows in the result set have changed as part of the query tuning exercise.
     * 
     */
    private @Nullable Integer outputRows;
    /**
     * @return Insights into the spatial coverage of the query, including the table with sub-optimal (max) spatial pruning. This information can help you identify areas for improvement in your partitioning strategy to enhance spatial pruning.
     * 
     */
    private @Nullable List<ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverage> querySpatialCoverages;
    /**
     * @return Number of tables in the query.
     * 
     */
    private @Nullable Integer queryTableCount;
    /**
     * @return Insights into the temporal range of the query, including the table with the largest (max) time range. Following are some of the potential options for optimizing time-based pruning: add missing time-predicates, remove functions around the time predicates, add time predicates to all the sub-queries.
     * 
     */
    private @Nullable List<ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRange> queryTemporalRanges;

    private ScheduledQueryRecentlyFailedRunQueryInsightsResponse() {}
    /**
     * @return Size of query result set in bytes. You can use this data to validate if the result set has changed as part of the query tuning exercise.
     * 
     */
    public Optional<Integer> outputBytes() {
        return Optional.ofNullable(this.outputBytes);
    }
    /**
     * @return Total number of rows returned as part of the query result set. You can use this data to validate if the number of rows in the result set have changed as part of the query tuning exercise.
     * 
     */
    public Optional<Integer> outputRows() {
        return Optional.ofNullable(this.outputRows);
    }
    /**
     * @return Insights into the spatial coverage of the query, including the table with sub-optimal (max) spatial pruning. This information can help you identify areas for improvement in your partitioning strategy to enhance spatial pruning.
     * 
     */
    public List<ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverage> querySpatialCoverages() {
        return this.querySpatialCoverages == null ? List.of() : this.querySpatialCoverages;
    }
    /**
     * @return Number of tables in the query.
     * 
     */
    public Optional<Integer> queryTableCount() {
        return Optional.ofNullable(this.queryTableCount);
    }
    /**
     * @return Insights into the temporal range of the query, including the table with the largest (max) time range. Following are some of the potential options for optimizing time-based pruning: add missing time-predicates, remove functions around the time predicates, add time predicates to all the sub-queries.
     * 
     */
    public List<ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRange> queryTemporalRanges() {
        return this.queryTemporalRanges == null ? List.of() : this.queryTemporalRanges;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(ScheduledQueryRecentlyFailedRunQueryInsightsResponse defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable Integer outputBytes;
        private @Nullable Integer outputRows;
        private @Nullable List<ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverage> querySpatialCoverages;
        private @Nullable Integer queryTableCount;
        private @Nullable List<ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRange> queryTemporalRanges;
        public Builder() {}
        public Builder(ScheduledQueryRecentlyFailedRunQueryInsightsResponse defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.outputBytes = defaults.outputBytes;
    	      this.outputRows = defaults.outputRows;
    	      this.querySpatialCoverages = defaults.querySpatialCoverages;
    	      this.queryTableCount = defaults.queryTableCount;
    	      this.queryTemporalRanges = defaults.queryTemporalRanges;
        }

        @CustomType.Setter
        public Builder outputBytes(@Nullable Integer outputBytes) {

            this.outputBytes = outputBytes;
            return this;
        }
        @CustomType.Setter
        public Builder outputRows(@Nullable Integer outputRows) {

            this.outputRows = outputRows;
            return this;
        }
        @CustomType.Setter
        public Builder querySpatialCoverages(@Nullable List<ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverage> querySpatialCoverages) {

            this.querySpatialCoverages = querySpatialCoverages;
            return this;
        }
        public Builder querySpatialCoverages(ScheduledQueryRecentlyFailedRunQueryInsightsResponseQuerySpatialCoverage... querySpatialCoverages) {
            return querySpatialCoverages(List.of(querySpatialCoverages));
        }
        @CustomType.Setter
        public Builder queryTableCount(@Nullable Integer queryTableCount) {

            this.queryTableCount = queryTableCount;
            return this;
        }
        @CustomType.Setter
        public Builder queryTemporalRanges(@Nullable List<ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRange> queryTemporalRanges) {

            this.queryTemporalRanges = queryTemporalRanges;
            return this;
        }
        public Builder queryTemporalRanges(ScheduledQueryRecentlyFailedRunQueryInsightsResponseQueryTemporalRange... queryTemporalRanges) {
            return queryTemporalRanges(List.of(queryTemporalRanges));
        }
        public ScheduledQueryRecentlyFailedRunQueryInsightsResponse build() {
            final var _resultValue = new ScheduledQueryRecentlyFailedRunQueryInsightsResponse();
            _resultValue.outputBytes = outputBytes;
            _resultValue.outputRows = outputRows;
            _resultValue.querySpatialCoverages = querySpatialCoverages;
            _resultValue.queryTableCount = queryTableCount;
            _resultValue.queryTemporalRanges = queryTemporalRanges;
            return _resultValue;
        }
    }
}
