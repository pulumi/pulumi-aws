// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aws.autoscalingplans.outputs;

import com.pulumi.aws.autoscalingplans.outputs.ScalingPlanScalingInstructionCustomizedLoadMetricSpecification;
import com.pulumi.aws.autoscalingplans.outputs.ScalingPlanScalingInstructionPredefinedLoadMetricSpecification;
import com.pulumi.aws.autoscalingplans.outputs.ScalingPlanScalingInstructionTargetTrackingConfiguration;
import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class ScalingPlanScalingInstruction {
    /**
     * @return Customized load metric to use for predictive scaling. You must specify either `customized_load_metric_specification` or `predefined_load_metric_specification` when configuring predictive scaling.
     * More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_CustomizedLoadMetricSpecification.html).
     * 
     */
    private @Nullable ScalingPlanScalingInstructionCustomizedLoadMetricSpecification customizedLoadMetricSpecification;
    /**
     * @return Boolean controlling whether dynamic scaling by AWS Auto Scaling is disabled. Defaults to `false`.
     * 
     */
    private @Nullable Boolean disableDynamicScaling;
    /**
     * @return Maximum capacity of the resource. The exception to this upper limit is if you specify a non-default setting for `predictive_scaling_max_capacity_behavior`.
     * 
     */
    private Integer maxCapacity;
    /**
     * @return Minimum capacity of the resource.
     * 
     */
    private Integer minCapacity;
    /**
     * @return Predefined load metric to use for predictive scaling. You must specify either `predefined_load_metric_specification` or `customized_load_metric_specification` when configuring predictive scaling.
     * More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_PredefinedLoadMetricSpecification.html).
     * 
     */
    private @Nullable ScalingPlanScalingInstructionPredefinedLoadMetricSpecification predefinedLoadMetricSpecification;
    /**
     * @return Defines the behavior that should be applied if the forecast capacity approaches or exceeds the maximum capacity specified for the resource.
     * Valid values: `SetForecastCapacityToMaxCapacity`, `SetMaxCapacityAboveForecastCapacity`, `SetMaxCapacityToForecastCapacity`.
     * 
     */
    private @Nullable String predictiveScalingMaxCapacityBehavior;
    /**
     * @return Size of the capacity buffer to use when the forecast capacity is close to or exceeds the maximum capacity.
     * 
     */
    private @Nullable Integer predictiveScalingMaxCapacityBuffer;
    /**
     * @return Predictive scaling mode. Valid values: `ForecastAndScale`, `ForecastOnly`.
     * 
     */
    private @Nullable String predictiveScalingMode;
    /**
     * @return ID of the resource. This string consists of the resource type and unique identifier.
     * 
     */
    private String resourceId;
    /**
     * @return Scalable dimension associated with the resource. Valid values: `autoscaling:autoScalingGroup:DesiredCapacity`, `dynamodb:index:ReadCapacityUnits`, `dynamodb:index:WriteCapacityUnits`, `dynamodb:table:ReadCapacityUnits`, `dynamodb:table:WriteCapacityUnits`, `ecs:service:DesiredCount`, `ec2:spot-fleet-request:TargetCapacity`, `rds:cluster:ReadReplicaCount`.
     * 
     */
    private String scalableDimension;
    /**
     * @return Controls whether a resource&#39;s externally created scaling policies are kept or replaced. Valid values: `KeepExternalPolicies`, `ReplaceExternalPolicies`. Defaults to `KeepExternalPolicies`.
     * 
     */
    private @Nullable String scalingPolicyUpdateBehavior;
    /**
     * @return Amount of time, in seconds, to buffer the run time of scheduled scaling actions when scaling out.
     * 
     */
    private @Nullable Integer scheduledActionBufferTime;
    /**
     * @return Namespace of the AWS service. Valid values: `autoscaling`, `dynamodb`, `ecs`, `ec2`, `rds`.
     * 
     */
    private String serviceNamespace;
    /**
     * @return Structure that defines new target tracking configurations. Each of these structures includes a specific scaling metric and a target value for the metric, along with various parameters to use with dynamic scaling.
     * More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_TargetTrackingConfiguration.html).
     * 
     */
    private List<ScalingPlanScalingInstructionTargetTrackingConfiguration> targetTrackingConfigurations;

    private ScalingPlanScalingInstruction() {}
    /**
     * @return Customized load metric to use for predictive scaling. You must specify either `customized_load_metric_specification` or `predefined_load_metric_specification` when configuring predictive scaling.
     * More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_CustomizedLoadMetricSpecification.html).
     * 
     */
    public Optional<ScalingPlanScalingInstructionCustomizedLoadMetricSpecification> customizedLoadMetricSpecification() {
        return Optional.ofNullable(this.customizedLoadMetricSpecification);
    }
    /**
     * @return Boolean controlling whether dynamic scaling by AWS Auto Scaling is disabled. Defaults to `false`.
     * 
     */
    public Optional<Boolean> disableDynamicScaling() {
        return Optional.ofNullable(this.disableDynamicScaling);
    }
    /**
     * @return Maximum capacity of the resource. The exception to this upper limit is if you specify a non-default setting for `predictive_scaling_max_capacity_behavior`.
     * 
     */
    public Integer maxCapacity() {
        return this.maxCapacity;
    }
    /**
     * @return Minimum capacity of the resource.
     * 
     */
    public Integer minCapacity() {
        return this.minCapacity;
    }
    /**
     * @return Predefined load metric to use for predictive scaling. You must specify either `predefined_load_metric_specification` or `customized_load_metric_specification` when configuring predictive scaling.
     * More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_PredefinedLoadMetricSpecification.html).
     * 
     */
    public Optional<ScalingPlanScalingInstructionPredefinedLoadMetricSpecification> predefinedLoadMetricSpecification() {
        return Optional.ofNullable(this.predefinedLoadMetricSpecification);
    }
    /**
     * @return Defines the behavior that should be applied if the forecast capacity approaches or exceeds the maximum capacity specified for the resource.
     * Valid values: `SetForecastCapacityToMaxCapacity`, `SetMaxCapacityAboveForecastCapacity`, `SetMaxCapacityToForecastCapacity`.
     * 
     */
    public Optional<String> predictiveScalingMaxCapacityBehavior() {
        return Optional.ofNullable(this.predictiveScalingMaxCapacityBehavior);
    }
    /**
     * @return Size of the capacity buffer to use when the forecast capacity is close to or exceeds the maximum capacity.
     * 
     */
    public Optional<Integer> predictiveScalingMaxCapacityBuffer() {
        return Optional.ofNullable(this.predictiveScalingMaxCapacityBuffer);
    }
    /**
     * @return Predictive scaling mode. Valid values: `ForecastAndScale`, `ForecastOnly`.
     * 
     */
    public Optional<String> predictiveScalingMode() {
        return Optional.ofNullable(this.predictiveScalingMode);
    }
    /**
     * @return ID of the resource. This string consists of the resource type and unique identifier.
     * 
     */
    public String resourceId() {
        return this.resourceId;
    }
    /**
     * @return Scalable dimension associated with the resource. Valid values: `autoscaling:autoScalingGroup:DesiredCapacity`, `dynamodb:index:ReadCapacityUnits`, `dynamodb:index:WriteCapacityUnits`, `dynamodb:table:ReadCapacityUnits`, `dynamodb:table:WriteCapacityUnits`, `ecs:service:DesiredCount`, `ec2:spot-fleet-request:TargetCapacity`, `rds:cluster:ReadReplicaCount`.
     * 
     */
    public String scalableDimension() {
        return this.scalableDimension;
    }
    /**
     * @return Controls whether a resource&#39;s externally created scaling policies are kept or replaced. Valid values: `KeepExternalPolicies`, `ReplaceExternalPolicies`. Defaults to `KeepExternalPolicies`.
     * 
     */
    public Optional<String> scalingPolicyUpdateBehavior() {
        return Optional.ofNullable(this.scalingPolicyUpdateBehavior);
    }
    /**
     * @return Amount of time, in seconds, to buffer the run time of scheduled scaling actions when scaling out.
     * 
     */
    public Optional<Integer> scheduledActionBufferTime() {
        return Optional.ofNullable(this.scheduledActionBufferTime);
    }
    /**
     * @return Namespace of the AWS service. Valid values: `autoscaling`, `dynamodb`, `ecs`, `ec2`, `rds`.
     * 
     */
    public String serviceNamespace() {
        return this.serviceNamespace;
    }
    /**
     * @return Structure that defines new target tracking configurations. Each of these structures includes a specific scaling metric and a target value for the metric, along with various parameters to use with dynamic scaling.
     * More details can be found in the [AWS Auto Scaling API Reference](https://docs.aws.amazon.com/autoscaling/plans/APIReference/API_TargetTrackingConfiguration.html).
     * 
     */
    public List<ScalingPlanScalingInstructionTargetTrackingConfiguration> targetTrackingConfigurations() {
        return this.targetTrackingConfigurations;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(ScalingPlanScalingInstruction defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable ScalingPlanScalingInstructionCustomizedLoadMetricSpecification customizedLoadMetricSpecification;
        private @Nullable Boolean disableDynamicScaling;
        private Integer maxCapacity;
        private Integer minCapacity;
        private @Nullable ScalingPlanScalingInstructionPredefinedLoadMetricSpecification predefinedLoadMetricSpecification;
        private @Nullable String predictiveScalingMaxCapacityBehavior;
        private @Nullable Integer predictiveScalingMaxCapacityBuffer;
        private @Nullable String predictiveScalingMode;
        private String resourceId;
        private String scalableDimension;
        private @Nullable String scalingPolicyUpdateBehavior;
        private @Nullable Integer scheduledActionBufferTime;
        private String serviceNamespace;
        private List<ScalingPlanScalingInstructionTargetTrackingConfiguration> targetTrackingConfigurations;
        public Builder() {}
        public Builder(ScalingPlanScalingInstruction defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.customizedLoadMetricSpecification = defaults.customizedLoadMetricSpecification;
    	      this.disableDynamicScaling = defaults.disableDynamicScaling;
    	      this.maxCapacity = defaults.maxCapacity;
    	      this.minCapacity = defaults.minCapacity;
    	      this.predefinedLoadMetricSpecification = defaults.predefinedLoadMetricSpecification;
    	      this.predictiveScalingMaxCapacityBehavior = defaults.predictiveScalingMaxCapacityBehavior;
    	      this.predictiveScalingMaxCapacityBuffer = defaults.predictiveScalingMaxCapacityBuffer;
    	      this.predictiveScalingMode = defaults.predictiveScalingMode;
    	      this.resourceId = defaults.resourceId;
    	      this.scalableDimension = defaults.scalableDimension;
    	      this.scalingPolicyUpdateBehavior = defaults.scalingPolicyUpdateBehavior;
    	      this.scheduledActionBufferTime = defaults.scheduledActionBufferTime;
    	      this.serviceNamespace = defaults.serviceNamespace;
    	      this.targetTrackingConfigurations = defaults.targetTrackingConfigurations;
        }

        @CustomType.Setter
        public Builder customizedLoadMetricSpecification(@Nullable ScalingPlanScalingInstructionCustomizedLoadMetricSpecification customizedLoadMetricSpecification) {

            this.customizedLoadMetricSpecification = customizedLoadMetricSpecification;
            return this;
        }
        @CustomType.Setter
        public Builder disableDynamicScaling(@Nullable Boolean disableDynamicScaling) {

            this.disableDynamicScaling = disableDynamicScaling;
            return this;
        }
        @CustomType.Setter
        public Builder maxCapacity(Integer maxCapacity) {
            if (maxCapacity == null) {
              throw new MissingRequiredPropertyException("ScalingPlanScalingInstruction", "maxCapacity");
            }
            this.maxCapacity = maxCapacity;
            return this;
        }
        @CustomType.Setter
        public Builder minCapacity(Integer minCapacity) {
            if (minCapacity == null) {
              throw new MissingRequiredPropertyException("ScalingPlanScalingInstruction", "minCapacity");
            }
            this.minCapacity = minCapacity;
            return this;
        }
        @CustomType.Setter
        public Builder predefinedLoadMetricSpecification(@Nullable ScalingPlanScalingInstructionPredefinedLoadMetricSpecification predefinedLoadMetricSpecification) {

            this.predefinedLoadMetricSpecification = predefinedLoadMetricSpecification;
            return this;
        }
        @CustomType.Setter
        public Builder predictiveScalingMaxCapacityBehavior(@Nullable String predictiveScalingMaxCapacityBehavior) {

            this.predictiveScalingMaxCapacityBehavior = predictiveScalingMaxCapacityBehavior;
            return this;
        }
        @CustomType.Setter
        public Builder predictiveScalingMaxCapacityBuffer(@Nullable Integer predictiveScalingMaxCapacityBuffer) {

            this.predictiveScalingMaxCapacityBuffer = predictiveScalingMaxCapacityBuffer;
            return this;
        }
        @CustomType.Setter
        public Builder predictiveScalingMode(@Nullable String predictiveScalingMode) {

            this.predictiveScalingMode = predictiveScalingMode;
            return this;
        }
        @CustomType.Setter
        public Builder resourceId(String resourceId) {
            if (resourceId == null) {
              throw new MissingRequiredPropertyException("ScalingPlanScalingInstruction", "resourceId");
            }
            this.resourceId = resourceId;
            return this;
        }
        @CustomType.Setter
        public Builder scalableDimension(String scalableDimension) {
            if (scalableDimension == null) {
              throw new MissingRequiredPropertyException("ScalingPlanScalingInstruction", "scalableDimension");
            }
            this.scalableDimension = scalableDimension;
            return this;
        }
        @CustomType.Setter
        public Builder scalingPolicyUpdateBehavior(@Nullable String scalingPolicyUpdateBehavior) {

            this.scalingPolicyUpdateBehavior = scalingPolicyUpdateBehavior;
            return this;
        }
        @CustomType.Setter
        public Builder scheduledActionBufferTime(@Nullable Integer scheduledActionBufferTime) {

            this.scheduledActionBufferTime = scheduledActionBufferTime;
            return this;
        }
        @CustomType.Setter
        public Builder serviceNamespace(String serviceNamespace) {
            if (serviceNamespace == null) {
              throw new MissingRequiredPropertyException("ScalingPlanScalingInstruction", "serviceNamespace");
            }
            this.serviceNamespace = serviceNamespace;
            return this;
        }
        @CustomType.Setter
        public Builder targetTrackingConfigurations(List<ScalingPlanScalingInstructionTargetTrackingConfiguration> targetTrackingConfigurations) {
            if (targetTrackingConfigurations == null) {
              throw new MissingRequiredPropertyException("ScalingPlanScalingInstruction", "targetTrackingConfigurations");
            }
            this.targetTrackingConfigurations = targetTrackingConfigurations;
            return this;
        }
        public Builder targetTrackingConfigurations(ScalingPlanScalingInstructionTargetTrackingConfiguration... targetTrackingConfigurations) {
            return targetTrackingConfigurations(List.of(targetTrackingConfigurations));
        }
        public ScalingPlanScalingInstruction build() {
            final var _resultValue = new ScalingPlanScalingInstruction();
            _resultValue.customizedLoadMetricSpecification = customizedLoadMetricSpecification;
            _resultValue.disableDynamicScaling = disableDynamicScaling;
            _resultValue.maxCapacity = maxCapacity;
            _resultValue.minCapacity = minCapacity;
            _resultValue.predefinedLoadMetricSpecification = predefinedLoadMetricSpecification;
            _resultValue.predictiveScalingMaxCapacityBehavior = predictiveScalingMaxCapacityBehavior;
            _resultValue.predictiveScalingMaxCapacityBuffer = predictiveScalingMaxCapacityBuffer;
            _resultValue.predictiveScalingMode = predictiveScalingMode;
            _resultValue.resourceId = resourceId;
            _resultValue.scalableDimension = scalableDimension;
            _resultValue.scalingPolicyUpdateBehavior = scalingPolicyUpdateBehavior;
            _resultValue.scheduledActionBufferTime = scheduledActionBufferTime;
            _resultValue.serviceNamespace = serviceNamespace;
            _resultValue.targetTrackingConfigurations = targetTrackingConfigurations;
            return _resultValue;
        }
    }
}
