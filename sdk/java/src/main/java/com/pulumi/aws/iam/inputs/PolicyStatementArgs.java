// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aws.iam.inputs;

import com.pulumi.aws.iam.enums.PolicyStatementEffect;
import com.pulumi.aws.iam.inputs.AWSPrincipalArgs;
import com.pulumi.aws.iam.inputs.FederatedPrincipalArgs;
import com.pulumi.aws.iam.inputs.ServicePrincipalArgs;
import com.pulumi.core.Either;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Object;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


/**
 * The Statement element is the main element for a policy. This element is required. It can include multiple elements (see the subsequent sections in this page). The Statement element contains an array of individual statements.
 * 
 */
public final class PolicyStatementArgs extends com.pulumi.resources.ResourceArgs {

    public static final PolicyStatementArgs Empty = new PolicyStatementArgs();

    /**
     * Include a list of actions that the policy allows or denies. Required (either Action or NotAction)
     * 
     */
    @Import(name="Action")
    private @Nullable Output<Either<String,List<String>>> Action;

    /**
     * @return Include a list of actions that the policy allows or denies. Required (either Action or NotAction)
     * 
     */
    public Optional<Output<Either<String,List<String>>>> Action() {
        return Optional.ofNullable(this.Action);
    }

    /**
     * Specify the circumstances under which the policy grants permission.
     * 
     */
    @Import(name="Condition")
    private @Nullable Output<Map<String,Object>> Condition;

    /**
     * @return Specify the circumstances under which the policy grants permission.
     * 
     */
    public Optional<Output<Map<String,Object>>> Condition() {
        return Optional.ofNullable(this.Condition);
    }

    /**
     * Indicate whether the policy allows or denies access.
     * 
     */
    @Import(name="Effect", required=true)
    private Output<PolicyStatementEffect> Effect;

    /**
     * @return Indicate whether the policy allows or denies access.
     * 
     */
    public Output<PolicyStatementEffect> Effect() {
        return this.Effect;
    }

    /**
     * Include a list of actions that are not covered by this policy. Required (either Action or NotAction)
     * 
     */
    @Import(name="NotAction")
    private @Nullable Output<Either<String,List<String>>> NotAction;

    /**
     * @return Include a list of actions that are not covered by this policy. Required (either Action or NotAction)
     * 
     */
    public Optional<Output<Either<String,List<String>>>> NotAction() {
        return Optional.ofNullable(this.NotAction);
    }

    /**
     * Indicate the account, user, role, or federated user to which this policy does not apply.
     * 
     */
    @Import(name="NotPrincipal")
    private @Nullable Output<Object> NotPrincipal;

    /**
     * @return Indicate the account, user, role, or federated user to which this policy does not apply.
     * 
     */
    public Optional<Output<Object>> NotPrincipal() {
        return Optional.ofNullable(this.NotPrincipal);
    }

    /**
     * A list of resources that are specifically excluded by this policy.
     * 
     */
    @Import(name="NotResource")
    private @Nullable Output<Either<String,List<String>>> NotResource;

    /**
     * @return A list of resources that are specifically excluded by this policy.
     * 
     */
    public Optional<Output<Either<String,List<String>>>> NotResource() {
        return Optional.ofNullable(this.NotResource);
    }

    /**
     * Indicate the account, user, role, or federated user to which you would like to allow or deny access. If you are creating a policy to attach to a user or role, you cannot include this element. The principal is implied as that user or role.
     * 
     */
    @Import(name="Principal")
    private @Nullable Output<Object> Principal;

    /**
     * @return Indicate the account, user, role, or federated user to which you would like to allow or deny access. If you are creating a policy to attach to a user or role, you cannot include this element. The principal is implied as that user or role.
     * 
     */
    public Optional<Output<Object>> Principal() {
        return Optional.ofNullable(this.Principal);
    }

    /**
     * A list of resources to which the actions apply.
     * 
     */
    @Import(name="Resource")
    private @Nullable Output<Either<String,List<String>>> Resource;

    /**
     * @return A list of resources to which the actions apply.
     * 
     */
    public Optional<Output<Either<String,List<String>>>> Resource() {
        return Optional.ofNullable(this.Resource);
    }

    /**
     * An optional statement ID to differentiate between your statements.
     * 
     */
    @Import(name="Sid")
    private @Nullable Output<String> Sid;

    /**
     * @return An optional statement ID to differentiate between your statements.
     * 
     */
    public Optional<Output<String>> Sid() {
        return Optional.ofNullable(this.Sid);
    }

    private PolicyStatementArgs() {}

    private PolicyStatementArgs(PolicyStatementArgs $) {
        this.Action = $.Action;
        this.Condition = $.Condition;
        this.Effect = $.Effect;
        this.NotAction = $.NotAction;
        this.NotPrincipal = $.NotPrincipal;
        this.NotResource = $.NotResource;
        this.Principal = $.Principal;
        this.Resource = $.Resource;
        this.Sid = $.Sid;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(PolicyStatementArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private PolicyStatementArgs $;

        public Builder() {
            $ = new PolicyStatementArgs();
        }

        public Builder(PolicyStatementArgs defaults) {
            $ = new PolicyStatementArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param Action Include a list of actions that the policy allows or denies. Required (either Action or NotAction)
         * 
         * @return builder
         * 
         */
        public Builder Action(@Nullable Output<Either<String,List<String>>> Action) {
            $.Action = Action;
            return this;
        }

        /**
         * @param Action Include a list of actions that the policy allows or denies. Required (either Action or NotAction)
         * 
         * @return builder
         * 
         */
        public Builder Action(Either<String,List<String>> Action) {
            return Action(Output.of(Action));
        }

        /**
         * @param Action Include a list of actions that the policy allows or denies. Required (either Action or NotAction)
         * 
         * @return builder
         * 
         */
        public Builder Action(String Action) {
            return Action(Either.ofLeft(Action));
        }

        /**
         * @param Action Include a list of actions that the policy allows or denies. Required (either Action or NotAction)
         * 
         * @return builder
         * 
         */
        public Builder Action(List<String> Action) {
            return Action(Either.ofRight(Action));
        }

        /**
         * @param Condition Specify the circumstances under which the policy grants permission.
         * 
         * @return builder
         * 
         */
        public Builder Condition(@Nullable Output<Map<String,Object>> Condition) {
            $.Condition = Condition;
            return this;
        }

        /**
         * @param Condition Specify the circumstances under which the policy grants permission.
         * 
         * @return builder
         * 
         */
        public Builder Condition(Map<String,Object> Condition) {
            return Condition(Output.of(Condition));
        }

        /**
         * @param Effect Indicate whether the policy allows or denies access.
         * 
         * @return builder
         * 
         */
        public Builder Effect(Output<PolicyStatementEffect> Effect) {
            $.Effect = Effect;
            return this;
        }

        /**
         * @param Effect Indicate whether the policy allows or denies access.
         * 
         * @return builder
         * 
         */
        public Builder Effect(PolicyStatementEffect Effect) {
            return Effect(Output.of(Effect));
        }

        /**
         * @param NotAction Include a list of actions that are not covered by this policy. Required (either Action or NotAction)
         * 
         * @return builder
         * 
         */
        public Builder NotAction(@Nullable Output<Either<String,List<String>>> NotAction) {
            $.NotAction = NotAction;
            return this;
        }

        /**
         * @param NotAction Include a list of actions that are not covered by this policy. Required (either Action or NotAction)
         * 
         * @return builder
         * 
         */
        public Builder NotAction(Either<String,List<String>> NotAction) {
            return NotAction(Output.of(NotAction));
        }

        /**
         * @param NotAction Include a list of actions that are not covered by this policy. Required (either Action or NotAction)
         * 
         * @return builder
         * 
         */
        public Builder NotAction(String NotAction) {
            return NotAction(Either.ofLeft(NotAction));
        }

        /**
         * @param NotAction Include a list of actions that are not covered by this policy. Required (either Action or NotAction)
         * 
         * @return builder
         * 
         */
        public Builder NotAction(List<String> NotAction) {
            return NotAction(Either.ofRight(NotAction));
        }

        /**
         * @param NotPrincipal Indicate the account, user, role, or federated user to which this policy does not apply.
         * 
         * @return builder
         * 
         */
        public Builder NotPrincipal(@Nullable Output<Object> NotPrincipal) {
            $.NotPrincipal = NotPrincipal;
            return this;
        }

        /**
         * @param NotPrincipal Indicate the account, user, role, or federated user to which this policy does not apply.
         * 
         * @return builder
         * 
         */
        public Builder NotPrincipal(Object NotPrincipal) {
            return NotPrincipal(Output.of(NotPrincipal));
        }

        /**
         * @param NotResource A list of resources that are specifically excluded by this policy.
         * 
         * @return builder
         * 
         */
        public Builder NotResource(@Nullable Output<Either<String,List<String>>> NotResource) {
            $.NotResource = NotResource;
            return this;
        }

        /**
         * @param NotResource A list of resources that are specifically excluded by this policy.
         * 
         * @return builder
         * 
         */
        public Builder NotResource(Either<String,List<String>> NotResource) {
            return NotResource(Output.of(NotResource));
        }

        /**
         * @param NotResource A list of resources that are specifically excluded by this policy.
         * 
         * @return builder
         * 
         */
        public Builder NotResource(String NotResource) {
            return NotResource(Either.ofLeft(NotResource));
        }

        /**
         * @param NotResource A list of resources that are specifically excluded by this policy.
         * 
         * @return builder
         * 
         */
        public Builder NotResource(List<String> NotResource) {
            return NotResource(Either.ofRight(NotResource));
        }

        /**
         * @param Principal Indicate the account, user, role, or federated user to which you would like to allow or deny access. If you are creating a policy to attach to a user or role, you cannot include this element. The principal is implied as that user or role.
         * 
         * @return builder
         * 
         */
        public Builder Principal(@Nullable Output<Object> Principal) {
            $.Principal = Principal;
            return this;
        }

        /**
         * @param Principal Indicate the account, user, role, or federated user to which you would like to allow or deny access. If you are creating a policy to attach to a user or role, you cannot include this element. The principal is implied as that user or role.
         * 
         * @return builder
         * 
         */
        public Builder Principal(Object Principal) {
            return Principal(Output.of(Principal));
        }

        /**
         * @param Resource A list of resources to which the actions apply.
         * 
         * @return builder
         * 
         */
        public Builder Resource(@Nullable Output<Either<String,List<String>>> Resource) {
            $.Resource = Resource;
            return this;
        }

        /**
         * @param Resource A list of resources to which the actions apply.
         * 
         * @return builder
         * 
         */
        public Builder Resource(Either<String,List<String>> Resource) {
            return Resource(Output.of(Resource));
        }

        /**
         * @param Resource A list of resources to which the actions apply.
         * 
         * @return builder
         * 
         */
        public Builder Resource(String Resource) {
            return Resource(Either.ofLeft(Resource));
        }

        /**
         * @param Resource A list of resources to which the actions apply.
         * 
         * @return builder
         * 
         */
        public Builder Resource(List<String> Resource) {
            return Resource(Either.ofRight(Resource));
        }

        /**
         * @param Sid An optional statement ID to differentiate between your statements.
         * 
         * @return builder
         * 
         */
        public Builder Sid(@Nullable Output<String> Sid) {
            $.Sid = Sid;
            return this;
        }

        /**
         * @param Sid An optional statement ID to differentiate between your statements.
         * 
         * @return builder
         * 
         */
        public Builder Sid(String Sid) {
            return Sid(Output.of(Sid));
        }

        public PolicyStatementArgs build() {
            if ($.Effect == null) {
                throw new MissingRequiredPropertyException("PolicyStatementArgs", "Effect");
            }
            return $;
        }
    }

}
