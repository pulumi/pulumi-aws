// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aws.neptunegraph;

import com.pulumi.aws.neptunegraph.inputs.GraphTimeoutsArgs;
import com.pulumi.aws.neptunegraph.inputs.GraphVectorSearchConfigurationArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class GraphArgs extends com.pulumi.resources.ResourceArgs {

    public static final GraphArgs Empty = new GraphArgs();

    /**
     * Value that indicates whether the Graph has deletion protection enabled. The graph can&#39;t be deleted when deletion protection is enabled.
     * 
     */
    @Import(name="deletionProtection")
    private @Nullable Output<Boolean> deletionProtection;

    /**
     * @return Value that indicates whether the Graph has deletion protection enabled. The graph can&#39;t be deleted when deletion protection is enabled.
     * 
     */
    public Optional<Output<Boolean>> deletionProtection() {
        return Optional.ofNullable(this.deletionProtection);
    }

    /**
     * The graph name. For example: my-graph-1.
     * 								The name must contain from 1 to 63 letters, numbers, or hyphens,
     * 								and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
     * 								If you don&#39;t specify a graph name, a unique graph name is generated for you using the prefix graph-for,
     * 								followed by a combination of Stack Name and a UUID.
     * 
     */
    @Import(name="graphName")
    private @Nullable Output<String> graphName;

    /**
     * @return The graph name. For example: my-graph-1.
     * 								The name must contain from 1 to 63 letters, numbers, or hyphens,
     * 								and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
     * 								If you don&#39;t specify a graph name, a unique graph name is generated for you using the prefix graph-for,
     * 								followed by a combination of Stack Name and a UUID.
     * 
     */
    public Optional<Output<String>> graphName() {
        return Optional.ofNullable(this.graphName);
    }

    /**
     * Allows user to specify name prefix and have remainder of name automatically generated.
     * 
     */
    @Import(name="graphNamePrefix")
    private @Nullable Output<String> graphNamePrefix;

    /**
     * @return Allows user to specify name prefix and have remainder of name automatically generated.
     * 
     */
    public Optional<Output<String>> graphNamePrefix() {
        return Optional.ofNullable(this.graphNamePrefix);
    }

    /**
     * The ARN for the KMS encryption key. By Default, Neptune Analytics will use an AWS provided key (&#34;AWS_OWNED_KEY&#34;). This parameter is used if you want to encrypt the graph using a KMS Customer Managed Key (CMK).
     * 
     */
    @Import(name="kmsKeyIdentifier")
    private @Nullable Output<String> kmsKeyIdentifier;

    /**
     * @return The ARN for the KMS encryption key. By Default, Neptune Analytics will use an AWS provided key (&#34;AWS_OWNED_KEY&#34;). This parameter is used if you want to encrypt the graph using a KMS Customer Managed Key (CMK).
     * 
     */
    public Optional<Output<String>> kmsKeyIdentifier() {
        return Optional.ofNullable(this.kmsKeyIdentifier);
    }

    /**
     * The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph.
     * 
     * The following arguments are optional:
     * 
     */
    @Import(name="provisionedMemory", required=true)
    private Output<Integer> provisionedMemory;

    /**
     * @return The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph.
     * 
     * The following arguments are optional:
     * 
     */
    public Output<Integer> provisionedMemory() {
        return this.provisionedMemory;
    }

    /**
     * Specifies whether the Graph can be reached over the internet. Access to all graphs requires IAM authentication.  When the Graph is publicly reachable, its Domain Name System (DNS) endpoint resolves to the public IP address from the internet.  When the Graph isn&#39;t publicly reachable, you need to create a PrivateGraphEndpoint in a given VPC to ensure the DNS name resolves to a private IP address that is reachable from the VPC.
     * 
     */
    @Import(name="publicConnectivity")
    private @Nullable Output<Boolean> publicConnectivity;

    /**
     * @return Specifies whether the Graph can be reached over the internet. Access to all graphs requires IAM authentication.  When the Graph is publicly reachable, its Domain Name System (DNS) endpoint resolves to the public IP address from the internet.  When the Graph isn&#39;t publicly reachable, you need to create a PrivateGraphEndpoint in a given VPC to ensure the DNS name resolves to a private IP address that is reachable from the VPC.
     * 
     */
    public Optional<Output<Boolean>> publicConnectivity() {
        return Optional.ofNullable(this.publicConnectivity);
    }

    /**
     * Region where this resource will be [managed](https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints). Defaults to the Region set in the provider configuration.
     * 
     */
    @Import(name="region")
    private @Nullable Output<String> region;

    /**
     * @return Region where this resource will be [managed](https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints). Defaults to the Region set in the provider configuration.
     * 
     */
    public Optional<Output<String>> region() {
        return Optional.ofNullable(this.region);
    }

    /**
     * Specifies the number of replicas you want when finished. All replicas will be provisioned in different availability zones.  Replica Count should always be less than or equal to 2.
     * 
     */
    @Import(name="replicaCount")
    private @Nullable Output<Integer> replicaCount;

    /**
     * @return Specifies the number of replicas you want when finished. All replicas will be provisioned in different availability zones.  Replica Count should always be less than or equal to 2.
     * 
     */
    public Optional<Output<Integer>> replicaCount() {
        return Optional.ofNullable(this.replicaCount);
    }

    /**
     * Key-value tags for the graph. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<Map<String,String>> tags;

    /**
     * @return Key-value tags for the graph. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    public Optional<Output<Map<String,String>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    @Import(name="timeouts")
    private @Nullable Output<GraphTimeoutsArgs> timeouts;

    public Optional<Output<GraphTimeoutsArgs>> timeouts() {
        return Optional.ofNullable(this.timeouts);
    }

    /**
     * Vector Search Configuration (see below for nested schema of vector_search_configuration)
     * 
     */
    @Import(name="vectorSearchConfiguration")
    private @Nullable Output<GraphVectorSearchConfigurationArgs> vectorSearchConfiguration;

    /**
     * @return Vector Search Configuration (see below for nested schema of vector_search_configuration)
     * 
     */
    public Optional<Output<GraphVectorSearchConfigurationArgs>> vectorSearchConfiguration() {
        return Optional.ofNullable(this.vectorSearchConfiguration);
    }

    private GraphArgs() {}

    private GraphArgs(GraphArgs $) {
        this.deletionProtection = $.deletionProtection;
        this.graphName = $.graphName;
        this.graphNamePrefix = $.graphNamePrefix;
        this.kmsKeyIdentifier = $.kmsKeyIdentifier;
        this.provisionedMemory = $.provisionedMemory;
        this.publicConnectivity = $.publicConnectivity;
        this.region = $.region;
        this.replicaCount = $.replicaCount;
        this.tags = $.tags;
        this.timeouts = $.timeouts;
        this.vectorSearchConfiguration = $.vectorSearchConfiguration;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(GraphArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private GraphArgs $;

        public Builder() {
            $ = new GraphArgs();
        }

        public Builder(GraphArgs defaults) {
            $ = new GraphArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param deletionProtection Value that indicates whether the Graph has deletion protection enabled. The graph can&#39;t be deleted when deletion protection is enabled.
         * 
         * @return builder
         * 
         */
        public Builder deletionProtection(@Nullable Output<Boolean> deletionProtection) {
            $.deletionProtection = deletionProtection;
            return this;
        }

        /**
         * @param deletionProtection Value that indicates whether the Graph has deletion protection enabled. The graph can&#39;t be deleted when deletion protection is enabled.
         * 
         * @return builder
         * 
         */
        public Builder deletionProtection(Boolean deletionProtection) {
            return deletionProtection(Output.of(deletionProtection));
        }

        /**
         * @param graphName The graph name. For example: my-graph-1.
         * 								The name must contain from 1 to 63 letters, numbers, or hyphens,
         * 								and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
         * 								If you don&#39;t specify a graph name, a unique graph name is generated for you using the prefix graph-for,
         * 								followed by a combination of Stack Name and a UUID.
         * 
         * @return builder
         * 
         */
        public Builder graphName(@Nullable Output<String> graphName) {
            $.graphName = graphName;
            return this;
        }

        /**
         * @param graphName The graph name. For example: my-graph-1.
         * 								The name must contain from 1 to 63 letters, numbers, or hyphens,
         * 								and its first character must be a letter. It cannot end with a hyphen or contain two consecutive hyphens.
         * 								If you don&#39;t specify a graph name, a unique graph name is generated for you using the prefix graph-for,
         * 								followed by a combination of Stack Name and a UUID.
         * 
         * @return builder
         * 
         */
        public Builder graphName(String graphName) {
            return graphName(Output.of(graphName));
        }

        /**
         * @param graphNamePrefix Allows user to specify name prefix and have remainder of name automatically generated.
         * 
         * @return builder
         * 
         */
        public Builder graphNamePrefix(@Nullable Output<String> graphNamePrefix) {
            $.graphNamePrefix = graphNamePrefix;
            return this;
        }

        /**
         * @param graphNamePrefix Allows user to specify name prefix and have remainder of name automatically generated.
         * 
         * @return builder
         * 
         */
        public Builder graphNamePrefix(String graphNamePrefix) {
            return graphNamePrefix(Output.of(graphNamePrefix));
        }

        /**
         * @param kmsKeyIdentifier The ARN for the KMS encryption key. By Default, Neptune Analytics will use an AWS provided key (&#34;AWS_OWNED_KEY&#34;). This parameter is used if you want to encrypt the graph using a KMS Customer Managed Key (CMK).
         * 
         * @return builder
         * 
         */
        public Builder kmsKeyIdentifier(@Nullable Output<String> kmsKeyIdentifier) {
            $.kmsKeyIdentifier = kmsKeyIdentifier;
            return this;
        }

        /**
         * @param kmsKeyIdentifier The ARN for the KMS encryption key. By Default, Neptune Analytics will use an AWS provided key (&#34;AWS_OWNED_KEY&#34;). This parameter is used if you want to encrypt the graph using a KMS Customer Managed Key (CMK).
         * 
         * @return builder
         * 
         */
        public Builder kmsKeyIdentifier(String kmsKeyIdentifier) {
            return kmsKeyIdentifier(Output.of(kmsKeyIdentifier));
        }

        /**
         * @param provisionedMemory The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph.
         * 
         * The following arguments are optional:
         * 
         * @return builder
         * 
         */
        public Builder provisionedMemory(Output<Integer> provisionedMemory) {
            $.provisionedMemory = provisionedMemory;
            return this;
        }

        /**
         * @param provisionedMemory The provisioned memory-optimized Neptune Capacity Units (m-NCUs) to use for the graph.
         * 
         * The following arguments are optional:
         * 
         * @return builder
         * 
         */
        public Builder provisionedMemory(Integer provisionedMemory) {
            return provisionedMemory(Output.of(provisionedMemory));
        }

        /**
         * @param publicConnectivity Specifies whether the Graph can be reached over the internet. Access to all graphs requires IAM authentication.  When the Graph is publicly reachable, its Domain Name System (DNS) endpoint resolves to the public IP address from the internet.  When the Graph isn&#39;t publicly reachable, you need to create a PrivateGraphEndpoint in a given VPC to ensure the DNS name resolves to a private IP address that is reachable from the VPC.
         * 
         * @return builder
         * 
         */
        public Builder publicConnectivity(@Nullable Output<Boolean> publicConnectivity) {
            $.publicConnectivity = publicConnectivity;
            return this;
        }

        /**
         * @param publicConnectivity Specifies whether the Graph can be reached over the internet. Access to all graphs requires IAM authentication.  When the Graph is publicly reachable, its Domain Name System (DNS) endpoint resolves to the public IP address from the internet.  When the Graph isn&#39;t publicly reachable, you need to create a PrivateGraphEndpoint in a given VPC to ensure the DNS name resolves to a private IP address that is reachable from the VPC.
         * 
         * @return builder
         * 
         */
        public Builder publicConnectivity(Boolean publicConnectivity) {
            return publicConnectivity(Output.of(publicConnectivity));
        }

        /**
         * @param region Region where this resource will be [managed](https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints). Defaults to the Region set in the provider configuration.
         * 
         * @return builder
         * 
         */
        public Builder region(@Nullable Output<String> region) {
            $.region = region;
            return this;
        }

        /**
         * @param region Region where this resource will be [managed](https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints). Defaults to the Region set in the provider configuration.
         * 
         * @return builder
         * 
         */
        public Builder region(String region) {
            return region(Output.of(region));
        }

        /**
         * @param replicaCount Specifies the number of replicas you want when finished. All replicas will be provisioned in different availability zones.  Replica Count should always be less than or equal to 2.
         * 
         * @return builder
         * 
         */
        public Builder replicaCount(@Nullable Output<Integer> replicaCount) {
            $.replicaCount = replicaCount;
            return this;
        }

        /**
         * @param replicaCount Specifies the number of replicas you want when finished. All replicas will be provisioned in different availability zones.  Replica Count should always be less than or equal to 2.
         * 
         * @return builder
         * 
         */
        public Builder replicaCount(Integer replicaCount) {
            return replicaCount(Output.of(replicaCount));
        }

        /**
         * @param tags Key-value tags for the graph. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable Output<Map<String,String>> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags Key-value tags for the graph. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         * 
         * @return builder
         * 
         */
        public Builder tags(Map<String,String> tags) {
            return tags(Output.of(tags));
        }

        public Builder timeouts(@Nullable Output<GraphTimeoutsArgs> timeouts) {
            $.timeouts = timeouts;
            return this;
        }

        public Builder timeouts(GraphTimeoutsArgs timeouts) {
            return timeouts(Output.of(timeouts));
        }

        /**
         * @param vectorSearchConfiguration Vector Search Configuration (see below for nested schema of vector_search_configuration)
         * 
         * @return builder
         * 
         */
        public Builder vectorSearchConfiguration(@Nullable Output<GraphVectorSearchConfigurationArgs> vectorSearchConfiguration) {
            $.vectorSearchConfiguration = vectorSearchConfiguration;
            return this;
        }

        /**
         * @param vectorSearchConfiguration Vector Search Configuration (see below for nested schema of vector_search_configuration)
         * 
         * @return builder
         * 
         */
        public Builder vectorSearchConfiguration(GraphVectorSearchConfigurationArgs vectorSearchConfiguration) {
            return vectorSearchConfiguration(Output.of(vectorSearchConfiguration));
        }

        public GraphArgs build() {
            if ($.provisionedMemory == null) {
                throw new MissingRequiredPropertyException("GraphArgs", "provisionedMemory");
            }
            return $;
        }
    }

}
