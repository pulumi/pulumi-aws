// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aws.medialive.outputs;

import com.pulumi.aws.medialive.outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings;
import com.pulumi.aws.medialive.outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings;
import com.pulumi.aws.medialive.outputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings;
import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings {
    /**
     * @return Enables or disables adaptive quantization.
     * 
     */
    private @Nullable String adaptiveQuantization;
    /**
     * @return Indicates that AFD values will be written into the output stream.
     * 
     */
    private @Nullable String afdSignaling;
    /**
     * @return Whether or not EML should insert an Alternative Transfer Function SEI message.
     * 
     */
    private @Nullable String alternativeTransferFunction;
    /**
     * @return Average bitrate in bits/second.
     * 
     */
    private Integer bitrate;
    /**
     * @return Size of buffer in bits.
     * 
     */
    private @Nullable Integer bufSize;
    /**
     * @return Includes color space metadata in the output.
     * 
     */
    private @Nullable String colorMetadata;
    /**
     * @return Define the color metadata for the output. H265 Color Space Settings for more details.
     * 
     */
    private @Nullable ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings colorSpaceSettings;
    /**
     * @return Filters to apply to an encode. See H265 Filter Settings for more details.
     * 
     */
    private @Nullable ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings filterSettings;
    /**
     * @return Four bit AFD value to write on all frames of video in the output stream.
     * 
     */
    private @Nullable String fixedAfd;
    private @Nullable String flickerAq;
    /**
     * @return Framerate denominator.
     * 
     */
    private Integer framerateDenominator;
    /**
     * @return Framerate numerator.
     * 
     */
    private Integer framerateNumerator;
    /**
     * @return Frequency of closed GOPs.
     * 
     */
    private @Nullable Integer gopClosedCadence;
    /**
     * @return GOP size in units of either frames of seconds per `gop_size_units`.
     * 
     */
    private @Nullable Double gopSize;
    /**
     * @return Indicates if the `gop_size` is specified in frames or seconds.
     * 
     */
    private @Nullable String gopSizeUnits;
    /**
     * @return H265 level.
     * 
     */
    private @Nullable String level;
    /**
     * @return Amount of lookahead.
     * 
     */
    private @Nullable String lookAheadRateControl;
    /**
     * @return Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
     * 
     */
    private @Nullable Integer maxBitrate;
    private @Nullable Integer minIInterval;
    /**
     * @return Pixel Aspect Ratio denominator.
     * 
     */
    private @Nullable Integer parDenominator;
    /**
     * @return Pixel Aspect Ratio numerator.
     * 
     */
    private @Nullable Integer parNumerator;
    /**
     * @return AAC profile.
     * 
     */
    private @Nullable String profile;
    /**
     * @return Controls the target quality for the video encode.
     * 
     */
    private @Nullable Integer qvbrQualityLevel;
    /**
     * @return The rate control mode.
     * 
     */
    private @Nullable String rateControlMode;
    /**
     * @return Sets the scan type of the output.
     * 
     */
    private @Nullable String scanType;
    /**
     * @return Scene change detection.
     * 
     */
    private @Nullable String sceneChangeDetect;
    /**
     * @return Number of slices per picture.
     * 
     */
    private @Nullable Integer slices;
    /**
     * @return Set the H265 tier in the output.
     * 
     */
    private @Nullable String tier;
    /**
     * @return Apply a burned in timecode. See H265 Timecode Burnin Settings for more details.
     * 
     */
    private @Nullable ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings timecodeBurninSettings;
    /**
     * @return Determines how timecodes should be inserted into the video elementary stream.
     * 
     */
    private @Nullable String timecodeInsertion;

    private ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings() {}
    /**
     * @return Enables or disables adaptive quantization.
     * 
     */
    public Optional<String> adaptiveQuantization() {
        return Optional.ofNullable(this.adaptiveQuantization);
    }
    /**
     * @return Indicates that AFD values will be written into the output stream.
     * 
     */
    public Optional<String> afdSignaling() {
        return Optional.ofNullable(this.afdSignaling);
    }
    /**
     * @return Whether or not EML should insert an Alternative Transfer Function SEI message.
     * 
     */
    public Optional<String> alternativeTransferFunction() {
        return Optional.ofNullable(this.alternativeTransferFunction);
    }
    /**
     * @return Average bitrate in bits/second.
     * 
     */
    public Integer bitrate() {
        return this.bitrate;
    }
    /**
     * @return Size of buffer in bits.
     * 
     */
    public Optional<Integer> bufSize() {
        return Optional.ofNullable(this.bufSize);
    }
    /**
     * @return Includes color space metadata in the output.
     * 
     */
    public Optional<String> colorMetadata() {
        return Optional.ofNullable(this.colorMetadata);
    }
    /**
     * @return Define the color metadata for the output. H265 Color Space Settings for more details.
     * 
     */
    public Optional<ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings> colorSpaceSettings() {
        return Optional.ofNullable(this.colorSpaceSettings);
    }
    /**
     * @return Filters to apply to an encode. See H265 Filter Settings for more details.
     * 
     */
    public Optional<ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings> filterSettings() {
        return Optional.ofNullable(this.filterSettings);
    }
    /**
     * @return Four bit AFD value to write on all frames of video in the output stream.
     * 
     */
    public Optional<String> fixedAfd() {
        return Optional.ofNullable(this.fixedAfd);
    }
    public Optional<String> flickerAq() {
        return Optional.ofNullable(this.flickerAq);
    }
    /**
     * @return Framerate denominator.
     * 
     */
    public Integer framerateDenominator() {
        return this.framerateDenominator;
    }
    /**
     * @return Framerate numerator.
     * 
     */
    public Integer framerateNumerator() {
        return this.framerateNumerator;
    }
    /**
     * @return Frequency of closed GOPs.
     * 
     */
    public Optional<Integer> gopClosedCadence() {
        return Optional.ofNullable(this.gopClosedCadence);
    }
    /**
     * @return GOP size in units of either frames of seconds per `gop_size_units`.
     * 
     */
    public Optional<Double> gopSize() {
        return Optional.ofNullable(this.gopSize);
    }
    /**
     * @return Indicates if the `gop_size` is specified in frames or seconds.
     * 
     */
    public Optional<String> gopSizeUnits() {
        return Optional.ofNullable(this.gopSizeUnits);
    }
    /**
     * @return H265 level.
     * 
     */
    public Optional<String> level() {
        return Optional.ofNullable(this.level);
    }
    /**
     * @return Amount of lookahead.
     * 
     */
    public Optional<String> lookAheadRateControl() {
        return Optional.ofNullable(this.lookAheadRateControl);
    }
    /**
     * @return Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
     * 
     */
    public Optional<Integer> maxBitrate() {
        return Optional.ofNullable(this.maxBitrate);
    }
    public Optional<Integer> minIInterval() {
        return Optional.ofNullable(this.minIInterval);
    }
    /**
     * @return Pixel Aspect Ratio denominator.
     * 
     */
    public Optional<Integer> parDenominator() {
        return Optional.ofNullable(this.parDenominator);
    }
    /**
     * @return Pixel Aspect Ratio numerator.
     * 
     */
    public Optional<Integer> parNumerator() {
        return Optional.ofNullable(this.parNumerator);
    }
    /**
     * @return AAC profile.
     * 
     */
    public Optional<String> profile() {
        return Optional.ofNullable(this.profile);
    }
    /**
     * @return Controls the target quality for the video encode.
     * 
     */
    public Optional<Integer> qvbrQualityLevel() {
        return Optional.ofNullable(this.qvbrQualityLevel);
    }
    /**
     * @return The rate control mode.
     * 
     */
    public Optional<String> rateControlMode() {
        return Optional.ofNullable(this.rateControlMode);
    }
    /**
     * @return Sets the scan type of the output.
     * 
     */
    public Optional<String> scanType() {
        return Optional.ofNullable(this.scanType);
    }
    /**
     * @return Scene change detection.
     * 
     */
    public Optional<String> sceneChangeDetect() {
        return Optional.ofNullable(this.sceneChangeDetect);
    }
    /**
     * @return Number of slices per picture.
     * 
     */
    public Optional<Integer> slices() {
        return Optional.ofNullable(this.slices);
    }
    /**
     * @return Set the H265 tier in the output.
     * 
     */
    public Optional<String> tier() {
        return Optional.ofNullable(this.tier);
    }
    /**
     * @return Apply a burned in timecode. See H265 Timecode Burnin Settings for more details.
     * 
     */
    public Optional<ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings> timecodeBurninSettings() {
        return Optional.ofNullable(this.timecodeBurninSettings);
    }
    /**
     * @return Determines how timecodes should be inserted into the video elementary stream.
     * 
     */
    public Optional<String> timecodeInsertion() {
        return Optional.ofNullable(this.timecodeInsertion);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable String adaptiveQuantization;
        private @Nullable String afdSignaling;
        private @Nullable String alternativeTransferFunction;
        private Integer bitrate;
        private @Nullable Integer bufSize;
        private @Nullable String colorMetadata;
        private @Nullable ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings colorSpaceSettings;
        private @Nullable ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings filterSettings;
        private @Nullable String fixedAfd;
        private @Nullable String flickerAq;
        private Integer framerateDenominator;
        private Integer framerateNumerator;
        private @Nullable Integer gopClosedCadence;
        private @Nullable Double gopSize;
        private @Nullable String gopSizeUnits;
        private @Nullable String level;
        private @Nullable String lookAheadRateControl;
        private @Nullable Integer maxBitrate;
        private @Nullable Integer minIInterval;
        private @Nullable Integer parDenominator;
        private @Nullable Integer parNumerator;
        private @Nullable String profile;
        private @Nullable Integer qvbrQualityLevel;
        private @Nullable String rateControlMode;
        private @Nullable String scanType;
        private @Nullable String sceneChangeDetect;
        private @Nullable Integer slices;
        private @Nullable String tier;
        private @Nullable ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings timecodeBurninSettings;
        private @Nullable String timecodeInsertion;
        public Builder() {}
        public Builder(ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.adaptiveQuantization = defaults.adaptiveQuantization;
    	      this.afdSignaling = defaults.afdSignaling;
    	      this.alternativeTransferFunction = defaults.alternativeTransferFunction;
    	      this.bitrate = defaults.bitrate;
    	      this.bufSize = defaults.bufSize;
    	      this.colorMetadata = defaults.colorMetadata;
    	      this.colorSpaceSettings = defaults.colorSpaceSettings;
    	      this.filterSettings = defaults.filterSettings;
    	      this.fixedAfd = defaults.fixedAfd;
    	      this.flickerAq = defaults.flickerAq;
    	      this.framerateDenominator = defaults.framerateDenominator;
    	      this.framerateNumerator = defaults.framerateNumerator;
    	      this.gopClosedCadence = defaults.gopClosedCadence;
    	      this.gopSize = defaults.gopSize;
    	      this.gopSizeUnits = defaults.gopSizeUnits;
    	      this.level = defaults.level;
    	      this.lookAheadRateControl = defaults.lookAheadRateControl;
    	      this.maxBitrate = defaults.maxBitrate;
    	      this.minIInterval = defaults.minIInterval;
    	      this.parDenominator = defaults.parDenominator;
    	      this.parNumerator = defaults.parNumerator;
    	      this.profile = defaults.profile;
    	      this.qvbrQualityLevel = defaults.qvbrQualityLevel;
    	      this.rateControlMode = defaults.rateControlMode;
    	      this.scanType = defaults.scanType;
    	      this.sceneChangeDetect = defaults.sceneChangeDetect;
    	      this.slices = defaults.slices;
    	      this.tier = defaults.tier;
    	      this.timecodeBurninSettings = defaults.timecodeBurninSettings;
    	      this.timecodeInsertion = defaults.timecodeInsertion;
        }

        @CustomType.Setter
        public Builder adaptiveQuantization(@Nullable String adaptiveQuantization) {

            this.adaptiveQuantization = adaptiveQuantization;
            return this;
        }
        @CustomType.Setter
        public Builder afdSignaling(@Nullable String afdSignaling) {

            this.afdSignaling = afdSignaling;
            return this;
        }
        @CustomType.Setter
        public Builder alternativeTransferFunction(@Nullable String alternativeTransferFunction) {

            this.alternativeTransferFunction = alternativeTransferFunction;
            return this;
        }
        @CustomType.Setter
        public Builder bitrate(Integer bitrate) {
            if (bitrate == null) {
              throw new MissingRequiredPropertyException("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings", "bitrate");
            }
            this.bitrate = bitrate;
            return this;
        }
        @CustomType.Setter
        public Builder bufSize(@Nullable Integer bufSize) {

            this.bufSize = bufSize;
            return this;
        }
        @CustomType.Setter
        public Builder colorMetadata(@Nullable String colorMetadata) {

            this.colorMetadata = colorMetadata;
            return this;
        }
        @CustomType.Setter
        public Builder colorSpaceSettings(@Nullable ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettings colorSpaceSettings) {

            this.colorSpaceSettings = colorSpaceSettings;
            return this;
        }
        @CustomType.Setter
        public Builder filterSettings(@Nullable ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettings filterSettings) {

            this.filterSettings = filterSettings;
            return this;
        }
        @CustomType.Setter
        public Builder fixedAfd(@Nullable String fixedAfd) {

            this.fixedAfd = fixedAfd;
            return this;
        }
        @CustomType.Setter
        public Builder flickerAq(@Nullable String flickerAq) {

            this.flickerAq = flickerAq;
            return this;
        }
        @CustomType.Setter
        public Builder framerateDenominator(Integer framerateDenominator) {
            if (framerateDenominator == null) {
              throw new MissingRequiredPropertyException("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings", "framerateDenominator");
            }
            this.framerateDenominator = framerateDenominator;
            return this;
        }
        @CustomType.Setter
        public Builder framerateNumerator(Integer framerateNumerator) {
            if (framerateNumerator == null) {
              throw new MissingRequiredPropertyException("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings", "framerateNumerator");
            }
            this.framerateNumerator = framerateNumerator;
            return this;
        }
        @CustomType.Setter
        public Builder gopClosedCadence(@Nullable Integer gopClosedCadence) {

            this.gopClosedCadence = gopClosedCadence;
            return this;
        }
        @CustomType.Setter
        public Builder gopSize(@Nullable Double gopSize) {

            this.gopSize = gopSize;
            return this;
        }
        @CustomType.Setter
        public Builder gopSizeUnits(@Nullable String gopSizeUnits) {

            this.gopSizeUnits = gopSizeUnits;
            return this;
        }
        @CustomType.Setter
        public Builder level(@Nullable String level) {

            this.level = level;
            return this;
        }
        @CustomType.Setter
        public Builder lookAheadRateControl(@Nullable String lookAheadRateControl) {

            this.lookAheadRateControl = lookAheadRateControl;
            return this;
        }
        @CustomType.Setter
        public Builder maxBitrate(@Nullable Integer maxBitrate) {

            this.maxBitrate = maxBitrate;
            return this;
        }
        @CustomType.Setter
        public Builder minIInterval(@Nullable Integer minIInterval) {

            this.minIInterval = minIInterval;
            return this;
        }
        @CustomType.Setter
        public Builder parDenominator(@Nullable Integer parDenominator) {

            this.parDenominator = parDenominator;
            return this;
        }
        @CustomType.Setter
        public Builder parNumerator(@Nullable Integer parNumerator) {

            this.parNumerator = parNumerator;
            return this;
        }
        @CustomType.Setter
        public Builder profile(@Nullable String profile) {

            this.profile = profile;
            return this;
        }
        @CustomType.Setter
        public Builder qvbrQualityLevel(@Nullable Integer qvbrQualityLevel) {

            this.qvbrQualityLevel = qvbrQualityLevel;
            return this;
        }
        @CustomType.Setter
        public Builder rateControlMode(@Nullable String rateControlMode) {

            this.rateControlMode = rateControlMode;
            return this;
        }
        @CustomType.Setter
        public Builder scanType(@Nullable String scanType) {

            this.scanType = scanType;
            return this;
        }
        @CustomType.Setter
        public Builder sceneChangeDetect(@Nullable String sceneChangeDetect) {

            this.sceneChangeDetect = sceneChangeDetect;
            return this;
        }
        @CustomType.Setter
        public Builder slices(@Nullable Integer slices) {

            this.slices = slices;
            return this;
        }
        @CustomType.Setter
        public Builder tier(@Nullable String tier) {

            this.tier = tier;
            return this;
        }
        @CustomType.Setter
        public Builder timecodeBurninSettings(@Nullable ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettings timecodeBurninSettings) {

            this.timecodeBurninSettings = timecodeBurninSettings;
            return this;
        }
        @CustomType.Setter
        public Builder timecodeInsertion(@Nullable String timecodeInsertion) {

            this.timecodeInsertion = timecodeInsertion;
            return this;
        }
        public ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings build() {
            final var _resultValue = new ChannelEncoderSettingsVideoDescriptionCodecSettingsH265Settings();
            _resultValue.adaptiveQuantization = adaptiveQuantization;
            _resultValue.afdSignaling = afdSignaling;
            _resultValue.alternativeTransferFunction = alternativeTransferFunction;
            _resultValue.bitrate = bitrate;
            _resultValue.bufSize = bufSize;
            _resultValue.colorMetadata = colorMetadata;
            _resultValue.colorSpaceSettings = colorSpaceSettings;
            _resultValue.filterSettings = filterSettings;
            _resultValue.fixedAfd = fixedAfd;
            _resultValue.flickerAq = flickerAq;
            _resultValue.framerateDenominator = framerateDenominator;
            _resultValue.framerateNumerator = framerateNumerator;
            _resultValue.gopClosedCadence = gopClosedCadence;
            _resultValue.gopSize = gopSize;
            _resultValue.gopSizeUnits = gopSizeUnits;
            _resultValue.level = level;
            _resultValue.lookAheadRateControl = lookAheadRateControl;
            _resultValue.maxBitrate = maxBitrate;
            _resultValue.minIInterval = minIInterval;
            _resultValue.parDenominator = parDenominator;
            _resultValue.parNumerator = parNumerator;
            _resultValue.profile = profile;
            _resultValue.qvbrQualityLevel = qvbrQualityLevel;
            _resultValue.rateControlMode = rateControlMode;
            _resultValue.scanType = scanType;
            _resultValue.sceneChangeDetect = sceneChangeDetect;
            _resultValue.slices = slices;
            _resultValue.tier = tier;
            _resultValue.timecodeBurninSettings = timecodeBurninSettings;
            _resultValue.timecodeInsertion = timecodeInsertion;
            return _resultValue;
        }
    }
}
