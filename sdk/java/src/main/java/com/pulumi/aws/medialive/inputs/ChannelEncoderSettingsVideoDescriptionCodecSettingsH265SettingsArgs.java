// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aws.medialive.inputs;

import com.pulumi.aws.medialive.inputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsArgs;
import com.pulumi.aws.medialive.inputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsArgs;
import com.pulumi.aws.medialive.inputs.ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettingsArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs extends com.pulumi.resources.ResourceArgs {

    public static final ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs Empty = new ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs();

    /**
     * Enables or disables adaptive quantization.
     * 
     */
    @Import(name="adaptiveQuantization")
    private @Nullable Output<String> adaptiveQuantization;

    /**
     * @return Enables or disables adaptive quantization.
     * 
     */
    public Optional<Output<String>> adaptiveQuantization() {
        return Optional.ofNullable(this.adaptiveQuantization);
    }

    /**
     * Indicates that AFD values will be written into the output stream.
     * 
     */
    @Import(name="afdSignaling")
    private @Nullable Output<String> afdSignaling;

    /**
     * @return Indicates that AFD values will be written into the output stream.
     * 
     */
    public Optional<Output<String>> afdSignaling() {
        return Optional.ofNullable(this.afdSignaling);
    }

    /**
     * Whether or not EML should insert an Alternative Transfer Function SEI message.
     * 
     */
    @Import(name="alternativeTransferFunction")
    private @Nullable Output<String> alternativeTransferFunction;

    /**
     * @return Whether or not EML should insert an Alternative Transfer Function SEI message.
     * 
     */
    public Optional<Output<String>> alternativeTransferFunction() {
        return Optional.ofNullable(this.alternativeTransferFunction);
    }

    /**
     * Average bitrate in bits/second.
     * 
     */
    @Import(name="bitrate", required=true)
    private Output<Integer> bitrate;

    /**
     * @return Average bitrate in bits/second.
     * 
     */
    public Output<Integer> bitrate() {
        return this.bitrate;
    }

    /**
     * Size of buffer in bits.
     * 
     */
    @Import(name="bufSize")
    private @Nullable Output<Integer> bufSize;

    /**
     * @return Size of buffer in bits.
     * 
     */
    public Optional<Output<Integer>> bufSize() {
        return Optional.ofNullable(this.bufSize);
    }

    /**
     * Includes color space metadata in the output.
     * 
     */
    @Import(name="colorMetadata")
    private @Nullable Output<String> colorMetadata;

    /**
     * @return Includes color space metadata in the output.
     * 
     */
    public Optional<Output<String>> colorMetadata() {
        return Optional.ofNullable(this.colorMetadata);
    }

    /**
     * Define the color metadata for the output. H265 Color Space Settings for more details.
     * 
     */
    @Import(name="colorSpaceSettings")
    private @Nullable Output<ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsArgs> colorSpaceSettings;

    /**
     * @return Define the color metadata for the output. H265 Color Space Settings for more details.
     * 
     */
    public Optional<Output<ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsArgs>> colorSpaceSettings() {
        return Optional.ofNullable(this.colorSpaceSettings);
    }

    /**
     * Filters to apply to an encode. See H265 Filter Settings for more details.
     * 
     */
    @Import(name="filterSettings")
    private @Nullable Output<ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsArgs> filterSettings;

    /**
     * @return Filters to apply to an encode. See H265 Filter Settings for more details.
     * 
     */
    public Optional<Output<ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsArgs>> filterSettings() {
        return Optional.ofNullable(this.filterSettings);
    }

    /**
     * Four bit AFD value to write on all frames of video in the output stream.
     * 
     */
    @Import(name="fixedAfd")
    private @Nullable Output<String> fixedAfd;

    /**
     * @return Four bit AFD value to write on all frames of video in the output stream.
     * 
     */
    public Optional<Output<String>> fixedAfd() {
        return Optional.ofNullable(this.fixedAfd);
    }

    @Import(name="flickerAq")
    private @Nullable Output<String> flickerAq;

    public Optional<Output<String>> flickerAq() {
        return Optional.ofNullable(this.flickerAq);
    }

    /**
     * Framerate denominator.
     * 
     */
    @Import(name="framerateDenominator", required=true)
    private Output<Integer> framerateDenominator;

    /**
     * @return Framerate denominator.
     * 
     */
    public Output<Integer> framerateDenominator() {
        return this.framerateDenominator;
    }

    /**
     * Framerate numerator.
     * 
     */
    @Import(name="framerateNumerator", required=true)
    private Output<Integer> framerateNumerator;

    /**
     * @return Framerate numerator.
     * 
     */
    public Output<Integer> framerateNumerator() {
        return this.framerateNumerator;
    }

    /**
     * Frequency of closed GOPs.
     * 
     */
    @Import(name="gopClosedCadence")
    private @Nullable Output<Integer> gopClosedCadence;

    /**
     * @return Frequency of closed GOPs.
     * 
     */
    public Optional<Output<Integer>> gopClosedCadence() {
        return Optional.ofNullable(this.gopClosedCadence);
    }

    /**
     * GOP size in units of either frames of seconds per `gop_size_units`.
     * 
     */
    @Import(name="gopSize")
    private @Nullable Output<Double> gopSize;

    /**
     * @return GOP size in units of either frames of seconds per `gop_size_units`.
     * 
     */
    public Optional<Output<Double>> gopSize() {
        return Optional.ofNullable(this.gopSize);
    }

    /**
     * Indicates if the `gop_size` is specified in frames or seconds.
     * 
     */
    @Import(name="gopSizeUnits")
    private @Nullable Output<String> gopSizeUnits;

    /**
     * @return Indicates if the `gop_size` is specified in frames or seconds.
     * 
     */
    public Optional<Output<String>> gopSizeUnits() {
        return Optional.ofNullable(this.gopSizeUnits);
    }

    /**
     * H265 level.
     * 
     */
    @Import(name="level")
    private @Nullable Output<String> level;

    /**
     * @return H265 level.
     * 
     */
    public Optional<Output<String>> level() {
        return Optional.ofNullable(this.level);
    }

    /**
     * Amount of lookahead.
     * 
     */
    @Import(name="lookAheadRateControl")
    private @Nullable Output<String> lookAheadRateControl;

    /**
     * @return Amount of lookahead.
     * 
     */
    public Optional<Output<String>> lookAheadRateControl() {
        return Optional.ofNullable(this.lookAheadRateControl);
    }

    /**
     * Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
     * 
     */
    @Import(name="maxBitrate")
    private @Nullable Output<Integer> maxBitrate;

    /**
     * @return Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
     * 
     */
    public Optional<Output<Integer>> maxBitrate() {
        return Optional.ofNullable(this.maxBitrate);
    }

    /**
     * Min interval.
     * 
     */
    @Import(name="minIInterval")
    private @Nullable Output<Integer> minIInterval;

    /**
     * @return Min interval.
     * 
     */
    public Optional<Output<Integer>> minIInterval() {
        return Optional.ofNullable(this.minIInterval);
    }

    /**
     * Set the minimum QP.
     * 
     */
    @Import(name="minQp")
    private @Nullable Output<Integer> minQp;

    /**
     * @return Set the minimum QP.
     * 
     */
    public Optional<Output<Integer>> minQp() {
        return Optional.ofNullable(this.minQp);
    }

    /**
     * Enables or disables motion vector over picture boundaries.
     * 
     */
    @Import(name="mvOverPictureBoundaries")
    private @Nullable Output<String> mvOverPictureBoundaries;

    /**
     * @return Enables or disables motion vector over picture boundaries.
     * 
     */
    public Optional<Output<String>> mvOverPictureBoundaries() {
        return Optional.ofNullable(this.mvOverPictureBoundaries);
    }

    /**
     * Enables or disables the motion vector temporal predictor.
     * 
     */
    @Import(name="mvTemporalPredictor")
    private @Nullable Output<String> mvTemporalPredictor;

    /**
     * @return Enables or disables the motion vector temporal predictor.
     * 
     */
    public Optional<Output<String>> mvTemporalPredictor() {
        return Optional.ofNullable(this.mvTemporalPredictor);
    }

    /**
     * Pixel Aspect Ratio denominator.
     * 
     */
    @Import(name="parDenominator")
    private @Nullable Output<Integer> parDenominator;

    /**
     * @return Pixel Aspect Ratio denominator.
     * 
     */
    public Optional<Output<Integer>> parDenominator() {
        return Optional.ofNullable(this.parDenominator);
    }

    /**
     * Pixel Aspect Ratio numerator.
     * 
     */
    @Import(name="parNumerator")
    private @Nullable Output<Integer> parNumerator;

    /**
     * @return Pixel Aspect Ratio numerator.
     * 
     */
    public Optional<Output<Integer>> parNumerator() {
        return Optional.ofNullable(this.parNumerator);
    }

    /**
     * H265 profile.
     * 
     */
    @Import(name="profile")
    private @Nullable Output<String> profile;

    /**
     * @return H265 profile.
     * 
     */
    public Optional<Output<String>> profile() {
        return Optional.ofNullable(this.profile);
    }

    /**
     * Controls the target quality for the video encode.
     * 
     */
    @Import(name="qvbrQualityLevel")
    private @Nullable Output<Integer> qvbrQualityLevel;

    /**
     * @return Controls the target quality for the video encode.
     * 
     */
    public Optional<Output<Integer>> qvbrQualityLevel() {
        return Optional.ofNullable(this.qvbrQualityLevel);
    }

    /**
     * Rate control mode.
     * 
     */
    @Import(name="rateControlMode")
    private @Nullable Output<String> rateControlMode;

    /**
     * @return Rate control mode.
     * 
     */
    public Optional<Output<String>> rateControlMode() {
        return Optional.ofNullable(this.rateControlMode);
    }

    /**
     * Sets the scan type of the output.
     * 
     */
    @Import(name="scanType")
    private @Nullable Output<String> scanType;

    /**
     * @return Sets the scan type of the output.
     * 
     */
    public Optional<Output<String>> scanType() {
        return Optional.ofNullable(this.scanType);
    }

    /**
     * Scene change detection.
     * 
     */
    @Import(name="sceneChangeDetect")
    private @Nullable Output<String> sceneChangeDetect;

    /**
     * @return Scene change detection.
     * 
     */
    public Optional<Output<String>> sceneChangeDetect() {
        return Optional.ofNullable(this.sceneChangeDetect);
    }

    /**
     * Number of slices per picture.
     * 
     */
    @Import(name="slices")
    private @Nullable Output<Integer> slices;

    /**
     * @return Number of slices per picture.
     * 
     */
    public Optional<Output<Integer>> slices() {
        return Optional.ofNullable(this.slices);
    }

    /**
     * Set the H265 tier in the output.
     * 
     */
    @Import(name="tier")
    private @Nullable Output<String> tier;

    /**
     * @return Set the H265 tier in the output.
     * 
     */
    public Optional<Output<String>> tier() {
        return Optional.ofNullable(this.tier);
    }

    /**
     * Sets the height of tiles.
     * 
     */
    @Import(name="tileHeight")
    private @Nullable Output<Integer> tileHeight;

    /**
     * @return Sets the height of tiles.
     * 
     */
    public Optional<Output<Integer>> tileHeight() {
        return Optional.ofNullable(this.tileHeight);
    }

    /**
     * Enables or disables padding of tiles.
     * 
     */
    @Import(name="tilePadding")
    private @Nullable Output<String> tilePadding;

    /**
     * @return Enables or disables padding of tiles.
     * 
     */
    public Optional<Output<String>> tilePadding() {
        return Optional.ofNullable(this.tilePadding);
    }

    /**
     * Sets the width of tiles.
     * 
     */
    @Import(name="tileWidth")
    private @Nullable Output<Integer> tileWidth;

    /**
     * @return Sets the width of tiles.
     * 
     */
    public Optional<Output<Integer>> tileWidth() {
        return Optional.ofNullable(this.tileWidth);
    }

    /**
     * Apply a burned in timecode. See H265 Timecode Burnin Settings for more details.
     * 
     */
    @Import(name="timecodeBurninSettings")
    private @Nullable Output<ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettingsArgs> timecodeBurninSettings;

    /**
     * @return Apply a burned in timecode. See H265 Timecode Burnin Settings for more details.
     * 
     */
    public Optional<Output<ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettingsArgs>> timecodeBurninSettings() {
        return Optional.ofNullable(this.timecodeBurninSettings);
    }

    /**
     * Determines how timecodes should be inserted into the video elementary stream.
     * 
     */
    @Import(name="timecodeInsertion")
    private @Nullable Output<String> timecodeInsertion;

    /**
     * @return Determines how timecodes should be inserted into the video elementary stream.
     * 
     */
    public Optional<Output<String>> timecodeInsertion() {
        return Optional.ofNullable(this.timecodeInsertion);
    }

    /**
     * Sets the size of the treeblock.
     * 
     */
    @Import(name="treeblockSize")
    private @Nullable Output<String> treeblockSize;

    /**
     * @return Sets the size of the treeblock.
     * 
     */
    public Optional<Output<String>> treeblockSize() {
        return Optional.ofNullable(this.treeblockSize);
    }

    private ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs() {}

    private ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs(ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs $) {
        this.adaptiveQuantization = $.adaptiveQuantization;
        this.afdSignaling = $.afdSignaling;
        this.alternativeTransferFunction = $.alternativeTransferFunction;
        this.bitrate = $.bitrate;
        this.bufSize = $.bufSize;
        this.colorMetadata = $.colorMetadata;
        this.colorSpaceSettings = $.colorSpaceSettings;
        this.filterSettings = $.filterSettings;
        this.fixedAfd = $.fixedAfd;
        this.flickerAq = $.flickerAq;
        this.framerateDenominator = $.framerateDenominator;
        this.framerateNumerator = $.framerateNumerator;
        this.gopClosedCadence = $.gopClosedCadence;
        this.gopSize = $.gopSize;
        this.gopSizeUnits = $.gopSizeUnits;
        this.level = $.level;
        this.lookAheadRateControl = $.lookAheadRateControl;
        this.maxBitrate = $.maxBitrate;
        this.minIInterval = $.minIInterval;
        this.minQp = $.minQp;
        this.mvOverPictureBoundaries = $.mvOverPictureBoundaries;
        this.mvTemporalPredictor = $.mvTemporalPredictor;
        this.parDenominator = $.parDenominator;
        this.parNumerator = $.parNumerator;
        this.profile = $.profile;
        this.qvbrQualityLevel = $.qvbrQualityLevel;
        this.rateControlMode = $.rateControlMode;
        this.scanType = $.scanType;
        this.sceneChangeDetect = $.sceneChangeDetect;
        this.slices = $.slices;
        this.tier = $.tier;
        this.tileHeight = $.tileHeight;
        this.tilePadding = $.tilePadding;
        this.tileWidth = $.tileWidth;
        this.timecodeBurninSettings = $.timecodeBurninSettings;
        this.timecodeInsertion = $.timecodeInsertion;
        this.treeblockSize = $.treeblockSize;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs $;

        public Builder() {
            $ = new ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs();
        }

        public Builder(ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs defaults) {
            $ = new ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param adaptiveQuantization Enables or disables adaptive quantization.
         * 
         * @return builder
         * 
         */
        public Builder adaptiveQuantization(@Nullable Output<String> adaptiveQuantization) {
            $.adaptiveQuantization = adaptiveQuantization;
            return this;
        }

        /**
         * @param adaptiveQuantization Enables or disables adaptive quantization.
         * 
         * @return builder
         * 
         */
        public Builder adaptiveQuantization(String adaptiveQuantization) {
            return adaptiveQuantization(Output.of(adaptiveQuantization));
        }

        /**
         * @param afdSignaling Indicates that AFD values will be written into the output stream.
         * 
         * @return builder
         * 
         */
        public Builder afdSignaling(@Nullable Output<String> afdSignaling) {
            $.afdSignaling = afdSignaling;
            return this;
        }

        /**
         * @param afdSignaling Indicates that AFD values will be written into the output stream.
         * 
         * @return builder
         * 
         */
        public Builder afdSignaling(String afdSignaling) {
            return afdSignaling(Output.of(afdSignaling));
        }

        /**
         * @param alternativeTransferFunction Whether or not EML should insert an Alternative Transfer Function SEI message.
         * 
         * @return builder
         * 
         */
        public Builder alternativeTransferFunction(@Nullable Output<String> alternativeTransferFunction) {
            $.alternativeTransferFunction = alternativeTransferFunction;
            return this;
        }

        /**
         * @param alternativeTransferFunction Whether or not EML should insert an Alternative Transfer Function SEI message.
         * 
         * @return builder
         * 
         */
        public Builder alternativeTransferFunction(String alternativeTransferFunction) {
            return alternativeTransferFunction(Output.of(alternativeTransferFunction));
        }

        /**
         * @param bitrate Average bitrate in bits/second.
         * 
         * @return builder
         * 
         */
        public Builder bitrate(Output<Integer> bitrate) {
            $.bitrate = bitrate;
            return this;
        }

        /**
         * @param bitrate Average bitrate in bits/second.
         * 
         * @return builder
         * 
         */
        public Builder bitrate(Integer bitrate) {
            return bitrate(Output.of(bitrate));
        }

        /**
         * @param bufSize Size of buffer in bits.
         * 
         * @return builder
         * 
         */
        public Builder bufSize(@Nullable Output<Integer> bufSize) {
            $.bufSize = bufSize;
            return this;
        }

        /**
         * @param bufSize Size of buffer in bits.
         * 
         * @return builder
         * 
         */
        public Builder bufSize(Integer bufSize) {
            return bufSize(Output.of(bufSize));
        }

        /**
         * @param colorMetadata Includes color space metadata in the output.
         * 
         * @return builder
         * 
         */
        public Builder colorMetadata(@Nullable Output<String> colorMetadata) {
            $.colorMetadata = colorMetadata;
            return this;
        }

        /**
         * @param colorMetadata Includes color space metadata in the output.
         * 
         * @return builder
         * 
         */
        public Builder colorMetadata(String colorMetadata) {
            return colorMetadata(Output.of(colorMetadata));
        }

        /**
         * @param colorSpaceSettings Define the color metadata for the output. H265 Color Space Settings for more details.
         * 
         * @return builder
         * 
         */
        public Builder colorSpaceSettings(@Nullable Output<ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsArgs> colorSpaceSettings) {
            $.colorSpaceSettings = colorSpaceSettings;
            return this;
        }

        /**
         * @param colorSpaceSettings Define the color metadata for the output. H265 Color Space Settings for more details.
         * 
         * @return builder
         * 
         */
        public Builder colorSpaceSettings(ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsColorSpaceSettingsArgs colorSpaceSettings) {
            return colorSpaceSettings(Output.of(colorSpaceSettings));
        }

        /**
         * @param filterSettings Filters to apply to an encode. See H265 Filter Settings for more details.
         * 
         * @return builder
         * 
         */
        public Builder filterSettings(@Nullable Output<ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsArgs> filterSettings) {
            $.filterSettings = filterSettings;
            return this;
        }

        /**
         * @param filterSettings Filters to apply to an encode. See H265 Filter Settings for more details.
         * 
         * @return builder
         * 
         */
        public Builder filterSettings(ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsFilterSettingsArgs filterSettings) {
            return filterSettings(Output.of(filterSettings));
        }

        /**
         * @param fixedAfd Four bit AFD value to write on all frames of video in the output stream.
         * 
         * @return builder
         * 
         */
        public Builder fixedAfd(@Nullable Output<String> fixedAfd) {
            $.fixedAfd = fixedAfd;
            return this;
        }

        /**
         * @param fixedAfd Four bit AFD value to write on all frames of video in the output stream.
         * 
         * @return builder
         * 
         */
        public Builder fixedAfd(String fixedAfd) {
            return fixedAfd(Output.of(fixedAfd));
        }

        public Builder flickerAq(@Nullable Output<String> flickerAq) {
            $.flickerAq = flickerAq;
            return this;
        }

        public Builder flickerAq(String flickerAq) {
            return flickerAq(Output.of(flickerAq));
        }

        /**
         * @param framerateDenominator Framerate denominator.
         * 
         * @return builder
         * 
         */
        public Builder framerateDenominator(Output<Integer> framerateDenominator) {
            $.framerateDenominator = framerateDenominator;
            return this;
        }

        /**
         * @param framerateDenominator Framerate denominator.
         * 
         * @return builder
         * 
         */
        public Builder framerateDenominator(Integer framerateDenominator) {
            return framerateDenominator(Output.of(framerateDenominator));
        }

        /**
         * @param framerateNumerator Framerate numerator.
         * 
         * @return builder
         * 
         */
        public Builder framerateNumerator(Output<Integer> framerateNumerator) {
            $.framerateNumerator = framerateNumerator;
            return this;
        }

        /**
         * @param framerateNumerator Framerate numerator.
         * 
         * @return builder
         * 
         */
        public Builder framerateNumerator(Integer framerateNumerator) {
            return framerateNumerator(Output.of(framerateNumerator));
        }

        /**
         * @param gopClosedCadence Frequency of closed GOPs.
         * 
         * @return builder
         * 
         */
        public Builder gopClosedCadence(@Nullable Output<Integer> gopClosedCadence) {
            $.gopClosedCadence = gopClosedCadence;
            return this;
        }

        /**
         * @param gopClosedCadence Frequency of closed GOPs.
         * 
         * @return builder
         * 
         */
        public Builder gopClosedCadence(Integer gopClosedCadence) {
            return gopClosedCadence(Output.of(gopClosedCadence));
        }

        /**
         * @param gopSize GOP size in units of either frames of seconds per `gop_size_units`.
         * 
         * @return builder
         * 
         */
        public Builder gopSize(@Nullable Output<Double> gopSize) {
            $.gopSize = gopSize;
            return this;
        }

        /**
         * @param gopSize GOP size in units of either frames of seconds per `gop_size_units`.
         * 
         * @return builder
         * 
         */
        public Builder gopSize(Double gopSize) {
            return gopSize(Output.of(gopSize));
        }

        /**
         * @param gopSizeUnits Indicates if the `gop_size` is specified in frames or seconds.
         * 
         * @return builder
         * 
         */
        public Builder gopSizeUnits(@Nullable Output<String> gopSizeUnits) {
            $.gopSizeUnits = gopSizeUnits;
            return this;
        }

        /**
         * @param gopSizeUnits Indicates if the `gop_size` is specified in frames or seconds.
         * 
         * @return builder
         * 
         */
        public Builder gopSizeUnits(String gopSizeUnits) {
            return gopSizeUnits(Output.of(gopSizeUnits));
        }

        /**
         * @param level H265 level.
         * 
         * @return builder
         * 
         */
        public Builder level(@Nullable Output<String> level) {
            $.level = level;
            return this;
        }

        /**
         * @param level H265 level.
         * 
         * @return builder
         * 
         */
        public Builder level(String level) {
            return level(Output.of(level));
        }

        /**
         * @param lookAheadRateControl Amount of lookahead.
         * 
         * @return builder
         * 
         */
        public Builder lookAheadRateControl(@Nullable Output<String> lookAheadRateControl) {
            $.lookAheadRateControl = lookAheadRateControl;
            return this;
        }

        /**
         * @param lookAheadRateControl Amount of lookahead.
         * 
         * @return builder
         * 
         */
        public Builder lookAheadRateControl(String lookAheadRateControl) {
            return lookAheadRateControl(Output.of(lookAheadRateControl));
        }

        /**
         * @param maxBitrate Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
         * 
         * @return builder
         * 
         */
        public Builder maxBitrate(@Nullable Output<Integer> maxBitrate) {
            $.maxBitrate = maxBitrate;
            return this;
        }

        /**
         * @param maxBitrate Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video.
         * 
         * @return builder
         * 
         */
        public Builder maxBitrate(Integer maxBitrate) {
            return maxBitrate(Output.of(maxBitrate));
        }

        /**
         * @param minIInterval Min interval.
         * 
         * @return builder
         * 
         */
        public Builder minIInterval(@Nullable Output<Integer> minIInterval) {
            $.minIInterval = minIInterval;
            return this;
        }

        /**
         * @param minIInterval Min interval.
         * 
         * @return builder
         * 
         */
        public Builder minIInterval(Integer minIInterval) {
            return minIInterval(Output.of(minIInterval));
        }

        /**
         * @param minQp Set the minimum QP.
         * 
         * @return builder
         * 
         */
        public Builder minQp(@Nullable Output<Integer> minQp) {
            $.minQp = minQp;
            return this;
        }

        /**
         * @param minQp Set the minimum QP.
         * 
         * @return builder
         * 
         */
        public Builder minQp(Integer minQp) {
            return minQp(Output.of(minQp));
        }

        /**
         * @param mvOverPictureBoundaries Enables or disables motion vector over picture boundaries.
         * 
         * @return builder
         * 
         */
        public Builder mvOverPictureBoundaries(@Nullable Output<String> mvOverPictureBoundaries) {
            $.mvOverPictureBoundaries = mvOverPictureBoundaries;
            return this;
        }

        /**
         * @param mvOverPictureBoundaries Enables or disables motion vector over picture boundaries.
         * 
         * @return builder
         * 
         */
        public Builder mvOverPictureBoundaries(String mvOverPictureBoundaries) {
            return mvOverPictureBoundaries(Output.of(mvOverPictureBoundaries));
        }

        /**
         * @param mvTemporalPredictor Enables or disables the motion vector temporal predictor.
         * 
         * @return builder
         * 
         */
        public Builder mvTemporalPredictor(@Nullable Output<String> mvTemporalPredictor) {
            $.mvTemporalPredictor = mvTemporalPredictor;
            return this;
        }

        /**
         * @param mvTemporalPredictor Enables or disables the motion vector temporal predictor.
         * 
         * @return builder
         * 
         */
        public Builder mvTemporalPredictor(String mvTemporalPredictor) {
            return mvTemporalPredictor(Output.of(mvTemporalPredictor));
        }

        /**
         * @param parDenominator Pixel Aspect Ratio denominator.
         * 
         * @return builder
         * 
         */
        public Builder parDenominator(@Nullable Output<Integer> parDenominator) {
            $.parDenominator = parDenominator;
            return this;
        }

        /**
         * @param parDenominator Pixel Aspect Ratio denominator.
         * 
         * @return builder
         * 
         */
        public Builder parDenominator(Integer parDenominator) {
            return parDenominator(Output.of(parDenominator));
        }

        /**
         * @param parNumerator Pixel Aspect Ratio numerator.
         * 
         * @return builder
         * 
         */
        public Builder parNumerator(@Nullable Output<Integer> parNumerator) {
            $.parNumerator = parNumerator;
            return this;
        }

        /**
         * @param parNumerator Pixel Aspect Ratio numerator.
         * 
         * @return builder
         * 
         */
        public Builder parNumerator(Integer parNumerator) {
            return parNumerator(Output.of(parNumerator));
        }

        /**
         * @param profile H265 profile.
         * 
         * @return builder
         * 
         */
        public Builder profile(@Nullable Output<String> profile) {
            $.profile = profile;
            return this;
        }

        /**
         * @param profile H265 profile.
         * 
         * @return builder
         * 
         */
        public Builder profile(String profile) {
            return profile(Output.of(profile));
        }

        /**
         * @param qvbrQualityLevel Controls the target quality for the video encode.
         * 
         * @return builder
         * 
         */
        public Builder qvbrQualityLevel(@Nullable Output<Integer> qvbrQualityLevel) {
            $.qvbrQualityLevel = qvbrQualityLevel;
            return this;
        }

        /**
         * @param qvbrQualityLevel Controls the target quality for the video encode.
         * 
         * @return builder
         * 
         */
        public Builder qvbrQualityLevel(Integer qvbrQualityLevel) {
            return qvbrQualityLevel(Output.of(qvbrQualityLevel));
        }

        /**
         * @param rateControlMode Rate control mode.
         * 
         * @return builder
         * 
         */
        public Builder rateControlMode(@Nullable Output<String> rateControlMode) {
            $.rateControlMode = rateControlMode;
            return this;
        }

        /**
         * @param rateControlMode Rate control mode.
         * 
         * @return builder
         * 
         */
        public Builder rateControlMode(String rateControlMode) {
            return rateControlMode(Output.of(rateControlMode));
        }

        /**
         * @param scanType Sets the scan type of the output.
         * 
         * @return builder
         * 
         */
        public Builder scanType(@Nullable Output<String> scanType) {
            $.scanType = scanType;
            return this;
        }

        /**
         * @param scanType Sets the scan type of the output.
         * 
         * @return builder
         * 
         */
        public Builder scanType(String scanType) {
            return scanType(Output.of(scanType));
        }

        /**
         * @param sceneChangeDetect Scene change detection.
         * 
         * @return builder
         * 
         */
        public Builder sceneChangeDetect(@Nullable Output<String> sceneChangeDetect) {
            $.sceneChangeDetect = sceneChangeDetect;
            return this;
        }

        /**
         * @param sceneChangeDetect Scene change detection.
         * 
         * @return builder
         * 
         */
        public Builder sceneChangeDetect(String sceneChangeDetect) {
            return sceneChangeDetect(Output.of(sceneChangeDetect));
        }

        /**
         * @param slices Number of slices per picture.
         * 
         * @return builder
         * 
         */
        public Builder slices(@Nullable Output<Integer> slices) {
            $.slices = slices;
            return this;
        }

        /**
         * @param slices Number of slices per picture.
         * 
         * @return builder
         * 
         */
        public Builder slices(Integer slices) {
            return slices(Output.of(slices));
        }

        /**
         * @param tier Set the H265 tier in the output.
         * 
         * @return builder
         * 
         */
        public Builder tier(@Nullable Output<String> tier) {
            $.tier = tier;
            return this;
        }

        /**
         * @param tier Set the H265 tier in the output.
         * 
         * @return builder
         * 
         */
        public Builder tier(String tier) {
            return tier(Output.of(tier));
        }

        /**
         * @param tileHeight Sets the height of tiles.
         * 
         * @return builder
         * 
         */
        public Builder tileHeight(@Nullable Output<Integer> tileHeight) {
            $.tileHeight = tileHeight;
            return this;
        }

        /**
         * @param tileHeight Sets the height of tiles.
         * 
         * @return builder
         * 
         */
        public Builder tileHeight(Integer tileHeight) {
            return tileHeight(Output.of(tileHeight));
        }

        /**
         * @param tilePadding Enables or disables padding of tiles.
         * 
         * @return builder
         * 
         */
        public Builder tilePadding(@Nullable Output<String> tilePadding) {
            $.tilePadding = tilePadding;
            return this;
        }

        /**
         * @param tilePadding Enables or disables padding of tiles.
         * 
         * @return builder
         * 
         */
        public Builder tilePadding(String tilePadding) {
            return tilePadding(Output.of(tilePadding));
        }

        /**
         * @param tileWidth Sets the width of tiles.
         * 
         * @return builder
         * 
         */
        public Builder tileWidth(@Nullable Output<Integer> tileWidth) {
            $.tileWidth = tileWidth;
            return this;
        }

        /**
         * @param tileWidth Sets the width of tiles.
         * 
         * @return builder
         * 
         */
        public Builder tileWidth(Integer tileWidth) {
            return tileWidth(Output.of(tileWidth));
        }

        /**
         * @param timecodeBurninSettings Apply a burned in timecode. See H265 Timecode Burnin Settings for more details.
         * 
         * @return builder
         * 
         */
        public Builder timecodeBurninSettings(@Nullable Output<ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettingsArgs> timecodeBurninSettings) {
            $.timecodeBurninSettings = timecodeBurninSettings;
            return this;
        }

        /**
         * @param timecodeBurninSettings Apply a burned in timecode. See H265 Timecode Burnin Settings for more details.
         * 
         * @return builder
         * 
         */
        public Builder timecodeBurninSettings(ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsTimecodeBurninSettingsArgs timecodeBurninSettings) {
            return timecodeBurninSettings(Output.of(timecodeBurninSettings));
        }

        /**
         * @param timecodeInsertion Determines how timecodes should be inserted into the video elementary stream.
         * 
         * @return builder
         * 
         */
        public Builder timecodeInsertion(@Nullable Output<String> timecodeInsertion) {
            $.timecodeInsertion = timecodeInsertion;
            return this;
        }

        /**
         * @param timecodeInsertion Determines how timecodes should be inserted into the video elementary stream.
         * 
         * @return builder
         * 
         */
        public Builder timecodeInsertion(String timecodeInsertion) {
            return timecodeInsertion(Output.of(timecodeInsertion));
        }

        /**
         * @param treeblockSize Sets the size of the treeblock.
         * 
         * @return builder
         * 
         */
        public Builder treeblockSize(@Nullable Output<String> treeblockSize) {
            $.treeblockSize = treeblockSize;
            return this;
        }

        /**
         * @param treeblockSize Sets the size of the treeblock.
         * 
         * @return builder
         * 
         */
        public Builder treeblockSize(String treeblockSize) {
            return treeblockSize(Output.of(treeblockSize));
        }

        public ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs build() {
            if ($.bitrate == null) {
                throw new MissingRequiredPropertyException("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs", "bitrate");
            }
            if ($.framerateDenominator == null) {
                throw new MissingRequiredPropertyException("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs", "framerateDenominator");
            }
            if ($.framerateNumerator == null) {
                throw new MissingRequiredPropertyException("ChannelEncoderSettingsVideoDescriptionCodecSettingsH265SettingsArgs", "framerateNumerator");
            }
            return $;
        }
    }

}
