// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aws.lambda.inputs;

import com.pulumi.aws.lambda.inputs.EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs;
import com.pulumi.aws.lambda.inputs.EventSourceMappingDestinationConfigArgs;
import com.pulumi.aws.lambda.inputs.EventSourceMappingFilterCriteriaArgs;
import com.pulumi.aws.lambda.inputs.EventSourceMappingSelfManagedEventSourceArgs;
import com.pulumi.aws.lambda.inputs.EventSourceMappingSelfManagedKafkaEventSourceConfigArgs;
import com.pulumi.aws.lambda.inputs.EventSourceMappingSourceAccessConfigurationArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class EventSourceMappingState extends com.pulumi.resources.ResourceArgs {

    public static final EventSourceMappingState Empty = new EventSourceMappingState();

    /**
     * Additional configuration block for Amazon Managed Kafka sources. Incompatible with &#34;self_managed_event_source&#34; and &#34;self_managed_kafka_event_source_config&#34;. Detailed below.
     * 
     */
    @Import(name="amazonManagedKafkaEventSourceConfig")
    private @Nullable Output<EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs> amazonManagedKafkaEventSourceConfig;

    /**
     * @return Additional configuration block for Amazon Managed Kafka sources. Incompatible with &#34;self_managed_event_source&#34; and &#34;self_managed_kafka_event_source_config&#34;. Detailed below.
     * 
     */
    public Optional<Output<EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs>> amazonManagedKafkaEventSourceConfig() {
        return Optional.ofNullable(this.amazonManagedKafkaEventSourceConfig);
    }

    /**
     * The largest number of records that Lambda will retrieve from your event source at the time of invocation. Defaults to `100` for DynamoDB, Kinesis, MQ and MSK, `10` for SQS.
     * * `bisect_batch_on_function_error`: - (Optional) If the function returns an error, split the batch in two and retry. Only available for stream sources (DynamoDB and Kinesis). Defaults to `false`.
     * * `destination_config`: - (Optional) An Amazon SQS queue or Amazon SNS topic destination for failed records. Only available for stream sources (DynamoDB and Kinesis). Detailed below.
     * 
     */
    @Import(name="batchSize")
    private @Nullable Output<Integer> batchSize;

    /**
     * @return The largest number of records that Lambda will retrieve from your event source at the time of invocation. Defaults to `100` for DynamoDB, Kinesis, MQ and MSK, `10` for SQS.
     * * `bisect_batch_on_function_error`: - (Optional) If the function returns an error, split the batch in two and retry. Only available for stream sources (DynamoDB and Kinesis). Defaults to `false`.
     * * `destination_config`: - (Optional) An Amazon SQS queue or Amazon SNS topic destination for failed records. Only available for stream sources (DynamoDB and Kinesis). Detailed below.
     * 
     */
    public Optional<Output<Integer>> batchSize() {
        return Optional.ofNullable(this.batchSize);
    }

    @Import(name="bisectBatchOnFunctionError")
    private @Nullable Output<Boolean> bisectBatchOnFunctionError;

    public Optional<Output<Boolean>> bisectBatchOnFunctionError() {
        return Optional.ofNullable(this.bisectBatchOnFunctionError);
    }

    @Import(name="destinationConfig")
    private @Nullable Output<EventSourceMappingDestinationConfigArgs> destinationConfig;

    public Optional<Output<EventSourceMappingDestinationConfigArgs>> destinationConfig() {
        return Optional.ofNullable(this.destinationConfig);
    }

    /**
     * Determines if the mapping will be enabled on creation. Defaults to `true`.
     * 
     */
    @Import(name="enabled")
    private @Nullable Output<Boolean> enabled;

    /**
     * @return Determines if the mapping will be enabled on creation. Defaults to `true`.
     * 
     */
    public Optional<Output<Boolean>> enabled() {
        return Optional.ofNullable(this.enabled);
    }

    /**
     * The event source ARN - this is required for Kinesis stream, DynamoDB stream, SQS queue, MQ broker or MSK cluster.  It is incompatible with a Self Managed Kafka source.
     * 
     */
    @Import(name="eventSourceArn")
    private @Nullable Output<String> eventSourceArn;

    /**
     * @return The event source ARN - this is required for Kinesis stream, DynamoDB stream, SQS queue, MQ broker or MSK cluster.  It is incompatible with a Self Managed Kafka source.
     * 
     */
    public Optional<Output<String>> eventSourceArn() {
        return Optional.ofNullable(this.eventSourceArn);
    }

    /**
     * The criteria to use for [event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html) Kinesis stream, DynamoDB stream, SQS queue event sources. Detailed below.
     * 
     */
    @Import(name="filterCriteria")
    private @Nullable Output<EventSourceMappingFilterCriteriaArgs> filterCriteria;

    /**
     * @return The criteria to use for [event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html) Kinesis stream, DynamoDB stream, SQS queue event sources. Detailed below.
     * 
     */
    public Optional<Output<EventSourceMappingFilterCriteriaArgs>> filterCriteria() {
        return Optional.ofNullable(this.filterCriteria);
    }

    /**
     * The the ARN of the Lambda function the event source mapping is sending events to. (Note: this is a computed value that differs from `function_name` above.)
     * 
     */
    @Import(name="functionArn")
    private @Nullable Output<String> functionArn;

    /**
     * @return The the ARN of the Lambda function the event source mapping is sending events to. (Note: this is a computed value that differs from `function_name` above.)
     * 
     */
    public Optional<Output<String>> functionArn() {
        return Optional.ofNullable(this.functionArn);
    }

    /**
     * The name or the ARN of the Lambda function that will be subscribing to events.
     * 
     */
    @Import(name="functionName")
    private @Nullable Output<String> functionName;

    /**
     * @return The name or the ARN of the Lambda function that will be subscribing to events.
     * 
     */
    public Optional<Output<String>> functionName() {
        return Optional.ofNullable(this.functionName);
    }

    /**
     * A list of current response type enums applied to the event source mapping for [AWS Lambda checkpointing](https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html#services-ddb-batchfailurereporting). Only available for SQS and stream sources (DynamoDB and Kinesis). Valid values: `ReportBatchItemFailures`.
     * 
     */
    @Import(name="functionResponseTypes")
    private @Nullable Output<List<String>> functionResponseTypes;

    /**
     * @return A list of current response type enums applied to the event source mapping for [AWS Lambda checkpointing](https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html#services-ddb-batchfailurereporting). Only available for SQS and stream sources (DynamoDB and Kinesis). Valid values: `ReportBatchItemFailures`.
     * 
     */
    public Optional<Output<List<String>>> functionResponseTypes() {
        return Optional.ofNullable(this.functionResponseTypes);
    }

    /**
     * The date this resource was last modified.
     * 
     */
    @Import(name="lastModified")
    private @Nullable Output<String> lastModified;

    /**
     * @return The date this resource was last modified.
     * 
     */
    public Optional<Output<String>> lastModified() {
        return Optional.ofNullable(this.lastModified);
    }

    /**
     * The result of the last AWS Lambda invocation of your Lambda function.
     * 
     */
    @Import(name="lastProcessingResult")
    private @Nullable Output<String> lastProcessingResult;

    /**
     * @return The result of the last AWS Lambda invocation of your Lambda function.
     * 
     */
    public Optional<Output<String>> lastProcessingResult() {
        return Optional.ofNullable(this.lastProcessingResult);
    }

    /**
     * The maximum amount of time to gather records before invoking the function, in seconds (between 0 and 300). Records will continue to buffer (or accumulate in the case of an SQS queue event source) until either `maximum_batching_window_in_seconds` expires or `batch_size` has been met. For streaming event sources, defaults to as soon as records are available in the stream. If the batch it reads from the stream/queue only has one record in it, Lambda only sends one record to the function. Only available for stream sources (DynamoDB and Kinesis) and SQS standard queues.
     * * `maximum_record_age_in_seconds`: - (Optional) The maximum age of a record that Lambda sends to a function for processing. Only available for stream sources (DynamoDB and Kinesis). Must be either -1 (forever, and the default value) or between 60 and 604800 (inclusive).
     * * `maximum_retry_attempts`: - (Optional) The maximum number of times to retry when the function returns an error. Only available for stream sources (DynamoDB and Kinesis). Minimum and default of -1 (forever), maximum of 10000.
     * * `parallelization_factor`: - (Optional) The number of batches to process from each shard concurrently. Only available for stream sources (DynamoDB and Kinesis). Minimum and default of 1, maximum of 10.
     * 
     */
    @Import(name="maximumBatchingWindowInSeconds")
    private @Nullable Output<Integer> maximumBatchingWindowInSeconds;

    /**
     * @return The maximum amount of time to gather records before invoking the function, in seconds (between 0 and 300). Records will continue to buffer (or accumulate in the case of an SQS queue event source) until either `maximum_batching_window_in_seconds` expires or `batch_size` has been met. For streaming event sources, defaults to as soon as records are available in the stream. If the batch it reads from the stream/queue only has one record in it, Lambda only sends one record to the function. Only available for stream sources (DynamoDB and Kinesis) and SQS standard queues.
     * * `maximum_record_age_in_seconds`: - (Optional) The maximum age of a record that Lambda sends to a function for processing. Only available for stream sources (DynamoDB and Kinesis). Must be either -1 (forever, and the default value) or between 60 and 604800 (inclusive).
     * * `maximum_retry_attempts`: - (Optional) The maximum number of times to retry when the function returns an error. Only available for stream sources (DynamoDB and Kinesis). Minimum and default of -1 (forever), maximum of 10000.
     * * `parallelization_factor`: - (Optional) The number of batches to process from each shard concurrently. Only available for stream sources (DynamoDB and Kinesis). Minimum and default of 1, maximum of 10.
     * 
     */
    public Optional<Output<Integer>> maximumBatchingWindowInSeconds() {
        return Optional.ofNullable(this.maximumBatchingWindowInSeconds);
    }

    @Import(name="maximumRecordAgeInSeconds")
    private @Nullable Output<Integer> maximumRecordAgeInSeconds;

    public Optional<Output<Integer>> maximumRecordAgeInSeconds() {
        return Optional.ofNullable(this.maximumRecordAgeInSeconds);
    }

    @Import(name="maximumRetryAttempts")
    private @Nullable Output<Integer> maximumRetryAttempts;

    public Optional<Output<Integer>> maximumRetryAttempts() {
        return Optional.ofNullable(this.maximumRetryAttempts);
    }

    @Import(name="parallelizationFactor")
    private @Nullable Output<Integer> parallelizationFactor;

    public Optional<Output<Integer>> parallelizationFactor() {
        return Optional.ofNullable(this.parallelizationFactor);
    }

    /**
     * The name of the Amazon MQ broker destination queue to consume. Only available for MQ sources. A single queue name must be specified.
     * * `self_managed_event_source`: - (Optional) For Self Managed Kafka sources, the location of the self managed cluster. If set, configuration must also include `source_access_configuration`. Detailed below.
     * 
     */
    @Import(name="queues")
    private @Nullable Output<List<String>> queues;

    /**
     * @return The name of the Amazon MQ broker destination queue to consume. Only available for MQ sources. A single queue name must be specified.
     * * `self_managed_event_source`: - (Optional) For Self Managed Kafka sources, the location of the self managed cluster. If set, configuration must also include `source_access_configuration`. Detailed below.
     * 
     */
    public Optional<Output<List<String>>> queues() {
        return Optional.ofNullable(this.queues);
    }

    @Import(name="selfManagedEventSource")
    private @Nullable Output<EventSourceMappingSelfManagedEventSourceArgs> selfManagedEventSource;

    public Optional<Output<EventSourceMappingSelfManagedEventSourceArgs>> selfManagedEventSource() {
        return Optional.ofNullable(this.selfManagedEventSource);
    }

    /**
     * Additional configuration block for Self Managed Kafka sources. Incompatible with &#34;event_source_arn&#34; and &#34;amazon_managed_kafka_event_source_config&#34;. Detailed below.
     * * `source_access_configuration`: (Optional) For Self Managed Kafka sources, the access configuration for the source. If set, configuration must also include `self_managed_event_source`. Detailed below.
     * 
     */
    @Import(name="selfManagedKafkaEventSourceConfig")
    private @Nullable Output<EventSourceMappingSelfManagedKafkaEventSourceConfigArgs> selfManagedKafkaEventSourceConfig;

    /**
     * @return Additional configuration block for Self Managed Kafka sources. Incompatible with &#34;event_source_arn&#34; and &#34;amazon_managed_kafka_event_source_config&#34;. Detailed below.
     * * `source_access_configuration`: (Optional) For Self Managed Kafka sources, the access configuration for the source. If set, configuration must also include `self_managed_event_source`. Detailed below.
     * 
     */
    public Optional<Output<EventSourceMappingSelfManagedKafkaEventSourceConfigArgs>> selfManagedKafkaEventSourceConfig() {
        return Optional.ofNullable(this.selfManagedKafkaEventSourceConfig);
    }

    @Import(name="sourceAccessConfigurations")
    private @Nullable Output<List<EventSourceMappingSourceAccessConfigurationArgs>> sourceAccessConfigurations;

    public Optional<Output<List<EventSourceMappingSourceAccessConfigurationArgs>>> sourceAccessConfigurations() {
        return Optional.ofNullable(this.sourceAccessConfigurations);
    }

    /**
     * The position in the stream where AWS Lambda should start reading. Must be one of `AT_TIMESTAMP` (Kinesis only), `LATEST` or `TRIM_HORIZON` if getting events from Kinesis, DynamoDB or MSK. Must not be provided if getting events from SQS. More information about these positions can be found in the [AWS DynamoDB Streams API Reference](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_streams_GetShardIterator.html) and [AWS Kinesis API Reference](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html#Kinesis-GetShardIterator-request-ShardIteratorType).
     * 
     */
    @Import(name="startingPosition")
    private @Nullable Output<String> startingPosition;

    /**
     * @return The position in the stream where AWS Lambda should start reading. Must be one of `AT_TIMESTAMP` (Kinesis only), `LATEST` or `TRIM_HORIZON` if getting events from Kinesis, DynamoDB or MSK. Must not be provided if getting events from SQS. More information about these positions can be found in the [AWS DynamoDB Streams API Reference](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_streams_GetShardIterator.html) and [AWS Kinesis API Reference](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html#Kinesis-GetShardIterator-request-ShardIteratorType).
     * 
     */
    public Optional<Output<String>> startingPosition() {
        return Optional.ofNullable(this.startingPosition);
    }

    /**
     * A timestamp in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8) of the data record which to start reading when using `starting_position` set to `AT_TIMESTAMP`. If a record with this exact timestamp does not exist, the next later record is chosen. If the timestamp is older than the current trim horizon, the oldest available record is chosen.
     * 
     */
    @Import(name="startingPositionTimestamp")
    private @Nullable Output<String> startingPositionTimestamp;

    /**
     * @return A timestamp in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8) of the data record which to start reading when using `starting_position` set to `AT_TIMESTAMP`. If a record with this exact timestamp does not exist, the next later record is chosen. If the timestamp is older than the current trim horizon, the oldest available record is chosen.
     * 
     */
    public Optional<Output<String>> startingPositionTimestamp() {
        return Optional.ofNullable(this.startingPositionTimestamp);
    }

    /**
     * The state of the event source mapping.
     * 
     */
    @Import(name="state")
    private @Nullable Output<String> state;

    /**
     * @return The state of the event source mapping.
     * 
     */
    public Optional<Output<String>> state() {
        return Optional.ofNullable(this.state);
    }

    /**
     * The reason the event source mapping is in its current state.
     * 
     */
    @Import(name="stateTransitionReason")
    private @Nullable Output<String> stateTransitionReason;

    /**
     * @return The reason the event source mapping is in its current state.
     * 
     */
    public Optional<Output<String>> stateTransitionReason() {
        return Optional.ofNullable(this.stateTransitionReason);
    }

    /**
     * The name of the Kafka topics. Only available for MSK sources. A single topic name must be specified.
     * 
     */
    @Import(name="topics")
    private @Nullable Output<List<String>> topics;

    /**
     * @return The name of the Kafka topics. Only available for MSK sources. A single topic name must be specified.
     * 
     */
    public Optional<Output<List<String>>> topics() {
        return Optional.ofNullable(this.topics);
    }

    /**
     * The duration in seconds of a processing window for [AWS Lambda streaming analytics](https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html#services-kinesis-windows). The range is between 1 second up to 900 seconds. Only available for stream sources (DynamoDB and Kinesis).
     * 
     */
    @Import(name="tumblingWindowInSeconds")
    private @Nullable Output<Integer> tumblingWindowInSeconds;

    /**
     * @return The duration in seconds of a processing window for [AWS Lambda streaming analytics](https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html#services-kinesis-windows). The range is between 1 second up to 900 seconds. Only available for stream sources (DynamoDB and Kinesis).
     * 
     */
    public Optional<Output<Integer>> tumblingWindowInSeconds() {
        return Optional.ofNullable(this.tumblingWindowInSeconds);
    }

    /**
     * The UUID of the created event source mapping.
     * 
     */
    @Import(name="uuid")
    private @Nullable Output<String> uuid;

    /**
     * @return The UUID of the created event source mapping.
     * 
     */
    public Optional<Output<String>> uuid() {
        return Optional.ofNullable(this.uuid);
    }

    private EventSourceMappingState() {}

    private EventSourceMappingState(EventSourceMappingState $) {
        this.amazonManagedKafkaEventSourceConfig = $.amazonManagedKafkaEventSourceConfig;
        this.batchSize = $.batchSize;
        this.bisectBatchOnFunctionError = $.bisectBatchOnFunctionError;
        this.destinationConfig = $.destinationConfig;
        this.enabled = $.enabled;
        this.eventSourceArn = $.eventSourceArn;
        this.filterCriteria = $.filterCriteria;
        this.functionArn = $.functionArn;
        this.functionName = $.functionName;
        this.functionResponseTypes = $.functionResponseTypes;
        this.lastModified = $.lastModified;
        this.lastProcessingResult = $.lastProcessingResult;
        this.maximumBatchingWindowInSeconds = $.maximumBatchingWindowInSeconds;
        this.maximumRecordAgeInSeconds = $.maximumRecordAgeInSeconds;
        this.maximumRetryAttempts = $.maximumRetryAttempts;
        this.parallelizationFactor = $.parallelizationFactor;
        this.queues = $.queues;
        this.selfManagedEventSource = $.selfManagedEventSource;
        this.selfManagedKafkaEventSourceConfig = $.selfManagedKafkaEventSourceConfig;
        this.sourceAccessConfigurations = $.sourceAccessConfigurations;
        this.startingPosition = $.startingPosition;
        this.startingPositionTimestamp = $.startingPositionTimestamp;
        this.state = $.state;
        this.stateTransitionReason = $.stateTransitionReason;
        this.topics = $.topics;
        this.tumblingWindowInSeconds = $.tumblingWindowInSeconds;
        this.uuid = $.uuid;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(EventSourceMappingState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private EventSourceMappingState $;

        public Builder() {
            $ = new EventSourceMappingState();
        }

        public Builder(EventSourceMappingState defaults) {
            $ = new EventSourceMappingState(Objects.requireNonNull(defaults));
        }

        /**
         * @param amazonManagedKafkaEventSourceConfig Additional configuration block for Amazon Managed Kafka sources. Incompatible with &#34;self_managed_event_source&#34; and &#34;self_managed_kafka_event_source_config&#34;. Detailed below.
         * 
         * @return builder
         * 
         */
        public Builder amazonManagedKafkaEventSourceConfig(@Nullable Output<EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs> amazonManagedKafkaEventSourceConfig) {
            $.amazonManagedKafkaEventSourceConfig = amazonManagedKafkaEventSourceConfig;
            return this;
        }

        /**
         * @param amazonManagedKafkaEventSourceConfig Additional configuration block for Amazon Managed Kafka sources. Incompatible with &#34;self_managed_event_source&#34; and &#34;self_managed_kafka_event_source_config&#34;. Detailed below.
         * 
         * @return builder
         * 
         */
        public Builder amazonManagedKafkaEventSourceConfig(EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs amazonManagedKafkaEventSourceConfig) {
            return amazonManagedKafkaEventSourceConfig(Output.of(amazonManagedKafkaEventSourceConfig));
        }

        /**
         * @param batchSize The largest number of records that Lambda will retrieve from your event source at the time of invocation. Defaults to `100` for DynamoDB, Kinesis, MQ and MSK, `10` for SQS.
         * * `bisect_batch_on_function_error`: - (Optional) If the function returns an error, split the batch in two and retry. Only available for stream sources (DynamoDB and Kinesis). Defaults to `false`.
         * * `destination_config`: - (Optional) An Amazon SQS queue or Amazon SNS topic destination for failed records. Only available for stream sources (DynamoDB and Kinesis). Detailed below.
         * 
         * @return builder
         * 
         */
        public Builder batchSize(@Nullable Output<Integer> batchSize) {
            $.batchSize = batchSize;
            return this;
        }

        /**
         * @param batchSize The largest number of records that Lambda will retrieve from your event source at the time of invocation. Defaults to `100` for DynamoDB, Kinesis, MQ and MSK, `10` for SQS.
         * * `bisect_batch_on_function_error`: - (Optional) If the function returns an error, split the batch in two and retry. Only available for stream sources (DynamoDB and Kinesis). Defaults to `false`.
         * * `destination_config`: - (Optional) An Amazon SQS queue or Amazon SNS topic destination for failed records. Only available for stream sources (DynamoDB and Kinesis). Detailed below.
         * 
         * @return builder
         * 
         */
        public Builder batchSize(Integer batchSize) {
            return batchSize(Output.of(batchSize));
        }

        public Builder bisectBatchOnFunctionError(@Nullable Output<Boolean> bisectBatchOnFunctionError) {
            $.bisectBatchOnFunctionError = bisectBatchOnFunctionError;
            return this;
        }

        public Builder bisectBatchOnFunctionError(Boolean bisectBatchOnFunctionError) {
            return bisectBatchOnFunctionError(Output.of(bisectBatchOnFunctionError));
        }

        public Builder destinationConfig(@Nullable Output<EventSourceMappingDestinationConfigArgs> destinationConfig) {
            $.destinationConfig = destinationConfig;
            return this;
        }

        public Builder destinationConfig(EventSourceMappingDestinationConfigArgs destinationConfig) {
            return destinationConfig(Output.of(destinationConfig));
        }

        /**
         * @param enabled Determines if the mapping will be enabled on creation. Defaults to `true`.
         * 
         * @return builder
         * 
         */
        public Builder enabled(@Nullable Output<Boolean> enabled) {
            $.enabled = enabled;
            return this;
        }

        /**
         * @param enabled Determines if the mapping will be enabled on creation. Defaults to `true`.
         * 
         * @return builder
         * 
         */
        public Builder enabled(Boolean enabled) {
            return enabled(Output.of(enabled));
        }

        /**
         * @param eventSourceArn The event source ARN - this is required for Kinesis stream, DynamoDB stream, SQS queue, MQ broker or MSK cluster.  It is incompatible with a Self Managed Kafka source.
         * 
         * @return builder
         * 
         */
        public Builder eventSourceArn(@Nullable Output<String> eventSourceArn) {
            $.eventSourceArn = eventSourceArn;
            return this;
        }

        /**
         * @param eventSourceArn The event source ARN - this is required for Kinesis stream, DynamoDB stream, SQS queue, MQ broker or MSK cluster.  It is incompatible with a Self Managed Kafka source.
         * 
         * @return builder
         * 
         */
        public Builder eventSourceArn(String eventSourceArn) {
            return eventSourceArn(Output.of(eventSourceArn));
        }

        /**
         * @param filterCriteria The criteria to use for [event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html) Kinesis stream, DynamoDB stream, SQS queue event sources. Detailed below.
         * 
         * @return builder
         * 
         */
        public Builder filterCriteria(@Nullable Output<EventSourceMappingFilterCriteriaArgs> filterCriteria) {
            $.filterCriteria = filterCriteria;
            return this;
        }

        /**
         * @param filterCriteria The criteria to use for [event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html) Kinesis stream, DynamoDB stream, SQS queue event sources. Detailed below.
         * 
         * @return builder
         * 
         */
        public Builder filterCriteria(EventSourceMappingFilterCriteriaArgs filterCriteria) {
            return filterCriteria(Output.of(filterCriteria));
        }

        /**
         * @param functionArn The the ARN of the Lambda function the event source mapping is sending events to. (Note: this is a computed value that differs from `function_name` above.)
         * 
         * @return builder
         * 
         */
        public Builder functionArn(@Nullable Output<String> functionArn) {
            $.functionArn = functionArn;
            return this;
        }

        /**
         * @param functionArn The the ARN of the Lambda function the event source mapping is sending events to. (Note: this is a computed value that differs from `function_name` above.)
         * 
         * @return builder
         * 
         */
        public Builder functionArn(String functionArn) {
            return functionArn(Output.of(functionArn));
        }

        /**
         * @param functionName The name or the ARN of the Lambda function that will be subscribing to events.
         * 
         * @return builder
         * 
         */
        public Builder functionName(@Nullable Output<String> functionName) {
            $.functionName = functionName;
            return this;
        }

        /**
         * @param functionName The name or the ARN of the Lambda function that will be subscribing to events.
         * 
         * @return builder
         * 
         */
        public Builder functionName(String functionName) {
            return functionName(Output.of(functionName));
        }

        /**
         * @param functionResponseTypes A list of current response type enums applied to the event source mapping for [AWS Lambda checkpointing](https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html#services-ddb-batchfailurereporting). Only available for SQS and stream sources (DynamoDB and Kinesis). Valid values: `ReportBatchItemFailures`.
         * 
         * @return builder
         * 
         */
        public Builder functionResponseTypes(@Nullable Output<List<String>> functionResponseTypes) {
            $.functionResponseTypes = functionResponseTypes;
            return this;
        }

        /**
         * @param functionResponseTypes A list of current response type enums applied to the event source mapping for [AWS Lambda checkpointing](https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html#services-ddb-batchfailurereporting). Only available for SQS and stream sources (DynamoDB and Kinesis). Valid values: `ReportBatchItemFailures`.
         * 
         * @return builder
         * 
         */
        public Builder functionResponseTypes(List<String> functionResponseTypes) {
            return functionResponseTypes(Output.of(functionResponseTypes));
        }

        /**
         * @param functionResponseTypes A list of current response type enums applied to the event source mapping for [AWS Lambda checkpointing](https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html#services-ddb-batchfailurereporting). Only available for SQS and stream sources (DynamoDB and Kinesis). Valid values: `ReportBatchItemFailures`.
         * 
         * @return builder
         * 
         */
        public Builder functionResponseTypes(String... functionResponseTypes) {
            return functionResponseTypes(List.of(functionResponseTypes));
        }

        /**
         * @param lastModified The date this resource was last modified.
         * 
         * @return builder
         * 
         */
        public Builder lastModified(@Nullable Output<String> lastModified) {
            $.lastModified = lastModified;
            return this;
        }

        /**
         * @param lastModified The date this resource was last modified.
         * 
         * @return builder
         * 
         */
        public Builder lastModified(String lastModified) {
            return lastModified(Output.of(lastModified));
        }

        /**
         * @param lastProcessingResult The result of the last AWS Lambda invocation of your Lambda function.
         * 
         * @return builder
         * 
         */
        public Builder lastProcessingResult(@Nullable Output<String> lastProcessingResult) {
            $.lastProcessingResult = lastProcessingResult;
            return this;
        }

        /**
         * @param lastProcessingResult The result of the last AWS Lambda invocation of your Lambda function.
         * 
         * @return builder
         * 
         */
        public Builder lastProcessingResult(String lastProcessingResult) {
            return lastProcessingResult(Output.of(lastProcessingResult));
        }

        /**
         * @param maximumBatchingWindowInSeconds The maximum amount of time to gather records before invoking the function, in seconds (between 0 and 300). Records will continue to buffer (or accumulate in the case of an SQS queue event source) until either `maximum_batching_window_in_seconds` expires or `batch_size` has been met. For streaming event sources, defaults to as soon as records are available in the stream. If the batch it reads from the stream/queue only has one record in it, Lambda only sends one record to the function. Only available for stream sources (DynamoDB and Kinesis) and SQS standard queues.
         * * `maximum_record_age_in_seconds`: - (Optional) The maximum age of a record that Lambda sends to a function for processing. Only available for stream sources (DynamoDB and Kinesis). Must be either -1 (forever, and the default value) or between 60 and 604800 (inclusive).
         * * `maximum_retry_attempts`: - (Optional) The maximum number of times to retry when the function returns an error. Only available for stream sources (DynamoDB and Kinesis). Minimum and default of -1 (forever), maximum of 10000.
         * * `parallelization_factor`: - (Optional) The number of batches to process from each shard concurrently. Only available for stream sources (DynamoDB and Kinesis). Minimum and default of 1, maximum of 10.
         * 
         * @return builder
         * 
         */
        public Builder maximumBatchingWindowInSeconds(@Nullable Output<Integer> maximumBatchingWindowInSeconds) {
            $.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds;
            return this;
        }

        /**
         * @param maximumBatchingWindowInSeconds The maximum amount of time to gather records before invoking the function, in seconds (between 0 and 300). Records will continue to buffer (or accumulate in the case of an SQS queue event source) until either `maximum_batching_window_in_seconds` expires or `batch_size` has been met. For streaming event sources, defaults to as soon as records are available in the stream. If the batch it reads from the stream/queue only has one record in it, Lambda only sends one record to the function. Only available for stream sources (DynamoDB and Kinesis) and SQS standard queues.
         * * `maximum_record_age_in_seconds`: - (Optional) The maximum age of a record that Lambda sends to a function for processing. Only available for stream sources (DynamoDB and Kinesis). Must be either -1 (forever, and the default value) or between 60 and 604800 (inclusive).
         * * `maximum_retry_attempts`: - (Optional) The maximum number of times to retry when the function returns an error. Only available for stream sources (DynamoDB and Kinesis). Minimum and default of -1 (forever), maximum of 10000.
         * * `parallelization_factor`: - (Optional) The number of batches to process from each shard concurrently. Only available for stream sources (DynamoDB and Kinesis). Minimum and default of 1, maximum of 10.
         * 
         * @return builder
         * 
         */
        public Builder maximumBatchingWindowInSeconds(Integer maximumBatchingWindowInSeconds) {
            return maximumBatchingWindowInSeconds(Output.of(maximumBatchingWindowInSeconds));
        }

        public Builder maximumRecordAgeInSeconds(@Nullable Output<Integer> maximumRecordAgeInSeconds) {
            $.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds;
            return this;
        }

        public Builder maximumRecordAgeInSeconds(Integer maximumRecordAgeInSeconds) {
            return maximumRecordAgeInSeconds(Output.of(maximumRecordAgeInSeconds));
        }

        public Builder maximumRetryAttempts(@Nullable Output<Integer> maximumRetryAttempts) {
            $.maximumRetryAttempts = maximumRetryAttempts;
            return this;
        }

        public Builder maximumRetryAttempts(Integer maximumRetryAttempts) {
            return maximumRetryAttempts(Output.of(maximumRetryAttempts));
        }

        public Builder parallelizationFactor(@Nullable Output<Integer> parallelizationFactor) {
            $.parallelizationFactor = parallelizationFactor;
            return this;
        }

        public Builder parallelizationFactor(Integer parallelizationFactor) {
            return parallelizationFactor(Output.of(parallelizationFactor));
        }

        /**
         * @param queues The name of the Amazon MQ broker destination queue to consume. Only available for MQ sources. A single queue name must be specified.
         * * `self_managed_event_source`: - (Optional) For Self Managed Kafka sources, the location of the self managed cluster. If set, configuration must also include `source_access_configuration`. Detailed below.
         * 
         * @return builder
         * 
         */
        public Builder queues(@Nullable Output<List<String>> queues) {
            $.queues = queues;
            return this;
        }

        /**
         * @param queues The name of the Amazon MQ broker destination queue to consume. Only available for MQ sources. A single queue name must be specified.
         * * `self_managed_event_source`: - (Optional) For Self Managed Kafka sources, the location of the self managed cluster. If set, configuration must also include `source_access_configuration`. Detailed below.
         * 
         * @return builder
         * 
         */
        public Builder queues(List<String> queues) {
            return queues(Output.of(queues));
        }

        /**
         * @param queues The name of the Amazon MQ broker destination queue to consume. Only available for MQ sources. A single queue name must be specified.
         * * `self_managed_event_source`: - (Optional) For Self Managed Kafka sources, the location of the self managed cluster. If set, configuration must also include `source_access_configuration`. Detailed below.
         * 
         * @return builder
         * 
         */
        public Builder queues(String... queues) {
            return queues(List.of(queues));
        }

        public Builder selfManagedEventSource(@Nullable Output<EventSourceMappingSelfManagedEventSourceArgs> selfManagedEventSource) {
            $.selfManagedEventSource = selfManagedEventSource;
            return this;
        }

        public Builder selfManagedEventSource(EventSourceMappingSelfManagedEventSourceArgs selfManagedEventSource) {
            return selfManagedEventSource(Output.of(selfManagedEventSource));
        }

        /**
         * @param selfManagedKafkaEventSourceConfig Additional configuration block for Self Managed Kafka sources. Incompatible with &#34;event_source_arn&#34; and &#34;amazon_managed_kafka_event_source_config&#34;. Detailed below.
         * * `source_access_configuration`: (Optional) For Self Managed Kafka sources, the access configuration for the source. If set, configuration must also include `self_managed_event_source`. Detailed below.
         * 
         * @return builder
         * 
         */
        public Builder selfManagedKafkaEventSourceConfig(@Nullable Output<EventSourceMappingSelfManagedKafkaEventSourceConfigArgs> selfManagedKafkaEventSourceConfig) {
            $.selfManagedKafkaEventSourceConfig = selfManagedKafkaEventSourceConfig;
            return this;
        }

        /**
         * @param selfManagedKafkaEventSourceConfig Additional configuration block for Self Managed Kafka sources. Incompatible with &#34;event_source_arn&#34; and &#34;amazon_managed_kafka_event_source_config&#34;. Detailed below.
         * * `source_access_configuration`: (Optional) For Self Managed Kafka sources, the access configuration for the source. If set, configuration must also include `self_managed_event_source`. Detailed below.
         * 
         * @return builder
         * 
         */
        public Builder selfManagedKafkaEventSourceConfig(EventSourceMappingSelfManagedKafkaEventSourceConfigArgs selfManagedKafkaEventSourceConfig) {
            return selfManagedKafkaEventSourceConfig(Output.of(selfManagedKafkaEventSourceConfig));
        }

        public Builder sourceAccessConfigurations(@Nullable Output<List<EventSourceMappingSourceAccessConfigurationArgs>> sourceAccessConfigurations) {
            $.sourceAccessConfigurations = sourceAccessConfigurations;
            return this;
        }

        public Builder sourceAccessConfigurations(List<EventSourceMappingSourceAccessConfigurationArgs> sourceAccessConfigurations) {
            return sourceAccessConfigurations(Output.of(sourceAccessConfigurations));
        }

        public Builder sourceAccessConfigurations(EventSourceMappingSourceAccessConfigurationArgs... sourceAccessConfigurations) {
            return sourceAccessConfigurations(List.of(sourceAccessConfigurations));
        }

        /**
         * @param startingPosition The position in the stream where AWS Lambda should start reading. Must be one of `AT_TIMESTAMP` (Kinesis only), `LATEST` or `TRIM_HORIZON` if getting events from Kinesis, DynamoDB or MSK. Must not be provided if getting events from SQS. More information about these positions can be found in the [AWS DynamoDB Streams API Reference](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_streams_GetShardIterator.html) and [AWS Kinesis API Reference](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html#Kinesis-GetShardIterator-request-ShardIteratorType).
         * 
         * @return builder
         * 
         */
        public Builder startingPosition(@Nullable Output<String> startingPosition) {
            $.startingPosition = startingPosition;
            return this;
        }

        /**
         * @param startingPosition The position in the stream where AWS Lambda should start reading. Must be one of `AT_TIMESTAMP` (Kinesis only), `LATEST` or `TRIM_HORIZON` if getting events from Kinesis, DynamoDB or MSK. Must not be provided if getting events from SQS. More information about these positions can be found in the [AWS DynamoDB Streams API Reference](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_streams_GetShardIterator.html) and [AWS Kinesis API Reference](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html#Kinesis-GetShardIterator-request-ShardIteratorType).
         * 
         * @return builder
         * 
         */
        public Builder startingPosition(String startingPosition) {
            return startingPosition(Output.of(startingPosition));
        }

        /**
         * @param startingPositionTimestamp A timestamp in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8) of the data record which to start reading when using `starting_position` set to `AT_TIMESTAMP`. If a record with this exact timestamp does not exist, the next later record is chosen. If the timestamp is older than the current trim horizon, the oldest available record is chosen.
         * 
         * @return builder
         * 
         */
        public Builder startingPositionTimestamp(@Nullable Output<String> startingPositionTimestamp) {
            $.startingPositionTimestamp = startingPositionTimestamp;
            return this;
        }

        /**
         * @param startingPositionTimestamp A timestamp in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8) of the data record which to start reading when using `starting_position` set to `AT_TIMESTAMP`. If a record with this exact timestamp does not exist, the next later record is chosen. If the timestamp is older than the current trim horizon, the oldest available record is chosen.
         * 
         * @return builder
         * 
         */
        public Builder startingPositionTimestamp(String startingPositionTimestamp) {
            return startingPositionTimestamp(Output.of(startingPositionTimestamp));
        }

        /**
         * @param state The state of the event source mapping.
         * 
         * @return builder
         * 
         */
        public Builder state(@Nullable Output<String> state) {
            $.state = state;
            return this;
        }

        /**
         * @param state The state of the event source mapping.
         * 
         * @return builder
         * 
         */
        public Builder state(String state) {
            return state(Output.of(state));
        }

        /**
         * @param stateTransitionReason The reason the event source mapping is in its current state.
         * 
         * @return builder
         * 
         */
        public Builder stateTransitionReason(@Nullable Output<String> stateTransitionReason) {
            $.stateTransitionReason = stateTransitionReason;
            return this;
        }

        /**
         * @param stateTransitionReason The reason the event source mapping is in its current state.
         * 
         * @return builder
         * 
         */
        public Builder stateTransitionReason(String stateTransitionReason) {
            return stateTransitionReason(Output.of(stateTransitionReason));
        }

        /**
         * @param topics The name of the Kafka topics. Only available for MSK sources. A single topic name must be specified.
         * 
         * @return builder
         * 
         */
        public Builder topics(@Nullable Output<List<String>> topics) {
            $.topics = topics;
            return this;
        }

        /**
         * @param topics The name of the Kafka topics. Only available for MSK sources. A single topic name must be specified.
         * 
         * @return builder
         * 
         */
        public Builder topics(List<String> topics) {
            return topics(Output.of(topics));
        }

        /**
         * @param topics The name of the Kafka topics. Only available for MSK sources. A single topic name must be specified.
         * 
         * @return builder
         * 
         */
        public Builder topics(String... topics) {
            return topics(List.of(topics));
        }

        /**
         * @param tumblingWindowInSeconds The duration in seconds of a processing window for [AWS Lambda streaming analytics](https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html#services-kinesis-windows). The range is between 1 second up to 900 seconds. Only available for stream sources (DynamoDB and Kinesis).
         * 
         * @return builder
         * 
         */
        public Builder tumblingWindowInSeconds(@Nullable Output<Integer> tumblingWindowInSeconds) {
            $.tumblingWindowInSeconds = tumblingWindowInSeconds;
            return this;
        }

        /**
         * @param tumblingWindowInSeconds The duration in seconds of a processing window for [AWS Lambda streaming analytics](https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html#services-kinesis-windows). The range is between 1 second up to 900 seconds. Only available for stream sources (DynamoDB and Kinesis).
         * 
         * @return builder
         * 
         */
        public Builder tumblingWindowInSeconds(Integer tumblingWindowInSeconds) {
            return tumblingWindowInSeconds(Output.of(tumblingWindowInSeconds));
        }

        /**
         * @param uuid The UUID of the created event source mapping.
         * 
         * @return builder
         * 
         */
        public Builder uuid(@Nullable Output<String> uuid) {
            $.uuid = uuid;
            return this;
        }

        /**
         * @param uuid The UUID of the created event source mapping.
         * 
         * @return builder
         * 
         */
        public Builder uuid(String uuid) {
            return uuid(Output.of(uuid));
        }

        public EventSourceMappingState build() {
            return $;
        }
    }

}
