// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aws.finspace.inputs;

import com.pulumi.aws.finspace.inputs.KxDataviewSegmentConfigurationArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class KxDataviewState extends com.pulumi.resources.ResourceArgs {

    public static final KxDataviewState Empty = new KxDataviewState();

    /**
     * Amazon Resource Name (ARN) identifier of the KX dataview.
     * 
     */
    @Import(name="arn")
    private @Nullable Output<String> arn;

    /**
     * @return Amazon Resource Name (ARN) identifier of the KX dataview.
     * 
     */
    public Optional<Output<String>> arn() {
        return Optional.ofNullable(this.arn);
    }

    /**
     * The option to specify whether you want to apply all the future additions and corrections automatically to the dataview, when you ingest new changesets. The default value is false.
     * 
     */
    @Import(name="autoUpdate")
    private @Nullable Output<Boolean> autoUpdate;

    /**
     * @return The option to specify whether you want to apply all the future additions and corrections automatically to the dataview, when you ingest new changesets. The default value is false.
     * 
     */
    public Optional<Output<Boolean>> autoUpdate() {
        return Optional.ofNullable(this.autoUpdate);
    }

    /**
     * The identifier of the availability zones. If attaching a volume, the volume must be in the same availability zone as the dataview that you are attaching to.
     * 
     */
    @Import(name="availabilityZoneId")
    private @Nullable Output<String> availabilityZoneId;

    /**
     * @return The identifier of the availability zones. If attaching a volume, the volume must be in the same availability zone as the dataview that you are attaching to.
     * 
     */
    public Optional<Output<String>> availabilityZoneId() {
        return Optional.ofNullable(this.availabilityZoneId);
    }

    /**
     * The number of availability zones you want to assign per cluster. This can be one of the following:
     * * `SINGLE` - Assigns one availability zone per cluster.
     * * `MULTI` - Assigns all the availability zones per cluster.
     * 
     */
    @Import(name="azMode")
    private @Nullable Output<String> azMode;

    /**
     * @return The number of availability zones you want to assign per cluster. This can be one of the following:
     * * `SINGLE` - Assigns one availability zone per cluster.
     * * `MULTI` - Assigns all the availability zones per cluster.
     * 
     */
    public Optional<Output<String>> azMode() {
        return Optional.ofNullable(this.azMode);
    }

    /**
     * A unique identifier of the changeset of the database that you want to use to ingest data.
     * 
     */
    @Import(name="changesetId")
    private @Nullable Output<String> changesetId;

    /**
     * @return A unique identifier of the changeset of the database that you want to use to ingest data.
     * 
     */
    public Optional<Output<String>> changesetId() {
        return Optional.ofNullable(this.changesetId);
    }

    /**
     * Timestamp at which the dataview was created in FinSpace. Value determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
     * 
     */
    @Import(name="createdTimestamp")
    private @Nullable Output<String> createdTimestamp;

    /**
     * @return Timestamp at which the dataview was created in FinSpace. Value determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
     * 
     */
    public Optional<Output<String>> createdTimestamp() {
        return Optional.ofNullable(this.createdTimestamp);
    }

    /**
     * The name of the database where you want to create a dataview.
     * 
     */
    @Import(name="databaseName")
    private @Nullable Output<String> databaseName;

    /**
     * @return The name of the database where you want to create a dataview.
     * 
     */
    public Optional<Output<String>> databaseName() {
        return Optional.ofNullable(this.databaseName);
    }

    /**
     * A description for the dataview.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return A description for the dataview.
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Unique identifier for the KX environment.
     * 
     */
    @Import(name="environmentId")
    private @Nullable Output<String> environmentId;

    /**
     * @return Unique identifier for the KX environment.
     * 
     */
    public Optional<Output<String>> environmentId() {
        return Optional.ofNullable(this.environmentId);
    }

    /**
     * The last time that the dataview was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
     * 
     */
    @Import(name="lastModifiedTimestamp")
    private @Nullable Output<String> lastModifiedTimestamp;

    /**
     * @return The last time that the dataview was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
     * 
     */
    public Optional<Output<String>> lastModifiedTimestamp() {
        return Optional.ofNullable(this.lastModifiedTimestamp);
    }

    /**
     * A unique identifier for the dataview.
     * 
     * The following arguments are optional:
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return A unique identifier for the dataview.
     * 
     * The following arguments are optional:
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * The option to specify whether you want to make the dataview writable to perform database maintenance. The following are some considerations related to writable dataviews.
     * * You cannot create partial writable dataviews. When you create writeable dataviews you must provide the entire database path. You cannot perform updates on a writeable dataview. Hence, `auto_update` must be set as `false` if `read_write` is `true` for a dataview.
     * * You must also use a unique volume for creating a writeable dataview. So, if you choose a volume that is already in use by another dataview, the dataview creation fails.
     * * Once you create a dataview as writeable, you cannot change it to read-only. So, you cannot update the `read_write` parameter later.
     * 
     */
    @Import(name="readWrite")
    private @Nullable Output<Boolean> readWrite;

    /**
     * @return The option to specify whether you want to make the dataview writable to perform database maintenance. The following are some considerations related to writable dataviews.
     * * You cannot create partial writable dataviews. When you create writeable dataviews you must provide the entire database path. You cannot perform updates on a writeable dataview. Hence, `auto_update` must be set as `false` if `read_write` is `true` for a dataview.
     * * You must also use a unique volume for creating a writeable dataview. So, if you choose a volume that is already in use by another dataview, the dataview creation fails.
     * * Once you create a dataview as writeable, you cannot change it to read-only. So, you cannot update the `read_write` parameter later.
     * 
     */
    public Optional<Output<Boolean>> readWrite() {
        return Optional.ofNullable(this.readWrite);
    }

    /**
     * The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment. See segment_configurations below.
     * 
     */
    @Import(name="segmentConfigurations")
    private @Nullable Output<List<KxDataviewSegmentConfigurationArgs>> segmentConfigurations;

    /**
     * @return The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment. See segment_configurations below.
     * 
     */
    public Optional<Output<List<KxDataviewSegmentConfigurationArgs>>> segmentConfigurations() {
        return Optional.ofNullable(this.segmentConfigurations);
    }

    @Import(name="status")
    private @Nullable Output<String> status;

    public Optional<Output<String>> status() {
        return Optional.ofNullable(this.status);
    }

    /**
     * Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<Map<String,String>> tags;

    /**
     * @return Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    public Optional<Output<Map<String,String>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    /**
     * Map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
     * 
     */
    @Import(name="tagsAll")
    private @Nullable Output<Map<String,String>> tagsAll;

    /**
     * @return Map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
     * 
     */
    public Optional<Output<Map<String,String>>> tagsAll() {
        return Optional.ofNullable(this.tagsAll);
    }

    private KxDataviewState() {}

    private KxDataviewState(KxDataviewState $) {
        this.arn = $.arn;
        this.autoUpdate = $.autoUpdate;
        this.availabilityZoneId = $.availabilityZoneId;
        this.azMode = $.azMode;
        this.changesetId = $.changesetId;
        this.createdTimestamp = $.createdTimestamp;
        this.databaseName = $.databaseName;
        this.description = $.description;
        this.environmentId = $.environmentId;
        this.lastModifiedTimestamp = $.lastModifiedTimestamp;
        this.name = $.name;
        this.readWrite = $.readWrite;
        this.segmentConfigurations = $.segmentConfigurations;
        this.status = $.status;
        this.tags = $.tags;
        this.tagsAll = $.tagsAll;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(KxDataviewState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private KxDataviewState $;

        public Builder() {
            $ = new KxDataviewState();
        }

        public Builder(KxDataviewState defaults) {
            $ = new KxDataviewState(Objects.requireNonNull(defaults));
        }

        /**
         * @param arn Amazon Resource Name (ARN) identifier of the KX dataview.
         * 
         * @return builder
         * 
         */
        public Builder arn(@Nullable Output<String> arn) {
            $.arn = arn;
            return this;
        }

        /**
         * @param arn Amazon Resource Name (ARN) identifier of the KX dataview.
         * 
         * @return builder
         * 
         */
        public Builder arn(String arn) {
            return arn(Output.of(arn));
        }

        /**
         * @param autoUpdate The option to specify whether you want to apply all the future additions and corrections automatically to the dataview, when you ingest new changesets. The default value is false.
         * 
         * @return builder
         * 
         */
        public Builder autoUpdate(@Nullable Output<Boolean> autoUpdate) {
            $.autoUpdate = autoUpdate;
            return this;
        }

        /**
         * @param autoUpdate The option to specify whether you want to apply all the future additions and corrections automatically to the dataview, when you ingest new changesets. The default value is false.
         * 
         * @return builder
         * 
         */
        public Builder autoUpdate(Boolean autoUpdate) {
            return autoUpdate(Output.of(autoUpdate));
        }

        /**
         * @param availabilityZoneId The identifier of the availability zones. If attaching a volume, the volume must be in the same availability zone as the dataview that you are attaching to.
         * 
         * @return builder
         * 
         */
        public Builder availabilityZoneId(@Nullable Output<String> availabilityZoneId) {
            $.availabilityZoneId = availabilityZoneId;
            return this;
        }

        /**
         * @param availabilityZoneId The identifier of the availability zones. If attaching a volume, the volume must be in the same availability zone as the dataview that you are attaching to.
         * 
         * @return builder
         * 
         */
        public Builder availabilityZoneId(String availabilityZoneId) {
            return availabilityZoneId(Output.of(availabilityZoneId));
        }

        /**
         * @param azMode The number of availability zones you want to assign per cluster. This can be one of the following:
         * * `SINGLE` - Assigns one availability zone per cluster.
         * * `MULTI` - Assigns all the availability zones per cluster.
         * 
         * @return builder
         * 
         */
        public Builder azMode(@Nullable Output<String> azMode) {
            $.azMode = azMode;
            return this;
        }

        /**
         * @param azMode The number of availability zones you want to assign per cluster. This can be one of the following:
         * * `SINGLE` - Assigns one availability zone per cluster.
         * * `MULTI` - Assigns all the availability zones per cluster.
         * 
         * @return builder
         * 
         */
        public Builder azMode(String azMode) {
            return azMode(Output.of(azMode));
        }

        /**
         * @param changesetId A unique identifier of the changeset of the database that you want to use to ingest data.
         * 
         * @return builder
         * 
         */
        public Builder changesetId(@Nullable Output<String> changesetId) {
            $.changesetId = changesetId;
            return this;
        }

        /**
         * @param changesetId A unique identifier of the changeset of the database that you want to use to ingest data.
         * 
         * @return builder
         * 
         */
        public Builder changesetId(String changesetId) {
            return changesetId(Output.of(changesetId));
        }

        /**
         * @param createdTimestamp Timestamp at which the dataview was created in FinSpace. Value determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
         * 
         * @return builder
         * 
         */
        public Builder createdTimestamp(@Nullable Output<String> createdTimestamp) {
            $.createdTimestamp = createdTimestamp;
            return this;
        }

        /**
         * @param createdTimestamp Timestamp at which the dataview was created in FinSpace. Value determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
         * 
         * @return builder
         * 
         */
        public Builder createdTimestamp(String createdTimestamp) {
            return createdTimestamp(Output.of(createdTimestamp));
        }

        /**
         * @param databaseName The name of the database where you want to create a dataview.
         * 
         * @return builder
         * 
         */
        public Builder databaseName(@Nullable Output<String> databaseName) {
            $.databaseName = databaseName;
            return this;
        }

        /**
         * @param databaseName The name of the database where you want to create a dataview.
         * 
         * @return builder
         * 
         */
        public Builder databaseName(String databaseName) {
            return databaseName(Output.of(databaseName));
        }

        /**
         * @param description A description for the dataview.
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description A description for the dataview.
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param environmentId Unique identifier for the KX environment.
         * 
         * @return builder
         * 
         */
        public Builder environmentId(@Nullable Output<String> environmentId) {
            $.environmentId = environmentId;
            return this;
        }

        /**
         * @param environmentId Unique identifier for the KX environment.
         * 
         * @return builder
         * 
         */
        public Builder environmentId(String environmentId) {
            return environmentId(Output.of(environmentId));
        }

        /**
         * @param lastModifiedTimestamp The last time that the dataview was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
         * 
         * @return builder
         * 
         */
        public Builder lastModifiedTimestamp(@Nullable Output<String> lastModifiedTimestamp) {
            $.lastModifiedTimestamp = lastModifiedTimestamp;
            return this;
        }

        /**
         * @param lastModifiedTimestamp The last time that the dataview was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
         * 
         * @return builder
         * 
         */
        public Builder lastModifiedTimestamp(String lastModifiedTimestamp) {
            return lastModifiedTimestamp(Output.of(lastModifiedTimestamp));
        }

        /**
         * @param name A unique identifier for the dataview.
         * 
         * The following arguments are optional:
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name A unique identifier for the dataview.
         * 
         * The following arguments are optional:
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param readWrite The option to specify whether you want to make the dataview writable to perform database maintenance. The following are some considerations related to writable dataviews.
         * * You cannot create partial writable dataviews. When you create writeable dataviews you must provide the entire database path. You cannot perform updates on a writeable dataview. Hence, `auto_update` must be set as `false` if `read_write` is `true` for a dataview.
         * * You must also use a unique volume for creating a writeable dataview. So, if you choose a volume that is already in use by another dataview, the dataview creation fails.
         * * Once you create a dataview as writeable, you cannot change it to read-only. So, you cannot update the `read_write` parameter later.
         * 
         * @return builder
         * 
         */
        public Builder readWrite(@Nullable Output<Boolean> readWrite) {
            $.readWrite = readWrite;
            return this;
        }

        /**
         * @param readWrite The option to specify whether you want to make the dataview writable to perform database maintenance. The following are some considerations related to writable dataviews.
         * * You cannot create partial writable dataviews. When you create writeable dataviews you must provide the entire database path. You cannot perform updates on a writeable dataview. Hence, `auto_update` must be set as `false` if `read_write` is `true` for a dataview.
         * * You must also use a unique volume for creating a writeable dataview. So, if you choose a volume that is already in use by another dataview, the dataview creation fails.
         * * Once you create a dataview as writeable, you cannot change it to read-only. So, you cannot update the `read_write` parameter later.
         * 
         * @return builder
         * 
         */
        public Builder readWrite(Boolean readWrite) {
            return readWrite(Output.of(readWrite));
        }

        /**
         * @param segmentConfigurations The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment. See segment_configurations below.
         * 
         * @return builder
         * 
         */
        public Builder segmentConfigurations(@Nullable Output<List<KxDataviewSegmentConfigurationArgs>> segmentConfigurations) {
            $.segmentConfigurations = segmentConfigurations;
            return this;
        }

        /**
         * @param segmentConfigurations The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment. See segment_configurations below.
         * 
         * @return builder
         * 
         */
        public Builder segmentConfigurations(List<KxDataviewSegmentConfigurationArgs> segmentConfigurations) {
            return segmentConfigurations(Output.of(segmentConfigurations));
        }

        /**
         * @param segmentConfigurations The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment. See segment_configurations below.
         * 
         * @return builder
         * 
         */
        public Builder segmentConfigurations(KxDataviewSegmentConfigurationArgs... segmentConfigurations) {
            return segmentConfigurations(List.of(segmentConfigurations));
        }

        public Builder status(@Nullable Output<String> status) {
            $.status = status;
            return this;
        }

        public Builder status(String status) {
            return status(Output.of(status));
        }

        /**
         * @param tags Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable Output<Map<String,String>> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         * 
         * @return builder
         * 
         */
        public Builder tags(Map<String,String> tags) {
            return tags(Output.of(tags));
        }

        /**
         * @param tagsAll Map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
         * 
         * @return builder
         * 
         */
        public Builder tagsAll(@Nullable Output<Map<String,String>> tagsAll) {
            $.tagsAll = tagsAll;
            return this;
        }

        /**
         * @param tagsAll Map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
         * 
         * @return builder
         * 
         */
        public Builder tagsAll(Map<String,String> tagsAll) {
            return tagsAll(Output.of(tagsAll));
        }

        public KxDataviewState build() {
            return $;
        }
    }

}
