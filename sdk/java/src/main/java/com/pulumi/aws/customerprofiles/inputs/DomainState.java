// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aws.customerprofiles.inputs;

import com.pulumi.aws.customerprofiles.inputs.DomainMatchingArgs;
import com.pulumi.aws.customerprofiles.inputs.DomainRuleBasedMatchingArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Integer;
import java.lang.String;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class DomainState extends com.pulumi.resources.ResourceArgs {

    public static final DomainState Empty = new DomainState();

    /**
     * The Amazon Resource Name (ARN) of the Customer Profiles Domain.
     * 
     */
    @Import(name="arn")
    private @Nullable Output<String> arn;

    /**
     * @return The Amazon Resource Name (ARN) of the Customer Profiles Domain.
     * 
     */
    public Optional<Output<String>> arn() {
        return Optional.ofNullable(this.arn);
    }

    /**
     * The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
     * 
     */
    @Import(name="deadLetterQueueUrl")
    private @Nullable Output<String> deadLetterQueueUrl;

    /**
     * @return The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
     * 
     */
    public Optional<Output<String>> deadLetterQueueUrl() {
        return Optional.ofNullable(this.deadLetterQueueUrl);
    }

    /**
     * The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
     * 
     */
    @Import(name="defaultEncryptionKey")
    private @Nullable Output<String> defaultEncryptionKey;

    /**
     * @return The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
     * 
     */
    public Optional<Output<String>> defaultEncryptionKey() {
        return Optional.ofNullable(this.defaultEncryptionKey);
    }

    /**
     * The default number of days until the data within the domain expires.
     * 
     * The following arguments are optional:
     * 
     */
    @Import(name="defaultExpirationDays")
    private @Nullable Output<Integer> defaultExpirationDays;

    /**
     * @return The default number of days until the data within the domain expires.
     * 
     * The following arguments are optional:
     * 
     */
    public Optional<Output<Integer>> defaultExpirationDays() {
        return Optional.ofNullable(this.defaultExpirationDays);
    }

    /**
     * The name for your Customer Profile domain. It must be unique for your AWS account.
     * 
     */
    @Import(name="domainName")
    private @Nullable Output<String> domainName;

    /**
     * @return The name for your Customer Profile domain. It must be unique for your AWS account.
     * 
     */
    public Optional<Output<String>> domainName() {
        return Optional.ofNullable(this.domainName);
    }

    /**
     * A block that specifies the process of matching duplicate profiles. Documented below.
     * 
     */
    @Import(name="matching")
    private @Nullable Output<DomainMatchingArgs> matching;

    /**
     * @return A block that specifies the process of matching duplicate profiles. Documented below.
     * 
     */
    public Optional<Output<DomainMatchingArgs>> matching() {
        return Optional.ofNullable(this.matching);
    }

    /**
     * A block that specifies the process of matching duplicate profiles using the Rule-Based matching. Documented below.
     * 
     */
    @Import(name="ruleBasedMatching")
    private @Nullable Output<DomainRuleBasedMatchingArgs> ruleBasedMatching;

    /**
     * @return A block that specifies the process of matching duplicate profiles using the Rule-Based matching. Documented below.
     * 
     */
    public Optional<Output<DomainRuleBasedMatchingArgs>> ruleBasedMatching() {
        return Optional.ofNullable(this.ruleBasedMatching);
    }

    /**
     * Tags to apply to the domain. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<Map<String,String>> tags;

    /**
     * @return Tags to apply to the domain. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    public Optional<Output<Map<String,String>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    /**
     * A map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
     * 
     */
    @Import(name="tagsAll")
    private @Nullable Output<Map<String,String>> tagsAll;

    /**
     * @return A map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
     * 
     */
    public Optional<Output<Map<String,String>>> tagsAll() {
        return Optional.ofNullable(this.tagsAll);
    }

    private DomainState() {}

    private DomainState(DomainState $) {
        this.arn = $.arn;
        this.deadLetterQueueUrl = $.deadLetterQueueUrl;
        this.defaultEncryptionKey = $.defaultEncryptionKey;
        this.defaultExpirationDays = $.defaultExpirationDays;
        this.domainName = $.domainName;
        this.matching = $.matching;
        this.ruleBasedMatching = $.ruleBasedMatching;
        this.tags = $.tags;
        this.tagsAll = $.tagsAll;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(DomainState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private DomainState $;

        public Builder() {
            $ = new DomainState();
        }

        public Builder(DomainState defaults) {
            $ = new DomainState(Objects.requireNonNull(defaults));
        }

        /**
         * @param arn The Amazon Resource Name (ARN) of the Customer Profiles Domain.
         * 
         * @return builder
         * 
         */
        public Builder arn(@Nullable Output<String> arn) {
            $.arn = arn;
            return this;
        }

        /**
         * @param arn The Amazon Resource Name (ARN) of the Customer Profiles Domain.
         * 
         * @return builder
         * 
         */
        public Builder arn(String arn) {
            return arn(Output.of(arn));
        }

        /**
         * @param deadLetterQueueUrl The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
         * 
         * @return builder
         * 
         */
        public Builder deadLetterQueueUrl(@Nullable Output<String> deadLetterQueueUrl) {
            $.deadLetterQueueUrl = deadLetterQueueUrl;
            return this;
        }

        /**
         * @param deadLetterQueueUrl The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
         * 
         * @return builder
         * 
         */
        public Builder deadLetterQueueUrl(String deadLetterQueueUrl) {
            return deadLetterQueueUrl(Output.of(deadLetterQueueUrl));
        }

        /**
         * @param defaultEncryptionKey The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
         * 
         * @return builder
         * 
         */
        public Builder defaultEncryptionKey(@Nullable Output<String> defaultEncryptionKey) {
            $.defaultEncryptionKey = defaultEncryptionKey;
            return this;
        }

        /**
         * @param defaultEncryptionKey The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
         * 
         * @return builder
         * 
         */
        public Builder defaultEncryptionKey(String defaultEncryptionKey) {
            return defaultEncryptionKey(Output.of(defaultEncryptionKey));
        }

        /**
         * @param defaultExpirationDays The default number of days until the data within the domain expires.
         * 
         * The following arguments are optional:
         * 
         * @return builder
         * 
         */
        public Builder defaultExpirationDays(@Nullable Output<Integer> defaultExpirationDays) {
            $.defaultExpirationDays = defaultExpirationDays;
            return this;
        }

        /**
         * @param defaultExpirationDays The default number of days until the data within the domain expires.
         * 
         * The following arguments are optional:
         * 
         * @return builder
         * 
         */
        public Builder defaultExpirationDays(Integer defaultExpirationDays) {
            return defaultExpirationDays(Output.of(defaultExpirationDays));
        }

        /**
         * @param domainName The name for your Customer Profile domain. It must be unique for your AWS account.
         * 
         * @return builder
         * 
         */
        public Builder domainName(@Nullable Output<String> domainName) {
            $.domainName = domainName;
            return this;
        }

        /**
         * @param domainName The name for your Customer Profile domain. It must be unique for your AWS account.
         * 
         * @return builder
         * 
         */
        public Builder domainName(String domainName) {
            return domainName(Output.of(domainName));
        }

        /**
         * @param matching A block that specifies the process of matching duplicate profiles. Documented below.
         * 
         * @return builder
         * 
         */
        public Builder matching(@Nullable Output<DomainMatchingArgs> matching) {
            $.matching = matching;
            return this;
        }

        /**
         * @param matching A block that specifies the process of matching duplicate profiles. Documented below.
         * 
         * @return builder
         * 
         */
        public Builder matching(DomainMatchingArgs matching) {
            return matching(Output.of(matching));
        }

        /**
         * @param ruleBasedMatching A block that specifies the process of matching duplicate profiles using the Rule-Based matching. Documented below.
         * 
         * @return builder
         * 
         */
        public Builder ruleBasedMatching(@Nullable Output<DomainRuleBasedMatchingArgs> ruleBasedMatching) {
            $.ruleBasedMatching = ruleBasedMatching;
            return this;
        }

        /**
         * @param ruleBasedMatching A block that specifies the process of matching duplicate profiles using the Rule-Based matching. Documented below.
         * 
         * @return builder
         * 
         */
        public Builder ruleBasedMatching(DomainRuleBasedMatchingArgs ruleBasedMatching) {
            return ruleBasedMatching(Output.of(ruleBasedMatching));
        }

        /**
         * @param tags Tags to apply to the domain. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable Output<Map<String,String>> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags Tags to apply to the domain. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
         * 
         * @return builder
         * 
         */
        public Builder tags(Map<String,String> tags) {
            return tags(Output.of(tags));
        }

        /**
         * @param tagsAll A map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
         * 
         * @return builder
         * 
         */
        public Builder tagsAll(@Nullable Output<Map<String,String>> tagsAll) {
            $.tagsAll = tagsAll;
            return this;
        }

        /**
         * @param tagsAll A map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
         * 
         * @return builder
         * 
         */
        public Builder tagsAll(Map<String,String> tagsAll) {
            return tagsAll(Output.of(tagsAll));
        }

        public DomainState build() {
            return $;
        }
    }

}
