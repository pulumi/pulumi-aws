// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aws.ecs;

import com.pulumi.aws.Utilities;
import com.pulumi.aws.ecs.ExpressGatewayServiceArgs;
import com.pulumi.aws.ecs.inputs.ExpressGatewayServiceState;
import com.pulumi.aws.ecs.outputs.ExpressGatewayServiceIngressPath;
import com.pulumi.aws.ecs.outputs.ExpressGatewayServiceNetworkConfiguration;
import com.pulumi.aws.ecs.outputs.ExpressGatewayServicePrimaryContainer;
import com.pulumi.aws.ecs.outputs.ExpressGatewayServiceScalingTarget;
import com.pulumi.aws.ecs.outputs.ExpressGatewayServiceTimeouts;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages an ECS Express service. The Express service provides a simplified way to deploy containerized applications with automatic provisioning and management of AWS infrastructure including Application Load Balancers (ALBs), target groups, security groups, and auto-scaling policies. This service offers built-in load balancing, auto-scaling, and networking capabilities with zero-downtime deployments.
 * 
 * Express services automatically handle infrastructure provisioning and updates through rolling deployments, ensuring high availability during service modifications. When you update an Express service, a new service revision is created and deployed with zero downtime.
 * 
 * ## Example Usage
 * 
 * ### Basic Usage
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.aws.ecs.ExpressGatewayService;
 * import com.pulumi.aws.ecs.ExpressGatewayServiceArgs;
 * import com.pulumi.aws.ecs.inputs.ExpressGatewayServicePrimaryContainerArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new ExpressGatewayService("example", ExpressGatewayServiceArgs.builder()
 *             .executionRoleArn(execution.arn())
 *             .infrastructureRoleArn(infrastructure.arn())
 *             .primaryContainer(ExpressGatewayServicePrimaryContainerArgs.builder()
 *                 .image("nginx:latest")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## Service Updates and Deletion
 * 
 * ### Updates
 * 
 * When you update an Express service configuration, a new service revision is created and deployed using a rolling deployment strategy with zero downtime. The service automatically manages the transition from the old configuration to the new one, ensuring continuous availability.
 * 
 * ### Deletion
 * 
 * When an Express service is deleted, it enters a `DRAINING` state where existing tasks are allowed to complete gracefully before termination. The deletion process is irreversible - once initiated, the service and all its associated AWS infrastructure (load balancers, target groups, etc.) will be permanently removed. During the draining process, no new tasks are started, and the service becomes unavailable once all tasks have completed.
 * 
 * ## Import
 * 
 * Using `pulumi import`, import ECS Express Gateway Services using the service ARN. For example:
 * 
 * ```sh
 * $ pulumi import aws:ecs/expressGatewayService:ExpressGatewayService example arn:aws:ecs:us-west-2:123456789012:service/my-cluster/my-express-gateway-service
 * ```
 * 
 */
@ResourceType(type="aws:ecs/expressGatewayService:ExpressGatewayService")
public class ExpressGatewayService extends com.pulumi.resources.CustomResource {
    /**
     * Name or ARN of the ECS cluster. Defaults to `default`.
     * 
     */
    @Export(name="cluster", refs={String.class}, tree="[0]")
    private Output<String> cluster;

    /**
     * @return Name or ARN of the ECS cluster. Defaults to `default`.
     * 
     */
    public Output<String> cluster() {
        return this.cluster;
    }
    /**
     * Number of CPU units used by the task. Valid values are powers of 2 between 256 and 4096.
     * 
     */
    @Export(name="cpu", refs={String.class}, tree="[0]")
    private Output<String> cpu;

    /**
     * @return Number of CPU units used by the task. Valid values are powers of 2 between 256 and 4096.
     * 
     */
    public Output<String> cpu() {
        return this.cpu;
    }
    /**
     * ARN of the current deployment.
     * 
     */
    @Export(name="currentDeployment", refs={String.class}, tree="[0]")
    private Output<String> currentDeployment;

    /**
     * @return ARN of the current deployment.
     * 
     */
    public Output<String> currentDeployment() {
        return this.currentDeployment;
    }
    /**
     * ARN of the IAM role that allows ECS to pull container images and publish container logs to Amazon CloudWatch.
     * 
     */
    @Export(name="executionRoleArn", refs={String.class}, tree="[0]")
    private Output<String> executionRoleArn;

    /**
     * @return ARN of the IAM role that allows ECS to pull container images and publish container logs to Amazon CloudWatch.
     * 
     */
    public Output<String> executionRoleArn() {
        return this.executionRoleArn;
    }
    /**
     * Path for health check requests. Defaults to `/ping`.
     * 
     */
    @Export(name="healthCheckPath", refs={String.class}, tree="[0]")
    private Output<String> healthCheckPath;

    /**
     * @return Path for health check requests. Defaults to `/ping`.
     * 
     */
    public Output<String> healthCheckPath() {
        return this.healthCheckPath;
    }
    /**
     * ARN of the IAM role that allows ECS to manage AWS infrastructure on your behalf. **Important:** The infrastructure role cannot be modified after the service is created. Changing this forces a new resource to be created.
     * 
     * The following arguments are optional:
     * 
     */
    @Export(name="infrastructureRoleArn", refs={String.class}, tree="[0]")
    private Output<String> infrastructureRoleArn;

    /**
     * @return ARN of the IAM role that allows ECS to manage AWS infrastructure on your behalf. **Important:** The infrastructure role cannot be modified after the service is created. Changing this forces a new resource to be created.
     * 
     * The following arguments are optional:
     * 
     */
    public Output<String> infrastructureRoleArn() {
        return this.infrastructureRoleArn;
    }
    /**
     * List of ingress paths with access type and endpoint information.
     * 
     */
    @Export(name="ingressPaths", refs={List.class,ExpressGatewayServiceIngressPath.class}, tree="[0,1]")
    private Output<List<ExpressGatewayServiceIngressPath>> ingressPaths;

    /**
     * @return List of ingress paths with access type and endpoint information.
     * 
     */
    public Output<List<ExpressGatewayServiceIngressPath>> ingressPaths() {
        return this.ingressPaths;
    }
    /**
     * Amount of memory (in MiB) used by the task. Valid values are between 512 and 8192.
     * 
     */
    @Export(name="memory", refs={String.class}, tree="[0]")
    private Output<String> memory;

    /**
     * @return Amount of memory (in MiB) used by the task. Valid values are between 512 and 8192.
     * 
     */
    public Output<String> memory() {
        return this.memory;
    }
    @Export(name="networkConfigurations", refs={List.class,ExpressGatewayServiceNetworkConfiguration.class}, tree="[0,1]")
    private Output<List<ExpressGatewayServiceNetworkConfiguration>> networkConfigurations;

    public Output<List<ExpressGatewayServiceNetworkConfiguration>> networkConfigurations() {
        return this.networkConfigurations;
    }
    @Export(name="primaryContainer", refs={ExpressGatewayServicePrimaryContainer.class}, tree="[0]")
    private Output<ExpressGatewayServicePrimaryContainer> primaryContainer;

    public Output<ExpressGatewayServicePrimaryContainer> primaryContainer() {
        return this.primaryContainer;
    }
    /**
     * AWS region where the service will be created. If not specified, the region configured in the provider will be used.
     * 
     */
    @Export(name="region", refs={String.class}, tree="[0]")
    private Output<String> region;

    /**
     * @return AWS region where the service will be created. If not specified, the region configured in the provider will be used.
     * 
     */
    public Output<String> region() {
        return this.region;
    }
    @Export(name="scalingTargets", refs={List.class,ExpressGatewayServiceScalingTarget.class}, tree="[0,1]")
    private Output<List<ExpressGatewayServiceScalingTarget>> scalingTargets;

    public Output<List<ExpressGatewayServiceScalingTarget>> scalingTargets() {
        return this.scalingTargets;
    }
    /**
     * ARN of the Express Gateway Service.
     * 
     */
    @Export(name="serviceArn", refs={String.class}, tree="[0]")
    private Output<String> serviceArn;

    /**
     * @return ARN of the Express Gateway Service.
     * 
     */
    public Output<String> serviceArn() {
        return this.serviceArn;
    }
    /**
     * Name of the service. If not specified, a name will be generated. Changing this forces a new resource to be created.
     * 
     */
    @Export(name="serviceName", refs={String.class}, tree="[0]")
    private Output<String> serviceName;

    /**
     * @return Name of the service. If not specified, a name will be generated. Changing this forces a new resource to be created.
     * 
     */
    public Output<String> serviceName() {
        return this.serviceName;
    }
    /**
     * ARN of the service revision.
     * 
     */
    @Export(name="serviceRevisionArn", refs={String.class}, tree="[0]")
    private Output<String> serviceRevisionArn;

    /**
     * @return ARN of the service revision.
     * 
     */
    public Output<String> serviceRevisionArn() {
        return this.serviceRevisionArn;
    }
    /**
     * Key-value map of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    @Export(name="tags", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> tags;

    /**
     * @return Key-value map of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    public Output<Optional<Map<String,String>>> tags() {
        return Codegen.optional(this.tags);
    }
    /**
     * Map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
     * 
     */
    @Export(name="tagsAll", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output<Map<String,String>> tagsAll;

    /**
     * @return Map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
     * 
     */
    public Output<Map<String,String>> tagsAll() {
        return this.tagsAll;
    }
    /**
     * ARN of the IAM role that allows your Amazon ECS container task to make calls to other AWS services.
     * 
     */
    @Export(name="taskRoleArn", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> taskRoleArn;

    /**
     * @return ARN of the IAM role that allows your Amazon ECS container task to make calls to other AWS services.
     * 
     */
    public Output<Optional<String>> taskRoleArn() {
        return Codegen.optional(this.taskRoleArn);
    }
    @Export(name="timeouts", refs={ExpressGatewayServiceTimeouts.class}, tree="[0]")
    private Output</* @Nullable */ ExpressGatewayServiceTimeouts> timeouts;

    public Output<Optional<ExpressGatewayServiceTimeouts>> timeouts() {
        return Codegen.optional(this.timeouts);
    }
    /**
     * Whether to wait for the service to reach a steady state before considering the operation complete. Defaults to `false`.
     * 
     */
    @Export(name="waitForSteadyState", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> waitForSteadyState;

    /**
     * @return Whether to wait for the service to reach a steady state before considering the operation complete. Defaults to `false`.
     * 
     */
    public Output<Boolean> waitForSteadyState() {
        return this.waitForSteadyState;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public ExpressGatewayService(java.lang.String name) {
        this(name, ExpressGatewayServiceArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public ExpressGatewayService(java.lang.String name, ExpressGatewayServiceArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public ExpressGatewayService(java.lang.String name, ExpressGatewayServiceArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("aws:ecs/expressGatewayService:ExpressGatewayService", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private ExpressGatewayService(java.lang.String name, Output<java.lang.String> id, @Nullable ExpressGatewayServiceState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("aws:ecs/expressGatewayService:ExpressGatewayService", name, state, makeResourceOptions(options, id), false);
    }

    private static ExpressGatewayServiceArgs makeArgs(ExpressGatewayServiceArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? ExpressGatewayServiceArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static ExpressGatewayService get(java.lang.String name, Output<java.lang.String> id, @Nullable ExpressGatewayServiceState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new ExpressGatewayService(name, id, state, options);
    }
}
