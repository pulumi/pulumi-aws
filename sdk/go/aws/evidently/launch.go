// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package evidently

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v7/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type Launch struct {
	pulumi.CustomResourceState

	Arn                   pulumi.StringOutput                  `pulumi:"arn"`
	CreatedTime           pulumi.StringOutput                  `pulumi:"createdTime"`
	Description           pulumi.StringPtrOutput               `pulumi:"description"`
	Executions            LaunchExecutionArrayOutput           `pulumi:"executions"`
	Groups                LaunchGroupArrayOutput               `pulumi:"groups"`
	LastUpdatedTime       pulumi.StringOutput                  `pulumi:"lastUpdatedTime"`
	MetricMonitors        LaunchMetricMonitorArrayOutput       `pulumi:"metricMonitors"`
	Name                  pulumi.StringOutput                  `pulumi:"name"`
	Project               pulumi.StringOutput                  `pulumi:"project"`
	RandomizationSalt     pulumi.StringPtrOutput               `pulumi:"randomizationSalt"`
	Region                pulumi.StringOutput                  `pulumi:"region"`
	ScheduledSplitsConfig LaunchScheduledSplitsConfigPtrOutput `pulumi:"scheduledSplitsConfig"`
	Status                pulumi.StringOutput                  `pulumi:"status"`
	StatusReason          pulumi.StringOutput                  `pulumi:"statusReason"`
	Tags                  pulumi.StringMapOutput               `pulumi:"tags"`
	TagsAll               pulumi.StringMapOutput               `pulumi:"tagsAll"`
	Type                  pulumi.StringOutput                  `pulumi:"type"`
}

// NewLaunch registers a new resource with the given unique name, arguments, and options.
func NewLaunch(ctx *pulumi.Context,
	name string, args *LaunchArgs, opts ...pulumi.ResourceOption) (*Launch, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Groups == nil {
		return nil, errors.New("invalid value for required argument 'Groups'")
	}
	if args.Project == nil {
		return nil, errors.New("invalid value for required argument 'Project'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Launch
	err := ctx.RegisterResource("aws:evidently/launch:Launch", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLaunch gets an existing Launch resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLaunch(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LaunchState, opts ...pulumi.ResourceOption) (*Launch, error) {
	var resource Launch
	err := ctx.ReadResource("aws:evidently/launch:Launch", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Launch resources.
type launchState struct {
	Arn                   *string                      `pulumi:"arn"`
	CreatedTime           *string                      `pulumi:"createdTime"`
	Description           *string                      `pulumi:"description"`
	Executions            []LaunchExecution            `pulumi:"executions"`
	Groups                []LaunchGroup                `pulumi:"groups"`
	LastUpdatedTime       *string                      `pulumi:"lastUpdatedTime"`
	MetricMonitors        []LaunchMetricMonitor        `pulumi:"metricMonitors"`
	Name                  *string                      `pulumi:"name"`
	Project               *string                      `pulumi:"project"`
	RandomizationSalt     *string                      `pulumi:"randomizationSalt"`
	Region                *string                      `pulumi:"region"`
	ScheduledSplitsConfig *LaunchScheduledSplitsConfig `pulumi:"scheduledSplitsConfig"`
	Status                *string                      `pulumi:"status"`
	StatusReason          *string                      `pulumi:"statusReason"`
	Tags                  map[string]string            `pulumi:"tags"`
	TagsAll               map[string]string            `pulumi:"tagsAll"`
	Type                  *string                      `pulumi:"type"`
}

type LaunchState struct {
	Arn                   pulumi.StringPtrInput
	CreatedTime           pulumi.StringPtrInput
	Description           pulumi.StringPtrInput
	Executions            LaunchExecutionArrayInput
	Groups                LaunchGroupArrayInput
	LastUpdatedTime       pulumi.StringPtrInput
	MetricMonitors        LaunchMetricMonitorArrayInput
	Name                  pulumi.StringPtrInput
	Project               pulumi.StringPtrInput
	RandomizationSalt     pulumi.StringPtrInput
	Region                pulumi.StringPtrInput
	ScheduledSplitsConfig LaunchScheduledSplitsConfigPtrInput
	Status                pulumi.StringPtrInput
	StatusReason          pulumi.StringPtrInput
	Tags                  pulumi.StringMapInput
	TagsAll               pulumi.StringMapInput
	Type                  pulumi.StringPtrInput
}

func (LaunchState) ElementType() reflect.Type {
	return reflect.TypeOf((*launchState)(nil)).Elem()
}

type launchArgs struct {
	Description           *string                      `pulumi:"description"`
	Groups                []LaunchGroup                `pulumi:"groups"`
	MetricMonitors        []LaunchMetricMonitor        `pulumi:"metricMonitors"`
	Name                  *string                      `pulumi:"name"`
	Project               string                       `pulumi:"project"`
	RandomizationSalt     *string                      `pulumi:"randomizationSalt"`
	Region                *string                      `pulumi:"region"`
	ScheduledSplitsConfig *LaunchScheduledSplitsConfig `pulumi:"scheduledSplitsConfig"`
	Tags                  map[string]string            `pulumi:"tags"`
}

// The set of arguments for constructing a Launch resource.
type LaunchArgs struct {
	Description           pulumi.StringPtrInput
	Groups                LaunchGroupArrayInput
	MetricMonitors        LaunchMetricMonitorArrayInput
	Name                  pulumi.StringPtrInput
	Project               pulumi.StringInput
	RandomizationSalt     pulumi.StringPtrInput
	Region                pulumi.StringPtrInput
	ScheduledSplitsConfig LaunchScheduledSplitsConfigPtrInput
	Tags                  pulumi.StringMapInput
}

func (LaunchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*launchArgs)(nil)).Elem()
}

type LaunchInput interface {
	pulumi.Input

	ToLaunchOutput() LaunchOutput
	ToLaunchOutputWithContext(ctx context.Context) LaunchOutput
}

func (*Launch) ElementType() reflect.Type {
	return reflect.TypeOf((**Launch)(nil)).Elem()
}

func (i *Launch) ToLaunchOutput() LaunchOutput {
	return i.ToLaunchOutputWithContext(context.Background())
}

func (i *Launch) ToLaunchOutputWithContext(ctx context.Context) LaunchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LaunchOutput)
}

// LaunchArrayInput is an input type that accepts LaunchArray and LaunchArrayOutput values.
// You can construct a concrete instance of `LaunchArrayInput` via:
//
//	LaunchArray{ LaunchArgs{...} }
type LaunchArrayInput interface {
	pulumi.Input

	ToLaunchArrayOutput() LaunchArrayOutput
	ToLaunchArrayOutputWithContext(context.Context) LaunchArrayOutput
}

type LaunchArray []LaunchInput

func (LaunchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Launch)(nil)).Elem()
}

func (i LaunchArray) ToLaunchArrayOutput() LaunchArrayOutput {
	return i.ToLaunchArrayOutputWithContext(context.Background())
}

func (i LaunchArray) ToLaunchArrayOutputWithContext(ctx context.Context) LaunchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LaunchArrayOutput)
}

// LaunchMapInput is an input type that accepts LaunchMap and LaunchMapOutput values.
// You can construct a concrete instance of `LaunchMapInput` via:
//
//	LaunchMap{ "key": LaunchArgs{...} }
type LaunchMapInput interface {
	pulumi.Input

	ToLaunchMapOutput() LaunchMapOutput
	ToLaunchMapOutputWithContext(context.Context) LaunchMapOutput
}

type LaunchMap map[string]LaunchInput

func (LaunchMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Launch)(nil)).Elem()
}

func (i LaunchMap) ToLaunchMapOutput() LaunchMapOutput {
	return i.ToLaunchMapOutputWithContext(context.Background())
}

func (i LaunchMap) ToLaunchMapOutputWithContext(ctx context.Context) LaunchMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LaunchMapOutput)
}

type LaunchOutput struct{ *pulumi.OutputState }

func (LaunchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Launch)(nil)).Elem()
}

func (o LaunchOutput) ToLaunchOutput() LaunchOutput {
	return o
}

func (o LaunchOutput) ToLaunchOutputWithContext(ctx context.Context) LaunchOutput {
	return o
}

func (o LaunchOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v *Launch) pulumi.StringOutput { return v.Arn }).(pulumi.StringOutput)
}

func (o LaunchOutput) CreatedTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Launch) pulumi.StringOutput { return v.CreatedTime }).(pulumi.StringOutput)
}

func (o LaunchOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Launch) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

func (o LaunchOutput) Executions() LaunchExecutionArrayOutput {
	return o.ApplyT(func(v *Launch) LaunchExecutionArrayOutput { return v.Executions }).(LaunchExecutionArrayOutput)
}

func (o LaunchOutput) Groups() LaunchGroupArrayOutput {
	return o.ApplyT(func(v *Launch) LaunchGroupArrayOutput { return v.Groups }).(LaunchGroupArrayOutput)
}

func (o LaunchOutput) LastUpdatedTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Launch) pulumi.StringOutput { return v.LastUpdatedTime }).(pulumi.StringOutput)
}

func (o LaunchOutput) MetricMonitors() LaunchMetricMonitorArrayOutput {
	return o.ApplyT(func(v *Launch) LaunchMetricMonitorArrayOutput { return v.MetricMonitors }).(LaunchMetricMonitorArrayOutput)
}

func (o LaunchOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Launch) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o LaunchOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *Launch) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

func (o LaunchOutput) RandomizationSalt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Launch) pulumi.StringPtrOutput { return v.RandomizationSalt }).(pulumi.StringPtrOutput)
}

func (o LaunchOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *Launch) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

func (o LaunchOutput) ScheduledSplitsConfig() LaunchScheduledSplitsConfigPtrOutput {
	return o.ApplyT(func(v *Launch) LaunchScheduledSplitsConfigPtrOutput { return v.ScheduledSplitsConfig }).(LaunchScheduledSplitsConfigPtrOutput)
}

func (o LaunchOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *Launch) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

func (o LaunchOutput) StatusReason() pulumi.StringOutput {
	return o.ApplyT(func(v *Launch) pulumi.StringOutput { return v.StatusReason }).(pulumi.StringOutput)
}

func (o LaunchOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Launch) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

func (o LaunchOutput) TagsAll() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Launch) pulumi.StringMapOutput { return v.TagsAll }).(pulumi.StringMapOutput)
}

func (o LaunchOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *Launch) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

type LaunchArrayOutput struct{ *pulumi.OutputState }

func (LaunchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Launch)(nil)).Elem()
}

func (o LaunchArrayOutput) ToLaunchArrayOutput() LaunchArrayOutput {
	return o
}

func (o LaunchArrayOutput) ToLaunchArrayOutputWithContext(ctx context.Context) LaunchArrayOutput {
	return o
}

func (o LaunchArrayOutput) Index(i pulumi.IntInput) LaunchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Launch {
		return vs[0].([]*Launch)[vs[1].(int)]
	}).(LaunchOutput)
}

type LaunchMapOutput struct{ *pulumi.OutputState }

func (LaunchMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Launch)(nil)).Elem()
}

func (o LaunchMapOutput) ToLaunchMapOutput() LaunchMapOutput {
	return o
}

func (o LaunchMapOutput) ToLaunchMapOutputWithContext(ctx context.Context) LaunchMapOutput {
	return o
}

func (o LaunchMapOutput) MapIndex(k pulumi.StringInput) LaunchOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Launch {
		return vs[0].(map[string]*Launch)[vs[1].(string)]
	}).(LaunchOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LaunchInput)(nil)).Elem(), &Launch{})
	pulumi.RegisterInputType(reflect.TypeOf((*LaunchArrayInput)(nil)).Elem(), LaunchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LaunchMapInput)(nil)).Elem(), LaunchMap{})
	pulumi.RegisterOutputType(LaunchOutput{})
	pulumi.RegisterOutputType(LaunchArrayOutput{})
	pulumi.RegisterOutputType(LaunchMapOutput{})
}
