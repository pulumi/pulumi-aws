// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package evidently

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v7/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type Feature struct {
	pulumi.CustomResourceState

	Arn                pulumi.StringOutput              `pulumi:"arn"`
	CreatedTime        pulumi.StringOutput              `pulumi:"createdTime"`
	DefaultVariation   pulumi.StringOutput              `pulumi:"defaultVariation"`
	Description        pulumi.StringPtrOutput           `pulumi:"description"`
	EntityOverrides    pulumi.StringMapOutput           `pulumi:"entityOverrides"`
	EvaluationRules    FeatureEvaluationRuleArrayOutput `pulumi:"evaluationRules"`
	EvaluationStrategy pulumi.StringOutput              `pulumi:"evaluationStrategy"`
	LastUpdatedTime    pulumi.StringOutput              `pulumi:"lastUpdatedTime"`
	Name               pulumi.StringOutput              `pulumi:"name"`
	Project            pulumi.StringOutput              `pulumi:"project"`
	Region             pulumi.StringOutput              `pulumi:"region"`
	Status             pulumi.StringOutput              `pulumi:"status"`
	Tags               pulumi.StringMapOutput           `pulumi:"tags"`
	TagsAll            pulumi.StringMapOutput           `pulumi:"tagsAll"`
	ValueType          pulumi.StringOutput              `pulumi:"valueType"`
	Variations         FeatureVariationArrayOutput      `pulumi:"variations"`
}

// NewFeature registers a new resource with the given unique name, arguments, and options.
func NewFeature(ctx *pulumi.Context,
	name string, args *FeatureArgs, opts ...pulumi.ResourceOption) (*Feature, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Project == nil {
		return nil, errors.New("invalid value for required argument 'Project'")
	}
	if args.Variations == nil {
		return nil, errors.New("invalid value for required argument 'Variations'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Feature
	err := ctx.RegisterResource("aws:evidently/feature:Feature", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFeature gets an existing Feature resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFeature(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FeatureState, opts ...pulumi.ResourceOption) (*Feature, error) {
	var resource Feature
	err := ctx.ReadResource("aws:evidently/feature:Feature", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Feature resources.
type featureState struct {
	Arn                *string                 `pulumi:"arn"`
	CreatedTime        *string                 `pulumi:"createdTime"`
	DefaultVariation   *string                 `pulumi:"defaultVariation"`
	Description        *string                 `pulumi:"description"`
	EntityOverrides    map[string]string       `pulumi:"entityOverrides"`
	EvaluationRules    []FeatureEvaluationRule `pulumi:"evaluationRules"`
	EvaluationStrategy *string                 `pulumi:"evaluationStrategy"`
	LastUpdatedTime    *string                 `pulumi:"lastUpdatedTime"`
	Name               *string                 `pulumi:"name"`
	Project            *string                 `pulumi:"project"`
	Region             *string                 `pulumi:"region"`
	Status             *string                 `pulumi:"status"`
	Tags               map[string]string       `pulumi:"tags"`
	TagsAll            map[string]string       `pulumi:"tagsAll"`
	ValueType          *string                 `pulumi:"valueType"`
	Variations         []FeatureVariation      `pulumi:"variations"`
}

type FeatureState struct {
	Arn                pulumi.StringPtrInput
	CreatedTime        pulumi.StringPtrInput
	DefaultVariation   pulumi.StringPtrInput
	Description        pulumi.StringPtrInput
	EntityOverrides    pulumi.StringMapInput
	EvaluationRules    FeatureEvaluationRuleArrayInput
	EvaluationStrategy pulumi.StringPtrInput
	LastUpdatedTime    pulumi.StringPtrInput
	Name               pulumi.StringPtrInput
	Project            pulumi.StringPtrInput
	Region             pulumi.StringPtrInput
	Status             pulumi.StringPtrInput
	Tags               pulumi.StringMapInput
	TagsAll            pulumi.StringMapInput
	ValueType          pulumi.StringPtrInput
	Variations         FeatureVariationArrayInput
}

func (FeatureState) ElementType() reflect.Type {
	return reflect.TypeOf((*featureState)(nil)).Elem()
}

type featureArgs struct {
	DefaultVariation   *string            `pulumi:"defaultVariation"`
	Description        *string            `pulumi:"description"`
	EntityOverrides    map[string]string  `pulumi:"entityOverrides"`
	EvaluationStrategy *string            `pulumi:"evaluationStrategy"`
	Name               *string            `pulumi:"name"`
	Project            string             `pulumi:"project"`
	Region             *string            `pulumi:"region"`
	Tags               map[string]string  `pulumi:"tags"`
	Variations         []FeatureVariation `pulumi:"variations"`
}

// The set of arguments for constructing a Feature resource.
type FeatureArgs struct {
	DefaultVariation   pulumi.StringPtrInput
	Description        pulumi.StringPtrInput
	EntityOverrides    pulumi.StringMapInput
	EvaluationStrategy pulumi.StringPtrInput
	Name               pulumi.StringPtrInput
	Project            pulumi.StringInput
	Region             pulumi.StringPtrInput
	Tags               pulumi.StringMapInput
	Variations         FeatureVariationArrayInput
}

func (FeatureArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*featureArgs)(nil)).Elem()
}

type FeatureInput interface {
	pulumi.Input

	ToFeatureOutput() FeatureOutput
	ToFeatureOutputWithContext(ctx context.Context) FeatureOutput
}

func (*Feature) ElementType() reflect.Type {
	return reflect.TypeOf((**Feature)(nil)).Elem()
}

func (i *Feature) ToFeatureOutput() FeatureOutput {
	return i.ToFeatureOutputWithContext(context.Background())
}

func (i *Feature) ToFeatureOutputWithContext(ctx context.Context) FeatureOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FeatureOutput)
}

// FeatureArrayInput is an input type that accepts FeatureArray and FeatureArrayOutput values.
// You can construct a concrete instance of `FeatureArrayInput` via:
//
//	FeatureArray{ FeatureArgs{...} }
type FeatureArrayInput interface {
	pulumi.Input

	ToFeatureArrayOutput() FeatureArrayOutput
	ToFeatureArrayOutputWithContext(context.Context) FeatureArrayOutput
}

type FeatureArray []FeatureInput

func (FeatureArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Feature)(nil)).Elem()
}

func (i FeatureArray) ToFeatureArrayOutput() FeatureArrayOutput {
	return i.ToFeatureArrayOutputWithContext(context.Background())
}

func (i FeatureArray) ToFeatureArrayOutputWithContext(ctx context.Context) FeatureArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FeatureArrayOutput)
}

// FeatureMapInput is an input type that accepts FeatureMap and FeatureMapOutput values.
// You can construct a concrete instance of `FeatureMapInput` via:
//
//	FeatureMap{ "key": FeatureArgs{...} }
type FeatureMapInput interface {
	pulumi.Input

	ToFeatureMapOutput() FeatureMapOutput
	ToFeatureMapOutputWithContext(context.Context) FeatureMapOutput
}

type FeatureMap map[string]FeatureInput

func (FeatureMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Feature)(nil)).Elem()
}

func (i FeatureMap) ToFeatureMapOutput() FeatureMapOutput {
	return i.ToFeatureMapOutputWithContext(context.Background())
}

func (i FeatureMap) ToFeatureMapOutputWithContext(ctx context.Context) FeatureMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FeatureMapOutput)
}

type FeatureOutput struct{ *pulumi.OutputState }

func (FeatureOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Feature)(nil)).Elem()
}

func (o FeatureOutput) ToFeatureOutput() FeatureOutput {
	return o
}

func (o FeatureOutput) ToFeatureOutputWithContext(ctx context.Context) FeatureOutput {
	return o
}

func (o FeatureOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v *Feature) pulumi.StringOutput { return v.Arn }).(pulumi.StringOutput)
}

func (o FeatureOutput) CreatedTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Feature) pulumi.StringOutput { return v.CreatedTime }).(pulumi.StringOutput)
}

func (o FeatureOutput) DefaultVariation() pulumi.StringOutput {
	return o.ApplyT(func(v *Feature) pulumi.StringOutput { return v.DefaultVariation }).(pulumi.StringOutput)
}

func (o FeatureOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Feature) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

func (o FeatureOutput) EntityOverrides() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Feature) pulumi.StringMapOutput { return v.EntityOverrides }).(pulumi.StringMapOutput)
}

func (o FeatureOutput) EvaluationRules() FeatureEvaluationRuleArrayOutput {
	return o.ApplyT(func(v *Feature) FeatureEvaluationRuleArrayOutput { return v.EvaluationRules }).(FeatureEvaluationRuleArrayOutput)
}

func (o FeatureOutput) EvaluationStrategy() pulumi.StringOutput {
	return o.ApplyT(func(v *Feature) pulumi.StringOutput { return v.EvaluationStrategy }).(pulumi.StringOutput)
}

func (o FeatureOutput) LastUpdatedTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Feature) pulumi.StringOutput { return v.LastUpdatedTime }).(pulumi.StringOutput)
}

func (o FeatureOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Feature) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o FeatureOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v *Feature) pulumi.StringOutput { return v.Project }).(pulumi.StringOutput)
}

func (o FeatureOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *Feature) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

func (o FeatureOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *Feature) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

func (o FeatureOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Feature) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

func (o FeatureOutput) TagsAll() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Feature) pulumi.StringMapOutput { return v.TagsAll }).(pulumi.StringMapOutput)
}

func (o FeatureOutput) ValueType() pulumi.StringOutput {
	return o.ApplyT(func(v *Feature) pulumi.StringOutput { return v.ValueType }).(pulumi.StringOutput)
}

func (o FeatureOutput) Variations() FeatureVariationArrayOutput {
	return o.ApplyT(func(v *Feature) FeatureVariationArrayOutput { return v.Variations }).(FeatureVariationArrayOutput)
}

type FeatureArrayOutput struct{ *pulumi.OutputState }

func (FeatureArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Feature)(nil)).Elem()
}

func (o FeatureArrayOutput) ToFeatureArrayOutput() FeatureArrayOutput {
	return o
}

func (o FeatureArrayOutput) ToFeatureArrayOutputWithContext(ctx context.Context) FeatureArrayOutput {
	return o
}

func (o FeatureArrayOutput) Index(i pulumi.IntInput) FeatureOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Feature {
		return vs[0].([]*Feature)[vs[1].(int)]
	}).(FeatureOutput)
}

type FeatureMapOutput struct{ *pulumi.OutputState }

func (FeatureMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Feature)(nil)).Elem()
}

func (o FeatureMapOutput) ToFeatureMapOutput() FeatureMapOutput {
	return o
}

func (o FeatureMapOutput) ToFeatureMapOutputWithContext(ctx context.Context) FeatureMapOutput {
	return o
}

func (o FeatureMapOutput) MapIndex(k pulumi.StringInput) FeatureOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Feature {
		return vs[0].(map[string]*Feature)[vs[1].(string)]
	}).(FeatureOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FeatureInput)(nil)).Elem(), &Feature{})
	pulumi.RegisterInputType(reflect.TypeOf((*FeatureArrayInput)(nil)).Elem(), FeatureArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FeatureMapInput)(nil)).Elem(), FeatureMap{})
	pulumi.RegisterOutputType(FeatureOutput{})
	pulumi.RegisterOutputType(FeatureArrayOutput{})
	pulumi.RegisterOutputType(FeatureMapOutput{})
}
