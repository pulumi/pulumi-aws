// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package s3

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type Inventory struct {
	pulumi.CustomResourceState

	Bucket                 pulumi.StringOutput        `pulumi:"bucket"`
	Destination            InventoryDestinationOutput `pulumi:"destination"`
	Enabled                pulumi.BoolPtrOutput       `pulumi:"enabled"`
	Filter                 InventoryFilterPtrOutput   `pulumi:"filter"`
	IncludedObjectVersions pulumi.StringOutput        `pulumi:"includedObjectVersions"`
	Name                   pulumi.StringOutput        `pulumi:"name"`
	OptionalFields         pulumi.StringArrayOutput   `pulumi:"optionalFields"`
	Schedule               InventoryScheduleOutput    `pulumi:"schedule"`
}

// NewInventory registers a new resource with the given unique name, arguments, and options.
func NewInventory(ctx *pulumi.Context,
	name string, args *InventoryArgs, opts ...pulumi.ResourceOption) (*Inventory, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Bucket == nil {
		return nil, errors.New("invalid value for required argument 'Bucket'")
	}
	if args.Destination == nil {
		return nil, errors.New("invalid value for required argument 'Destination'")
	}
	if args.IncludedObjectVersions == nil {
		return nil, errors.New("invalid value for required argument 'IncludedObjectVersions'")
	}
	if args.Schedule == nil {
		return nil, errors.New("invalid value for required argument 'Schedule'")
	}
	var resource Inventory
	err := ctx.RegisterResource("aws:s3/inventory:Inventory", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetInventory gets an existing Inventory resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetInventory(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *InventoryState, opts ...pulumi.ResourceOption) (*Inventory, error) {
	var resource Inventory
	err := ctx.ReadResource("aws:s3/inventory:Inventory", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Inventory resources.
type inventoryState struct {
	Bucket                 *string               `pulumi:"bucket"`
	Destination            *InventoryDestination `pulumi:"destination"`
	Enabled                *bool                 `pulumi:"enabled"`
	Filter                 *InventoryFilter      `pulumi:"filter"`
	IncludedObjectVersions *string               `pulumi:"includedObjectVersions"`
	Name                   *string               `pulumi:"name"`
	OptionalFields         []string              `pulumi:"optionalFields"`
	Schedule               *InventorySchedule    `pulumi:"schedule"`
}

type InventoryState struct {
	Bucket                 pulumi.StringPtrInput
	Destination            InventoryDestinationPtrInput
	Enabled                pulumi.BoolPtrInput
	Filter                 InventoryFilterPtrInput
	IncludedObjectVersions pulumi.StringPtrInput
	Name                   pulumi.StringPtrInput
	OptionalFields         pulumi.StringArrayInput
	Schedule               InventorySchedulePtrInput
}

func (InventoryState) ElementType() reflect.Type {
	return reflect.TypeOf((*inventoryState)(nil)).Elem()
}

type inventoryArgs struct {
	Bucket                 string               `pulumi:"bucket"`
	Destination            InventoryDestination `pulumi:"destination"`
	Enabled                *bool                `pulumi:"enabled"`
	Filter                 *InventoryFilter     `pulumi:"filter"`
	IncludedObjectVersions string               `pulumi:"includedObjectVersions"`
	Name                   *string              `pulumi:"name"`
	OptionalFields         []string             `pulumi:"optionalFields"`
	Schedule               InventorySchedule    `pulumi:"schedule"`
}

// The set of arguments for constructing a Inventory resource.
type InventoryArgs struct {
	Bucket                 pulumi.StringInput
	Destination            InventoryDestinationInput
	Enabled                pulumi.BoolPtrInput
	Filter                 InventoryFilterPtrInput
	IncludedObjectVersions pulumi.StringInput
	Name                   pulumi.StringPtrInput
	OptionalFields         pulumi.StringArrayInput
	Schedule               InventoryScheduleInput
}

func (InventoryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*inventoryArgs)(nil)).Elem()
}

type InventoryInput interface {
	pulumi.Input

	ToInventoryOutput() InventoryOutput
	ToInventoryOutputWithContext(ctx context.Context) InventoryOutput
}

func (*Inventory) ElementType() reflect.Type {
	return reflect.TypeOf((**Inventory)(nil)).Elem()
}

func (i *Inventory) ToInventoryOutput() InventoryOutput {
	return i.ToInventoryOutputWithContext(context.Background())
}

func (i *Inventory) ToInventoryOutputWithContext(ctx context.Context) InventoryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InventoryOutput)
}

// InventoryArrayInput is an input type that accepts InventoryArray and InventoryArrayOutput values.
// You can construct a concrete instance of `InventoryArrayInput` via:
//
//	InventoryArray{ InventoryArgs{...} }
type InventoryArrayInput interface {
	pulumi.Input

	ToInventoryArrayOutput() InventoryArrayOutput
	ToInventoryArrayOutputWithContext(context.Context) InventoryArrayOutput
}

type InventoryArray []InventoryInput

func (InventoryArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Inventory)(nil)).Elem()
}

func (i InventoryArray) ToInventoryArrayOutput() InventoryArrayOutput {
	return i.ToInventoryArrayOutputWithContext(context.Background())
}

func (i InventoryArray) ToInventoryArrayOutputWithContext(ctx context.Context) InventoryArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InventoryArrayOutput)
}

// InventoryMapInput is an input type that accepts InventoryMap and InventoryMapOutput values.
// You can construct a concrete instance of `InventoryMapInput` via:
//
//	InventoryMap{ "key": InventoryArgs{...} }
type InventoryMapInput interface {
	pulumi.Input

	ToInventoryMapOutput() InventoryMapOutput
	ToInventoryMapOutputWithContext(context.Context) InventoryMapOutput
}

type InventoryMap map[string]InventoryInput

func (InventoryMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Inventory)(nil)).Elem()
}

func (i InventoryMap) ToInventoryMapOutput() InventoryMapOutput {
	return i.ToInventoryMapOutputWithContext(context.Background())
}

func (i InventoryMap) ToInventoryMapOutputWithContext(ctx context.Context) InventoryMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InventoryMapOutput)
}

type InventoryOutput struct{ *pulumi.OutputState }

func (InventoryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Inventory)(nil)).Elem()
}

func (o InventoryOutput) ToInventoryOutput() InventoryOutput {
	return o
}

func (o InventoryOutput) ToInventoryOutputWithContext(ctx context.Context) InventoryOutput {
	return o
}

func (o InventoryOutput) Bucket() pulumi.StringOutput {
	return o.ApplyT(func(v *Inventory) pulumi.StringOutput { return v.Bucket }).(pulumi.StringOutput)
}

func (o InventoryOutput) Destination() InventoryDestinationOutput {
	return o.ApplyT(func(v *Inventory) InventoryDestinationOutput { return v.Destination }).(InventoryDestinationOutput)
}

func (o InventoryOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Inventory) pulumi.BoolPtrOutput { return v.Enabled }).(pulumi.BoolPtrOutput)
}

func (o InventoryOutput) Filter() InventoryFilterPtrOutput {
	return o.ApplyT(func(v *Inventory) InventoryFilterPtrOutput { return v.Filter }).(InventoryFilterPtrOutput)
}

func (o InventoryOutput) IncludedObjectVersions() pulumi.StringOutput {
	return o.ApplyT(func(v *Inventory) pulumi.StringOutput { return v.IncludedObjectVersions }).(pulumi.StringOutput)
}

func (o InventoryOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Inventory) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o InventoryOutput) OptionalFields() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Inventory) pulumi.StringArrayOutput { return v.OptionalFields }).(pulumi.StringArrayOutput)
}

func (o InventoryOutput) Schedule() InventoryScheduleOutput {
	return o.ApplyT(func(v *Inventory) InventoryScheduleOutput { return v.Schedule }).(InventoryScheduleOutput)
}

type InventoryArrayOutput struct{ *pulumi.OutputState }

func (InventoryArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Inventory)(nil)).Elem()
}

func (o InventoryArrayOutput) ToInventoryArrayOutput() InventoryArrayOutput {
	return o
}

func (o InventoryArrayOutput) ToInventoryArrayOutputWithContext(ctx context.Context) InventoryArrayOutput {
	return o
}

func (o InventoryArrayOutput) Index(i pulumi.IntInput) InventoryOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Inventory {
		return vs[0].([]*Inventory)[vs[1].(int)]
	}).(InventoryOutput)
}

type InventoryMapOutput struct{ *pulumi.OutputState }

func (InventoryMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Inventory)(nil)).Elem()
}

func (o InventoryMapOutput) ToInventoryMapOutput() InventoryMapOutput {
	return o
}

func (o InventoryMapOutput) ToInventoryMapOutputWithContext(ctx context.Context) InventoryMapOutput {
	return o
}

func (o InventoryMapOutput) MapIndex(k pulumi.StringInput) InventoryOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Inventory {
		return vs[0].(map[string]*Inventory)[vs[1].(string)]
	}).(InventoryOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*InventoryInput)(nil)).Elem(), &Inventory{})
	pulumi.RegisterInputType(reflect.TypeOf((*InventoryArrayInput)(nil)).Elem(), InventoryArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*InventoryMapInput)(nil)).Elem(), InventoryMap{})
	pulumi.RegisterOutputType(InventoryOutput{})
	pulumi.RegisterOutputType(InventoryArrayOutput{})
	pulumi.RegisterOutputType(InventoryMapOutput{})
}
