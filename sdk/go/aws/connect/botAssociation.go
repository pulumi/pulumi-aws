// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package connect

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v7/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type BotAssociation struct {
	pulumi.CustomResourceState

	InstanceId pulumi.StringOutput        `pulumi:"instanceId"`
	LexBot     BotAssociationLexBotOutput `pulumi:"lexBot"`
	Region     pulumi.StringOutput        `pulumi:"region"`
}

// NewBotAssociation registers a new resource with the given unique name, arguments, and options.
func NewBotAssociation(ctx *pulumi.Context,
	name string, args *BotAssociationArgs, opts ...pulumi.ResourceOption) (*BotAssociation, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.InstanceId == nil {
		return nil, errors.New("invalid value for required argument 'InstanceId'")
	}
	if args.LexBot == nil {
		return nil, errors.New("invalid value for required argument 'LexBot'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource BotAssociation
	err := ctx.RegisterResource("aws:connect/botAssociation:BotAssociation", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetBotAssociation gets an existing BotAssociation resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetBotAssociation(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *BotAssociationState, opts ...pulumi.ResourceOption) (*BotAssociation, error) {
	var resource BotAssociation
	err := ctx.ReadResource("aws:connect/botAssociation:BotAssociation", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering BotAssociation resources.
type botAssociationState struct {
	InstanceId *string               `pulumi:"instanceId"`
	LexBot     *BotAssociationLexBot `pulumi:"lexBot"`
	Region     *string               `pulumi:"region"`
}

type BotAssociationState struct {
	InstanceId pulumi.StringPtrInput
	LexBot     BotAssociationLexBotPtrInput
	Region     pulumi.StringPtrInput
}

func (BotAssociationState) ElementType() reflect.Type {
	return reflect.TypeOf((*botAssociationState)(nil)).Elem()
}

type botAssociationArgs struct {
	InstanceId string               `pulumi:"instanceId"`
	LexBot     BotAssociationLexBot `pulumi:"lexBot"`
	Region     *string              `pulumi:"region"`
}

// The set of arguments for constructing a BotAssociation resource.
type BotAssociationArgs struct {
	InstanceId pulumi.StringInput
	LexBot     BotAssociationLexBotInput
	Region     pulumi.StringPtrInput
}

func (BotAssociationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*botAssociationArgs)(nil)).Elem()
}

type BotAssociationInput interface {
	pulumi.Input

	ToBotAssociationOutput() BotAssociationOutput
	ToBotAssociationOutputWithContext(ctx context.Context) BotAssociationOutput
}

func (*BotAssociation) ElementType() reflect.Type {
	return reflect.TypeOf((**BotAssociation)(nil)).Elem()
}

func (i *BotAssociation) ToBotAssociationOutput() BotAssociationOutput {
	return i.ToBotAssociationOutputWithContext(context.Background())
}

func (i *BotAssociation) ToBotAssociationOutputWithContext(ctx context.Context) BotAssociationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BotAssociationOutput)
}

// BotAssociationArrayInput is an input type that accepts BotAssociationArray and BotAssociationArrayOutput values.
// You can construct a concrete instance of `BotAssociationArrayInput` via:
//
//	BotAssociationArray{ BotAssociationArgs{...} }
type BotAssociationArrayInput interface {
	pulumi.Input

	ToBotAssociationArrayOutput() BotAssociationArrayOutput
	ToBotAssociationArrayOutputWithContext(context.Context) BotAssociationArrayOutput
}

type BotAssociationArray []BotAssociationInput

func (BotAssociationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*BotAssociation)(nil)).Elem()
}

func (i BotAssociationArray) ToBotAssociationArrayOutput() BotAssociationArrayOutput {
	return i.ToBotAssociationArrayOutputWithContext(context.Background())
}

func (i BotAssociationArray) ToBotAssociationArrayOutputWithContext(ctx context.Context) BotAssociationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BotAssociationArrayOutput)
}

// BotAssociationMapInput is an input type that accepts BotAssociationMap and BotAssociationMapOutput values.
// You can construct a concrete instance of `BotAssociationMapInput` via:
//
//	BotAssociationMap{ "key": BotAssociationArgs{...} }
type BotAssociationMapInput interface {
	pulumi.Input

	ToBotAssociationMapOutput() BotAssociationMapOutput
	ToBotAssociationMapOutputWithContext(context.Context) BotAssociationMapOutput
}

type BotAssociationMap map[string]BotAssociationInput

func (BotAssociationMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*BotAssociation)(nil)).Elem()
}

func (i BotAssociationMap) ToBotAssociationMapOutput() BotAssociationMapOutput {
	return i.ToBotAssociationMapOutputWithContext(context.Background())
}

func (i BotAssociationMap) ToBotAssociationMapOutputWithContext(ctx context.Context) BotAssociationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BotAssociationMapOutput)
}

type BotAssociationOutput struct{ *pulumi.OutputState }

func (BotAssociationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BotAssociation)(nil)).Elem()
}

func (o BotAssociationOutput) ToBotAssociationOutput() BotAssociationOutput {
	return o
}

func (o BotAssociationOutput) ToBotAssociationOutputWithContext(ctx context.Context) BotAssociationOutput {
	return o
}

func (o BotAssociationOutput) InstanceId() pulumi.StringOutput {
	return o.ApplyT(func(v *BotAssociation) pulumi.StringOutput { return v.InstanceId }).(pulumi.StringOutput)
}

func (o BotAssociationOutput) LexBot() BotAssociationLexBotOutput {
	return o.ApplyT(func(v *BotAssociation) BotAssociationLexBotOutput { return v.LexBot }).(BotAssociationLexBotOutput)
}

func (o BotAssociationOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *BotAssociation) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

type BotAssociationArrayOutput struct{ *pulumi.OutputState }

func (BotAssociationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*BotAssociation)(nil)).Elem()
}

func (o BotAssociationArrayOutput) ToBotAssociationArrayOutput() BotAssociationArrayOutput {
	return o
}

func (o BotAssociationArrayOutput) ToBotAssociationArrayOutputWithContext(ctx context.Context) BotAssociationArrayOutput {
	return o
}

func (o BotAssociationArrayOutput) Index(i pulumi.IntInput) BotAssociationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *BotAssociation {
		return vs[0].([]*BotAssociation)[vs[1].(int)]
	}).(BotAssociationOutput)
}

type BotAssociationMapOutput struct{ *pulumi.OutputState }

func (BotAssociationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*BotAssociation)(nil)).Elem()
}

func (o BotAssociationMapOutput) ToBotAssociationMapOutput() BotAssociationMapOutput {
	return o
}

func (o BotAssociationMapOutput) ToBotAssociationMapOutputWithContext(ctx context.Context) BotAssociationMapOutput {
	return o
}

func (o BotAssociationMapOutput) MapIndex(k pulumi.StringInput) BotAssociationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *BotAssociation {
		return vs[0].(map[string]*BotAssociation)[vs[1].(string)]
	}).(BotAssociationOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*BotAssociationInput)(nil)).Elem(), &BotAssociation{})
	pulumi.RegisterInputType(reflect.TypeOf((*BotAssociationArrayInput)(nil)).Elem(), BotAssociationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BotAssociationMapInput)(nil)).Elem(), BotAssociationMap{})
	pulumi.RegisterOutputType(BotAssociationOutput{})
	pulumi.RegisterOutputType(BotAssociationArrayOutput{})
	pulumi.RegisterOutputType(BotAssociationMapOutput{})
}
