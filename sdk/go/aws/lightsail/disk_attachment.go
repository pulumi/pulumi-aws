// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package lightsail

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Attaches a Lightsail disk to a Lightsail Instance
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-aws/sdk/v5/go/aws"
//	"github.com/pulumi/pulumi-aws/sdk/v5/go/aws/lightsail"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			available, err := aws.GetAvailabilityZones(ctx, &GetAvailabilityZonesArgs{
//				State: pulumi.StringRef("available"),
//				Filters: []GetAvailabilityZonesFilter{
//					GetAvailabilityZonesFilter{
//						Name: "opt-in-status",
//						Values: []string{
//							"opt-in-not-required",
//						},
//					},
//				},
//			}, nil)
//			if err != nil {
//				return err
//			}
//			testDisk, err := lightsail.NewDisk(ctx, "testDisk", &lightsail.DiskArgs{
//				SizeInGb:         pulumi.Int(8),
//				AvailabilityZone: pulumi.String(available.Names[0]),
//			})
//			if err != nil {
//				return err
//			}
//			testInstance, err := lightsail.NewInstance(ctx, "testInstance", &lightsail.InstanceArgs{
//				AvailabilityZone: pulumi.String(available.Names[0]),
//				BlueprintId:      pulumi.String("amazon_linux"),
//				BundleId:         pulumi.String("nano_1_0"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = lightsail.NewDisk_attachment(ctx, "testDisk_attachment", &lightsail.Disk_attachmentArgs{
//				DiskName:     testDisk.Name,
//				InstanceName: testInstance.Name,
//				DiskPath:     pulumi.String("/dev/xvdf"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// `aws_lightsail_disk` can be imported by using the id attribute, e.g.,
//
// ```sh
//
//	$ pulumi import aws:lightsail/disk_attachment:Disk_attachment test test-disk,test-instance
//
// ```
type Disk_attachment struct {
	pulumi.CustomResourceState

	// The name of the Lightsail Disk.
	DiskName pulumi.StringOutput `pulumi:"diskName"`
	// The disk path to expose to the instance.
	DiskPath pulumi.StringOutput `pulumi:"diskPath"`
	// The name of the Lightsail Instance to attach to.
	InstanceName pulumi.StringOutput `pulumi:"instanceName"`
}

// NewDisk_attachment registers a new resource with the given unique name, arguments, and options.
func NewDisk_attachment(ctx *pulumi.Context,
	name string, args *Disk_attachmentArgs, opts ...pulumi.ResourceOption) (*Disk_attachment, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DiskName == nil {
		return nil, errors.New("invalid value for required argument 'DiskName'")
	}
	if args.DiskPath == nil {
		return nil, errors.New("invalid value for required argument 'DiskPath'")
	}
	if args.InstanceName == nil {
		return nil, errors.New("invalid value for required argument 'InstanceName'")
	}
	var resource Disk_attachment
	err := ctx.RegisterResource("aws:lightsail/disk_attachment:Disk_attachment", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDisk_attachment gets an existing Disk_attachment resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDisk_attachment(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *Disk_attachmentState, opts ...pulumi.ResourceOption) (*Disk_attachment, error) {
	var resource Disk_attachment
	err := ctx.ReadResource("aws:lightsail/disk_attachment:Disk_attachment", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Disk_attachment resources.
type disk_attachmentState struct {
	// The name of the Lightsail Disk.
	DiskName *string `pulumi:"diskName"`
	// The disk path to expose to the instance.
	DiskPath *string `pulumi:"diskPath"`
	// The name of the Lightsail Instance to attach to.
	InstanceName *string `pulumi:"instanceName"`
}

type Disk_attachmentState struct {
	// The name of the Lightsail Disk.
	DiskName pulumi.StringPtrInput
	// The disk path to expose to the instance.
	DiskPath pulumi.StringPtrInput
	// The name of the Lightsail Instance to attach to.
	InstanceName pulumi.StringPtrInput
}

func (Disk_attachmentState) ElementType() reflect.Type {
	return reflect.TypeOf((*disk_attachmentState)(nil)).Elem()
}

type disk_attachmentArgs struct {
	// The name of the Lightsail Disk.
	DiskName string `pulumi:"diskName"`
	// The disk path to expose to the instance.
	DiskPath string `pulumi:"diskPath"`
	// The name of the Lightsail Instance to attach to.
	InstanceName string `pulumi:"instanceName"`
}

// The set of arguments for constructing a Disk_attachment resource.
type Disk_attachmentArgs struct {
	// The name of the Lightsail Disk.
	DiskName pulumi.StringInput
	// The disk path to expose to the instance.
	DiskPath pulumi.StringInput
	// The name of the Lightsail Instance to attach to.
	InstanceName pulumi.StringInput
}

func (Disk_attachmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*disk_attachmentArgs)(nil)).Elem()
}

type Disk_attachmentInput interface {
	pulumi.Input

	ToDisk_attachmentOutput() Disk_attachmentOutput
	ToDisk_attachmentOutputWithContext(ctx context.Context) Disk_attachmentOutput
}

func (*Disk_attachment) ElementType() reflect.Type {
	return reflect.TypeOf((**Disk_attachment)(nil)).Elem()
}

func (i *Disk_attachment) ToDisk_attachmentOutput() Disk_attachmentOutput {
	return i.ToDisk_attachmentOutputWithContext(context.Background())
}

func (i *Disk_attachment) ToDisk_attachmentOutputWithContext(ctx context.Context) Disk_attachmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Disk_attachmentOutput)
}

// Disk_attachmentArrayInput is an input type that accepts Disk_attachmentArray and Disk_attachmentArrayOutput values.
// You can construct a concrete instance of `Disk_attachmentArrayInput` via:
//
//	Disk_attachmentArray{ Disk_attachmentArgs{...} }
type Disk_attachmentArrayInput interface {
	pulumi.Input

	ToDisk_attachmentArrayOutput() Disk_attachmentArrayOutput
	ToDisk_attachmentArrayOutputWithContext(context.Context) Disk_attachmentArrayOutput
}

type Disk_attachmentArray []Disk_attachmentInput

func (Disk_attachmentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Disk_attachment)(nil)).Elem()
}

func (i Disk_attachmentArray) ToDisk_attachmentArrayOutput() Disk_attachmentArrayOutput {
	return i.ToDisk_attachmentArrayOutputWithContext(context.Background())
}

func (i Disk_attachmentArray) ToDisk_attachmentArrayOutputWithContext(ctx context.Context) Disk_attachmentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Disk_attachmentArrayOutput)
}

// Disk_attachmentMapInput is an input type that accepts Disk_attachmentMap and Disk_attachmentMapOutput values.
// You can construct a concrete instance of `Disk_attachmentMapInput` via:
//
//	Disk_attachmentMap{ "key": Disk_attachmentArgs{...} }
type Disk_attachmentMapInput interface {
	pulumi.Input

	ToDisk_attachmentMapOutput() Disk_attachmentMapOutput
	ToDisk_attachmentMapOutputWithContext(context.Context) Disk_attachmentMapOutput
}

type Disk_attachmentMap map[string]Disk_attachmentInput

func (Disk_attachmentMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Disk_attachment)(nil)).Elem()
}

func (i Disk_attachmentMap) ToDisk_attachmentMapOutput() Disk_attachmentMapOutput {
	return i.ToDisk_attachmentMapOutputWithContext(context.Background())
}

func (i Disk_attachmentMap) ToDisk_attachmentMapOutputWithContext(ctx context.Context) Disk_attachmentMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(Disk_attachmentMapOutput)
}

type Disk_attachmentOutput struct{ *pulumi.OutputState }

func (Disk_attachmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Disk_attachment)(nil)).Elem()
}

func (o Disk_attachmentOutput) ToDisk_attachmentOutput() Disk_attachmentOutput {
	return o
}

func (o Disk_attachmentOutput) ToDisk_attachmentOutputWithContext(ctx context.Context) Disk_attachmentOutput {
	return o
}

// The name of the Lightsail Disk.
func (o Disk_attachmentOutput) DiskName() pulumi.StringOutput {
	return o.ApplyT(func(v *Disk_attachment) pulumi.StringOutput { return v.DiskName }).(pulumi.StringOutput)
}

// The disk path to expose to the instance.
func (o Disk_attachmentOutput) DiskPath() pulumi.StringOutput {
	return o.ApplyT(func(v *Disk_attachment) pulumi.StringOutput { return v.DiskPath }).(pulumi.StringOutput)
}

// The name of the Lightsail Instance to attach to.
func (o Disk_attachmentOutput) InstanceName() pulumi.StringOutput {
	return o.ApplyT(func(v *Disk_attachment) pulumi.StringOutput { return v.InstanceName }).(pulumi.StringOutput)
}

type Disk_attachmentArrayOutput struct{ *pulumi.OutputState }

func (Disk_attachmentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Disk_attachment)(nil)).Elem()
}

func (o Disk_attachmentArrayOutput) ToDisk_attachmentArrayOutput() Disk_attachmentArrayOutput {
	return o
}

func (o Disk_attachmentArrayOutput) ToDisk_attachmentArrayOutputWithContext(ctx context.Context) Disk_attachmentArrayOutput {
	return o
}

func (o Disk_attachmentArrayOutput) Index(i pulumi.IntInput) Disk_attachmentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Disk_attachment {
		return vs[0].([]*Disk_attachment)[vs[1].(int)]
	}).(Disk_attachmentOutput)
}

type Disk_attachmentMapOutput struct{ *pulumi.OutputState }

func (Disk_attachmentMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Disk_attachment)(nil)).Elem()
}

func (o Disk_attachmentMapOutput) ToDisk_attachmentMapOutput() Disk_attachmentMapOutput {
	return o
}

func (o Disk_attachmentMapOutput) ToDisk_attachmentMapOutputWithContext(ctx context.Context) Disk_attachmentMapOutput {
	return o
}

func (o Disk_attachmentMapOutput) MapIndex(k pulumi.StringInput) Disk_attachmentOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Disk_attachment {
		return vs[0].(map[string]*Disk_attachment)[vs[1].(string)]
	}).(Disk_attachmentOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*Disk_attachmentInput)(nil)).Elem(), &Disk_attachment{})
	pulumi.RegisterInputType(reflect.TypeOf((*Disk_attachmentArrayInput)(nil)).Elem(), Disk_attachmentArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*Disk_attachmentMapInput)(nil)).Elem(), Disk_attachmentMap{})
	pulumi.RegisterOutputType(Disk_attachmentOutput{})
	pulumi.RegisterOutputType(Disk_attachmentArrayOutput{})
	pulumi.RegisterOutputType(Disk_attachmentMapOutput{})
}
