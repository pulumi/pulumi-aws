// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package lightsail

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v7/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type Instance struct {
	pulumi.CustomResourceState

	AddOn            InstanceAddOnPtrOutput   `pulumi:"addOn"`
	Arn              pulumi.StringOutput      `pulumi:"arn"`
	AvailabilityZone pulumi.StringOutput      `pulumi:"availabilityZone"`
	BlueprintId      pulumi.StringOutput      `pulumi:"blueprintId"`
	BundleId         pulumi.StringOutput      `pulumi:"bundleId"`
	CpuCount         pulumi.IntOutput         `pulumi:"cpuCount"`
	CreatedAt        pulumi.StringOutput      `pulumi:"createdAt"`
	IpAddressType    pulumi.StringPtrOutput   `pulumi:"ipAddressType"`
	Ipv6Addresses    pulumi.StringArrayOutput `pulumi:"ipv6Addresses"`
	IsStaticIp       pulumi.BoolOutput        `pulumi:"isStaticIp"`
	KeyPairName      pulumi.StringPtrOutput   `pulumi:"keyPairName"`
	Name             pulumi.StringOutput      `pulumi:"name"`
	PrivateIpAddress pulumi.StringOutput      `pulumi:"privateIpAddress"`
	PublicIpAddress  pulumi.StringOutput      `pulumi:"publicIpAddress"`
	RamSize          pulumi.Float64Output     `pulumi:"ramSize"`
	Region           pulumi.StringOutput      `pulumi:"region"`
	Tags             pulumi.StringMapOutput   `pulumi:"tags"`
	TagsAll          pulumi.StringMapOutput   `pulumi:"tagsAll"`
	UserData         pulumi.StringPtrOutput   `pulumi:"userData"`
	Username         pulumi.StringOutput      `pulumi:"username"`
}

// NewInstance registers a new resource with the given unique name, arguments, and options.
func NewInstance(ctx *pulumi.Context,
	name string, args *InstanceArgs, opts ...pulumi.ResourceOption) (*Instance, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AvailabilityZone == nil {
		return nil, errors.New("invalid value for required argument 'AvailabilityZone'")
	}
	if args.BlueprintId == nil {
		return nil, errors.New("invalid value for required argument 'BlueprintId'")
	}
	if args.BundleId == nil {
		return nil, errors.New("invalid value for required argument 'BundleId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Instance
	err := ctx.RegisterResource("aws:lightsail/instance:Instance", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetInstance gets an existing Instance resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetInstance(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *InstanceState, opts ...pulumi.ResourceOption) (*Instance, error) {
	var resource Instance
	err := ctx.ReadResource("aws:lightsail/instance:Instance", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Instance resources.
type instanceState struct {
	AddOn            *InstanceAddOn    `pulumi:"addOn"`
	Arn              *string           `pulumi:"arn"`
	AvailabilityZone *string           `pulumi:"availabilityZone"`
	BlueprintId      *string           `pulumi:"blueprintId"`
	BundleId         *string           `pulumi:"bundleId"`
	CpuCount         *int              `pulumi:"cpuCount"`
	CreatedAt        *string           `pulumi:"createdAt"`
	IpAddressType    *string           `pulumi:"ipAddressType"`
	Ipv6Addresses    []string          `pulumi:"ipv6Addresses"`
	IsStaticIp       *bool             `pulumi:"isStaticIp"`
	KeyPairName      *string           `pulumi:"keyPairName"`
	Name             *string           `pulumi:"name"`
	PrivateIpAddress *string           `pulumi:"privateIpAddress"`
	PublicIpAddress  *string           `pulumi:"publicIpAddress"`
	RamSize          *float64          `pulumi:"ramSize"`
	Region           *string           `pulumi:"region"`
	Tags             map[string]string `pulumi:"tags"`
	TagsAll          map[string]string `pulumi:"tagsAll"`
	UserData         *string           `pulumi:"userData"`
	Username         *string           `pulumi:"username"`
}

type InstanceState struct {
	AddOn            InstanceAddOnPtrInput
	Arn              pulumi.StringPtrInput
	AvailabilityZone pulumi.StringPtrInput
	BlueprintId      pulumi.StringPtrInput
	BundleId         pulumi.StringPtrInput
	CpuCount         pulumi.IntPtrInput
	CreatedAt        pulumi.StringPtrInput
	IpAddressType    pulumi.StringPtrInput
	Ipv6Addresses    pulumi.StringArrayInput
	IsStaticIp       pulumi.BoolPtrInput
	KeyPairName      pulumi.StringPtrInput
	Name             pulumi.StringPtrInput
	PrivateIpAddress pulumi.StringPtrInput
	PublicIpAddress  pulumi.StringPtrInput
	RamSize          pulumi.Float64PtrInput
	Region           pulumi.StringPtrInput
	Tags             pulumi.StringMapInput
	TagsAll          pulumi.StringMapInput
	UserData         pulumi.StringPtrInput
	Username         pulumi.StringPtrInput
}

func (InstanceState) ElementType() reflect.Type {
	return reflect.TypeOf((*instanceState)(nil)).Elem()
}

type instanceArgs struct {
	AddOn            *InstanceAddOn    `pulumi:"addOn"`
	AvailabilityZone string            `pulumi:"availabilityZone"`
	BlueprintId      string            `pulumi:"blueprintId"`
	BundleId         string            `pulumi:"bundleId"`
	IpAddressType    *string           `pulumi:"ipAddressType"`
	KeyPairName      *string           `pulumi:"keyPairName"`
	Name             *string           `pulumi:"name"`
	Region           *string           `pulumi:"region"`
	Tags             map[string]string `pulumi:"tags"`
	UserData         *string           `pulumi:"userData"`
}

// The set of arguments for constructing a Instance resource.
type InstanceArgs struct {
	AddOn            InstanceAddOnPtrInput
	AvailabilityZone pulumi.StringInput
	BlueprintId      pulumi.StringInput
	BundleId         pulumi.StringInput
	IpAddressType    pulumi.StringPtrInput
	KeyPairName      pulumi.StringPtrInput
	Name             pulumi.StringPtrInput
	Region           pulumi.StringPtrInput
	Tags             pulumi.StringMapInput
	UserData         pulumi.StringPtrInput
}

func (InstanceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*instanceArgs)(nil)).Elem()
}

type InstanceInput interface {
	pulumi.Input

	ToInstanceOutput() InstanceOutput
	ToInstanceOutputWithContext(ctx context.Context) InstanceOutput
}

func (*Instance) ElementType() reflect.Type {
	return reflect.TypeOf((**Instance)(nil)).Elem()
}

func (i *Instance) ToInstanceOutput() InstanceOutput {
	return i.ToInstanceOutputWithContext(context.Background())
}

func (i *Instance) ToInstanceOutputWithContext(ctx context.Context) InstanceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceOutput)
}

// InstanceArrayInput is an input type that accepts InstanceArray and InstanceArrayOutput values.
// You can construct a concrete instance of `InstanceArrayInput` via:
//
//	InstanceArray{ InstanceArgs{...} }
type InstanceArrayInput interface {
	pulumi.Input

	ToInstanceArrayOutput() InstanceArrayOutput
	ToInstanceArrayOutputWithContext(context.Context) InstanceArrayOutput
}

type InstanceArray []InstanceInput

func (InstanceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Instance)(nil)).Elem()
}

func (i InstanceArray) ToInstanceArrayOutput() InstanceArrayOutput {
	return i.ToInstanceArrayOutputWithContext(context.Background())
}

func (i InstanceArray) ToInstanceArrayOutputWithContext(ctx context.Context) InstanceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceArrayOutput)
}

// InstanceMapInput is an input type that accepts InstanceMap and InstanceMapOutput values.
// You can construct a concrete instance of `InstanceMapInput` via:
//
//	InstanceMap{ "key": InstanceArgs{...} }
type InstanceMapInput interface {
	pulumi.Input

	ToInstanceMapOutput() InstanceMapOutput
	ToInstanceMapOutputWithContext(context.Context) InstanceMapOutput
}

type InstanceMap map[string]InstanceInput

func (InstanceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Instance)(nil)).Elem()
}

func (i InstanceMap) ToInstanceMapOutput() InstanceMapOutput {
	return i.ToInstanceMapOutputWithContext(context.Background())
}

func (i InstanceMap) ToInstanceMapOutputWithContext(ctx context.Context) InstanceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceMapOutput)
}

type InstanceOutput struct{ *pulumi.OutputState }

func (InstanceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Instance)(nil)).Elem()
}

func (o InstanceOutput) ToInstanceOutput() InstanceOutput {
	return o
}

func (o InstanceOutput) ToInstanceOutputWithContext(ctx context.Context) InstanceOutput {
	return o
}

func (o InstanceOutput) AddOn() InstanceAddOnPtrOutput {
	return o.ApplyT(func(v *Instance) InstanceAddOnPtrOutput { return v.AddOn }).(InstanceAddOnPtrOutput)
}

func (o InstanceOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.Arn }).(pulumi.StringOutput)
}

func (o InstanceOutput) AvailabilityZone() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.AvailabilityZone }).(pulumi.StringOutput)
}

func (o InstanceOutput) BlueprintId() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.BlueprintId }).(pulumi.StringOutput)
}

func (o InstanceOutput) BundleId() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.BundleId }).(pulumi.StringOutput)
}

func (o InstanceOutput) CpuCount() pulumi.IntOutput {
	return o.ApplyT(func(v *Instance) pulumi.IntOutput { return v.CpuCount }).(pulumi.IntOutput)
}

func (o InstanceOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

func (o InstanceOutput) IpAddressType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringPtrOutput { return v.IpAddressType }).(pulumi.StringPtrOutput)
}

func (o InstanceOutput) Ipv6Addresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringArrayOutput { return v.Ipv6Addresses }).(pulumi.StringArrayOutput)
}

func (o InstanceOutput) IsStaticIp() pulumi.BoolOutput {
	return o.ApplyT(func(v *Instance) pulumi.BoolOutput { return v.IsStaticIp }).(pulumi.BoolOutput)
}

func (o InstanceOutput) KeyPairName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringPtrOutput { return v.KeyPairName }).(pulumi.StringPtrOutput)
}

func (o InstanceOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o InstanceOutput) PrivateIpAddress() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.PrivateIpAddress }).(pulumi.StringOutput)
}

func (o InstanceOutput) PublicIpAddress() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.PublicIpAddress }).(pulumi.StringOutput)
}

func (o InstanceOutput) RamSize() pulumi.Float64Output {
	return o.ApplyT(func(v *Instance) pulumi.Float64Output { return v.RamSize }).(pulumi.Float64Output)
}

func (o InstanceOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

func (o InstanceOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

func (o InstanceOutput) TagsAll() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringMapOutput { return v.TagsAll }).(pulumi.StringMapOutput)
}

func (o InstanceOutput) UserData() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringPtrOutput { return v.UserData }).(pulumi.StringPtrOutput)
}

func (o InstanceOutput) Username() pulumi.StringOutput {
	return o.ApplyT(func(v *Instance) pulumi.StringOutput { return v.Username }).(pulumi.StringOutput)
}

type InstanceArrayOutput struct{ *pulumi.OutputState }

func (InstanceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Instance)(nil)).Elem()
}

func (o InstanceArrayOutput) ToInstanceArrayOutput() InstanceArrayOutput {
	return o
}

func (o InstanceArrayOutput) ToInstanceArrayOutputWithContext(ctx context.Context) InstanceArrayOutput {
	return o
}

func (o InstanceArrayOutput) Index(i pulumi.IntInput) InstanceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Instance {
		return vs[0].([]*Instance)[vs[1].(int)]
	}).(InstanceOutput)
}

type InstanceMapOutput struct{ *pulumi.OutputState }

func (InstanceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Instance)(nil)).Elem()
}

func (o InstanceMapOutput) ToInstanceMapOutput() InstanceMapOutput {
	return o
}

func (o InstanceMapOutput) ToInstanceMapOutputWithContext(ctx context.Context) InstanceMapOutput {
	return o
}

func (o InstanceMapOutput) MapIndex(k pulumi.StringInput) InstanceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Instance {
		return vs[0].(map[string]*Instance)[vs[1].(string)]
	}).(InstanceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceInput)(nil)).Elem(), &Instance{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceArrayInput)(nil)).Elem(), InstanceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceMapInput)(nil)).Elem(), InstanceMap{})
	pulumi.RegisterOutputType(InstanceOutput{})
	pulumi.RegisterOutputType(InstanceArrayOutput{})
	pulumi.RegisterOutputType(InstanceMapOutput{})
}
