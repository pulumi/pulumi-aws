// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package codebuild

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v7/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type Fleet struct {
	pulumi.CustomResourceState

	Arn                  pulumi.StringOutput                `pulumi:"arn"`
	BaseCapacity         pulumi.IntOutput                   `pulumi:"baseCapacity"`
	ComputeConfiguration FleetComputeConfigurationPtrOutput `pulumi:"computeConfiguration"`
	ComputeType          pulumi.StringOutput                `pulumi:"computeType"`
	Created              pulumi.StringOutput                `pulumi:"created"`
	EnvironmentType      pulumi.StringOutput                `pulumi:"environmentType"`
	FleetServiceRole     pulumi.StringPtrOutput             `pulumi:"fleetServiceRole"`
	ImageId              pulumi.StringPtrOutput             `pulumi:"imageId"`
	LastModified         pulumi.StringOutput                `pulumi:"lastModified"`
	Name                 pulumi.StringOutput                `pulumi:"name"`
	OverflowBehavior     pulumi.StringOutput                `pulumi:"overflowBehavior"`
	Region               pulumi.StringOutput                `pulumi:"region"`
	ScalingConfiguration FleetScalingConfigurationPtrOutput `pulumi:"scalingConfiguration"`
	Statuses             FleetStatusArrayOutput             `pulumi:"statuses"`
	Tags                 pulumi.StringMapOutput             `pulumi:"tags"`
	TagsAll              pulumi.StringMapOutput             `pulumi:"tagsAll"`
	VpcConfigs           FleetVpcConfigArrayOutput          `pulumi:"vpcConfigs"`
}

// NewFleet registers a new resource with the given unique name, arguments, and options.
func NewFleet(ctx *pulumi.Context,
	name string, args *FleetArgs, opts ...pulumi.ResourceOption) (*Fleet, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.BaseCapacity == nil {
		return nil, errors.New("invalid value for required argument 'BaseCapacity'")
	}
	if args.ComputeType == nil {
		return nil, errors.New("invalid value for required argument 'ComputeType'")
	}
	if args.EnvironmentType == nil {
		return nil, errors.New("invalid value for required argument 'EnvironmentType'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Fleet
	err := ctx.RegisterResource("aws:codebuild/fleet:Fleet", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFleet gets an existing Fleet resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFleet(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FleetState, opts ...pulumi.ResourceOption) (*Fleet, error) {
	var resource Fleet
	err := ctx.ReadResource("aws:codebuild/fleet:Fleet", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Fleet resources.
type fleetState struct {
	Arn                  *string                    `pulumi:"arn"`
	BaseCapacity         *int                       `pulumi:"baseCapacity"`
	ComputeConfiguration *FleetComputeConfiguration `pulumi:"computeConfiguration"`
	ComputeType          *string                    `pulumi:"computeType"`
	Created              *string                    `pulumi:"created"`
	EnvironmentType      *string                    `pulumi:"environmentType"`
	FleetServiceRole     *string                    `pulumi:"fleetServiceRole"`
	ImageId              *string                    `pulumi:"imageId"`
	LastModified         *string                    `pulumi:"lastModified"`
	Name                 *string                    `pulumi:"name"`
	OverflowBehavior     *string                    `pulumi:"overflowBehavior"`
	Region               *string                    `pulumi:"region"`
	ScalingConfiguration *FleetScalingConfiguration `pulumi:"scalingConfiguration"`
	Statuses             []FleetStatus              `pulumi:"statuses"`
	Tags                 map[string]string          `pulumi:"tags"`
	TagsAll              map[string]string          `pulumi:"tagsAll"`
	VpcConfigs           []FleetVpcConfig           `pulumi:"vpcConfigs"`
}

type FleetState struct {
	Arn                  pulumi.StringPtrInput
	BaseCapacity         pulumi.IntPtrInput
	ComputeConfiguration FleetComputeConfigurationPtrInput
	ComputeType          pulumi.StringPtrInput
	Created              pulumi.StringPtrInput
	EnvironmentType      pulumi.StringPtrInput
	FleetServiceRole     pulumi.StringPtrInput
	ImageId              pulumi.StringPtrInput
	LastModified         pulumi.StringPtrInput
	Name                 pulumi.StringPtrInput
	OverflowBehavior     pulumi.StringPtrInput
	Region               pulumi.StringPtrInput
	ScalingConfiguration FleetScalingConfigurationPtrInput
	Statuses             FleetStatusArrayInput
	Tags                 pulumi.StringMapInput
	TagsAll              pulumi.StringMapInput
	VpcConfigs           FleetVpcConfigArrayInput
}

func (FleetState) ElementType() reflect.Type {
	return reflect.TypeOf((*fleetState)(nil)).Elem()
}

type fleetArgs struct {
	BaseCapacity         int                        `pulumi:"baseCapacity"`
	ComputeConfiguration *FleetComputeConfiguration `pulumi:"computeConfiguration"`
	ComputeType          string                     `pulumi:"computeType"`
	EnvironmentType      string                     `pulumi:"environmentType"`
	FleetServiceRole     *string                    `pulumi:"fleetServiceRole"`
	ImageId              *string                    `pulumi:"imageId"`
	Name                 *string                    `pulumi:"name"`
	OverflowBehavior     *string                    `pulumi:"overflowBehavior"`
	Region               *string                    `pulumi:"region"`
	ScalingConfiguration *FleetScalingConfiguration `pulumi:"scalingConfiguration"`
	Tags                 map[string]string          `pulumi:"tags"`
	VpcConfigs           []FleetVpcConfig           `pulumi:"vpcConfigs"`
}

// The set of arguments for constructing a Fleet resource.
type FleetArgs struct {
	BaseCapacity         pulumi.IntInput
	ComputeConfiguration FleetComputeConfigurationPtrInput
	ComputeType          pulumi.StringInput
	EnvironmentType      pulumi.StringInput
	FleetServiceRole     pulumi.StringPtrInput
	ImageId              pulumi.StringPtrInput
	Name                 pulumi.StringPtrInput
	OverflowBehavior     pulumi.StringPtrInput
	Region               pulumi.StringPtrInput
	ScalingConfiguration FleetScalingConfigurationPtrInput
	Tags                 pulumi.StringMapInput
	VpcConfigs           FleetVpcConfigArrayInput
}

func (FleetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*fleetArgs)(nil)).Elem()
}

type FleetInput interface {
	pulumi.Input

	ToFleetOutput() FleetOutput
	ToFleetOutputWithContext(ctx context.Context) FleetOutput
}

func (*Fleet) ElementType() reflect.Type {
	return reflect.TypeOf((**Fleet)(nil)).Elem()
}

func (i *Fleet) ToFleetOutput() FleetOutput {
	return i.ToFleetOutputWithContext(context.Background())
}

func (i *Fleet) ToFleetOutputWithContext(ctx context.Context) FleetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetOutput)
}

// FleetArrayInput is an input type that accepts FleetArray and FleetArrayOutput values.
// You can construct a concrete instance of `FleetArrayInput` via:
//
//	FleetArray{ FleetArgs{...} }
type FleetArrayInput interface {
	pulumi.Input

	ToFleetArrayOutput() FleetArrayOutput
	ToFleetArrayOutputWithContext(context.Context) FleetArrayOutput
}

type FleetArray []FleetInput

func (FleetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Fleet)(nil)).Elem()
}

func (i FleetArray) ToFleetArrayOutput() FleetArrayOutput {
	return i.ToFleetArrayOutputWithContext(context.Background())
}

func (i FleetArray) ToFleetArrayOutputWithContext(ctx context.Context) FleetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetArrayOutput)
}

// FleetMapInput is an input type that accepts FleetMap and FleetMapOutput values.
// You can construct a concrete instance of `FleetMapInput` via:
//
//	FleetMap{ "key": FleetArgs{...} }
type FleetMapInput interface {
	pulumi.Input

	ToFleetMapOutput() FleetMapOutput
	ToFleetMapOutputWithContext(context.Context) FleetMapOutput
}

type FleetMap map[string]FleetInput

func (FleetMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Fleet)(nil)).Elem()
}

func (i FleetMap) ToFleetMapOutput() FleetMapOutput {
	return i.ToFleetMapOutputWithContext(context.Background())
}

func (i FleetMap) ToFleetMapOutputWithContext(ctx context.Context) FleetMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetMapOutput)
}

type FleetOutput struct{ *pulumi.OutputState }

func (FleetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Fleet)(nil)).Elem()
}

func (o FleetOutput) ToFleetOutput() FleetOutput {
	return o
}

func (o FleetOutput) ToFleetOutputWithContext(ctx context.Context) FleetOutput {
	return o
}

func (o FleetOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringOutput { return v.Arn }).(pulumi.StringOutput)
}

func (o FleetOutput) BaseCapacity() pulumi.IntOutput {
	return o.ApplyT(func(v *Fleet) pulumi.IntOutput { return v.BaseCapacity }).(pulumi.IntOutput)
}

func (o FleetOutput) ComputeConfiguration() FleetComputeConfigurationPtrOutput {
	return o.ApplyT(func(v *Fleet) FleetComputeConfigurationPtrOutput { return v.ComputeConfiguration }).(FleetComputeConfigurationPtrOutput)
}

func (o FleetOutput) ComputeType() pulumi.StringOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringOutput { return v.ComputeType }).(pulumi.StringOutput)
}

func (o FleetOutput) Created() pulumi.StringOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringOutput { return v.Created }).(pulumi.StringOutput)
}

func (o FleetOutput) EnvironmentType() pulumi.StringOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringOutput { return v.EnvironmentType }).(pulumi.StringOutput)
}

func (o FleetOutput) FleetServiceRole() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringPtrOutput { return v.FleetServiceRole }).(pulumi.StringPtrOutput)
}

func (o FleetOutput) ImageId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringPtrOutput { return v.ImageId }).(pulumi.StringPtrOutput)
}

func (o FleetOutput) LastModified() pulumi.StringOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringOutput { return v.LastModified }).(pulumi.StringOutput)
}

func (o FleetOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o FleetOutput) OverflowBehavior() pulumi.StringOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringOutput { return v.OverflowBehavior }).(pulumi.StringOutput)
}

func (o FleetOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

func (o FleetOutput) ScalingConfiguration() FleetScalingConfigurationPtrOutput {
	return o.ApplyT(func(v *Fleet) FleetScalingConfigurationPtrOutput { return v.ScalingConfiguration }).(FleetScalingConfigurationPtrOutput)
}

func (o FleetOutput) Statuses() FleetStatusArrayOutput {
	return o.ApplyT(func(v *Fleet) FleetStatusArrayOutput { return v.Statuses }).(FleetStatusArrayOutput)
}

func (o FleetOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

func (o FleetOutput) TagsAll() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringMapOutput { return v.TagsAll }).(pulumi.StringMapOutput)
}

func (o FleetOutput) VpcConfigs() FleetVpcConfigArrayOutput {
	return o.ApplyT(func(v *Fleet) FleetVpcConfigArrayOutput { return v.VpcConfigs }).(FleetVpcConfigArrayOutput)
}

type FleetArrayOutput struct{ *pulumi.OutputState }

func (FleetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Fleet)(nil)).Elem()
}

func (o FleetArrayOutput) ToFleetArrayOutput() FleetArrayOutput {
	return o
}

func (o FleetArrayOutput) ToFleetArrayOutputWithContext(ctx context.Context) FleetArrayOutput {
	return o
}

func (o FleetArrayOutput) Index(i pulumi.IntInput) FleetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Fleet {
		return vs[0].([]*Fleet)[vs[1].(int)]
	}).(FleetOutput)
}

type FleetMapOutput struct{ *pulumi.OutputState }

func (FleetMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Fleet)(nil)).Elem()
}

func (o FleetMapOutput) ToFleetMapOutput() FleetMapOutput {
	return o
}

func (o FleetMapOutput) ToFleetMapOutputWithContext(ctx context.Context) FleetMapOutput {
	return o
}

func (o FleetMapOutput) MapIndex(k pulumi.StringInput) FleetOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Fleet {
		return vs[0].(map[string]*Fleet)[vs[1].(string)]
	}).(FleetOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FleetInput)(nil)).Elem(), &Fleet{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetArrayInput)(nil)).Elem(), FleetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetMapInput)(nil)).Elem(), FleetMap{})
	pulumi.RegisterOutputType(FleetOutput{})
	pulumi.RegisterOutputType(FleetArrayOutput{})
	pulumi.RegisterOutputType(FleetMapOutput{})
}
