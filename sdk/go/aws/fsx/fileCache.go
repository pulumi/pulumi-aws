// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package fsx

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type FileCache struct {
	pulumi.CustomResourceState

	Arn                                  pulumi.StringOutput                           `pulumi:"arn"`
	CopyTagsToDataRepositoryAssociations pulumi.BoolPtrOutput                          `pulumi:"copyTagsToDataRepositoryAssociations"`
	DataRepositoryAssociationIds         pulumi.StringArrayOutput                      `pulumi:"dataRepositoryAssociationIds"`
	DataRepositoryAssociations           FileCacheDataRepositoryAssociationArrayOutput `pulumi:"dataRepositoryAssociations"`
	DnsName                              pulumi.StringOutput                           `pulumi:"dnsName"`
	FileCacheId                          pulumi.StringOutput                           `pulumi:"fileCacheId"`
	FileCacheType                        pulumi.StringOutput                           `pulumi:"fileCacheType"`
	FileCacheTypeVersion                 pulumi.StringOutput                           `pulumi:"fileCacheTypeVersion"`
	KmsKeyId                             pulumi.StringOutput                           `pulumi:"kmsKeyId"`
	LustreConfigurations                 FileCacheLustreConfigurationArrayOutput       `pulumi:"lustreConfigurations"`
	NetworkInterfaceIds                  pulumi.StringArrayOutput                      `pulumi:"networkInterfaceIds"`
	OwnerId                              pulumi.StringOutput                           `pulumi:"ownerId"`
	SecurityGroupIds                     pulumi.StringArrayOutput                      `pulumi:"securityGroupIds"`
	StorageCapacity                      pulumi.IntOutput                              `pulumi:"storageCapacity"`
	SubnetIds                            pulumi.StringArrayOutput                      `pulumi:"subnetIds"`
	Tags                                 pulumi.StringMapOutput                        `pulumi:"tags"`
	TagsAll                              pulumi.StringMapOutput                        `pulumi:"tagsAll"`
	VpcId                                pulumi.StringOutput                           `pulumi:"vpcId"`
}

// NewFileCache registers a new resource with the given unique name, arguments, and options.
func NewFileCache(ctx *pulumi.Context,
	name string, args *FileCacheArgs, opts ...pulumi.ResourceOption) (*FileCache, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.FileCacheType == nil {
		return nil, errors.New("invalid value for required argument 'FileCacheType'")
	}
	if args.FileCacheTypeVersion == nil {
		return nil, errors.New("invalid value for required argument 'FileCacheTypeVersion'")
	}
	if args.StorageCapacity == nil {
		return nil, errors.New("invalid value for required argument 'StorageCapacity'")
	}
	if args.SubnetIds == nil {
		return nil, errors.New("invalid value for required argument 'SubnetIds'")
	}
	var resource FileCache
	err := ctx.RegisterResource("aws:fsx/fileCache:FileCache", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFileCache gets an existing FileCache resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFileCache(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FileCacheState, opts ...pulumi.ResourceOption) (*FileCache, error) {
	var resource FileCache
	err := ctx.ReadResource("aws:fsx/fileCache:FileCache", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering FileCache resources.
type fileCacheState struct {
	Arn                                  *string                              `pulumi:"arn"`
	CopyTagsToDataRepositoryAssociations *bool                                `pulumi:"copyTagsToDataRepositoryAssociations"`
	DataRepositoryAssociationIds         []string                             `pulumi:"dataRepositoryAssociationIds"`
	DataRepositoryAssociations           []FileCacheDataRepositoryAssociation `pulumi:"dataRepositoryAssociations"`
	DnsName                              *string                              `pulumi:"dnsName"`
	FileCacheId                          *string                              `pulumi:"fileCacheId"`
	FileCacheType                        *string                              `pulumi:"fileCacheType"`
	FileCacheTypeVersion                 *string                              `pulumi:"fileCacheTypeVersion"`
	KmsKeyId                             *string                              `pulumi:"kmsKeyId"`
	LustreConfigurations                 []FileCacheLustreConfiguration       `pulumi:"lustreConfigurations"`
	NetworkInterfaceIds                  []string                             `pulumi:"networkInterfaceIds"`
	OwnerId                              *string                              `pulumi:"ownerId"`
	SecurityGroupIds                     []string                             `pulumi:"securityGroupIds"`
	StorageCapacity                      *int                                 `pulumi:"storageCapacity"`
	SubnetIds                            []string                             `pulumi:"subnetIds"`
	Tags                                 map[string]string                    `pulumi:"tags"`
	TagsAll                              map[string]string                    `pulumi:"tagsAll"`
	VpcId                                *string                              `pulumi:"vpcId"`
}

type FileCacheState struct {
	Arn                                  pulumi.StringPtrInput
	CopyTagsToDataRepositoryAssociations pulumi.BoolPtrInput
	DataRepositoryAssociationIds         pulumi.StringArrayInput
	DataRepositoryAssociations           FileCacheDataRepositoryAssociationArrayInput
	DnsName                              pulumi.StringPtrInput
	FileCacheId                          pulumi.StringPtrInput
	FileCacheType                        pulumi.StringPtrInput
	FileCacheTypeVersion                 pulumi.StringPtrInput
	KmsKeyId                             pulumi.StringPtrInput
	LustreConfigurations                 FileCacheLustreConfigurationArrayInput
	NetworkInterfaceIds                  pulumi.StringArrayInput
	OwnerId                              pulumi.StringPtrInput
	SecurityGroupIds                     pulumi.StringArrayInput
	StorageCapacity                      pulumi.IntPtrInput
	SubnetIds                            pulumi.StringArrayInput
	Tags                                 pulumi.StringMapInput
	TagsAll                              pulumi.StringMapInput
	VpcId                                pulumi.StringPtrInput
}

func (FileCacheState) ElementType() reflect.Type {
	return reflect.TypeOf((*fileCacheState)(nil)).Elem()
}

type fileCacheArgs struct {
	CopyTagsToDataRepositoryAssociations *bool                                `pulumi:"copyTagsToDataRepositoryAssociations"`
	DataRepositoryAssociations           []FileCacheDataRepositoryAssociation `pulumi:"dataRepositoryAssociations"`
	FileCacheType                        string                               `pulumi:"fileCacheType"`
	FileCacheTypeVersion                 string                               `pulumi:"fileCacheTypeVersion"`
	KmsKeyId                             *string                              `pulumi:"kmsKeyId"`
	LustreConfigurations                 []FileCacheLustreConfiguration       `pulumi:"lustreConfigurations"`
	SecurityGroupIds                     []string                             `pulumi:"securityGroupIds"`
	StorageCapacity                      int                                  `pulumi:"storageCapacity"`
	SubnetIds                            []string                             `pulumi:"subnetIds"`
	Tags                                 map[string]string                    `pulumi:"tags"`
}

// The set of arguments for constructing a FileCache resource.
type FileCacheArgs struct {
	CopyTagsToDataRepositoryAssociations pulumi.BoolPtrInput
	DataRepositoryAssociations           FileCacheDataRepositoryAssociationArrayInput
	FileCacheType                        pulumi.StringInput
	FileCacheTypeVersion                 pulumi.StringInput
	KmsKeyId                             pulumi.StringPtrInput
	LustreConfigurations                 FileCacheLustreConfigurationArrayInput
	SecurityGroupIds                     pulumi.StringArrayInput
	StorageCapacity                      pulumi.IntInput
	SubnetIds                            pulumi.StringArrayInput
	Tags                                 pulumi.StringMapInput
}

func (FileCacheArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*fileCacheArgs)(nil)).Elem()
}

type FileCacheInput interface {
	pulumi.Input

	ToFileCacheOutput() FileCacheOutput
	ToFileCacheOutputWithContext(ctx context.Context) FileCacheOutput
}

func (*FileCache) ElementType() reflect.Type {
	return reflect.TypeOf((**FileCache)(nil)).Elem()
}

func (i *FileCache) ToFileCacheOutput() FileCacheOutput {
	return i.ToFileCacheOutputWithContext(context.Background())
}

func (i *FileCache) ToFileCacheOutputWithContext(ctx context.Context) FileCacheOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileCacheOutput)
}

// FileCacheArrayInput is an input type that accepts FileCacheArray and FileCacheArrayOutput values.
// You can construct a concrete instance of `FileCacheArrayInput` via:
//
//	FileCacheArray{ FileCacheArgs{...} }
type FileCacheArrayInput interface {
	pulumi.Input

	ToFileCacheArrayOutput() FileCacheArrayOutput
	ToFileCacheArrayOutputWithContext(context.Context) FileCacheArrayOutput
}

type FileCacheArray []FileCacheInput

func (FileCacheArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FileCache)(nil)).Elem()
}

func (i FileCacheArray) ToFileCacheArrayOutput() FileCacheArrayOutput {
	return i.ToFileCacheArrayOutputWithContext(context.Background())
}

func (i FileCacheArray) ToFileCacheArrayOutputWithContext(ctx context.Context) FileCacheArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileCacheArrayOutput)
}

// FileCacheMapInput is an input type that accepts FileCacheMap and FileCacheMapOutput values.
// You can construct a concrete instance of `FileCacheMapInput` via:
//
//	FileCacheMap{ "key": FileCacheArgs{...} }
type FileCacheMapInput interface {
	pulumi.Input

	ToFileCacheMapOutput() FileCacheMapOutput
	ToFileCacheMapOutputWithContext(context.Context) FileCacheMapOutput
}

type FileCacheMap map[string]FileCacheInput

func (FileCacheMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FileCache)(nil)).Elem()
}

func (i FileCacheMap) ToFileCacheMapOutput() FileCacheMapOutput {
	return i.ToFileCacheMapOutputWithContext(context.Background())
}

func (i FileCacheMap) ToFileCacheMapOutputWithContext(ctx context.Context) FileCacheMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FileCacheMapOutput)
}

type FileCacheOutput struct{ *pulumi.OutputState }

func (FileCacheOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FileCache)(nil)).Elem()
}

func (o FileCacheOutput) ToFileCacheOutput() FileCacheOutput {
	return o
}

func (o FileCacheOutput) ToFileCacheOutputWithContext(ctx context.Context) FileCacheOutput {
	return o
}

func (o FileCacheOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v *FileCache) pulumi.StringOutput { return v.Arn }).(pulumi.StringOutput)
}

func (o FileCacheOutput) CopyTagsToDataRepositoryAssociations() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *FileCache) pulumi.BoolPtrOutput { return v.CopyTagsToDataRepositoryAssociations }).(pulumi.BoolPtrOutput)
}

func (o FileCacheOutput) DataRepositoryAssociationIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FileCache) pulumi.StringArrayOutput { return v.DataRepositoryAssociationIds }).(pulumi.StringArrayOutput)
}

func (o FileCacheOutput) DataRepositoryAssociations() FileCacheDataRepositoryAssociationArrayOutput {
	return o.ApplyT(func(v *FileCache) FileCacheDataRepositoryAssociationArrayOutput { return v.DataRepositoryAssociations }).(FileCacheDataRepositoryAssociationArrayOutput)
}

func (o FileCacheOutput) DnsName() pulumi.StringOutput {
	return o.ApplyT(func(v *FileCache) pulumi.StringOutput { return v.DnsName }).(pulumi.StringOutput)
}

func (o FileCacheOutput) FileCacheId() pulumi.StringOutput {
	return o.ApplyT(func(v *FileCache) pulumi.StringOutput { return v.FileCacheId }).(pulumi.StringOutput)
}

func (o FileCacheOutput) FileCacheType() pulumi.StringOutput {
	return o.ApplyT(func(v *FileCache) pulumi.StringOutput { return v.FileCacheType }).(pulumi.StringOutput)
}

func (o FileCacheOutput) FileCacheTypeVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *FileCache) pulumi.StringOutput { return v.FileCacheTypeVersion }).(pulumi.StringOutput)
}

func (o FileCacheOutput) KmsKeyId() pulumi.StringOutput {
	return o.ApplyT(func(v *FileCache) pulumi.StringOutput { return v.KmsKeyId }).(pulumi.StringOutput)
}

func (o FileCacheOutput) LustreConfigurations() FileCacheLustreConfigurationArrayOutput {
	return o.ApplyT(func(v *FileCache) FileCacheLustreConfigurationArrayOutput { return v.LustreConfigurations }).(FileCacheLustreConfigurationArrayOutput)
}

func (o FileCacheOutput) NetworkInterfaceIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FileCache) pulumi.StringArrayOutput { return v.NetworkInterfaceIds }).(pulumi.StringArrayOutput)
}

func (o FileCacheOutput) OwnerId() pulumi.StringOutput {
	return o.ApplyT(func(v *FileCache) pulumi.StringOutput { return v.OwnerId }).(pulumi.StringOutput)
}

func (o FileCacheOutput) SecurityGroupIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FileCache) pulumi.StringArrayOutput { return v.SecurityGroupIds }).(pulumi.StringArrayOutput)
}

func (o FileCacheOutput) StorageCapacity() pulumi.IntOutput {
	return o.ApplyT(func(v *FileCache) pulumi.IntOutput { return v.StorageCapacity }).(pulumi.IntOutput)
}

func (o FileCacheOutput) SubnetIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FileCache) pulumi.StringArrayOutput { return v.SubnetIds }).(pulumi.StringArrayOutput)
}

func (o FileCacheOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *FileCache) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

func (o FileCacheOutput) TagsAll() pulumi.StringMapOutput {
	return o.ApplyT(func(v *FileCache) pulumi.StringMapOutput { return v.TagsAll }).(pulumi.StringMapOutput)
}

func (o FileCacheOutput) VpcId() pulumi.StringOutput {
	return o.ApplyT(func(v *FileCache) pulumi.StringOutput { return v.VpcId }).(pulumi.StringOutput)
}

type FileCacheArrayOutput struct{ *pulumi.OutputState }

func (FileCacheArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FileCache)(nil)).Elem()
}

func (o FileCacheArrayOutput) ToFileCacheArrayOutput() FileCacheArrayOutput {
	return o
}

func (o FileCacheArrayOutput) ToFileCacheArrayOutputWithContext(ctx context.Context) FileCacheArrayOutput {
	return o
}

func (o FileCacheArrayOutput) Index(i pulumi.IntInput) FileCacheOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *FileCache {
		return vs[0].([]*FileCache)[vs[1].(int)]
	}).(FileCacheOutput)
}

type FileCacheMapOutput struct{ *pulumi.OutputState }

func (FileCacheMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FileCache)(nil)).Elem()
}

func (o FileCacheMapOutput) ToFileCacheMapOutput() FileCacheMapOutput {
	return o
}

func (o FileCacheMapOutput) ToFileCacheMapOutputWithContext(ctx context.Context) FileCacheMapOutput {
	return o
}

func (o FileCacheMapOutput) MapIndex(k pulumi.StringInput) FileCacheOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *FileCache {
		return vs[0].(map[string]*FileCache)[vs[1].(string)]
	}).(FileCacheOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FileCacheInput)(nil)).Elem(), &FileCache{})
	pulumi.RegisterInputType(reflect.TypeOf((*FileCacheArrayInput)(nil)).Elem(), FileCacheArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FileCacheMapInput)(nil)).Elem(), FileCacheMap{})
	pulumi.RegisterOutputType(FileCacheOutput{})
	pulumi.RegisterOutputType(FileCacheArrayOutput{})
	pulumi.RegisterOutputType(FileCacheMapOutput{})
}
