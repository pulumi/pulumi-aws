// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package route53

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Import
//
// Using `pulumi import`, import Route 53 Records Exclusive using the `zone_id`. For example:
//
// ```sh
// $ pulumi import aws:route53/recordsExclusive:RecordsExclusive example ABCD1234
// ```
type RecordsExclusive struct {
	pulumi.CustomResourceState

	// A list of all resource record sets associated with the hosted zone.
	// See `resourceRecordSet` below.
	ResourceRecordSets RecordsExclusiveResourceRecordSetArrayOutput `pulumi:"resourceRecordSets"`
	Timeouts           RecordsExclusiveTimeoutsPtrOutput            `pulumi:"timeouts"`
	// ID of the hosted zone containing the resource record sets.
	//
	// The following arguments are optional:
	ZoneId pulumi.StringOutput `pulumi:"zoneId"`
}

// NewRecordsExclusive registers a new resource with the given unique name, arguments, and options.
func NewRecordsExclusive(ctx *pulumi.Context,
	name string, args *RecordsExclusiveArgs, opts ...pulumi.ResourceOption) (*RecordsExclusive, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ZoneId == nil {
		return nil, errors.New("invalid value for required argument 'ZoneId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource RecordsExclusive
	err := ctx.RegisterResource("aws:route53/recordsExclusive:RecordsExclusive", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRecordsExclusive gets an existing RecordsExclusive resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRecordsExclusive(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RecordsExclusiveState, opts ...pulumi.ResourceOption) (*RecordsExclusive, error) {
	var resource RecordsExclusive
	err := ctx.ReadResource("aws:route53/recordsExclusive:RecordsExclusive", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering RecordsExclusive resources.
type recordsExclusiveState struct {
	// A list of all resource record sets associated with the hosted zone.
	// See `resourceRecordSet` below.
	ResourceRecordSets []RecordsExclusiveResourceRecordSet `pulumi:"resourceRecordSets"`
	Timeouts           *RecordsExclusiveTimeouts           `pulumi:"timeouts"`
	// ID of the hosted zone containing the resource record sets.
	//
	// The following arguments are optional:
	ZoneId *string `pulumi:"zoneId"`
}

type RecordsExclusiveState struct {
	// A list of all resource record sets associated with the hosted zone.
	// See `resourceRecordSet` below.
	ResourceRecordSets RecordsExclusiveResourceRecordSetArrayInput
	Timeouts           RecordsExclusiveTimeoutsPtrInput
	// ID of the hosted zone containing the resource record sets.
	//
	// The following arguments are optional:
	ZoneId pulumi.StringPtrInput
}

func (RecordsExclusiveState) ElementType() reflect.Type {
	return reflect.TypeOf((*recordsExclusiveState)(nil)).Elem()
}

type recordsExclusiveArgs struct {
	// A list of all resource record sets associated with the hosted zone.
	// See `resourceRecordSet` below.
	ResourceRecordSets []RecordsExclusiveResourceRecordSet `pulumi:"resourceRecordSets"`
	Timeouts           *RecordsExclusiveTimeouts           `pulumi:"timeouts"`
	// ID of the hosted zone containing the resource record sets.
	//
	// The following arguments are optional:
	ZoneId string `pulumi:"zoneId"`
}

// The set of arguments for constructing a RecordsExclusive resource.
type RecordsExclusiveArgs struct {
	// A list of all resource record sets associated with the hosted zone.
	// See `resourceRecordSet` below.
	ResourceRecordSets RecordsExclusiveResourceRecordSetArrayInput
	Timeouts           RecordsExclusiveTimeoutsPtrInput
	// ID of the hosted zone containing the resource record sets.
	//
	// The following arguments are optional:
	ZoneId pulumi.StringInput
}

func (RecordsExclusiveArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*recordsExclusiveArgs)(nil)).Elem()
}

type RecordsExclusiveInput interface {
	pulumi.Input

	ToRecordsExclusiveOutput() RecordsExclusiveOutput
	ToRecordsExclusiveOutputWithContext(ctx context.Context) RecordsExclusiveOutput
}

func (*RecordsExclusive) ElementType() reflect.Type {
	return reflect.TypeOf((**RecordsExclusive)(nil)).Elem()
}

func (i *RecordsExclusive) ToRecordsExclusiveOutput() RecordsExclusiveOutput {
	return i.ToRecordsExclusiveOutputWithContext(context.Background())
}

func (i *RecordsExclusive) ToRecordsExclusiveOutputWithContext(ctx context.Context) RecordsExclusiveOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecordsExclusiveOutput)
}

// RecordsExclusiveArrayInput is an input type that accepts RecordsExclusiveArray and RecordsExclusiveArrayOutput values.
// You can construct a concrete instance of `RecordsExclusiveArrayInput` via:
//
//	RecordsExclusiveArray{ RecordsExclusiveArgs{...} }
type RecordsExclusiveArrayInput interface {
	pulumi.Input

	ToRecordsExclusiveArrayOutput() RecordsExclusiveArrayOutput
	ToRecordsExclusiveArrayOutputWithContext(context.Context) RecordsExclusiveArrayOutput
}

type RecordsExclusiveArray []RecordsExclusiveInput

func (RecordsExclusiveArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RecordsExclusive)(nil)).Elem()
}

func (i RecordsExclusiveArray) ToRecordsExclusiveArrayOutput() RecordsExclusiveArrayOutput {
	return i.ToRecordsExclusiveArrayOutputWithContext(context.Background())
}

func (i RecordsExclusiveArray) ToRecordsExclusiveArrayOutputWithContext(ctx context.Context) RecordsExclusiveArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecordsExclusiveArrayOutput)
}

// RecordsExclusiveMapInput is an input type that accepts RecordsExclusiveMap and RecordsExclusiveMapOutput values.
// You can construct a concrete instance of `RecordsExclusiveMapInput` via:
//
//	RecordsExclusiveMap{ "key": RecordsExclusiveArgs{...} }
type RecordsExclusiveMapInput interface {
	pulumi.Input

	ToRecordsExclusiveMapOutput() RecordsExclusiveMapOutput
	ToRecordsExclusiveMapOutputWithContext(context.Context) RecordsExclusiveMapOutput
}

type RecordsExclusiveMap map[string]RecordsExclusiveInput

func (RecordsExclusiveMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RecordsExclusive)(nil)).Elem()
}

func (i RecordsExclusiveMap) ToRecordsExclusiveMapOutput() RecordsExclusiveMapOutput {
	return i.ToRecordsExclusiveMapOutputWithContext(context.Background())
}

func (i RecordsExclusiveMap) ToRecordsExclusiveMapOutputWithContext(ctx context.Context) RecordsExclusiveMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecordsExclusiveMapOutput)
}

type RecordsExclusiveOutput struct{ *pulumi.OutputState }

func (RecordsExclusiveOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RecordsExclusive)(nil)).Elem()
}

func (o RecordsExclusiveOutput) ToRecordsExclusiveOutput() RecordsExclusiveOutput {
	return o
}

func (o RecordsExclusiveOutput) ToRecordsExclusiveOutputWithContext(ctx context.Context) RecordsExclusiveOutput {
	return o
}

// A list of all resource record sets associated with the hosted zone.
// See `resourceRecordSet` below.
func (o RecordsExclusiveOutput) ResourceRecordSets() RecordsExclusiveResourceRecordSetArrayOutput {
	return o.ApplyT(func(v *RecordsExclusive) RecordsExclusiveResourceRecordSetArrayOutput { return v.ResourceRecordSets }).(RecordsExclusiveResourceRecordSetArrayOutput)
}

func (o RecordsExclusiveOutput) Timeouts() RecordsExclusiveTimeoutsPtrOutput {
	return o.ApplyT(func(v *RecordsExclusive) RecordsExclusiveTimeoutsPtrOutput { return v.Timeouts }).(RecordsExclusiveTimeoutsPtrOutput)
}

// ID of the hosted zone containing the resource record sets.
//
// The following arguments are optional:
func (o RecordsExclusiveOutput) ZoneId() pulumi.StringOutput {
	return o.ApplyT(func(v *RecordsExclusive) pulumi.StringOutput { return v.ZoneId }).(pulumi.StringOutput)
}

type RecordsExclusiveArrayOutput struct{ *pulumi.OutputState }

func (RecordsExclusiveArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RecordsExclusive)(nil)).Elem()
}

func (o RecordsExclusiveArrayOutput) ToRecordsExclusiveArrayOutput() RecordsExclusiveArrayOutput {
	return o
}

func (o RecordsExclusiveArrayOutput) ToRecordsExclusiveArrayOutputWithContext(ctx context.Context) RecordsExclusiveArrayOutput {
	return o
}

func (o RecordsExclusiveArrayOutput) Index(i pulumi.IntInput) RecordsExclusiveOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *RecordsExclusive {
		return vs[0].([]*RecordsExclusive)[vs[1].(int)]
	}).(RecordsExclusiveOutput)
}

type RecordsExclusiveMapOutput struct{ *pulumi.OutputState }

func (RecordsExclusiveMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RecordsExclusive)(nil)).Elem()
}

func (o RecordsExclusiveMapOutput) ToRecordsExclusiveMapOutput() RecordsExclusiveMapOutput {
	return o
}

func (o RecordsExclusiveMapOutput) ToRecordsExclusiveMapOutputWithContext(ctx context.Context) RecordsExclusiveMapOutput {
	return o
}

func (o RecordsExclusiveMapOutput) MapIndex(k pulumi.StringInput) RecordsExclusiveOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *RecordsExclusive {
		return vs[0].(map[string]*RecordsExclusive)[vs[1].(string)]
	}).(RecordsExclusiveOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RecordsExclusiveInput)(nil)).Elem(), &RecordsExclusive{})
	pulumi.RegisterInputType(reflect.TypeOf((*RecordsExclusiveArrayInput)(nil)).Elem(), RecordsExclusiveArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RecordsExclusiveMapInput)(nil)).Elem(), RecordsExclusiveMap{})
	pulumi.RegisterOutputType(RecordsExclusiveOutput{})
	pulumi.RegisterOutputType(RecordsExclusiveArrayOutput{})
	pulumi.RegisterOutputType(RecordsExclusiveMapOutput{})
}
