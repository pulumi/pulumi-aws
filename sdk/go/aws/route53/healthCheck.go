// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package route53

import (
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// Provides a Route53 health check.
//
// > This content is derived from https://github.com/terraform-providers/terraform-provider-aws/blob/master/website/docs/r/route53_health_check.html.markdown.
type HealthCheck struct {
	s *pulumi.ResourceState
}

// NewHealthCheck registers a new resource with the given unique name, arguments, and options.
func NewHealthCheck(ctx *pulumi.Context,
	name string, args *HealthCheckArgs, opts ...pulumi.ResourceOpt) (*HealthCheck, error) {
	if args == nil || args.Type == nil {
		return nil, errors.New("missing required argument 'Type'")
	}
	inputs := make(map[string]interface{})
	if args == nil {
		inputs["childHealthThreshold"] = nil
		inputs["childHealthchecks"] = nil
		inputs["cloudwatchAlarmName"] = nil
		inputs["cloudwatchAlarmRegion"] = nil
		inputs["enableSni"] = nil
		inputs["failureThreshold"] = nil
		inputs["fqdn"] = nil
		inputs["insufficientDataHealthStatus"] = nil
		inputs["invertHealthcheck"] = nil
		inputs["ipAddress"] = nil
		inputs["measureLatency"] = nil
		inputs["port"] = nil
		inputs["referenceName"] = nil
		inputs["regions"] = nil
		inputs["requestInterval"] = nil
		inputs["resourcePath"] = nil
		inputs["searchString"] = nil
		inputs["tags"] = nil
		inputs["type"] = nil
	} else {
		inputs["childHealthThreshold"] = args.ChildHealthThreshold
		inputs["childHealthchecks"] = args.ChildHealthchecks
		inputs["cloudwatchAlarmName"] = args.CloudwatchAlarmName
		inputs["cloudwatchAlarmRegion"] = args.CloudwatchAlarmRegion
		inputs["enableSni"] = args.EnableSni
		inputs["failureThreshold"] = args.FailureThreshold
		inputs["fqdn"] = args.Fqdn
		inputs["insufficientDataHealthStatus"] = args.InsufficientDataHealthStatus
		inputs["invertHealthcheck"] = args.InvertHealthcheck
		inputs["ipAddress"] = args.IpAddress
		inputs["measureLatency"] = args.MeasureLatency
		inputs["port"] = args.Port
		inputs["referenceName"] = args.ReferenceName
		inputs["regions"] = args.Regions
		inputs["requestInterval"] = args.RequestInterval
		inputs["resourcePath"] = args.ResourcePath
		inputs["searchString"] = args.SearchString
		inputs["tags"] = args.Tags
		inputs["type"] = args.Type
	}
	s, err := ctx.RegisterResource("aws:route53/healthCheck:HealthCheck", name, true, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &HealthCheck{s: s}, nil
}

// GetHealthCheck gets an existing HealthCheck resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetHealthCheck(ctx *pulumi.Context,
	name string, id pulumi.ID, state *HealthCheckState, opts ...pulumi.ResourceOpt) (*HealthCheck, error) {
	inputs := make(map[string]interface{})
	if state != nil {
		inputs["childHealthThreshold"] = state.ChildHealthThreshold
		inputs["childHealthchecks"] = state.ChildHealthchecks
		inputs["cloudwatchAlarmName"] = state.CloudwatchAlarmName
		inputs["cloudwatchAlarmRegion"] = state.CloudwatchAlarmRegion
		inputs["enableSni"] = state.EnableSni
		inputs["failureThreshold"] = state.FailureThreshold
		inputs["fqdn"] = state.Fqdn
		inputs["insufficientDataHealthStatus"] = state.InsufficientDataHealthStatus
		inputs["invertHealthcheck"] = state.InvertHealthcheck
		inputs["ipAddress"] = state.IpAddress
		inputs["measureLatency"] = state.MeasureLatency
		inputs["port"] = state.Port
		inputs["referenceName"] = state.ReferenceName
		inputs["regions"] = state.Regions
		inputs["requestInterval"] = state.RequestInterval
		inputs["resourcePath"] = state.ResourcePath
		inputs["searchString"] = state.SearchString
		inputs["tags"] = state.Tags
		inputs["type"] = state.Type
	}
	s, err := ctx.ReadResource("aws:route53/healthCheck:HealthCheck", name, id, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &HealthCheck{s: s}, nil
}

// URN is this resource's unique name assigned by Pulumi.
func (r *HealthCheck) URN() *pulumi.URNOutput {
	return r.s.URN()
}

// ID is this resource's unique identifier assigned by its provider.
func (r *HealthCheck) ID() *pulumi.IDOutput {
	return r.s.ID()
}

// The minimum number of child health checks that must be healthy for Route 53 to consider the parent health check to be healthy. Valid values are integers between 0 and 256, inclusive
func (r *HealthCheck) ChildHealthThreshold() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["childHealthThreshold"])
}

// For a specified parent health check, a list of HealthCheckId values for the associated child health checks.
func (r *HealthCheck) ChildHealthchecks() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["childHealthchecks"])
}

// The name of the CloudWatch alarm.
func (r *HealthCheck) CloudwatchAlarmName() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["cloudwatchAlarmName"])
}

// The CloudWatchRegion that the CloudWatch alarm was created in.
func (r *HealthCheck) CloudwatchAlarmRegion() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["cloudwatchAlarmRegion"])
}

// A boolean value that indicates whether Route53 should send the `fqdn` to the endpoint when performing the health check. This defaults to AWS' defaults: when the `type` is "HTTPS" `enable_sni` defaults to `true`, when `type` is anything else `enable_sni` defaults to `false`.
func (r *HealthCheck) EnableSni() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["enableSni"])
}

// The number of consecutive health checks that an endpoint must pass or fail.
func (r *HealthCheck) FailureThreshold() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["failureThreshold"])
}

// The fully qualified domain name of the endpoint to be checked.
func (r *HealthCheck) Fqdn() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["fqdn"])
}

// The status of the health check when CloudWatch has insufficient data about the state of associated alarm. Valid values are `Healthy` , `Unhealthy` and `LastKnownStatus`.
func (r *HealthCheck) InsufficientDataHealthStatus() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["insufficientDataHealthStatus"])
}

// A boolean value that indicates whether the status of health check should be inverted. For example, if a health check is healthy but Inverted is True , then Route 53 considers the health check to be unhealthy.
func (r *HealthCheck) InvertHealthcheck() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["invertHealthcheck"])
}

// The IP address of the endpoint to be checked.
func (r *HealthCheck) IpAddress() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["ipAddress"])
}

// A Boolean value that indicates whether you want Route 53 to measure the latency between health checkers in multiple AWS regions and your endpoint and to display CloudWatch latency graphs in the Route 53 console.
func (r *HealthCheck) MeasureLatency() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["measureLatency"])
}

// The port of the endpoint to be checked.
func (r *HealthCheck) Port() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["port"])
}

// This is a reference name used in Caller Reference
// (helpful for identifying single health_check set amongst others)
func (r *HealthCheck) ReferenceName() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["referenceName"])
}

// A list of AWS regions that you want Amazon Route 53 health checkers to check the specified endpoint from.
func (r *HealthCheck) Regions() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["regions"])
}

// The number of seconds between the time that Amazon Route 53 gets a response from your endpoint and the time that it sends the next health-check request.
func (r *HealthCheck) RequestInterval() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["requestInterval"])
}

// The path that you want Amazon Route 53 to request when performing health checks.
func (r *HealthCheck) ResourcePath() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["resourcePath"])
}

// String searched in the first 5120 bytes of the response body for check to be considered healthy. Only valid with `HTTP_STR_MATCH` and `HTTPS_STR_MATCH`.
func (r *HealthCheck) SearchString() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["searchString"])
}

// A mapping of tags to assign to the health check.
func (r *HealthCheck) Tags() *pulumi.MapOutput {
	return (*pulumi.MapOutput)(r.s.State["tags"])
}

// The protocol to use when performing health checks. Valid values are `HTTP`, `HTTPS`, `HTTP_STR_MATCH`, `HTTPS_STR_MATCH`, `TCP`, `CALCULATED` and `CLOUDWATCH_METRIC`.
func (r *HealthCheck) Type() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["type"])
}

// Input properties used for looking up and filtering HealthCheck resources.
type HealthCheckState struct {
	// The minimum number of child health checks that must be healthy for Route 53 to consider the parent health check to be healthy. Valid values are integers between 0 and 256, inclusive
	ChildHealthThreshold interface{}
	// For a specified parent health check, a list of HealthCheckId values for the associated child health checks.
	ChildHealthchecks interface{}
	// The name of the CloudWatch alarm.
	CloudwatchAlarmName interface{}
	// The CloudWatchRegion that the CloudWatch alarm was created in.
	CloudwatchAlarmRegion interface{}
	// A boolean value that indicates whether Route53 should send the `fqdn` to the endpoint when performing the health check. This defaults to AWS' defaults: when the `type` is "HTTPS" `enable_sni` defaults to `true`, when `type` is anything else `enable_sni` defaults to `false`.
	EnableSni interface{}
	// The number of consecutive health checks that an endpoint must pass or fail.
	FailureThreshold interface{}
	// The fully qualified domain name of the endpoint to be checked.
	Fqdn interface{}
	// The status of the health check when CloudWatch has insufficient data about the state of associated alarm. Valid values are `Healthy` , `Unhealthy` and `LastKnownStatus`.
	InsufficientDataHealthStatus interface{}
	// A boolean value that indicates whether the status of health check should be inverted. For example, if a health check is healthy but Inverted is True , then Route 53 considers the health check to be unhealthy.
	InvertHealthcheck interface{}
	// The IP address of the endpoint to be checked.
	IpAddress interface{}
	// A Boolean value that indicates whether you want Route 53 to measure the latency between health checkers in multiple AWS regions and your endpoint and to display CloudWatch latency graphs in the Route 53 console.
	MeasureLatency interface{}
	// The port of the endpoint to be checked.
	Port interface{}
	// This is a reference name used in Caller Reference
	// (helpful for identifying single health_check set amongst others)
	ReferenceName interface{}
	// A list of AWS regions that you want Amazon Route 53 health checkers to check the specified endpoint from.
	Regions interface{}
	// The number of seconds between the time that Amazon Route 53 gets a response from your endpoint and the time that it sends the next health-check request.
	RequestInterval interface{}
	// The path that you want Amazon Route 53 to request when performing health checks.
	ResourcePath interface{}
	// String searched in the first 5120 bytes of the response body for check to be considered healthy. Only valid with `HTTP_STR_MATCH` and `HTTPS_STR_MATCH`.
	SearchString interface{}
	// A mapping of tags to assign to the health check.
	Tags interface{}
	// The protocol to use when performing health checks. Valid values are `HTTP`, `HTTPS`, `HTTP_STR_MATCH`, `HTTPS_STR_MATCH`, `TCP`, `CALCULATED` and `CLOUDWATCH_METRIC`.
	Type interface{}
}

// The set of arguments for constructing a HealthCheck resource.
type HealthCheckArgs struct {
	// The minimum number of child health checks that must be healthy for Route 53 to consider the parent health check to be healthy. Valid values are integers between 0 and 256, inclusive
	ChildHealthThreshold interface{}
	// For a specified parent health check, a list of HealthCheckId values for the associated child health checks.
	ChildHealthchecks interface{}
	// The name of the CloudWatch alarm.
	CloudwatchAlarmName interface{}
	// The CloudWatchRegion that the CloudWatch alarm was created in.
	CloudwatchAlarmRegion interface{}
	// A boolean value that indicates whether Route53 should send the `fqdn` to the endpoint when performing the health check. This defaults to AWS' defaults: when the `type` is "HTTPS" `enable_sni` defaults to `true`, when `type` is anything else `enable_sni` defaults to `false`.
	EnableSni interface{}
	// The number of consecutive health checks that an endpoint must pass or fail.
	FailureThreshold interface{}
	// The fully qualified domain name of the endpoint to be checked.
	Fqdn interface{}
	// The status of the health check when CloudWatch has insufficient data about the state of associated alarm. Valid values are `Healthy` , `Unhealthy` and `LastKnownStatus`.
	InsufficientDataHealthStatus interface{}
	// A boolean value that indicates whether the status of health check should be inverted. For example, if a health check is healthy but Inverted is True , then Route 53 considers the health check to be unhealthy.
	InvertHealthcheck interface{}
	// The IP address of the endpoint to be checked.
	IpAddress interface{}
	// A Boolean value that indicates whether you want Route 53 to measure the latency between health checkers in multiple AWS regions and your endpoint and to display CloudWatch latency graphs in the Route 53 console.
	MeasureLatency interface{}
	// The port of the endpoint to be checked.
	Port interface{}
	// This is a reference name used in Caller Reference
	// (helpful for identifying single health_check set amongst others)
	ReferenceName interface{}
	// A list of AWS regions that you want Amazon Route 53 health checkers to check the specified endpoint from.
	Regions interface{}
	// The number of seconds between the time that Amazon Route 53 gets a response from your endpoint and the time that it sends the next health-check request.
	RequestInterval interface{}
	// The path that you want Amazon Route 53 to request when performing health checks.
	ResourcePath interface{}
	// String searched in the first 5120 bytes of the response body for check to be considered healthy. Only valid with `HTTP_STR_MATCH` and `HTTPS_STR_MATCH`.
	SearchString interface{}
	// A mapping of tags to assign to the health check.
	Tags interface{}
	// The protocol to use when performing health checks. Valid values are `HTTP`, `HTTPS`, `HTTP_STR_MATCH`, `HTTPS_STR_MATCH`, `TCP`, `CALCULATED` and `CLOUDWATCH_METRIC`.
	Type interface{}
}
