// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package gamelift

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

type AliasRoutingStrategy struct {
	// ID of the Gamelift Fleet to point the alias to.
	FleetId *string `pulumi:"fleetId"`
	// Message text to be used with the `TERMINAL` routing strategy.
	Message *string `pulumi:"message"`
	// Type of routing strategy. e.g. `SIMPLE` or `TERMINAL`
	Type string `pulumi:"type"`
}

// AliasRoutingStrategyInput is an input type that accepts AliasRoutingStrategyArgs and AliasRoutingStrategyOutput values.
// You can construct a concrete instance of `AliasRoutingStrategyInput` via:
//
// 		 AliasRoutingStrategyArgs{...}
//
type AliasRoutingStrategyInput interface {
	pulumi.Input

	ToAliasRoutingStrategyOutput() AliasRoutingStrategyOutput
	ToAliasRoutingStrategyOutputWithContext(context.Context) AliasRoutingStrategyOutput
}

type AliasRoutingStrategyArgs struct {
	// ID of the Gamelift Fleet to point the alias to.
	FleetId pulumi.StringPtrInput `pulumi:"fleetId"`
	// Message text to be used with the `TERMINAL` routing strategy.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// Type of routing strategy. e.g. `SIMPLE` or `TERMINAL`
	Type pulumi.StringInput `pulumi:"type"`
}

func (AliasRoutingStrategyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AliasRoutingStrategy)(nil)).Elem()
}

func (i AliasRoutingStrategyArgs) ToAliasRoutingStrategyOutput() AliasRoutingStrategyOutput {
	return i.ToAliasRoutingStrategyOutputWithContext(context.Background())
}

func (i AliasRoutingStrategyArgs) ToAliasRoutingStrategyOutputWithContext(ctx context.Context) AliasRoutingStrategyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AliasRoutingStrategyOutput)
}

func (i AliasRoutingStrategyArgs) ToAliasRoutingStrategyPtrOutput() AliasRoutingStrategyPtrOutput {
	return i.ToAliasRoutingStrategyPtrOutputWithContext(context.Background())
}

func (i AliasRoutingStrategyArgs) ToAliasRoutingStrategyPtrOutputWithContext(ctx context.Context) AliasRoutingStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AliasRoutingStrategyOutput).ToAliasRoutingStrategyPtrOutputWithContext(ctx)
}

// AliasRoutingStrategyPtrInput is an input type that accepts AliasRoutingStrategyArgs, AliasRoutingStrategyPtr and AliasRoutingStrategyPtrOutput values.
// You can construct a concrete instance of `AliasRoutingStrategyPtrInput` via:
//
// 		 AliasRoutingStrategyArgs{...}
//
//  or:
//
// 		 nil
//
type AliasRoutingStrategyPtrInput interface {
	pulumi.Input

	ToAliasRoutingStrategyPtrOutput() AliasRoutingStrategyPtrOutput
	ToAliasRoutingStrategyPtrOutputWithContext(context.Context) AliasRoutingStrategyPtrOutput
}

type aliasRoutingStrategyPtrType AliasRoutingStrategyArgs

func AliasRoutingStrategyPtr(v *AliasRoutingStrategyArgs) AliasRoutingStrategyPtrInput {
	return (*aliasRoutingStrategyPtrType)(v)
}

func (*aliasRoutingStrategyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AliasRoutingStrategy)(nil)).Elem()
}

func (i *aliasRoutingStrategyPtrType) ToAliasRoutingStrategyPtrOutput() AliasRoutingStrategyPtrOutput {
	return i.ToAliasRoutingStrategyPtrOutputWithContext(context.Background())
}

func (i *aliasRoutingStrategyPtrType) ToAliasRoutingStrategyPtrOutputWithContext(ctx context.Context) AliasRoutingStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AliasRoutingStrategyPtrOutput)
}

type AliasRoutingStrategyOutput struct{ *pulumi.OutputState }

func (AliasRoutingStrategyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AliasRoutingStrategy)(nil)).Elem()
}

func (o AliasRoutingStrategyOutput) ToAliasRoutingStrategyOutput() AliasRoutingStrategyOutput {
	return o
}

func (o AliasRoutingStrategyOutput) ToAliasRoutingStrategyOutputWithContext(ctx context.Context) AliasRoutingStrategyOutput {
	return o
}

func (o AliasRoutingStrategyOutput) ToAliasRoutingStrategyPtrOutput() AliasRoutingStrategyPtrOutput {
	return o.ToAliasRoutingStrategyPtrOutputWithContext(context.Background())
}

func (o AliasRoutingStrategyOutput) ToAliasRoutingStrategyPtrOutputWithContext(ctx context.Context) AliasRoutingStrategyPtrOutput {
	return o.ApplyT(func(v AliasRoutingStrategy) *AliasRoutingStrategy {
		return &v
	}).(AliasRoutingStrategyPtrOutput)
}

// ID of the Gamelift Fleet to point the alias to.
func (o AliasRoutingStrategyOutput) FleetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AliasRoutingStrategy) *string { return v.FleetId }).(pulumi.StringPtrOutput)
}

// Message text to be used with the `TERMINAL` routing strategy.
func (o AliasRoutingStrategyOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AliasRoutingStrategy) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// Type of routing strategy. e.g. `SIMPLE` or `TERMINAL`
func (o AliasRoutingStrategyOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v AliasRoutingStrategy) string { return v.Type }).(pulumi.StringOutput)
}

type AliasRoutingStrategyPtrOutput struct{ *pulumi.OutputState }

func (AliasRoutingStrategyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AliasRoutingStrategy)(nil)).Elem()
}

func (o AliasRoutingStrategyPtrOutput) ToAliasRoutingStrategyPtrOutput() AliasRoutingStrategyPtrOutput {
	return o
}

func (o AliasRoutingStrategyPtrOutput) ToAliasRoutingStrategyPtrOutputWithContext(ctx context.Context) AliasRoutingStrategyPtrOutput {
	return o
}

func (o AliasRoutingStrategyPtrOutput) Elem() AliasRoutingStrategyOutput {
	return o.ApplyT(func(v *AliasRoutingStrategy) AliasRoutingStrategy { return *v }).(AliasRoutingStrategyOutput)
}

// ID of the Gamelift Fleet to point the alias to.
func (o AliasRoutingStrategyPtrOutput) FleetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AliasRoutingStrategy) *string { return v.FleetId }).(pulumi.StringPtrOutput)
}

// Message text to be used with the `TERMINAL` routing strategy.
func (o AliasRoutingStrategyPtrOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AliasRoutingStrategy) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// Type of routing strategy. e.g. `SIMPLE` or `TERMINAL`
func (o AliasRoutingStrategyPtrOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v AliasRoutingStrategy) string { return v.Type }).(pulumi.StringOutput)
}

type BuildStorageLocation struct {
	// Name of your S3 bucket.
	Bucket string `pulumi:"bucket"`
	// Name of the zip file containing your build files.
	Key string `pulumi:"key"`
	// ARN of the access role that allows Amazon GameLift to access your S3 bucket.
	RoleArn string `pulumi:"roleArn"`
}

// BuildStorageLocationInput is an input type that accepts BuildStorageLocationArgs and BuildStorageLocationOutput values.
// You can construct a concrete instance of `BuildStorageLocationInput` via:
//
// 		 BuildStorageLocationArgs{...}
//
type BuildStorageLocationInput interface {
	pulumi.Input

	ToBuildStorageLocationOutput() BuildStorageLocationOutput
	ToBuildStorageLocationOutputWithContext(context.Context) BuildStorageLocationOutput
}

type BuildStorageLocationArgs struct {
	// Name of your S3 bucket.
	Bucket pulumi.StringInput `pulumi:"bucket"`
	// Name of the zip file containing your build files.
	Key pulumi.StringInput `pulumi:"key"`
	// ARN of the access role that allows Amazon GameLift to access your S3 bucket.
	RoleArn pulumi.StringInput `pulumi:"roleArn"`
}

func (BuildStorageLocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildStorageLocation)(nil)).Elem()
}

func (i BuildStorageLocationArgs) ToBuildStorageLocationOutput() BuildStorageLocationOutput {
	return i.ToBuildStorageLocationOutputWithContext(context.Background())
}

func (i BuildStorageLocationArgs) ToBuildStorageLocationOutputWithContext(ctx context.Context) BuildStorageLocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildStorageLocationOutput)
}

func (i BuildStorageLocationArgs) ToBuildStorageLocationPtrOutput() BuildStorageLocationPtrOutput {
	return i.ToBuildStorageLocationPtrOutputWithContext(context.Background())
}

func (i BuildStorageLocationArgs) ToBuildStorageLocationPtrOutputWithContext(ctx context.Context) BuildStorageLocationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildStorageLocationOutput).ToBuildStorageLocationPtrOutputWithContext(ctx)
}

// BuildStorageLocationPtrInput is an input type that accepts BuildStorageLocationArgs, BuildStorageLocationPtr and BuildStorageLocationPtrOutput values.
// You can construct a concrete instance of `BuildStorageLocationPtrInput` via:
//
// 		 BuildStorageLocationArgs{...}
//
//  or:
//
// 		 nil
//
type BuildStorageLocationPtrInput interface {
	pulumi.Input

	ToBuildStorageLocationPtrOutput() BuildStorageLocationPtrOutput
	ToBuildStorageLocationPtrOutputWithContext(context.Context) BuildStorageLocationPtrOutput
}

type buildStorageLocationPtrType BuildStorageLocationArgs

func BuildStorageLocationPtr(v *BuildStorageLocationArgs) BuildStorageLocationPtrInput {
	return (*buildStorageLocationPtrType)(v)
}

func (*buildStorageLocationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildStorageLocation)(nil)).Elem()
}

func (i *buildStorageLocationPtrType) ToBuildStorageLocationPtrOutput() BuildStorageLocationPtrOutput {
	return i.ToBuildStorageLocationPtrOutputWithContext(context.Background())
}

func (i *buildStorageLocationPtrType) ToBuildStorageLocationPtrOutputWithContext(ctx context.Context) BuildStorageLocationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildStorageLocationPtrOutput)
}

type BuildStorageLocationOutput struct{ *pulumi.OutputState }

func (BuildStorageLocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildStorageLocation)(nil)).Elem()
}

func (o BuildStorageLocationOutput) ToBuildStorageLocationOutput() BuildStorageLocationOutput {
	return o
}

func (o BuildStorageLocationOutput) ToBuildStorageLocationOutputWithContext(ctx context.Context) BuildStorageLocationOutput {
	return o
}

func (o BuildStorageLocationOutput) ToBuildStorageLocationPtrOutput() BuildStorageLocationPtrOutput {
	return o.ToBuildStorageLocationPtrOutputWithContext(context.Background())
}

func (o BuildStorageLocationOutput) ToBuildStorageLocationPtrOutputWithContext(ctx context.Context) BuildStorageLocationPtrOutput {
	return o.ApplyT(func(v BuildStorageLocation) *BuildStorageLocation {
		return &v
	}).(BuildStorageLocationPtrOutput)
}

// Name of your S3 bucket.
func (o BuildStorageLocationOutput) Bucket() pulumi.StringOutput {
	return o.ApplyT(func(v BuildStorageLocation) string { return v.Bucket }).(pulumi.StringOutput)
}

// Name of the zip file containing your build files.
func (o BuildStorageLocationOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v BuildStorageLocation) string { return v.Key }).(pulumi.StringOutput)
}

// ARN of the access role that allows Amazon GameLift to access your S3 bucket.
func (o BuildStorageLocationOutput) RoleArn() pulumi.StringOutput {
	return o.ApplyT(func(v BuildStorageLocation) string { return v.RoleArn }).(pulumi.StringOutput)
}

type BuildStorageLocationPtrOutput struct{ *pulumi.OutputState }

func (BuildStorageLocationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildStorageLocation)(nil)).Elem()
}

func (o BuildStorageLocationPtrOutput) ToBuildStorageLocationPtrOutput() BuildStorageLocationPtrOutput {
	return o
}

func (o BuildStorageLocationPtrOutput) ToBuildStorageLocationPtrOutputWithContext(ctx context.Context) BuildStorageLocationPtrOutput {
	return o
}

func (o BuildStorageLocationPtrOutput) Elem() BuildStorageLocationOutput {
	return o.ApplyT(func(v *BuildStorageLocation) BuildStorageLocation { return *v }).(BuildStorageLocationOutput)
}

// Name of your S3 bucket.
func (o BuildStorageLocationPtrOutput) Bucket() pulumi.StringOutput {
	return o.ApplyT(func(v BuildStorageLocation) string { return v.Bucket }).(pulumi.StringOutput)
}

// Name of the zip file containing your build files.
func (o BuildStorageLocationPtrOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v BuildStorageLocation) string { return v.Key }).(pulumi.StringOutput)
}

// ARN of the access role that allows Amazon GameLift to access your S3 bucket.
func (o BuildStorageLocationPtrOutput) RoleArn() pulumi.StringOutput {
	return o.ApplyT(func(v BuildStorageLocation) string { return v.RoleArn }).(pulumi.StringOutput)
}

type FleetEc2InboundPermission struct {
	// Starting value for a range of allowed port numbers.
	FromPort int `pulumi:"fromPort"`
	// Range of allowed IP addresses expressed in CIDR notation. e.g. `000.000.000.000/[subnet mask]` or `0.0.0.0/[subnet mask]`.
	IpRange string `pulumi:"ipRange"`
	// Network communication protocol used by the fleet. e.g. `TCP` or `UDP`
	Protocol string `pulumi:"protocol"`
	// Ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than `fromPort`.
	ToPort int `pulumi:"toPort"`
}

// FleetEc2InboundPermissionInput is an input type that accepts FleetEc2InboundPermissionArgs and FleetEc2InboundPermissionOutput values.
// You can construct a concrete instance of `FleetEc2InboundPermissionInput` via:
//
// 		 FleetEc2InboundPermissionArgs{...}
//
type FleetEc2InboundPermissionInput interface {
	pulumi.Input

	ToFleetEc2InboundPermissionOutput() FleetEc2InboundPermissionOutput
	ToFleetEc2InboundPermissionOutputWithContext(context.Context) FleetEc2InboundPermissionOutput
}

type FleetEc2InboundPermissionArgs struct {
	// Starting value for a range of allowed port numbers.
	FromPort pulumi.IntInput `pulumi:"fromPort"`
	// Range of allowed IP addresses expressed in CIDR notation. e.g. `000.000.000.000/[subnet mask]` or `0.0.0.0/[subnet mask]`.
	IpRange pulumi.StringInput `pulumi:"ipRange"`
	// Network communication protocol used by the fleet. e.g. `TCP` or `UDP`
	Protocol pulumi.StringInput `pulumi:"protocol"`
	// Ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than `fromPort`.
	ToPort pulumi.IntInput `pulumi:"toPort"`
}

func (FleetEc2InboundPermissionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetEc2InboundPermission)(nil)).Elem()
}

func (i FleetEc2InboundPermissionArgs) ToFleetEc2InboundPermissionOutput() FleetEc2InboundPermissionOutput {
	return i.ToFleetEc2InboundPermissionOutputWithContext(context.Background())
}

func (i FleetEc2InboundPermissionArgs) ToFleetEc2InboundPermissionOutputWithContext(ctx context.Context) FleetEc2InboundPermissionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetEc2InboundPermissionOutput)
}

// FleetEc2InboundPermissionArrayInput is an input type that accepts FleetEc2InboundPermissionArray and FleetEc2InboundPermissionArrayOutput values.
// You can construct a concrete instance of `FleetEc2InboundPermissionArrayInput` via:
//
// 		 FleetEc2InboundPermissionArray{ FleetEc2InboundPermissionArgs{...} }
//
type FleetEc2InboundPermissionArrayInput interface {
	pulumi.Input

	ToFleetEc2InboundPermissionArrayOutput() FleetEc2InboundPermissionArrayOutput
	ToFleetEc2InboundPermissionArrayOutputWithContext(context.Context) FleetEc2InboundPermissionArrayOutput
}

type FleetEc2InboundPermissionArray []FleetEc2InboundPermissionInput

func (FleetEc2InboundPermissionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetEc2InboundPermission)(nil)).Elem()
}

func (i FleetEc2InboundPermissionArray) ToFleetEc2InboundPermissionArrayOutput() FleetEc2InboundPermissionArrayOutput {
	return i.ToFleetEc2InboundPermissionArrayOutputWithContext(context.Background())
}

func (i FleetEc2InboundPermissionArray) ToFleetEc2InboundPermissionArrayOutputWithContext(ctx context.Context) FleetEc2InboundPermissionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetEc2InboundPermissionArrayOutput)
}

type FleetEc2InboundPermissionOutput struct{ *pulumi.OutputState }

func (FleetEc2InboundPermissionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetEc2InboundPermission)(nil)).Elem()
}

func (o FleetEc2InboundPermissionOutput) ToFleetEc2InboundPermissionOutput() FleetEc2InboundPermissionOutput {
	return o
}

func (o FleetEc2InboundPermissionOutput) ToFleetEc2InboundPermissionOutputWithContext(ctx context.Context) FleetEc2InboundPermissionOutput {
	return o
}

// Starting value for a range of allowed port numbers.
func (o FleetEc2InboundPermissionOutput) FromPort() pulumi.IntOutput {
	return o.ApplyT(func(v FleetEc2InboundPermission) int { return v.FromPort }).(pulumi.IntOutput)
}

// Range of allowed IP addresses expressed in CIDR notation. e.g. `000.000.000.000/[subnet mask]` or `0.0.0.0/[subnet mask]`.
func (o FleetEc2InboundPermissionOutput) IpRange() pulumi.StringOutput {
	return o.ApplyT(func(v FleetEc2InboundPermission) string { return v.IpRange }).(pulumi.StringOutput)
}

// Network communication protocol used by the fleet. e.g. `TCP` or `UDP`
func (o FleetEc2InboundPermissionOutput) Protocol() pulumi.StringOutput {
	return o.ApplyT(func(v FleetEc2InboundPermission) string { return v.Protocol }).(pulumi.StringOutput)
}

// Ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than `fromPort`.
func (o FleetEc2InboundPermissionOutput) ToPort() pulumi.IntOutput {
	return o.ApplyT(func(v FleetEc2InboundPermission) int { return v.ToPort }).(pulumi.IntOutput)
}

type FleetEc2InboundPermissionArrayOutput struct{ *pulumi.OutputState }

func (FleetEc2InboundPermissionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetEc2InboundPermission)(nil)).Elem()
}

func (o FleetEc2InboundPermissionArrayOutput) ToFleetEc2InboundPermissionArrayOutput() FleetEc2InboundPermissionArrayOutput {
	return o
}

func (o FleetEc2InboundPermissionArrayOutput) ToFleetEc2InboundPermissionArrayOutputWithContext(ctx context.Context) FleetEc2InboundPermissionArrayOutput {
	return o
}

func (o FleetEc2InboundPermissionArrayOutput) Index(i pulumi.IntInput) FleetEc2InboundPermissionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FleetEc2InboundPermission {
		return vs[0].([]FleetEc2InboundPermission)[vs[1].(int)]
	}).(FleetEc2InboundPermissionOutput)
}

type FleetResourceCreationLimitPolicy struct {
	// Maximum number of game sessions that an individual can create during the policy period.
	NewGameSessionsPerCreator *int `pulumi:"newGameSessionsPerCreator"`
	// Time span used in evaluating the resource creation limit policy.
	PolicyPeriodInMinutes *int `pulumi:"policyPeriodInMinutes"`
}

// FleetResourceCreationLimitPolicyInput is an input type that accepts FleetResourceCreationLimitPolicyArgs and FleetResourceCreationLimitPolicyOutput values.
// You can construct a concrete instance of `FleetResourceCreationLimitPolicyInput` via:
//
// 		 FleetResourceCreationLimitPolicyArgs{...}
//
type FleetResourceCreationLimitPolicyInput interface {
	pulumi.Input

	ToFleetResourceCreationLimitPolicyOutput() FleetResourceCreationLimitPolicyOutput
	ToFleetResourceCreationLimitPolicyOutputWithContext(context.Context) FleetResourceCreationLimitPolicyOutput
}

type FleetResourceCreationLimitPolicyArgs struct {
	// Maximum number of game sessions that an individual can create during the policy period.
	NewGameSessionsPerCreator pulumi.IntPtrInput `pulumi:"newGameSessionsPerCreator"`
	// Time span used in evaluating the resource creation limit policy.
	PolicyPeriodInMinutes pulumi.IntPtrInput `pulumi:"policyPeriodInMinutes"`
}

func (FleetResourceCreationLimitPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyOutput() FleetResourceCreationLimitPolicyOutput {
	return i.ToFleetResourceCreationLimitPolicyOutputWithContext(context.Background())
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetResourceCreationLimitPolicyOutput)
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput {
	return i.ToFleetResourceCreationLimitPolicyPtrOutputWithContext(context.Background())
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetResourceCreationLimitPolicyOutput).ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx)
}

// FleetResourceCreationLimitPolicyPtrInput is an input type that accepts FleetResourceCreationLimitPolicyArgs, FleetResourceCreationLimitPolicyPtr and FleetResourceCreationLimitPolicyPtrOutput values.
// You can construct a concrete instance of `FleetResourceCreationLimitPolicyPtrInput` via:
//
// 		 FleetResourceCreationLimitPolicyArgs{...}
//
//  or:
//
// 		 nil
//
type FleetResourceCreationLimitPolicyPtrInput interface {
	pulumi.Input

	ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput
	ToFleetResourceCreationLimitPolicyPtrOutputWithContext(context.Context) FleetResourceCreationLimitPolicyPtrOutput
}

type fleetResourceCreationLimitPolicyPtrType FleetResourceCreationLimitPolicyArgs

func FleetResourceCreationLimitPolicyPtr(v *FleetResourceCreationLimitPolicyArgs) FleetResourceCreationLimitPolicyPtrInput {
	return (*fleetResourceCreationLimitPolicyPtrType)(v)
}

func (*fleetResourceCreationLimitPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (i *fleetResourceCreationLimitPolicyPtrType) ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput {
	return i.ToFleetResourceCreationLimitPolicyPtrOutputWithContext(context.Background())
}

func (i *fleetResourceCreationLimitPolicyPtrType) ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetResourceCreationLimitPolicyPtrOutput)
}

type FleetResourceCreationLimitPolicyOutput struct{ *pulumi.OutputState }

func (FleetResourceCreationLimitPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyOutput() FleetResourceCreationLimitPolicyOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput {
	return o.ToFleetResourceCreationLimitPolicyPtrOutputWithContext(context.Background())
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyPtrOutput {
	return o.ApplyT(func(v FleetResourceCreationLimitPolicy) *FleetResourceCreationLimitPolicy {
		return &v
	}).(FleetResourceCreationLimitPolicyPtrOutput)
}

// Maximum number of game sessions that an individual can create during the policy period.
func (o FleetResourceCreationLimitPolicyOutput) NewGameSessionsPerCreator() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetResourceCreationLimitPolicy) *int { return v.NewGameSessionsPerCreator }).(pulumi.IntPtrOutput)
}

// Time span used in evaluating the resource creation limit policy.
func (o FleetResourceCreationLimitPolicyOutput) PolicyPeriodInMinutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetResourceCreationLimitPolicy) *int { return v.PolicyPeriodInMinutes }).(pulumi.IntPtrOutput)
}

type FleetResourceCreationLimitPolicyPtrOutput struct{ *pulumi.OutputState }

func (FleetResourceCreationLimitPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (o FleetResourceCreationLimitPolicyPtrOutput) ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyPtrOutput) ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyPtrOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyPtrOutput) Elem() FleetResourceCreationLimitPolicyOutput {
	return o.ApplyT(func(v *FleetResourceCreationLimitPolicy) FleetResourceCreationLimitPolicy { return *v }).(FleetResourceCreationLimitPolicyOutput)
}

// Maximum number of game sessions that an individual can create during the policy period.
func (o FleetResourceCreationLimitPolicyPtrOutput) NewGameSessionsPerCreator() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetResourceCreationLimitPolicy) *int { return v.NewGameSessionsPerCreator }).(pulumi.IntPtrOutput)
}

// Time span used in evaluating the resource creation limit policy.
func (o FleetResourceCreationLimitPolicyPtrOutput) PolicyPeriodInMinutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetResourceCreationLimitPolicy) *int { return v.PolicyPeriodInMinutes }).(pulumi.IntPtrOutput)
}

type FleetRuntimeConfiguration struct {
	// Maximum amount of time (in seconds) that a game session can remain in status `ACTIVATING`.
	GameSessionActivationTimeoutSeconds *int `pulumi:"gameSessionActivationTimeoutSeconds"`
	// Maximum number of game sessions with status `ACTIVATING` to allow on an instance simultaneously.
	MaxConcurrentGameSessionActivations *int `pulumi:"maxConcurrentGameSessionActivations"`
	// Collection of server process configurations that describe which server processes to run on each instance in a fleet. See below.
	ServerProcesses []FleetRuntimeConfigurationServerProcess `pulumi:"serverProcesses"`
}

// FleetRuntimeConfigurationInput is an input type that accepts FleetRuntimeConfigurationArgs and FleetRuntimeConfigurationOutput values.
// You can construct a concrete instance of `FleetRuntimeConfigurationInput` via:
//
// 		 FleetRuntimeConfigurationArgs{...}
//
type FleetRuntimeConfigurationInput interface {
	pulumi.Input

	ToFleetRuntimeConfigurationOutput() FleetRuntimeConfigurationOutput
	ToFleetRuntimeConfigurationOutputWithContext(context.Context) FleetRuntimeConfigurationOutput
}

type FleetRuntimeConfigurationArgs struct {
	// Maximum amount of time (in seconds) that a game session can remain in status `ACTIVATING`.
	GameSessionActivationTimeoutSeconds pulumi.IntPtrInput `pulumi:"gameSessionActivationTimeoutSeconds"`
	// Maximum number of game sessions with status `ACTIVATING` to allow on an instance simultaneously.
	MaxConcurrentGameSessionActivations pulumi.IntPtrInput `pulumi:"maxConcurrentGameSessionActivations"`
	// Collection of server process configurations that describe which server processes to run on each instance in a fleet. See below.
	ServerProcesses FleetRuntimeConfigurationServerProcessArrayInput `pulumi:"serverProcesses"`
}

func (FleetRuntimeConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetRuntimeConfiguration)(nil)).Elem()
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationOutput() FleetRuntimeConfigurationOutput {
	return i.ToFleetRuntimeConfigurationOutputWithContext(context.Background())
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationOutputWithContext(ctx context.Context) FleetRuntimeConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetRuntimeConfigurationOutput)
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput {
	return i.ToFleetRuntimeConfigurationPtrOutputWithContext(context.Background())
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationPtrOutputWithContext(ctx context.Context) FleetRuntimeConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetRuntimeConfigurationOutput).ToFleetRuntimeConfigurationPtrOutputWithContext(ctx)
}

// FleetRuntimeConfigurationPtrInput is an input type that accepts FleetRuntimeConfigurationArgs, FleetRuntimeConfigurationPtr and FleetRuntimeConfigurationPtrOutput values.
// You can construct a concrete instance of `FleetRuntimeConfigurationPtrInput` via:
//
// 		 FleetRuntimeConfigurationArgs{...}
//
//  or:
//
// 		 nil
//
type FleetRuntimeConfigurationPtrInput interface {
	pulumi.Input

	ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput
	ToFleetRuntimeConfigurationPtrOutputWithContext(context.Context) FleetRuntimeConfigurationPtrOutput
}

type fleetRuntimeConfigurationPtrType FleetRuntimeConfigurationArgs

func FleetRuntimeConfigurationPtr(v *FleetRuntimeConfigurationArgs) FleetRuntimeConfigurationPtrInput {
	return (*fleetRuntimeConfigurationPtrType)(v)
}

func (*fleetRuntimeConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetRuntimeConfiguration)(nil)).Elem()
}

func (i *fleetRuntimeConfigurationPtrType) ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput {
	return i.ToFleetRuntimeConfigurationPtrOutputWithContext(context.Background())
}

func (i *fleetRuntimeConfigurationPtrType) ToFleetRuntimeConfigurationPtrOutputWithContext(ctx context.Context) FleetRuntimeConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetRuntimeConfigurationPtrOutput)
}

type FleetRuntimeConfigurationOutput struct{ *pulumi.OutputState }

func (FleetRuntimeConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetRuntimeConfiguration)(nil)).Elem()
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationOutput() FleetRuntimeConfigurationOutput {
	return o
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationOutputWithContext(ctx context.Context) FleetRuntimeConfigurationOutput {
	return o
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput {
	return o.ToFleetRuntimeConfigurationPtrOutputWithContext(context.Background())
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationPtrOutputWithContext(ctx context.Context) FleetRuntimeConfigurationPtrOutput {
	return o.ApplyT(func(v FleetRuntimeConfiguration) *FleetRuntimeConfiguration {
		return &v
	}).(FleetRuntimeConfigurationPtrOutput)
}

// Maximum amount of time (in seconds) that a game session can remain in status `ACTIVATING`.
func (o FleetRuntimeConfigurationOutput) GameSessionActivationTimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetRuntimeConfiguration) *int { return v.GameSessionActivationTimeoutSeconds }).(pulumi.IntPtrOutput)
}

// Maximum number of game sessions with status `ACTIVATING` to allow on an instance simultaneously.
func (o FleetRuntimeConfigurationOutput) MaxConcurrentGameSessionActivations() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetRuntimeConfiguration) *int { return v.MaxConcurrentGameSessionActivations }).(pulumi.IntPtrOutput)
}

// Collection of server process configurations that describe which server processes to run on each instance in a fleet. See below.
func (o FleetRuntimeConfigurationOutput) ServerProcesses() FleetRuntimeConfigurationServerProcessArrayOutput {
	return o.ApplyT(func(v FleetRuntimeConfiguration) []FleetRuntimeConfigurationServerProcess { return v.ServerProcesses }).(FleetRuntimeConfigurationServerProcessArrayOutput)
}

type FleetRuntimeConfigurationPtrOutput struct{ *pulumi.OutputState }

func (FleetRuntimeConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetRuntimeConfiguration)(nil)).Elem()
}

func (o FleetRuntimeConfigurationPtrOutput) ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput {
	return o
}

func (o FleetRuntimeConfigurationPtrOutput) ToFleetRuntimeConfigurationPtrOutputWithContext(ctx context.Context) FleetRuntimeConfigurationPtrOutput {
	return o
}

func (o FleetRuntimeConfigurationPtrOutput) Elem() FleetRuntimeConfigurationOutput {
	return o.ApplyT(func(v *FleetRuntimeConfiguration) FleetRuntimeConfiguration { return *v }).(FleetRuntimeConfigurationOutput)
}

// Maximum amount of time (in seconds) that a game session can remain in status `ACTIVATING`.
func (o FleetRuntimeConfigurationPtrOutput) GameSessionActivationTimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetRuntimeConfiguration) *int { return v.GameSessionActivationTimeoutSeconds }).(pulumi.IntPtrOutput)
}

// Maximum number of game sessions with status `ACTIVATING` to allow on an instance simultaneously.
func (o FleetRuntimeConfigurationPtrOutput) MaxConcurrentGameSessionActivations() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetRuntimeConfiguration) *int { return v.MaxConcurrentGameSessionActivations }).(pulumi.IntPtrOutput)
}

// Collection of server process configurations that describe which server processes to run on each instance in a fleet. See below.
func (o FleetRuntimeConfigurationPtrOutput) ServerProcesses() FleetRuntimeConfigurationServerProcessArrayOutput {
	return o.ApplyT(func(v FleetRuntimeConfiguration) []FleetRuntimeConfigurationServerProcess { return v.ServerProcesses }).(FleetRuntimeConfigurationServerProcessArrayOutput)
}

type FleetRuntimeConfigurationServerProcess struct {
	// Number of server processes using this configuration to run concurrently on an instance.
	ConcurrentExecutions int `pulumi:"concurrentExecutions"`
	// Location of the server executable in a game build. All game builds are installed on instances at the root : for Windows instances `C:\game`, and for Linux instances `/local/game`.
	LaunchPath string `pulumi:"launchPath"`
	// Optional list of parameters to pass to the server executable on launch.
	Parameters *string `pulumi:"parameters"`
}

// FleetRuntimeConfigurationServerProcessInput is an input type that accepts FleetRuntimeConfigurationServerProcessArgs and FleetRuntimeConfigurationServerProcessOutput values.
// You can construct a concrete instance of `FleetRuntimeConfigurationServerProcessInput` via:
//
// 		 FleetRuntimeConfigurationServerProcessArgs{...}
//
type FleetRuntimeConfigurationServerProcessInput interface {
	pulumi.Input

	ToFleetRuntimeConfigurationServerProcessOutput() FleetRuntimeConfigurationServerProcessOutput
	ToFleetRuntimeConfigurationServerProcessOutputWithContext(context.Context) FleetRuntimeConfigurationServerProcessOutput
}

type FleetRuntimeConfigurationServerProcessArgs struct {
	// Number of server processes using this configuration to run concurrently on an instance.
	ConcurrentExecutions pulumi.IntInput `pulumi:"concurrentExecutions"`
	// Location of the server executable in a game build. All game builds are installed on instances at the root : for Windows instances `C:\game`, and for Linux instances `/local/game`.
	LaunchPath pulumi.StringInput `pulumi:"launchPath"`
	// Optional list of parameters to pass to the server executable on launch.
	Parameters pulumi.StringPtrInput `pulumi:"parameters"`
}

func (FleetRuntimeConfigurationServerProcessArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetRuntimeConfigurationServerProcess)(nil)).Elem()
}

func (i FleetRuntimeConfigurationServerProcessArgs) ToFleetRuntimeConfigurationServerProcessOutput() FleetRuntimeConfigurationServerProcessOutput {
	return i.ToFleetRuntimeConfigurationServerProcessOutputWithContext(context.Background())
}

func (i FleetRuntimeConfigurationServerProcessArgs) ToFleetRuntimeConfigurationServerProcessOutputWithContext(ctx context.Context) FleetRuntimeConfigurationServerProcessOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetRuntimeConfigurationServerProcessOutput)
}

// FleetRuntimeConfigurationServerProcessArrayInput is an input type that accepts FleetRuntimeConfigurationServerProcessArray and FleetRuntimeConfigurationServerProcessArrayOutput values.
// You can construct a concrete instance of `FleetRuntimeConfigurationServerProcessArrayInput` via:
//
// 		 FleetRuntimeConfigurationServerProcessArray{ FleetRuntimeConfigurationServerProcessArgs{...} }
//
type FleetRuntimeConfigurationServerProcessArrayInput interface {
	pulumi.Input

	ToFleetRuntimeConfigurationServerProcessArrayOutput() FleetRuntimeConfigurationServerProcessArrayOutput
	ToFleetRuntimeConfigurationServerProcessArrayOutputWithContext(context.Context) FleetRuntimeConfigurationServerProcessArrayOutput
}

type FleetRuntimeConfigurationServerProcessArray []FleetRuntimeConfigurationServerProcessInput

func (FleetRuntimeConfigurationServerProcessArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetRuntimeConfigurationServerProcess)(nil)).Elem()
}

func (i FleetRuntimeConfigurationServerProcessArray) ToFleetRuntimeConfigurationServerProcessArrayOutput() FleetRuntimeConfigurationServerProcessArrayOutput {
	return i.ToFleetRuntimeConfigurationServerProcessArrayOutputWithContext(context.Background())
}

func (i FleetRuntimeConfigurationServerProcessArray) ToFleetRuntimeConfigurationServerProcessArrayOutputWithContext(ctx context.Context) FleetRuntimeConfigurationServerProcessArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetRuntimeConfigurationServerProcessArrayOutput)
}

type FleetRuntimeConfigurationServerProcessOutput struct{ *pulumi.OutputState }

func (FleetRuntimeConfigurationServerProcessOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetRuntimeConfigurationServerProcess)(nil)).Elem()
}

func (o FleetRuntimeConfigurationServerProcessOutput) ToFleetRuntimeConfigurationServerProcessOutput() FleetRuntimeConfigurationServerProcessOutput {
	return o
}

func (o FleetRuntimeConfigurationServerProcessOutput) ToFleetRuntimeConfigurationServerProcessOutputWithContext(ctx context.Context) FleetRuntimeConfigurationServerProcessOutput {
	return o
}

// Number of server processes using this configuration to run concurrently on an instance.
func (o FleetRuntimeConfigurationServerProcessOutput) ConcurrentExecutions() pulumi.IntOutput {
	return o.ApplyT(func(v FleetRuntimeConfigurationServerProcess) int { return v.ConcurrentExecutions }).(pulumi.IntOutput)
}

// Location of the server executable in a game build. All game builds are installed on instances at the root : for Windows instances `C:\game`, and for Linux instances `/local/game`.
func (o FleetRuntimeConfigurationServerProcessOutput) LaunchPath() pulumi.StringOutput {
	return o.ApplyT(func(v FleetRuntimeConfigurationServerProcess) string { return v.LaunchPath }).(pulumi.StringOutput)
}

// Optional list of parameters to pass to the server executable on launch.
func (o FleetRuntimeConfigurationServerProcessOutput) Parameters() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FleetRuntimeConfigurationServerProcess) *string { return v.Parameters }).(pulumi.StringPtrOutput)
}

type FleetRuntimeConfigurationServerProcessArrayOutput struct{ *pulumi.OutputState }

func (FleetRuntimeConfigurationServerProcessArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetRuntimeConfigurationServerProcess)(nil)).Elem()
}

func (o FleetRuntimeConfigurationServerProcessArrayOutput) ToFleetRuntimeConfigurationServerProcessArrayOutput() FleetRuntimeConfigurationServerProcessArrayOutput {
	return o
}

func (o FleetRuntimeConfigurationServerProcessArrayOutput) ToFleetRuntimeConfigurationServerProcessArrayOutputWithContext(ctx context.Context) FleetRuntimeConfigurationServerProcessArrayOutput {
	return o
}

func (o FleetRuntimeConfigurationServerProcessArrayOutput) Index(i pulumi.IntInput) FleetRuntimeConfigurationServerProcessOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FleetRuntimeConfigurationServerProcess {
		return vs[0].([]FleetRuntimeConfigurationServerProcess)[vs[1].(int)]
	}).(FleetRuntimeConfigurationServerProcessOutput)
}

type GameSessionQueuePlayerLatencyPolicy struct {
	// Maximum latency value that is allowed for any player.
	MaximumIndividualPlayerLatencyMilliseconds int `pulumi:"maximumIndividualPlayerLatencyMilliseconds"`
	// Length of time that the policy is enforced while placing a new game session. Absence of value for this attribute means that the policy is enforced until the queue times out.
	PolicyDurationSeconds *int `pulumi:"policyDurationSeconds"`
}

// GameSessionQueuePlayerLatencyPolicyInput is an input type that accepts GameSessionQueuePlayerLatencyPolicyArgs and GameSessionQueuePlayerLatencyPolicyOutput values.
// You can construct a concrete instance of `GameSessionQueuePlayerLatencyPolicyInput` via:
//
// 		 GameSessionQueuePlayerLatencyPolicyArgs{...}
//
type GameSessionQueuePlayerLatencyPolicyInput interface {
	pulumi.Input

	ToGameSessionQueuePlayerLatencyPolicyOutput() GameSessionQueuePlayerLatencyPolicyOutput
	ToGameSessionQueuePlayerLatencyPolicyOutputWithContext(context.Context) GameSessionQueuePlayerLatencyPolicyOutput
}

type GameSessionQueuePlayerLatencyPolicyArgs struct {
	// Maximum latency value that is allowed for any player.
	MaximumIndividualPlayerLatencyMilliseconds pulumi.IntInput `pulumi:"maximumIndividualPlayerLatencyMilliseconds"`
	// Length of time that the policy is enforced while placing a new game session. Absence of value for this attribute means that the policy is enforced until the queue times out.
	PolicyDurationSeconds pulumi.IntPtrInput `pulumi:"policyDurationSeconds"`
}

func (GameSessionQueuePlayerLatencyPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueuePlayerLatencyPolicy)(nil)).Elem()
}

func (i GameSessionQueuePlayerLatencyPolicyArgs) ToGameSessionQueuePlayerLatencyPolicyOutput() GameSessionQueuePlayerLatencyPolicyOutput {
	return i.ToGameSessionQueuePlayerLatencyPolicyOutputWithContext(context.Background())
}

func (i GameSessionQueuePlayerLatencyPolicyArgs) ToGameSessionQueuePlayerLatencyPolicyOutputWithContext(ctx context.Context) GameSessionQueuePlayerLatencyPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueuePlayerLatencyPolicyOutput)
}

// GameSessionQueuePlayerLatencyPolicyArrayInput is an input type that accepts GameSessionQueuePlayerLatencyPolicyArray and GameSessionQueuePlayerLatencyPolicyArrayOutput values.
// You can construct a concrete instance of `GameSessionQueuePlayerLatencyPolicyArrayInput` via:
//
// 		 GameSessionQueuePlayerLatencyPolicyArray{ GameSessionQueuePlayerLatencyPolicyArgs{...} }
//
type GameSessionQueuePlayerLatencyPolicyArrayInput interface {
	pulumi.Input

	ToGameSessionQueuePlayerLatencyPolicyArrayOutput() GameSessionQueuePlayerLatencyPolicyArrayOutput
	ToGameSessionQueuePlayerLatencyPolicyArrayOutputWithContext(context.Context) GameSessionQueuePlayerLatencyPolicyArrayOutput
}

type GameSessionQueuePlayerLatencyPolicyArray []GameSessionQueuePlayerLatencyPolicyInput

func (GameSessionQueuePlayerLatencyPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameSessionQueuePlayerLatencyPolicy)(nil)).Elem()
}

func (i GameSessionQueuePlayerLatencyPolicyArray) ToGameSessionQueuePlayerLatencyPolicyArrayOutput() GameSessionQueuePlayerLatencyPolicyArrayOutput {
	return i.ToGameSessionQueuePlayerLatencyPolicyArrayOutputWithContext(context.Background())
}

func (i GameSessionQueuePlayerLatencyPolicyArray) ToGameSessionQueuePlayerLatencyPolicyArrayOutputWithContext(ctx context.Context) GameSessionQueuePlayerLatencyPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueuePlayerLatencyPolicyArrayOutput)
}

type GameSessionQueuePlayerLatencyPolicyOutput struct{ *pulumi.OutputState }

func (GameSessionQueuePlayerLatencyPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueuePlayerLatencyPolicy)(nil)).Elem()
}

func (o GameSessionQueuePlayerLatencyPolicyOutput) ToGameSessionQueuePlayerLatencyPolicyOutput() GameSessionQueuePlayerLatencyPolicyOutput {
	return o
}

func (o GameSessionQueuePlayerLatencyPolicyOutput) ToGameSessionQueuePlayerLatencyPolicyOutputWithContext(ctx context.Context) GameSessionQueuePlayerLatencyPolicyOutput {
	return o
}

// Maximum latency value that is allowed for any player.
func (o GameSessionQueuePlayerLatencyPolicyOutput) MaximumIndividualPlayerLatencyMilliseconds() pulumi.IntOutput {
	return o.ApplyT(func(v GameSessionQueuePlayerLatencyPolicy) int { return v.MaximumIndividualPlayerLatencyMilliseconds }).(pulumi.IntOutput)
}

// Length of time that the policy is enforced while placing a new game session. Absence of value for this attribute means that the policy is enforced until the queue times out.
func (o GameSessionQueuePlayerLatencyPolicyOutput) PolicyDurationSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GameSessionQueuePlayerLatencyPolicy) *int { return v.PolicyDurationSeconds }).(pulumi.IntPtrOutput)
}

type GameSessionQueuePlayerLatencyPolicyArrayOutput struct{ *pulumi.OutputState }

func (GameSessionQueuePlayerLatencyPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameSessionQueuePlayerLatencyPolicy)(nil)).Elem()
}

func (o GameSessionQueuePlayerLatencyPolicyArrayOutput) ToGameSessionQueuePlayerLatencyPolicyArrayOutput() GameSessionQueuePlayerLatencyPolicyArrayOutput {
	return o
}

func (o GameSessionQueuePlayerLatencyPolicyArrayOutput) ToGameSessionQueuePlayerLatencyPolicyArrayOutputWithContext(ctx context.Context) GameSessionQueuePlayerLatencyPolicyArrayOutput {
	return o
}

func (o GameSessionQueuePlayerLatencyPolicyArrayOutput) Index(i pulumi.IntInput) GameSessionQueuePlayerLatencyPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GameSessionQueuePlayerLatencyPolicy {
		return vs[0].([]GameSessionQueuePlayerLatencyPolicy)[vs[1].(int)]
	}).(GameSessionQueuePlayerLatencyPolicyOutput)
}

func init() {
	pulumi.RegisterOutputType(AliasRoutingStrategyOutput{})
	pulumi.RegisterOutputType(AliasRoutingStrategyPtrOutput{})
	pulumi.RegisterOutputType(BuildStorageLocationOutput{})
	pulumi.RegisterOutputType(BuildStorageLocationPtrOutput{})
	pulumi.RegisterOutputType(FleetEc2InboundPermissionOutput{})
	pulumi.RegisterOutputType(FleetEc2InboundPermissionArrayOutput{})
	pulumi.RegisterOutputType(FleetResourceCreationLimitPolicyOutput{})
	pulumi.RegisterOutputType(FleetResourceCreationLimitPolicyPtrOutput{})
	pulumi.RegisterOutputType(FleetRuntimeConfigurationOutput{})
	pulumi.RegisterOutputType(FleetRuntimeConfigurationPtrOutput{})
	pulumi.RegisterOutputType(FleetRuntimeConfigurationServerProcessOutput{})
	pulumi.RegisterOutputType(FleetRuntimeConfigurationServerProcessArrayOutput{})
	pulumi.RegisterOutputType(GameSessionQueuePlayerLatencyPolicyOutput{})
	pulumi.RegisterOutputType(GameSessionQueuePlayerLatencyPolicyArrayOutput{})
}
