// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package timestreamquery

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Resource for managing an AWS Timestream Query Scheduled Query.
//
// ## Example Usage
//
// ### Basic Usage
//
// Before creating a scheduled query, you must have a source database and table with ingested data. Below is a multi-step example, providing an opportunity for data ingestion.
//
// If your infrastructure is already set up—including the source database and table with data, results database and table, error report S3 bucket, SNS topic, and IAM role—you can create a scheduled query as follows:
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/timestreamquery"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := timestreamquery.NewScheduledQuery(ctx, "example", &timestreamquery.ScheduledQueryArgs{
//				ExecutionRoleArn: pulumi.Any(exampleAwsIamRole.Arn),
//				Name:             pulumi.Any(exampleAwsTimestreamwriteTable.TableName),
//				QueryString: pulumi.String(`SELECT region, az, hostname, BIN(time, 15s) AS binned_timestamp,
//		ROUND(AVG(cpu_utilization), 2) AS avg_cpu_utilization,
//		ROUND(APPROX_PERCENTILE(cpu_utilization, 0.9), 2) AS p90_cpu_utilization,
//		ROUND(APPROX_PERCENTILE(cpu_utilization, 0.95), 2) AS p95_cpu_utilization,
//		ROUND(APPROX_PERCENTILE(cpu_utilization, 0.99), 2) AS p99_cpu_utilization
//
// FROM exampledatabase.exampletable
// WHERE measure_name = 'metrics' AND time > ago(2h)
// GROUP BY region, hostname, az, BIN(time, 15s)
// ORDER BY binned_timestamp ASC
// LIMIT 5
// `),
//
//				ErrorReportConfiguration: &timestreamquery.ScheduledQueryErrorReportConfigurationArgs{
//					S3Configuration: &timestreamquery.ScheduledQueryErrorReportConfigurationS3ConfigurationArgs{
//						BucketName: pulumi.Any(exampleAwsS3Bucket.Bucket),
//					},
//				},
//				NotificationConfiguration: &timestreamquery.ScheduledQueryNotificationConfigurationArgs{
//					SnsConfiguration: &timestreamquery.ScheduledQueryNotificationConfigurationSnsConfigurationArgs{
//						TopicArn: pulumi.Any(exampleAwsSnsTopic.Arn),
//					},
//				},
//				ScheduleConfiguration: &timestreamquery.ScheduledQueryScheduleConfigurationArgs{
//					ScheduleExpression: pulumi.String("rate(1 hour)"),
//				},
//				TargetConfiguration: &timestreamquery.ScheduledQueryTargetConfigurationArgs{
//					TimestreamConfiguration: &timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationArgs{
//						DatabaseName: pulumi.Any(results.DatabaseName),
//						TableName:    pulumi.Any(resultsAwsTimestreamwriteTable.TableName),
//						TimeColumn:   pulumi.String("binned_timestamp"),
//						DimensionMappings: timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArray{
//							&timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgs{
//								DimensionValueType: pulumi.String("VARCHAR"),
//								Name:               pulumi.String("az"),
//							},
//							&timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgs{
//								DimensionValueType: pulumi.String("VARCHAR"),
//								Name:               pulumi.String("region"),
//							},
//							&timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgs{
//								DimensionValueType: pulumi.String("VARCHAR"),
//								Name:               pulumi.String("hostname"),
//							},
//						},
//						MultiMeasureMappings: &timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgs{
//							TargetMultiMeasureName: pulumi.String("multi-metrics"),
//							MultiMeasureAttributeMappings: timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArray{
//								&timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgs{
//									MeasureValueType: pulumi.String("DOUBLE"),
//									SourceColumn:     pulumi.String("avg_cpu_utilization"),
//								},
//								&timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgs{
//									MeasureValueType: pulumi.String("DOUBLE"),
//									SourceColumn:     pulumi.String("p90_cpu_utilization"),
//								},
//								&timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgs{
//									MeasureValueType: pulumi.String("DOUBLE"),
//									SourceColumn:     pulumi.String("p95_cpu_utilization"),
//								},
//								&timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgs{
//									MeasureValueType: pulumi.String("DOUBLE"),
//									SourceColumn:     pulumi.String("p99_cpu_utilization"),
//								},
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Multi-step Example
//
// To ingest data before creating a scheduled query, this example provides multiple steps:
//
// 1. Create the prerequisite infrastructure
// 2. Ingest data
// 3. Create the scheduled query
//
// ### Step 1. Create the prerequisite infrastructure
//
// ```go
// package main
//
// import (
//
//	"encoding/json"
//
//	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/iam"
//	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/s3"
//	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/sns"
//	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/sqs"
//	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/timestreamwrite"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := s3.NewBucketV2(ctx, "test", &s3.BucketV2Args{
//				Bucket:       pulumi.String("example"),
//				ForceDestroy: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			testTopic, err := sns.NewTopic(ctx, "test", &sns.TopicArgs{
//				Name: pulumi.String("example"),
//			})
//			if err != nil {
//				return err
//			}
//			testQueue, err := sqs.NewQueue(ctx, "test", &sqs.QueueArgs{
//				Name:                 pulumi.String("example"),
//				SqsManagedSseEnabled: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = sns.NewTopicSubscription(ctx, "test", &sns.TopicSubscriptionArgs{
//				Topic:    testTopic.Arn,
//				Protocol: pulumi.String("sqs"),
//				Endpoint: testQueue.Arn,
//			})
//			if err != nil {
//				return err
//			}
//			_, err = sqs.NewQueuePolicy(ctx, "test", &sqs.QueuePolicyArgs{
//				QueueUrl: testQueue.ID(),
//				Policy: pulumi.All(testQueue.Arn, testTopic.Arn).ApplyT(func(_args []interface{}) (string, error) {
//					testQueueArn := _args[0].(string)
//					testTopicArn := _args[1].(string)
//					var _zero string
//					tmpJSON0, err := json.Marshal(map[string]interface{}{
//						"Version": "2012-10-17",
//						"Statement": []map[string]interface{}{
//							map[string]interface{}{
//								"Effect": "Allow",
//								"Principal": map[string]interface{}{
//									"AWS": "*",
//								},
//								"Action": []string{
//									"sqs:SendMessage",
//								},
//								"Resource": testQueueArn,
//								"Condition": map[string]interface{}{
//									"ArnEquals": map[string]interface{}{
//										"aws:SourceArn": testTopicArn,
//									},
//								},
//							},
//						},
//					})
//					if err != nil {
//						return _zero, err
//					}
//					json0 := string(tmpJSON0)
//					return json0, nil
//				}).(pulumi.StringOutput),
//			})
//			if err != nil {
//				return err
//			}
//			tmpJSON1, err := json.Marshal(map[string]interface{}{
//				"Version": "2012-10-17",
//				"Statement": []map[string]interface{}{
//					map[string]interface{}{
//						"Effect": "Allow",
//						"Principal": map[string]interface{}{
//							"Service": "timestream.amazonaws.com",
//						},
//						"Action": "sts:AssumeRole",
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			json1 := string(tmpJSON1)
//			testRole, err := iam.NewRole(ctx, "test", &iam.RoleArgs{
//				Name:             pulumi.String("example"),
//				AssumeRolePolicy: pulumi.String(json1),
//				Tags: pulumi.StringMap{
//					"Name": pulumi.String("example"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			tmpJSON2, err := json.Marshal(map[string]interface{}{
//				"Version": "2012-10-17",
//				"Statement": []map[string]interface{}{
//					map[string]interface{}{
//						"Action": []string{
//							"kms:Decrypt",
//							"sns:Publish",
//							"timestream:describeEndpoints",
//							"timestream:Select",
//							"timestream:SelectValues",
//							"timestream:WriteRecords",
//							"s3:PutObject",
//						},
//						"Resource": "*",
//						"Effect":   "Allow",
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			json2 := string(tmpJSON2)
//			_, err = iam.NewRolePolicy(ctx, "test", &iam.RolePolicyArgs{
//				Name:   pulumi.String("example"),
//				Role:   testRole.ID(),
//				Policy: pulumi.String(json2),
//			})
//			if err != nil {
//				return err
//			}
//			testDatabase, err := timestreamwrite.NewDatabase(ctx, "test", &timestreamwrite.DatabaseArgs{
//				DatabaseName: pulumi.String("exampledatabase"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = timestreamwrite.NewTable(ctx, "test", &timestreamwrite.TableArgs{
//				DatabaseName: testDatabase.DatabaseName,
//				TableName:    pulumi.String("exampletable"),
//				MagneticStoreWriteProperties: &timestreamwrite.TableMagneticStoreWritePropertiesArgs{
//					EnableMagneticStoreWrites: pulumi.Bool(true),
//				},
//				RetentionProperties: &timestreamwrite.TableRetentionPropertiesArgs{
//					MagneticStoreRetentionPeriodInDays: pulumi.Int(1),
//					MemoryStoreRetentionPeriodInHours:  pulumi.Int(1),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			results, err := timestreamwrite.NewDatabase(ctx, "results", &timestreamwrite.DatabaseArgs{
//				DatabaseName: pulumi.String("exampledatabase-results"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = timestreamwrite.NewTable(ctx, "results", &timestreamwrite.TableArgs{
//				DatabaseName: results.DatabaseName,
//				TableName:    pulumi.String("exampletable-results"),
//				MagneticStoreWriteProperties: &timestreamwrite.TableMagneticStoreWritePropertiesArgs{
//					EnableMagneticStoreWrites: pulumi.Bool(true),
//				},
//				RetentionProperties: &timestreamwrite.TableRetentionPropertiesArgs{
//					MagneticStoreRetentionPeriodInDays: pulumi.Int(1),
//					MemoryStoreRetentionPeriodInHours:  pulumi.Int(1),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// #### Step 2. Ingest data
//
// This is done with Amazon Timestream Write [WriteRecords](https://docs.aws.amazon.com/timestream/latest/developerguide/API_WriteRecords.html).
//
// ### Step 3. Create the scheduled query
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/timestreamquery"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := timestreamquery.NewScheduledQuery(ctx, "example", &timestreamquery.ScheduledQueryArgs{
//				ExecutionRoleArn: pulumi.Any(exampleAwsIamRole.Arn),
//				Name:             pulumi.Any(exampleAwsTimestreamwriteTable.TableName),
//				QueryString: pulumi.String(`SELECT region, az, hostname, BIN(time, 15s) AS binned_timestamp,
//		ROUND(AVG(cpu_utilization), 2) AS avg_cpu_utilization,
//		ROUND(APPROX_PERCENTILE(cpu_utilization, 0.9), 2) AS p90_cpu_utilization,
//		ROUND(APPROX_PERCENTILE(cpu_utilization, 0.95), 2) AS p95_cpu_utilization,
//		ROUND(APPROX_PERCENTILE(cpu_utilization, 0.99), 2) AS p99_cpu_utilization
//
// FROM exampledatabase.exampletable
// WHERE measure_name = 'metrics' AND time > ago(2h)
// GROUP BY region, hostname, az, BIN(time, 15s)
// ORDER BY binned_timestamp ASC
// LIMIT 5
// `),
//
//				ErrorReportConfiguration: &timestreamquery.ScheduledQueryErrorReportConfigurationArgs{
//					S3Configuration: &timestreamquery.ScheduledQueryErrorReportConfigurationS3ConfigurationArgs{
//						BucketName: pulumi.Any(exampleAwsS3Bucket.Bucket),
//					},
//				},
//				NotificationConfiguration: &timestreamquery.ScheduledQueryNotificationConfigurationArgs{
//					SnsConfiguration: &timestreamquery.ScheduledQueryNotificationConfigurationSnsConfigurationArgs{
//						TopicArn: pulumi.Any(exampleAwsSnsTopic.Arn),
//					},
//				},
//				ScheduleConfiguration: &timestreamquery.ScheduledQueryScheduleConfigurationArgs{
//					ScheduleExpression: pulumi.String("rate(1 hour)"),
//				},
//				TargetConfiguration: &timestreamquery.ScheduledQueryTargetConfigurationArgs{
//					TimestreamConfiguration: &timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationArgs{
//						DatabaseName: pulumi.Any(results.DatabaseName),
//						TableName:    pulumi.Any(resultsAwsTimestreamwriteTable.TableName),
//						TimeColumn:   pulumi.String("binned_timestamp"),
//						DimensionMappings: timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArray{
//							&timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgs{
//								DimensionValueType: pulumi.String("VARCHAR"),
//								Name:               pulumi.String("az"),
//							},
//							&timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgs{
//								DimensionValueType: pulumi.String("VARCHAR"),
//								Name:               pulumi.String("region"),
//							},
//							&timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationDimensionMappingArgs{
//								DimensionValueType: pulumi.String("VARCHAR"),
//								Name:               pulumi.String("hostname"),
//							},
//						},
//						MultiMeasureMappings: &timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsArgs{
//							TargetMultiMeasureName: pulumi.String("multi-metrics"),
//							MultiMeasureAttributeMappings: timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArray{
//								&timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgs{
//									MeasureValueType: pulumi.String("DOUBLE"),
//									SourceColumn:     pulumi.String("avg_cpu_utilization"),
//								},
//								&timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgs{
//									MeasureValueType: pulumi.String("DOUBLE"),
//									SourceColumn:     pulumi.String("p90_cpu_utilization"),
//								},
//								&timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgs{
//									MeasureValueType: pulumi.String("DOUBLE"),
//									SourceColumn:     pulumi.String("p95_cpu_utilization"),
//								},
//								&timestreamquery.ScheduledQueryTargetConfigurationTimestreamConfigurationMultiMeasureMappingsMultiMeasureAttributeMappingArgs{
//									MeasureValueType: pulumi.String("DOUBLE"),
//									SourceColumn:     pulumi.String("p99_cpu_utilization"),
//								},
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Using `pulumi import`, import Timestream Query Scheduled Query using the `arn`. For example:
//
// ```sh
// $ pulumi import aws:timestreamquery/scheduledQuery:ScheduledQuery example arn:aws:timestream:us-west-2:012345678901:scheduled-query/tf-acc-test-7774188528604787105-e13659544fe66c8d
// ```
type ScheduledQuery struct {
	pulumi.CustomResourceState

	// ARN of the Scheduled Query.
	Arn pulumi.StringOutput `pulumi:"arn"`
	// Creation time for the scheduled query.
	CreationTime pulumi.StringOutput `pulumi:"creationTime"`
	// Configuration block for error reporting configuration. See below.
	ErrorReportConfiguration ScheduledQueryErrorReportConfigurationOutput `pulumi:"errorReportConfiguration"`
	// ARN for the IAM role that Timestream will assume when running the scheduled query.
	ExecutionRoleArn pulumi.StringOutput `pulumi:"executionRoleArn"`
	// Amazon KMS key used to encrypt the scheduled query resource, at-rest. If not specified, the scheduled query resource will be encrypted with a Timestream owned Amazon KMS key. To specify a KMS key, use the key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix the name with "alias/". If `errorReportConfiguration` uses `SSE_KMS` as the encryption type, the same `kmsKeyId` is used to encrypt the error report at rest.
	KmsKeyId pulumi.StringPtrOutput `pulumi:"kmsKeyId"`
	// Runtime summary for the last scheduled query run.
	LastRunSummaries ScheduledQueryLastRunSummaryArrayOutput `pulumi:"lastRunSummaries"`
	// Name of the scheduled query.
	Name pulumi.StringOutput `pulumi:"name"`
	// Next time the scheduled query is scheduled to run.
	NextInvocationTime pulumi.StringOutput `pulumi:"nextInvocationTime"`
	// Configuration block for notification configuration for a scheduled query. A notification is sent by Timestream when a scheduled query is created, its state is updated, or when it is deleted. See below.
	NotificationConfiguration ScheduledQueryNotificationConfigurationOutput `pulumi:"notificationConfiguration"`
	// Last time the scheduled query was run.
	PreviousInvocationTime pulumi.StringOutput `pulumi:"previousInvocationTime"`
	// Query string to run. Parameter names can be specified in the query string using the `@` character followed by an identifier. The named parameter `@scheduled_runtime` is reserved and can be used in the query to get the time at which the query is scheduled to run. The timestamp calculated according to the `scheduleConfiguration` parameter, will be the value of `@scheduled_runtime` paramater for each query run. For example, consider an instance of a scheduled query executing on 2021-12-01 00:00:00. For this instance, the `@scheduled_runtime` parameter is initialized to the timestamp 2021-12-01 00:00:00 when invoking the query.
	QueryString pulumi.StringOutput `pulumi:"queryString"`
	// Runtime summary for the last five failed scheduled query runs.
	RecentlyFailedRuns ScheduledQueryRecentlyFailedRunArrayOutput `pulumi:"recentlyFailedRuns"`
	// Configuration block for schedule configuration for the query. See below.
	ScheduleConfiguration ScheduledQueryScheduleConfigurationOutput `pulumi:"scheduleConfiguration"`
	// State of the scheduled query, either `ENABLED` or `DISABLED`.
	State pulumi.StringOutput `pulumi:"state"`
	// Map of tags assigned to the resource. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags pulumi.StringMapOutput `pulumi:"tags"`
	// Map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
	//
	// Deprecated: Please use `tags` instead.
	TagsAll pulumi.StringMapOutput `pulumi:"tagsAll"`
	// Configuration block for writing the result of a query. See below.
	//
	// The following arguments are optional:
	TargetConfiguration ScheduledQueryTargetConfigurationOutput `pulumi:"targetConfiguration"`
	Timeouts            ScheduledQueryTimeoutsPtrOutput         `pulumi:"timeouts"`
}

// NewScheduledQuery registers a new resource with the given unique name, arguments, and options.
func NewScheduledQuery(ctx *pulumi.Context,
	name string, args *ScheduledQueryArgs, opts ...pulumi.ResourceOption) (*ScheduledQuery, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ErrorReportConfiguration == nil {
		return nil, errors.New("invalid value for required argument 'ErrorReportConfiguration'")
	}
	if args.ExecutionRoleArn == nil {
		return nil, errors.New("invalid value for required argument 'ExecutionRoleArn'")
	}
	if args.NotificationConfiguration == nil {
		return nil, errors.New("invalid value for required argument 'NotificationConfiguration'")
	}
	if args.QueryString == nil {
		return nil, errors.New("invalid value for required argument 'QueryString'")
	}
	if args.ScheduleConfiguration == nil {
		return nil, errors.New("invalid value for required argument 'ScheduleConfiguration'")
	}
	if args.TargetConfiguration == nil {
		return nil, errors.New("invalid value for required argument 'TargetConfiguration'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ScheduledQuery
	err := ctx.RegisterResource("aws:timestreamquery/scheduledQuery:ScheduledQuery", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetScheduledQuery gets an existing ScheduledQuery resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetScheduledQuery(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ScheduledQueryState, opts ...pulumi.ResourceOption) (*ScheduledQuery, error) {
	var resource ScheduledQuery
	err := ctx.ReadResource("aws:timestreamquery/scheduledQuery:ScheduledQuery", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ScheduledQuery resources.
type scheduledQueryState struct {
	// ARN of the Scheduled Query.
	Arn *string `pulumi:"arn"`
	// Creation time for the scheduled query.
	CreationTime *string `pulumi:"creationTime"`
	// Configuration block for error reporting configuration. See below.
	ErrorReportConfiguration *ScheduledQueryErrorReportConfiguration `pulumi:"errorReportConfiguration"`
	// ARN for the IAM role that Timestream will assume when running the scheduled query.
	ExecutionRoleArn *string `pulumi:"executionRoleArn"`
	// Amazon KMS key used to encrypt the scheduled query resource, at-rest. If not specified, the scheduled query resource will be encrypted with a Timestream owned Amazon KMS key. To specify a KMS key, use the key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix the name with "alias/". If `errorReportConfiguration` uses `SSE_KMS` as the encryption type, the same `kmsKeyId` is used to encrypt the error report at rest.
	KmsKeyId *string `pulumi:"kmsKeyId"`
	// Runtime summary for the last scheduled query run.
	LastRunSummaries []ScheduledQueryLastRunSummary `pulumi:"lastRunSummaries"`
	// Name of the scheduled query.
	Name *string `pulumi:"name"`
	// Next time the scheduled query is scheduled to run.
	NextInvocationTime *string `pulumi:"nextInvocationTime"`
	// Configuration block for notification configuration for a scheduled query. A notification is sent by Timestream when a scheduled query is created, its state is updated, or when it is deleted. See below.
	NotificationConfiguration *ScheduledQueryNotificationConfiguration `pulumi:"notificationConfiguration"`
	// Last time the scheduled query was run.
	PreviousInvocationTime *string `pulumi:"previousInvocationTime"`
	// Query string to run. Parameter names can be specified in the query string using the `@` character followed by an identifier. The named parameter `@scheduled_runtime` is reserved and can be used in the query to get the time at which the query is scheduled to run. The timestamp calculated according to the `scheduleConfiguration` parameter, will be the value of `@scheduled_runtime` paramater for each query run. For example, consider an instance of a scheduled query executing on 2021-12-01 00:00:00. For this instance, the `@scheduled_runtime` parameter is initialized to the timestamp 2021-12-01 00:00:00 when invoking the query.
	QueryString *string `pulumi:"queryString"`
	// Runtime summary for the last five failed scheduled query runs.
	RecentlyFailedRuns []ScheduledQueryRecentlyFailedRun `pulumi:"recentlyFailedRuns"`
	// Configuration block for schedule configuration for the query. See below.
	ScheduleConfiguration *ScheduledQueryScheduleConfiguration `pulumi:"scheduleConfiguration"`
	// State of the scheduled query, either `ENABLED` or `DISABLED`.
	State *string `pulumi:"state"`
	// Map of tags assigned to the resource. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags map[string]string `pulumi:"tags"`
	// Map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
	//
	// Deprecated: Please use `tags` instead.
	TagsAll map[string]string `pulumi:"tagsAll"`
	// Configuration block for writing the result of a query. See below.
	//
	// The following arguments are optional:
	TargetConfiguration *ScheduledQueryTargetConfiguration `pulumi:"targetConfiguration"`
	Timeouts            *ScheduledQueryTimeouts            `pulumi:"timeouts"`
}

type ScheduledQueryState struct {
	// ARN of the Scheduled Query.
	Arn pulumi.StringPtrInput
	// Creation time for the scheduled query.
	CreationTime pulumi.StringPtrInput
	// Configuration block for error reporting configuration. See below.
	ErrorReportConfiguration ScheduledQueryErrorReportConfigurationPtrInput
	// ARN for the IAM role that Timestream will assume when running the scheduled query.
	ExecutionRoleArn pulumi.StringPtrInput
	// Amazon KMS key used to encrypt the scheduled query resource, at-rest. If not specified, the scheduled query resource will be encrypted with a Timestream owned Amazon KMS key. To specify a KMS key, use the key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix the name with "alias/". If `errorReportConfiguration` uses `SSE_KMS` as the encryption type, the same `kmsKeyId` is used to encrypt the error report at rest.
	KmsKeyId pulumi.StringPtrInput
	// Runtime summary for the last scheduled query run.
	LastRunSummaries ScheduledQueryLastRunSummaryArrayInput
	// Name of the scheduled query.
	Name pulumi.StringPtrInput
	// Next time the scheduled query is scheduled to run.
	NextInvocationTime pulumi.StringPtrInput
	// Configuration block for notification configuration for a scheduled query. A notification is sent by Timestream when a scheduled query is created, its state is updated, or when it is deleted. See below.
	NotificationConfiguration ScheduledQueryNotificationConfigurationPtrInput
	// Last time the scheduled query was run.
	PreviousInvocationTime pulumi.StringPtrInput
	// Query string to run. Parameter names can be specified in the query string using the `@` character followed by an identifier. The named parameter `@scheduled_runtime` is reserved and can be used in the query to get the time at which the query is scheduled to run. The timestamp calculated according to the `scheduleConfiguration` parameter, will be the value of `@scheduled_runtime` paramater for each query run. For example, consider an instance of a scheduled query executing on 2021-12-01 00:00:00. For this instance, the `@scheduled_runtime` parameter is initialized to the timestamp 2021-12-01 00:00:00 when invoking the query.
	QueryString pulumi.StringPtrInput
	// Runtime summary for the last five failed scheduled query runs.
	RecentlyFailedRuns ScheduledQueryRecentlyFailedRunArrayInput
	// Configuration block for schedule configuration for the query. See below.
	ScheduleConfiguration ScheduledQueryScheduleConfigurationPtrInput
	// State of the scheduled query, either `ENABLED` or `DISABLED`.
	State pulumi.StringPtrInput
	// Map of tags assigned to the resource. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags pulumi.StringMapInput
	// Map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
	//
	// Deprecated: Please use `tags` instead.
	TagsAll pulumi.StringMapInput
	// Configuration block for writing the result of a query. See below.
	//
	// The following arguments are optional:
	TargetConfiguration ScheduledQueryTargetConfigurationPtrInput
	Timeouts            ScheduledQueryTimeoutsPtrInput
}

func (ScheduledQueryState) ElementType() reflect.Type {
	return reflect.TypeOf((*scheduledQueryState)(nil)).Elem()
}

type scheduledQueryArgs struct {
	// Configuration block for error reporting configuration. See below.
	ErrorReportConfiguration ScheduledQueryErrorReportConfiguration `pulumi:"errorReportConfiguration"`
	// ARN for the IAM role that Timestream will assume when running the scheduled query.
	ExecutionRoleArn string `pulumi:"executionRoleArn"`
	// Amazon KMS key used to encrypt the scheduled query resource, at-rest. If not specified, the scheduled query resource will be encrypted with a Timestream owned Amazon KMS key. To specify a KMS key, use the key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix the name with "alias/". If `errorReportConfiguration` uses `SSE_KMS` as the encryption type, the same `kmsKeyId` is used to encrypt the error report at rest.
	KmsKeyId *string `pulumi:"kmsKeyId"`
	// Runtime summary for the last scheduled query run.
	LastRunSummaries []ScheduledQueryLastRunSummary `pulumi:"lastRunSummaries"`
	// Name of the scheduled query.
	Name *string `pulumi:"name"`
	// Configuration block for notification configuration for a scheduled query. A notification is sent by Timestream when a scheduled query is created, its state is updated, or when it is deleted. See below.
	NotificationConfiguration ScheduledQueryNotificationConfiguration `pulumi:"notificationConfiguration"`
	// Query string to run. Parameter names can be specified in the query string using the `@` character followed by an identifier. The named parameter `@scheduled_runtime` is reserved and can be used in the query to get the time at which the query is scheduled to run. The timestamp calculated according to the `scheduleConfiguration` parameter, will be the value of `@scheduled_runtime` paramater for each query run. For example, consider an instance of a scheduled query executing on 2021-12-01 00:00:00. For this instance, the `@scheduled_runtime` parameter is initialized to the timestamp 2021-12-01 00:00:00 when invoking the query.
	QueryString string `pulumi:"queryString"`
	// Runtime summary for the last five failed scheduled query runs.
	RecentlyFailedRuns []ScheduledQueryRecentlyFailedRun `pulumi:"recentlyFailedRuns"`
	// Configuration block for schedule configuration for the query. See below.
	ScheduleConfiguration ScheduledQueryScheduleConfiguration `pulumi:"scheduleConfiguration"`
	// Map of tags assigned to the resource. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags map[string]string `pulumi:"tags"`
	// Configuration block for writing the result of a query. See below.
	//
	// The following arguments are optional:
	TargetConfiguration ScheduledQueryTargetConfiguration `pulumi:"targetConfiguration"`
	Timeouts            *ScheduledQueryTimeouts           `pulumi:"timeouts"`
}

// The set of arguments for constructing a ScheduledQuery resource.
type ScheduledQueryArgs struct {
	// Configuration block for error reporting configuration. See below.
	ErrorReportConfiguration ScheduledQueryErrorReportConfigurationInput
	// ARN for the IAM role that Timestream will assume when running the scheduled query.
	ExecutionRoleArn pulumi.StringInput
	// Amazon KMS key used to encrypt the scheduled query resource, at-rest. If not specified, the scheduled query resource will be encrypted with a Timestream owned Amazon KMS key. To specify a KMS key, use the key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix the name with "alias/". If `errorReportConfiguration` uses `SSE_KMS` as the encryption type, the same `kmsKeyId` is used to encrypt the error report at rest.
	KmsKeyId pulumi.StringPtrInput
	// Runtime summary for the last scheduled query run.
	LastRunSummaries ScheduledQueryLastRunSummaryArrayInput
	// Name of the scheduled query.
	Name pulumi.StringPtrInput
	// Configuration block for notification configuration for a scheduled query. A notification is sent by Timestream when a scheduled query is created, its state is updated, or when it is deleted. See below.
	NotificationConfiguration ScheduledQueryNotificationConfigurationInput
	// Query string to run. Parameter names can be specified in the query string using the `@` character followed by an identifier. The named parameter `@scheduled_runtime` is reserved and can be used in the query to get the time at which the query is scheduled to run. The timestamp calculated according to the `scheduleConfiguration` parameter, will be the value of `@scheduled_runtime` paramater for each query run. For example, consider an instance of a scheduled query executing on 2021-12-01 00:00:00. For this instance, the `@scheduled_runtime` parameter is initialized to the timestamp 2021-12-01 00:00:00 when invoking the query.
	QueryString pulumi.StringInput
	// Runtime summary for the last five failed scheduled query runs.
	RecentlyFailedRuns ScheduledQueryRecentlyFailedRunArrayInput
	// Configuration block for schedule configuration for the query. See below.
	ScheduleConfiguration ScheduledQueryScheduleConfigurationInput
	// Map of tags assigned to the resource. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags pulumi.StringMapInput
	// Configuration block for writing the result of a query. See below.
	//
	// The following arguments are optional:
	TargetConfiguration ScheduledQueryTargetConfigurationInput
	Timeouts            ScheduledQueryTimeoutsPtrInput
}

func (ScheduledQueryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*scheduledQueryArgs)(nil)).Elem()
}

type ScheduledQueryInput interface {
	pulumi.Input

	ToScheduledQueryOutput() ScheduledQueryOutput
	ToScheduledQueryOutputWithContext(ctx context.Context) ScheduledQueryOutput
}

func (*ScheduledQuery) ElementType() reflect.Type {
	return reflect.TypeOf((**ScheduledQuery)(nil)).Elem()
}

func (i *ScheduledQuery) ToScheduledQueryOutput() ScheduledQueryOutput {
	return i.ToScheduledQueryOutputWithContext(context.Background())
}

func (i *ScheduledQuery) ToScheduledQueryOutputWithContext(ctx context.Context) ScheduledQueryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScheduledQueryOutput)
}

// ScheduledQueryArrayInput is an input type that accepts ScheduledQueryArray and ScheduledQueryArrayOutput values.
// You can construct a concrete instance of `ScheduledQueryArrayInput` via:
//
//	ScheduledQueryArray{ ScheduledQueryArgs{...} }
type ScheduledQueryArrayInput interface {
	pulumi.Input

	ToScheduledQueryArrayOutput() ScheduledQueryArrayOutput
	ToScheduledQueryArrayOutputWithContext(context.Context) ScheduledQueryArrayOutput
}

type ScheduledQueryArray []ScheduledQueryInput

func (ScheduledQueryArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ScheduledQuery)(nil)).Elem()
}

func (i ScheduledQueryArray) ToScheduledQueryArrayOutput() ScheduledQueryArrayOutput {
	return i.ToScheduledQueryArrayOutputWithContext(context.Background())
}

func (i ScheduledQueryArray) ToScheduledQueryArrayOutputWithContext(ctx context.Context) ScheduledQueryArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScheduledQueryArrayOutput)
}

// ScheduledQueryMapInput is an input type that accepts ScheduledQueryMap and ScheduledQueryMapOutput values.
// You can construct a concrete instance of `ScheduledQueryMapInput` via:
//
//	ScheduledQueryMap{ "key": ScheduledQueryArgs{...} }
type ScheduledQueryMapInput interface {
	pulumi.Input

	ToScheduledQueryMapOutput() ScheduledQueryMapOutput
	ToScheduledQueryMapOutputWithContext(context.Context) ScheduledQueryMapOutput
}

type ScheduledQueryMap map[string]ScheduledQueryInput

func (ScheduledQueryMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ScheduledQuery)(nil)).Elem()
}

func (i ScheduledQueryMap) ToScheduledQueryMapOutput() ScheduledQueryMapOutput {
	return i.ToScheduledQueryMapOutputWithContext(context.Background())
}

func (i ScheduledQueryMap) ToScheduledQueryMapOutputWithContext(ctx context.Context) ScheduledQueryMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScheduledQueryMapOutput)
}

type ScheduledQueryOutput struct{ *pulumi.OutputState }

func (ScheduledQueryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ScheduledQuery)(nil)).Elem()
}

func (o ScheduledQueryOutput) ToScheduledQueryOutput() ScheduledQueryOutput {
	return o
}

func (o ScheduledQueryOutput) ToScheduledQueryOutputWithContext(ctx context.Context) ScheduledQueryOutput {
	return o
}

// ARN of the Scheduled Query.
func (o ScheduledQueryOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v *ScheduledQuery) pulumi.StringOutput { return v.Arn }).(pulumi.StringOutput)
}

// Creation time for the scheduled query.
func (o ScheduledQueryOutput) CreationTime() pulumi.StringOutput {
	return o.ApplyT(func(v *ScheduledQuery) pulumi.StringOutput { return v.CreationTime }).(pulumi.StringOutput)
}

// Configuration block for error reporting configuration. See below.
func (o ScheduledQueryOutput) ErrorReportConfiguration() ScheduledQueryErrorReportConfigurationOutput {
	return o.ApplyT(func(v *ScheduledQuery) ScheduledQueryErrorReportConfigurationOutput {
		return v.ErrorReportConfiguration
	}).(ScheduledQueryErrorReportConfigurationOutput)
}

// ARN for the IAM role that Timestream will assume when running the scheduled query.
func (o ScheduledQueryOutput) ExecutionRoleArn() pulumi.StringOutput {
	return o.ApplyT(func(v *ScheduledQuery) pulumi.StringOutput { return v.ExecutionRoleArn }).(pulumi.StringOutput)
}

// Amazon KMS key used to encrypt the scheduled query resource, at-rest. If not specified, the scheduled query resource will be encrypted with a Timestream owned Amazon KMS key. To specify a KMS key, use the key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix the name with "alias/". If `errorReportConfiguration` uses `SSE_KMS` as the encryption type, the same `kmsKeyId` is used to encrypt the error report at rest.
func (o ScheduledQueryOutput) KmsKeyId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ScheduledQuery) pulumi.StringPtrOutput { return v.KmsKeyId }).(pulumi.StringPtrOutput)
}

// Runtime summary for the last scheduled query run.
func (o ScheduledQueryOutput) LastRunSummaries() ScheduledQueryLastRunSummaryArrayOutput {
	return o.ApplyT(func(v *ScheduledQuery) ScheduledQueryLastRunSummaryArrayOutput { return v.LastRunSummaries }).(ScheduledQueryLastRunSummaryArrayOutput)
}

// Name of the scheduled query.
func (o ScheduledQueryOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ScheduledQuery) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Next time the scheduled query is scheduled to run.
func (o ScheduledQueryOutput) NextInvocationTime() pulumi.StringOutput {
	return o.ApplyT(func(v *ScheduledQuery) pulumi.StringOutput { return v.NextInvocationTime }).(pulumi.StringOutput)
}

// Configuration block for notification configuration for a scheduled query. A notification is sent by Timestream when a scheduled query is created, its state is updated, or when it is deleted. See below.
func (o ScheduledQueryOutput) NotificationConfiguration() ScheduledQueryNotificationConfigurationOutput {
	return o.ApplyT(func(v *ScheduledQuery) ScheduledQueryNotificationConfigurationOutput {
		return v.NotificationConfiguration
	}).(ScheduledQueryNotificationConfigurationOutput)
}

// Last time the scheduled query was run.
func (o ScheduledQueryOutput) PreviousInvocationTime() pulumi.StringOutput {
	return o.ApplyT(func(v *ScheduledQuery) pulumi.StringOutput { return v.PreviousInvocationTime }).(pulumi.StringOutput)
}

// Query string to run. Parameter names can be specified in the query string using the `@` character followed by an identifier. The named parameter `@scheduled_runtime` is reserved and can be used in the query to get the time at which the query is scheduled to run. The timestamp calculated according to the `scheduleConfiguration` parameter, will be the value of `@scheduled_runtime` paramater for each query run. For example, consider an instance of a scheduled query executing on 2021-12-01 00:00:00. For this instance, the `@scheduled_runtime` parameter is initialized to the timestamp 2021-12-01 00:00:00 when invoking the query.
func (o ScheduledQueryOutput) QueryString() pulumi.StringOutput {
	return o.ApplyT(func(v *ScheduledQuery) pulumi.StringOutput { return v.QueryString }).(pulumi.StringOutput)
}

// Runtime summary for the last five failed scheduled query runs.
func (o ScheduledQueryOutput) RecentlyFailedRuns() ScheduledQueryRecentlyFailedRunArrayOutput {
	return o.ApplyT(func(v *ScheduledQuery) ScheduledQueryRecentlyFailedRunArrayOutput { return v.RecentlyFailedRuns }).(ScheduledQueryRecentlyFailedRunArrayOutput)
}

// Configuration block for schedule configuration for the query. See below.
func (o ScheduledQueryOutput) ScheduleConfiguration() ScheduledQueryScheduleConfigurationOutput {
	return o.ApplyT(func(v *ScheduledQuery) ScheduledQueryScheduleConfigurationOutput { return v.ScheduleConfiguration }).(ScheduledQueryScheduleConfigurationOutput)
}

// State of the scheduled query, either `ENABLED` or `DISABLED`.
func (o ScheduledQueryOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *ScheduledQuery) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// Map of tags assigned to the resource. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
func (o ScheduledQueryOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ScheduledQuery) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

// Map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
//
// Deprecated: Please use `tags` instead.
func (o ScheduledQueryOutput) TagsAll() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ScheduledQuery) pulumi.StringMapOutput { return v.TagsAll }).(pulumi.StringMapOutput)
}

// Configuration block for writing the result of a query. See below.
//
// The following arguments are optional:
func (o ScheduledQueryOutput) TargetConfiguration() ScheduledQueryTargetConfigurationOutput {
	return o.ApplyT(func(v *ScheduledQuery) ScheduledQueryTargetConfigurationOutput { return v.TargetConfiguration }).(ScheduledQueryTargetConfigurationOutput)
}

func (o ScheduledQueryOutput) Timeouts() ScheduledQueryTimeoutsPtrOutput {
	return o.ApplyT(func(v *ScheduledQuery) ScheduledQueryTimeoutsPtrOutput { return v.Timeouts }).(ScheduledQueryTimeoutsPtrOutput)
}

type ScheduledQueryArrayOutput struct{ *pulumi.OutputState }

func (ScheduledQueryArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ScheduledQuery)(nil)).Elem()
}

func (o ScheduledQueryArrayOutput) ToScheduledQueryArrayOutput() ScheduledQueryArrayOutput {
	return o
}

func (o ScheduledQueryArrayOutput) ToScheduledQueryArrayOutputWithContext(ctx context.Context) ScheduledQueryArrayOutput {
	return o
}

func (o ScheduledQueryArrayOutput) Index(i pulumi.IntInput) ScheduledQueryOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ScheduledQuery {
		return vs[0].([]*ScheduledQuery)[vs[1].(int)]
	}).(ScheduledQueryOutput)
}

type ScheduledQueryMapOutput struct{ *pulumi.OutputState }

func (ScheduledQueryMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ScheduledQuery)(nil)).Elem()
}

func (o ScheduledQueryMapOutput) ToScheduledQueryMapOutput() ScheduledQueryMapOutput {
	return o
}

func (o ScheduledQueryMapOutput) ToScheduledQueryMapOutputWithContext(ctx context.Context) ScheduledQueryMapOutput {
	return o
}

func (o ScheduledQueryMapOutput) MapIndex(k pulumi.StringInput) ScheduledQueryOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ScheduledQuery {
		return vs[0].(map[string]*ScheduledQuery)[vs[1].(string)]
	}).(ScheduledQueryOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ScheduledQueryInput)(nil)).Elem(), &ScheduledQuery{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScheduledQueryArrayInput)(nil)).Elem(), ScheduledQueryArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScheduledQueryMapInput)(nil)).Elem(), ScheduledQueryMap{})
	pulumi.RegisterOutputType(ScheduledQueryOutput{})
	pulumi.RegisterOutputType(ScheduledQueryArrayOutput{})
	pulumi.RegisterOutputType(ScheduledQueryMapOutput{})
}
