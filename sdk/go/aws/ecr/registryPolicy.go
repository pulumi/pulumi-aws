// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ecr

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides an Elastic Container Registry Policy.
//
// > **NOTE on ECR Registry Policies:** While the AWS Management Console interface may suggest the ability to define multiple policies by creating multiple statements, ECR registry policies are effectively managed as singular entities at the regional level by the AWS APIs. Therefore, the `ecr.RegistryPolicy` resource should be configured only once per region with all necessary statements defined in the same policy. Attempting to define multiple `ecr.RegistryPolicy` resources may result in perpetual differences, with one policy overriding another.
//
// ## Example Usage
//
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"encoding/json"
//	"fmt"
//
//	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws"
//	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/ecr"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			current, err := aws.GetCallerIdentity(ctx, nil, nil)
//			if err != nil {
//				return err
//			}
//			currentGetRegion, err := aws.GetRegion(ctx, nil, nil)
//			if err != nil {
//				return err
//			}
//			currentGetPartition, err := aws.GetPartition(ctx, nil, nil)
//			if err != nil {
//				return err
//			}
//			tmpJSON0, err := json.Marshal(map[string]interface{}{
//				"version": "2012-10-17",
//				"statement": []map[string]interface{}{
//					map[string]interface{}{
//						"sid":    "testpolicy",
//						"effect": "Allow",
//						"principal": map[string]interface{}{
//							"AWS": fmt.Sprintf("arn:%v:iam::%v:root", currentGetPartition.Partition, current.AccountId),
//						},
//						"action": []string{
//							"ecr:ReplicateImage",
//						},
//						"resource": []string{
//							fmt.Sprintf("arn:%v:ecr:%v:%v:repository/*", currentGetPartition.Partition, currentGetRegion.Name, current.AccountId),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			json0 := string(tmpJSON0)
//			_, err = ecr.NewRegistryPolicy(ctx, "example", &ecr.RegistryPolicyArgs{
//				Policy: pulumi.String(json0),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
//
// ## Import
//
// Using `pulumi import`, import ECR Registry Policy using the registry id. For example:
//
// ```sh
// $ pulumi import aws:ecr/registryPolicy:RegistryPolicy example 123456789012
// ```
type RegistryPolicy struct {
	pulumi.CustomResourceState

	// The policy document. This is a JSON formatted string.
	Policy pulumi.StringOutput `pulumi:"policy"`
	// The registry ID where the registry was created.
	RegistryId pulumi.StringOutput `pulumi:"registryId"`
}

// NewRegistryPolicy registers a new resource with the given unique name, arguments, and options.
func NewRegistryPolicy(ctx *pulumi.Context,
	name string, args *RegistryPolicyArgs, opts ...pulumi.ResourceOption) (*RegistryPolicy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Policy == nil {
		return nil, errors.New("invalid value for required argument 'Policy'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource RegistryPolicy
	err := ctx.RegisterResource("aws:ecr/registryPolicy:RegistryPolicy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRegistryPolicy gets an existing RegistryPolicy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRegistryPolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RegistryPolicyState, opts ...pulumi.ResourceOption) (*RegistryPolicy, error) {
	var resource RegistryPolicy
	err := ctx.ReadResource("aws:ecr/registryPolicy:RegistryPolicy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering RegistryPolicy resources.
type registryPolicyState struct {
	// The policy document. This is a JSON formatted string.
	Policy *string `pulumi:"policy"`
	// The registry ID where the registry was created.
	RegistryId *string `pulumi:"registryId"`
}

type RegistryPolicyState struct {
	// The policy document. This is a JSON formatted string.
	Policy pulumi.StringPtrInput
	// The registry ID where the registry was created.
	RegistryId pulumi.StringPtrInput
}

func (RegistryPolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*registryPolicyState)(nil)).Elem()
}

type registryPolicyArgs struct {
	// The policy document. This is a JSON formatted string.
	Policy string `pulumi:"policy"`
}

// The set of arguments for constructing a RegistryPolicy resource.
type RegistryPolicyArgs struct {
	// The policy document. This is a JSON formatted string.
	Policy pulumi.StringInput
}

func (RegistryPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*registryPolicyArgs)(nil)).Elem()
}

type RegistryPolicyInput interface {
	pulumi.Input

	ToRegistryPolicyOutput() RegistryPolicyOutput
	ToRegistryPolicyOutputWithContext(ctx context.Context) RegistryPolicyOutput
}

func (*RegistryPolicy) ElementType() reflect.Type {
	return reflect.TypeOf((**RegistryPolicy)(nil)).Elem()
}

func (i *RegistryPolicy) ToRegistryPolicyOutput() RegistryPolicyOutput {
	return i.ToRegistryPolicyOutputWithContext(context.Background())
}

func (i *RegistryPolicy) ToRegistryPolicyOutputWithContext(ctx context.Context) RegistryPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryPolicyOutput)
}

// RegistryPolicyArrayInput is an input type that accepts RegistryPolicyArray and RegistryPolicyArrayOutput values.
// You can construct a concrete instance of `RegistryPolicyArrayInput` via:
//
//	RegistryPolicyArray{ RegistryPolicyArgs{...} }
type RegistryPolicyArrayInput interface {
	pulumi.Input

	ToRegistryPolicyArrayOutput() RegistryPolicyArrayOutput
	ToRegistryPolicyArrayOutputWithContext(context.Context) RegistryPolicyArrayOutput
}

type RegistryPolicyArray []RegistryPolicyInput

func (RegistryPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RegistryPolicy)(nil)).Elem()
}

func (i RegistryPolicyArray) ToRegistryPolicyArrayOutput() RegistryPolicyArrayOutput {
	return i.ToRegistryPolicyArrayOutputWithContext(context.Background())
}

func (i RegistryPolicyArray) ToRegistryPolicyArrayOutputWithContext(ctx context.Context) RegistryPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryPolicyArrayOutput)
}

// RegistryPolicyMapInput is an input type that accepts RegistryPolicyMap and RegistryPolicyMapOutput values.
// You can construct a concrete instance of `RegistryPolicyMapInput` via:
//
//	RegistryPolicyMap{ "key": RegistryPolicyArgs{...} }
type RegistryPolicyMapInput interface {
	pulumi.Input

	ToRegistryPolicyMapOutput() RegistryPolicyMapOutput
	ToRegistryPolicyMapOutputWithContext(context.Context) RegistryPolicyMapOutput
}

type RegistryPolicyMap map[string]RegistryPolicyInput

func (RegistryPolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RegistryPolicy)(nil)).Elem()
}

func (i RegistryPolicyMap) ToRegistryPolicyMapOutput() RegistryPolicyMapOutput {
	return i.ToRegistryPolicyMapOutputWithContext(context.Background())
}

func (i RegistryPolicyMap) ToRegistryPolicyMapOutputWithContext(ctx context.Context) RegistryPolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryPolicyMapOutput)
}

type RegistryPolicyOutput struct{ *pulumi.OutputState }

func (RegistryPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RegistryPolicy)(nil)).Elem()
}

func (o RegistryPolicyOutput) ToRegistryPolicyOutput() RegistryPolicyOutput {
	return o
}

func (o RegistryPolicyOutput) ToRegistryPolicyOutputWithContext(ctx context.Context) RegistryPolicyOutput {
	return o
}

// The policy document. This is a JSON formatted string.
func (o RegistryPolicyOutput) Policy() pulumi.StringOutput {
	return o.ApplyT(func(v *RegistryPolicy) pulumi.StringOutput { return v.Policy }).(pulumi.StringOutput)
}

// The registry ID where the registry was created.
func (o RegistryPolicyOutput) RegistryId() pulumi.StringOutput {
	return o.ApplyT(func(v *RegistryPolicy) pulumi.StringOutput { return v.RegistryId }).(pulumi.StringOutput)
}

type RegistryPolicyArrayOutput struct{ *pulumi.OutputState }

func (RegistryPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RegistryPolicy)(nil)).Elem()
}

func (o RegistryPolicyArrayOutput) ToRegistryPolicyArrayOutput() RegistryPolicyArrayOutput {
	return o
}

func (o RegistryPolicyArrayOutput) ToRegistryPolicyArrayOutputWithContext(ctx context.Context) RegistryPolicyArrayOutput {
	return o
}

func (o RegistryPolicyArrayOutput) Index(i pulumi.IntInput) RegistryPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *RegistryPolicy {
		return vs[0].([]*RegistryPolicy)[vs[1].(int)]
	}).(RegistryPolicyOutput)
}

type RegistryPolicyMapOutput struct{ *pulumi.OutputState }

func (RegistryPolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RegistryPolicy)(nil)).Elem()
}

func (o RegistryPolicyMapOutput) ToRegistryPolicyMapOutput() RegistryPolicyMapOutput {
	return o
}

func (o RegistryPolicyMapOutput) ToRegistryPolicyMapOutputWithContext(ctx context.Context) RegistryPolicyMapOutput {
	return o
}

func (o RegistryPolicyMapOutput) MapIndex(k pulumi.StringInput) RegistryPolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *RegistryPolicy {
		return vs[0].(map[string]*RegistryPolicy)[vs[1].(string)]
	}).(RegistryPolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RegistryPolicyInput)(nil)).Elem(), &RegistryPolicy{})
	pulumi.RegisterInputType(reflect.TypeOf((*RegistryPolicyArrayInput)(nil)).Elem(), RegistryPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RegistryPolicyMapInput)(nil)).Elem(), RegistryPolicyMap{})
	pulumi.RegisterOutputType(RegistryPolicyOutput{})
	pulumi.RegisterOutputType(RegistryPolicyArrayOutput{})
	pulumi.RegisterOutputType(RegistryPolicyMapOutput{})
}
