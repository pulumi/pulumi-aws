// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package medialive

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type Channel struct {
	pulumi.CustomResourceState

	Arn                   pulumi.StringOutput                   `pulumi:"arn"`
	CdiInputSpecification ChannelCdiInputSpecificationPtrOutput `pulumi:"cdiInputSpecification"`
	ChannelClass          pulumi.StringOutput                   `pulumi:"channelClass"`
	ChannelId             pulumi.StringOutput                   `pulumi:"channelId"`
	Destinations          ChannelDestinationArrayOutput         `pulumi:"destinations"`
	EncoderSettings       ChannelEncoderSettingsOutput          `pulumi:"encoderSettings"`
	InputAttachments      ChannelInputAttachmentArrayOutput     `pulumi:"inputAttachments"`
	InputSpecification    ChannelInputSpecificationOutput       `pulumi:"inputSpecification"`
	LogLevel              pulumi.StringOutput                   `pulumi:"logLevel"`
	Maintenance           ChannelMaintenanceOutput              `pulumi:"maintenance"`
	Name                  pulumi.StringOutput                   `pulumi:"name"`
	RoleArn               pulumi.StringPtrOutput                `pulumi:"roleArn"`
	StartChannel          pulumi.BoolPtrOutput                  `pulumi:"startChannel"`
	Tags                  pulumi.StringMapOutput                `pulumi:"tags"`
	TagsAll               pulumi.StringMapOutput                `pulumi:"tagsAll"`
	Vpc                   ChannelVpcPtrOutput                   `pulumi:"vpc"`
}

// NewChannel registers a new resource with the given unique name, arguments, and options.
func NewChannel(ctx *pulumi.Context,
	name string, args *ChannelArgs, opts ...pulumi.ResourceOption) (*Channel, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ChannelClass == nil {
		return nil, errors.New("invalid value for required argument 'ChannelClass'")
	}
	if args.Destinations == nil {
		return nil, errors.New("invalid value for required argument 'Destinations'")
	}
	if args.EncoderSettings == nil {
		return nil, errors.New("invalid value for required argument 'EncoderSettings'")
	}
	if args.InputAttachments == nil {
		return nil, errors.New("invalid value for required argument 'InputAttachments'")
	}
	if args.InputSpecification == nil {
		return nil, errors.New("invalid value for required argument 'InputSpecification'")
	}
	var resource Channel
	err := ctx.RegisterResource("aws:medialive/channel:Channel", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetChannel gets an existing Channel resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetChannel(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ChannelState, opts ...pulumi.ResourceOption) (*Channel, error) {
	var resource Channel
	err := ctx.ReadResource("aws:medialive/channel:Channel", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Channel resources.
type channelState struct {
	Arn                   *string                       `pulumi:"arn"`
	CdiInputSpecification *ChannelCdiInputSpecification `pulumi:"cdiInputSpecification"`
	ChannelClass          *string                       `pulumi:"channelClass"`
	ChannelId             *string                       `pulumi:"channelId"`
	Destinations          []ChannelDestination          `pulumi:"destinations"`
	EncoderSettings       *ChannelEncoderSettings       `pulumi:"encoderSettings"`
	InputAttachments      []ChannelInputAttachment      `pulumi:"inputAttachments"`
	InputSpecification    *ChannelInputSpecification    `pulumi:"inputSpecification"`
	LogLevel              *string                       `pulumi:"logLevel"`
	Maintenance           *ChannelMaintenance           `pulumi:"maintenance"`
	Name                  *string                       `pulumi:"name"`
	RoleArn               *string                       `pulumi:"roleArn"`
	StartChannel          *bool                         `pulumi:"startChannel"`
	Tags                  map[string]string             `pulumi:"tags"`
	TagsAll               map[string]string             `pulumi:"tagsAll"`
	Vpc                   *ChannelVpc                   `pulumi:"vpc"`
}

type ChannelState struct {
	Arn                   pulumi.StringPtrInput
	CdiInputSpecification ChannelCdiInputSpecificationPtrInput
	ChannelClass          pulumi.StringPtrInput
	ChannelId             pulumi.StringPtrInput
	Destinations          ChannelDestinationArrayInput
	EncoderSettings       ChannelEncoderSettingsPtrInput
	InputAttachments      ChannelInputAttachmentArrayInput
	InputSpecification    ChannelInputSpecificationPtrInput
	LogLevel              pulumi.StringPtrInput
	Maintenance           ChannelMaintenancePtrInput
	Name                  pulumi.StringPtrInput
	RoleArn               pulumi.StringPtrInput
	StartChannel          pulumi.BoolPtrInput
	Tags                  pulumi.StringMapInput
	TagsAll               pulumi.StringMapInput
	Vpc                   ChannelVpcPtrInput
}

func (ChannelState) ElementType() reflect.Type {
	return reflect.TypeOf((*channelState)(nil)).Elem()
}

type channelArgs struct {
	CdiInputSpecification *ChannelCdiInputSpecification `pulumi:"cdiInputSpecification"`
	ChannelClass          string                        `pulumi:"channelClass"`
	Destinations          []ChannelDestination          `pulumi:"destinations"`
	EncoderSettings       ChannelEncoderSettings        `pulumi:"encoderSettings"`
	InputAttachments      []ChannelInputAttachment      `pulumi:"inputAttachments"`
	InputSpecification    ChannelInputSpecification     `pulumi:"inputSpecification"`
	LogLevel              *string                       `pulumi:"logLevel"`
	Maintenance           *ChannelMaintenance           `pulumi:"maintenance"`
	Name                  *string                       `pulumi:"name"`
	RoleArn               *string                       `pulumi:"roleArn"`
	StartChannel          *bool                         `pulumi:"startChannel"`
	Tags                  map[string]string             `pulumi:"tags"`
	Vpc                   *ChannelVpc                   `pulumi:"vpc"`
}

// The set of arguments for constructing a Channel resource.
type ChannelArgs struct {
	CdiInputSpecification ChannelCdiInputSpecificationPtrInput
	ChannelClass          pulumi.StringInput
	Destinations          ChannelDestinationArrayInput
	EncoderSettings       ChannelEncoderSettingsInput
	InputAttachments      ChannelInputAttachmentArrayInput
	InputSpecification    ChannelInputSpecificationInput
	LogLevel              pulumi.StringPtrInput
	Maintenance           ChannelMaintenancePtrInput
	Name                  pulumi.StringPtrInput
	RoleArn               pulumi.StringPtrInput
	StartChannel          pulumi.BoolPtrInput
	Tags                  pulumi.StringMapInput
	Vpc                   ChannelVpcPtrInput
}

func (ChannelArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*channelArgs)(nil)).Elem()
}

type ChannelInput interface {
	pulumi.Input

	ToChannelOutput() ChannelOutput
	ToChannelOutputWithContext(ctx context.Context) ChannelOutput
}

func (*Channel) ElementType() reflect.Type {
	return reflect.TypeOf((**Channel)(nil)).Elem()
}

func (i *Channel) ToChannelOutput() ChannelOutput {
	return i.ToChannelOutputWithContext(context.Background())
}

func (i *Channel) ToChannelOutputWithContext(ctx context.Context) ChannelOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelOutput)
}

// ChannelArrayInput is an input type that accepts ChannelArray and ChannelArrayOutput values.
// You can construct a concrete instance of `ChannelArrayInput` via:
//
//	ChannelArray{ ChannelArgs{...} }
type ChannelArrayInput interface {
	pulumi.Input

	ToChannelArrayOutput() ChannelArrayOutput
	ToChannelArrayOutputWithContext(context.Context) ChannelArrayOutput
}

type ChannelArray []ChannelInput

func (ChannelArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Channel)(nil)).Elem()
}

func (i ChannelArray) ToChannelArrayOutput() ChannelArrayOutput {
	return i.ToChannelArrayOutputWithContext(context.Background())
}

func (i ChannelArray) ToChannelArrayOutputWithContext(ctx context.Context) ChannelArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelArrayOutput)
}

// ChannelMapInput is an input type that accepts ChannelMap and ChannelMapOutput values.
// You can construct a concrete instance of `ChannelMapInput` via:
//
//	ChannelMap{ "key": ChannelArgs{...} }
type ChannelMapInput interface {
	pulumi.Input

	ToChannelMapOutput() ChannelMapOutput
	ToChannelMapOutputWithContext(context.Context) ChannelMapOutput
}

type ChannelMap map[string]ChannelInput

func (ChannelMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Channel)(nil)).Elem()
}

func (i ChannelMap) ToChannelMapOutput() ChannelMapOutput {
	return i.ToChannelMapOutputWithContext(context.Background())
}

func (i ChannelMap) ToChannelMapOutputWithContext(ctx context.Context) ChannelMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelMapOutput)
}

type ChannelOutput struct{ *pulumi.OutputState }

func (ChannelOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Channel)(nil)).Elem()
}

func (o ChannelOutput) ToChannelOutput() ChannelOutput {
	return o
}

func (o ChannelOutput) ToChannelOutputWithContext(ctx context.Context) ChannelOutput {
	return o
}

func (o ChannelOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v *Channel) pulumi.StringOutput { return v.Arn }).(pulumi.StringOutput)
}

func (o ChannelOutput) CdiInputSpecification() ChannelCdiInputSpecificationPtrOutput {
	return o.ApplyT(func(v *Channel) ChannelCdiInputSpecificationPtrOutput { return v.CdiInputSpecification }).(ChannelCdiInputSpecificationPtrOutput)
}

func (o ChannelOutput) ChannelClass() pulumi.StringOutput {
	return o.ApplyT(func(v *Channel) pulumi.StringOutput { return v.ChannelClass }).(pulumi.StringOutput)
}

func (o ChannelOutput) ChannelId() pulumi.StringOutput {
	return o.ApplyT(func(v *Channel) pulumi.StringOutput { return v.ChannelId }).(pulumi.StringOutput)
}

func (o ChannelOutput) Destinations() ChannelDestinationArrayOutput {
	return o.ApplyT(func(v *Channel) ChannelDestinationArrayOutput { return v.Destinations }).(ChannelDestinationArrayOutput)
}

func (o ChannelOutput) EncoderSettings() ChannelEncoderSettingsOutput {
	return o.ApplyT(func(v *Channel) ChannelEncoderSettingsOutput { return v.EncoderSettings }).(ChannelEncoderSettingsOutput)
}

func (o ChannelOutput) InputAttachments() ChannelInputAttachmentArrayOutput {
	return o.ApplyT(func(v *Channel) ChannelInputAttachmentArrayOutput { return v.InputAttachments }).(ChannelInputAttachmentArrayOutput)
}

func (o ChannelOutput) InputSpecification() ChannelInputSpecificationOutput {
	return o.ApplyT(func(v *Channel) ChannelInputSpecificationOutput { return v.InputSpecification }).(ChannelInputSpecificationOutput)
}

func (o ChannelOutput) LogLevel() pulumi.StringOutput {
	return o.ApplyT(func(v *Channel) pulumi.StringOutput { return v.LogLevel }).(pulumi.StringOutput)
}

func (o ChannelOutput) Maintenance() ChannelMaintenanceOutput {
	return o.ApplyT(func(v *Channel) ChannelMaintenanceOutput { return v.Maintenance }).(ChannelMaintenanceOutput)
}

func (o ChannelOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Channel) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o ChannelOutput) RoleArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Channel) pulumi.StringPtrOutput { return v.RoleArn }).(pulumi.StringPtrOutput)
}

func (o ChannelOutput) StartChannel() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Channel) pulumi.BoolPtrOutput { return v.StartChannel }).(pulumi.BoolPtrOutput)
}

func (o ChannelOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Channel) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

func (o ChannelOutput) TagsAll() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Channel) pulumi.StringMapOutput { return v.TagsAll }).(pulumi.StringMapOutput)
}

func (o ChannelOutput) Vpc() ChannelVpcPtrOutput {
	return o.ApplyT(func(v *Channel) ChannelVpcPtrOutput { return v.Vpc }).(ChannelVpcPtrOutput)
}

type ChannelArrayOutput struct{ *pulumi.OutputState }

func (ChannelArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Channel)(nil)).Elem()
}

func (o ChannelArrayOutput) ToChannelArrayOutput() ChannelArrayOutput {
	return o
}

func (o ChannelArrayOutput) ToChannelArrayOutputWithContext(ctx context.Context) ChannelArrayOutput {
	return o
}

func (o ChannelArrayOutput) Index(i pulumi.IntInput) ChannelOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Channel {
		return vs[0].([]*Channel)[vs[1].(int)]
	}).(ChannelOutput)
}

type ChannelMapOutput struct{ *pulumi.OutputState }

func (ChannelMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Channel)(nil)).Elem()
}

func (o ChannelMapOutput) ToChannelMapOutput() ChannelMapOutput {
	return o
}

func (o ChannelMapOutput) ToChannelMapOutputWithContext(ctx context.Context) ChannelMapOutput {
	return o
}

func (o ChannelMapOutput) MapIndex(k pulumi.StringInput) ChannelOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Channel {
		return vs[0].(map[string]*Channel)[vs[1].(string)]
	}).(ChannelOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ChannelInput)(nil)).Elem(), &Channel{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChannelArrayInput)(nil)).Elem(), ChannelArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChannelMapInput)(nil)).Elem(), ChannelMap{})
	pulumi.RegisterOutputType(ChannelOutput{})
	pulumi.RegisterOutputType(ChannelArrayOutput{})
	pulumi.RegisterOutputType(ChannelMapOutput{})
}
