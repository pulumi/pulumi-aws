// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package paymentcryptography

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws/sdk/v7/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

type KeyKeyAttribute struct {
	// Key algorithm to be use during creation of an AWS Payment Cryptography key.
	KeyAlgorithm string `pulumi:"keyAlgorithm"`
	// Type of AWS Payment Cryptography key to create.
	KeyClass string `pulumi:"keyClass"`
	// List of cryptographic operations that you can perform using the key.
	KeyModesOfUses []KeyKeyAttributeKeyModesOfUse `pulumi:"keyModesOfUses"`
	// Cryptographic usage of an AWS Payment Cryptography key as defined in section A.5.2 of the TR-31 spec.
	KeyUsage string `pulumi:"keyUsage"`
}

// KeyKeyAttributeInput is an input type that accepts KeyKeyAttributeArgs and KeyKeyAttributeOutput values.
// You can construct a concrete instance of `KeyKeyAttributeInput` via:
//
//	KeyKeyAttributeArgs{...}
type KeyKeyAttributeInput interface {
	pulumi.Input

	ToKeyKeyAttributeOutput() KeyKeyAttributeOutput
	ToKeyKeyAttributeOutputWithContext(context.Context) KeyKeyAttributeOutput
}

type KeyKeyAttributeArgs struct {
	// Key algorithm to be use during creation of an AWS Payment Cryptography key.
	KeyAlgorithm pulumi.StringInput `pulumi:"keyAlgorithm"`
	// Type of AWS Payment Cryptography key to create.
	KeyClass pulumi.StringInput `pulumi:"keyClass"`
	// List of cryptographic operations that you can perform using the key.
	KeyModesOfUses KeyKeyAttributeKeyModesOfUseArrayInput `pulumi:"keyModesOfUses"`
	// Cryptographic usage of an AWS Payment Cryptography key as defined in section A.5.2 of the TR-31 spec.
	KeyUsage pulumi.StringInput `pulumi:"keyUsage"`
}

func (KeyKeyAttributeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyKeyAttribute)(nil)).Elem()
}

func (i KeyKeyAttributeArgs) ToKeyKeyAttributeOutput() KeyKeyAttributeOutput {
	return i.ToKeyKeyAttributeOutputWithContext(context.Background())
}

func (i KeyKeyAttributeArgs) ToKeyKeyAttributeOutputWithContext(ctx context.Context) KeyKeyAttributeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyKeyAttributeOutput)
}

// KeyKeyAttributeArrayInput is an input type that accepts KeyKeyAttributeArray and KeyKeyAttributeArrayOutput values.
// You can construct a concrete instance of `KeyKeyAttributeArrayInput` via:
//
//	KeyKeyAttributeArray{ KeyKeyAttributeArgs{...} }
type KeyKeyAttributeArrayInput interface {
	pulumi.Input

	ToKeyKeyAttributeArrayOutput() KeyKeyAttributeArrayOutput
	ToKeyKeyAttributeArrayOutputWithContext(context.Context) KeyKeyAttributeArrayOutput
}

type KeyKeyAttributeArray []KeyKeyAttributeInput

func (KeyKeyAttributeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KeyKeyAttribute)(nil)).Elem()
}

func (i KeyKeyAttributeArray) ToKeyKeyAttributeArrayOutput() KeyKeyAttributeArrayOutput {
	return i.ToKeyKeyAttributeArrayOutputWithContext(context.Background())
}

func (i KeyKeyAttributeArray) ToKeyKeyAttributeArrayOutputWithContext(ctx context.Context) KeyKeyAttributeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyKeyAttributeArrayOutput)
}

type KeyKeyAttributeOutput struct{ *pulumi.OutputState }

func (KeyKeyAttributeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyKeyAttribute)(nil)).Elem()
}

func (o KeyKeyAttributeOutput) ToKeyKeyAttributeOutput() KeyKeyAttributeOutput {
	return o
}

func (o KeyKeyAttributeOutput) ToKeyKeyAttributeOutputWithContext(ctx context.Context) KeyKeyAttributeOutput {
	return o
}

// Key algorithm to be use during creation of an AWS Payment Cryptography key.
func (o KeyKeyAttributeOutput) KeyAlgorithm() pulumi.StringOutput {
	return o.ApplyT(func(v KeyKeyAttribute) string { return v.KeyAlgorithm }).(pulumi.StringOutput)
}

// Type of AWS Payment Cryptography key to create.
func (o KeyKeyAttributeOutput) KeyClass() pulumi.StringOutput {
	return o.ApplyT(func(v KeyKeyAttribute) string { return v.KeyClass }).(pulumi.StringOutput)
}

// List of cryptographic operations that you can perform using the key.
func (o KeyKeyAttributeOutput) KeyModesOfUses() KeyKeyAttributeKeyModesOfUseArrayOutput {
	return o.ApplyT(func(v KeyKeyAttribute) []KeyKeyAttributeKeyModesOfUse { return v.KeyModesOfUses }).(KeyKeyAttributeKeyModesOfUseArrayOutput)
}

// Cryptographic usage of an AWS Payment Cryptography key as defined in section A.5.2 of the TR-31 spec.
func (o KeyKeyAttributeOutput) KeyUsage() pulumi.StringOutput {
	return o.ApplyT(func(v KeyKeyAttribute) string { return v.KeyUsage }).(pulumi.StringOutput)
}

type KeyKeyAttributeArrayOutput struct{ *pulumi.OutputState }

func (KeyKeyAttributeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KeyKeyAttribute)(nil)).Elem()
}

func (o KeyKeyAttributeArrayOutput) ToKeyKeyAttributeArrayOutput() KeyKeyAttributeArrayOutput {
	return o
}

func (o KeyKeyAttributeArrayOutput) ToKeyKeyAttributeArrayOutputWithContext(ctx context.Context) KeyKeyAttributeArrayOutput {
	return o
}

func (o KeyKeyAttributeArrayOutput) Index(i pulumi.IntInput) KeyKeyAttributeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) KeyKeyAttribute {
		return vs[0].([]KeyKeyAttribute)[vs[1].(int)]
	}).(KeyKeyAttributeOutput)
}

type KeyKeyAttributeKeyModesOfUse struct {
	// Whether an AWS Payment Cryptography key can be used to decrypt data.
	Decrypt *bool `pulumi:"decrypt"`
	// Whether an AWS Payment Cryptography key can be used to derive new keys.
	DeriveKey *bool `pulumi:"deriveKey"`
	// Whether an AWS Payment Cryptography key can be used to encrypt data.
	Encrypt *bool `pulumi:"encrypt"`
	// Whether an AWS Payment Cryptography key can be used to generate and verify other card and PIN verification keys.
	Generate *bool `pulumi:"generate"`
	// Whether an AWS Payment Cryptography key has no special restrictions other than the restrictions implied by KeyUsage.
	NoRestrictions *bool `pulumi:"noRestrictions"`
	// Whether an AWS Payment Cryptography key can be used for signing.
	Sign *bool `pulumi:"sign"`
	// Whether an AWS Payment Cryptography key can be used to unwrap other keys.
	Unwrap *bool `pulumi:"unwrap"`
	// Whether an AWS Payment Cryptography key can be used to verify signatures.
	Verify *bool `pulumi:"verify"`
	// Whether an AWS Payment Cryptography key can be used to wrap other keys.
	Wrap *bool `pulumi:"wrap"`
}

// KeyKeyAttributeKeyModesOfUseInput is an input type that accepts KeyKeyAttributeKeyModesOfUseArgs and KeyKeyAttributeKeyModesOfUseOutput values.
// You can construct a concrete instance of `KeyKeyAttributeKeyModesOfUseInput` via:
//
//	KeyKeyAttributeKeyModesOfUseArgs{...}
type KeyKeyAttributeKeyModesOfUseInput interface {
	pulumi.Input

	ToKeyKeyAttributeKeyModesOfUseOutput() KeyKeyAttributeKeyModesOfUseOutput
	ToKeyKeyAttributeKeyModesOfUseOutputWithContext(context.Context) KeyKeyAttributeKeyModesOfUseOutput
}

type KeyKeyAttributeKeyModesOfUseArgs struct {
	// Whether an AWS Payment Cryptography key can be used to decrypt data.
	Decrypt pulumi.BoolPtrInput `pulumi:"decrypt"`
	// Whether an AWS Payment Cryptography key can be used to derive new keys.
	DeriveKey pulumi.BoolPtrInput `pulumi:"deriveKey"`
	// Whether an AWS Payment Cryptography key can be used to encrypt data.
	Encrypt pulumi.BoolPtrInput `pulumi:"encrypt"`
	// Whether an AWS Payment Cryptography key can be used to generate and verify other card and PIN verification keys.
	Generate pulumi.BoolPtrInput `pulumi:"generate"`
	// Whether an AWS Payment Cryptography key has no special restrictions other than the restrictions implied by KeyUsage.
	NoRestrictions pulumi.BoolPtrInput `pulumi:"noRestrictions"`
	// Whether an AWS Payment Cryptography key can be used for signing.
	Sign pulumi.BoolPtrInput `pulumi:"sign"`
	// Whether an AWS Payment Cryptography key can be used to unwrap other keys.
	Unwrap pulumi.BoolPtrInput `pulumi:"unwrap"`
	// Whether an AWS Payment Cryptography key can be used to verify signatures.
	Verify pulumi.BoolPtrInput `pulumi:"verify"`
	// Whether an AWS Payment Cryptography key can be used to wrap other keys.
	Wrap pulumi.BoolPtrInput `pulumi:"wrap"`
}

func (KeyKeyAttributeKeyModesOfUseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyKeyAttributeKeyModesOfUse)(nil)).Elem()
}

func (i KeyKeyAttributeKeyModesOfUseArgs) ToKeyKeyAttributeKeyModesOfUseOutput() KeyKeyAttributeKeyModesOfUseOutput {
	return i.ToKeyKeyAttributeKeyModesOfUseOutputWithContext(context.Background())
}

func (i KeyKeyAttributeKeyModesOfUseArgs) ToKeyKeyAttributeKeyModesOfUseOutputWithContext(ctx context.Context) KeyKeyAttributeKeyModesOfUseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyKeyAttributeKeyModesOfUseOutput)
}

// KeyKeyAttributeKeyModesOfUseArrayInput is an input type that accepts KeyKeyAttributeKeyModesOfUseArray and KeyKeyAttributeKeyModesOfUseArrayOutput values.
// You can construct a concrete instance of `KeyKeyAttributeKeyModesOfUseArrayInput` via:
//
//	KeyKeyAttributeKeyModesOfUseArray{ KeyKeyAttributeKeyModesOfUseArgs{...} }
type KeyKeyAttributeKeyModesOfUseArrayInput interface {
	pulumi.Input

	ToKeyKeyAttributeKeyModesOfUseArrayOutput() KeyKeyAttributeKeyModesOfUseArrayOutput
	ToKeyKeyAttributeKeyModesOfUseArrayOutputWithContext(context.Context) KeyKeyAttributeKeyModesOfUseArrayOutput
}

type KeyKeyAttributeKeyModesOfUseArray []KeyKeyAttributeKeyModesOfUseInput

func (KeyKeyAttributeKeyModesOfUseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KeyKeyAttributeKeyModesOfUse)(nil)).Elem()
}

func (i KeyKeyAttributeKeyModesOfUseArray) ToKeyKeyAttributeKeyModesOfUseArrayOutput() KeyKeyAttributeKeyModesOfUseArrayOutput {
	return i.ToKeyKeyAttributeKeyModesOfUseArrayOutputWithContext(context.Background())
}

func (i KeyKeyAttributeKeyModesOfUseArray) ToKeyKeyAttributeKeyModesOfUseArrayOutputWithContext(ctx context.Context) KeyKeyAttributeKeyModesOfUseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyKeyAttributeKeyModesOfUseArrayOutput)
}

type KeyKeyAttributeKeyModesOfUseOutput struct{ *pulumi.OutputState }

func (KeyKeyAttributeKeyModesOfUseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyKeyAttributeKeyModesOfUse)(nil)).Elem()
}

func (o KeyKeyAttributeKeyModesOfUseOutput) ToKeyKeyAttributeKeyModesOfUseOutput() KeyKeyAttributeKeyModesOfUseOutput {
	return o
}

func (o KeyKeyAttributeKeyModesOfUseOutput) ToKeyKeyAttributeKeyModesOfUseOutputWithContext(ctx context.Context) KeyKeyAttributeKeyModesOfUseOutput {
	return o
}

// Whether an AWS Payment Cryptography key can be used to decrypt data.
func (o KeyKeyAttributeKeyModesOfUseOutput) Decrypt() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v KeyKeyAttributeKeyModesOfUse) *bool { return v.Decrypt }).(pulumi.BoolPtrOutput)
}

// Whether an AWS Payment Cryptography key can be used to derive new keys.
func (o KeyKeyAttributeKeyModesOfUseOutput) DeriveKey() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v KeyKeyAttributeKeyModesOfUse) *bool { return v.DeriveKey }).(pulumi.BoolPtrOutput)
}

// Whether an AWS Payment Cryptography key can be used to encrypt data.
func (o KeyKeyAttributeKeyModesOfUseOutput) Encrypt() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v KeyKeyAttributeKeyModesOfUse) *bool { return v.Encrypt }).(pulumi.BoolPtrOutput)
}

// Whether an AWS Payment Cryptography key can be used to generate and verify other card and PIN verification keys.
func (o KeyKeyAttributeKeyModesOfUseOutput) Generate() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v KeyKeyAttributeKeyModesOfUse) *bool { return v.Generate }).(pulumi.BoolPtrOutput)
}

// Whether an AWS Payment Cryptography key has no special restrictions other than the restrictions implied by KeyUsage.
func (o KeyKeyAttributeKeyModesOfUseOutput) NoRestrictions() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v KeyKeyAttributeKeyModesOfUse) *bool { return v.NoRestrictions }).(pulumi.BoolPtrOutput)
}

// Whether an AWS Payment Cryptography key can be used for signing.
func (o KeyKeyAttributeKeyModesOfUseOutput) Sign() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v KeyKeyAttributeKeyModesOfUse) *bool { return v.Sign }).(pulumi.BoolPtrOutput)
}

// Whether an AWS Payment Cryptography key can be used to unwrap other keys.
func (o KeyKeyAttributeKeyModesOfUseOutput) Unwrap() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v KeyKeyAttributeKeyModesOfUse) *bool { return v.Unwrap }).(pulumi.BoolPtrOutput)
}

// Whether an AWS Payment Cryptography key can be used to verify signatures.
func (o KeyKeyAttributeKeyModesOfUseOutput) Verify() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v KeyKeyAttributeKeyModesOfUse) *bool { return v.Verify }).(pulumi.BoolPtrOutput)
}

// Whether an AWS Payment Cryptography key can be used to wrap other keys.
func (o KeyKeyAttributeKeyModesOfUseOutput) Wrap() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v KeyKeyAttributeKeyModesOfUse) *bool { return v.Wrap }).(pulumi.BoolPtrOutput)
}

type KeyKeyAttributeKeyModesOfUseArrayOutput struct{ *pulumi.OutputState }

func (KeyKeyAttributeKeyModesOfUseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KeyKeyAttributeKeyModesOfUse)(nil)).Elem()
}

func (o KeyKeyAttributeKeyModesOfUseArrayOutput) ToKeyKeyAttributeKeyModesOfUseArrayOutput() KeyKeyAttributeKeyModesOfUseArrayOutput {
	return o
}

func (o KeyKeyAttributeKeyModesOfUseArrayOutput) ToKeyKeyAttributeKeyModesOfUseArrayOutputWithContext(ctx context.Context) KeyKeyAttributeKeyModesOfUseArrayOutput {
	return o
}

func (o KeyKeyAttributeKeyModesOfUseArrayOutput) Index(i pulumi.IntInput) KeyKeyAttributeKeyModesOfUseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) KeyKeyAttributeKeyModesOfUse {
		return vs[0].([]KeyKeyAttributeKeyModesOfUse)[vs[1].(int)]
	}).(KeyKeyAttributeKeyModesOfUseOutput)
}

type KeyTimeouts struct {
	// A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
	Create *string `pulumi:"create"`
	// A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
	Delete *string `pulumi:"delete"`
	// A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
	Update *string `pulumi:"update"`
}

// KeyTimeoutsInput is an input type that accepts KeyTimeoutsArgs and KeyTimeoutsOutput values.
// You can construct a concrete instance of `KeyTimeoutsInput` via:
//
//	KeyTimeoutsArgs{...}
type KeyTimeoutsInput interface {
	pulumi.Input

	ToKeyTimeoutsOutput() KeyTimeoutsOutput
	ToKeyTimeoutsOutputWithContext(context.Context) KeyTimeoutsOutput
}

type KeyTimeoutsArgs struct {
	// A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
	Create pulumi.StringPtrInput `pulumi:"create"`
	// A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
	Delete pulumi.StringPtrInput `pulumi:"delete"`
	// A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
	Update pulumi.StringPtrInput `pulumi:"update"`
}

func (KeyTimeoutsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyTimeouts)(nil)).Elem()
}

func (i KeyTimeoutsArgs) ToKeyTimeoutsOutput() KeyTimeoutsOutput {
	return i.ToKeyTimeoutsOutputWithContext(context.Background())
}

func (i KeyTimeoutsArgs) ToKeyTimeoutsOutputWithContext(ctx context.Context) KeyTimeoutsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyTimeoutsOutput)
}

func (i KeyTimeoutsArgs) ToKeyTimeoutsPtrOutput() KeyTimeoutsPtrOutput {
	return i.ToKeyTimeoutsPtrOutputWithContext(context.Background())
}

func (i KeyTimeoutsArgs) ToKeyTimeoutsPtrOutputWithContext(ctx context.Context) KeyTimeoutsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyTimeoutsOutput).ToKeyTimeoutsPtrOutputWithContext(ctx)
}

// KeyTimeoutsPtrInput is an input type that accepts KeyTimeoutsArgs, KeyTimeoutsPtr and KeyTimeoutsPtrOutput values.
// You can construct a concrete instance of `KeyTimeoutsPtrInput` via:
//
//	        KeyTimeoutsArgs{...}
//
//	or:
//
//	        nil
type KeyTimeoutsPtrInput interface {
	pulumi.Input

	ToKeyTimeoutsPtrOutput() KeyTimeoutsPtrOutput
	ToKeyTimeoutsPtrOutputWithContext(context.Context) KeyTimeoutsPtrOutput
}

type keyTimeoutsPtrType KeyTimeoutsArgs

func KeyTimeoutsPtr(v *KeyTimeoutsArgs) KeyTimeoutsPtrInput {
	return (*keyTimeoutsPtrType)(v)
}

func (*keyTimeoutsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**KeyTimeouts)(nil)).Elem()
}

func (i *keyTimeoutsPtrType) ToKeyTimeoutsPtrOutput() KeyTimeoutsPtrOutput {
	return i.ToKeyTimeoutsPtrOutputWithContext(context.Background())
}

func (i *keyTimeoutsPtrType) ToKeyTimeoutsPtrOutputWithContext(ctx context.Context) KeyTimeoutsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyTimeoutsPtrOutput)
}

type KeyTimeoutsOutput struct{ *pulumi.OutputState }

func (KeyTimeoutsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KeyTimeouts)(nil)).Elem()
}

func (o KeyTimeoutsOutput) ToKeyTimeoutsOutput() KeyTimeoutsOutput {
	return o
}

func (o KeyTimeoutsOutput) ToKeyTimeoutsOutputWithContext(ctx context.Context) KeyTimeoutsOutput {
	return o
}

func (o KeyTimeoutsOutput) ToKeyTimeoutsPtrOutput() KeyTimeoutsPtrOutput {
	return o.ToKeyTimeoutsPtrOutputWithContext(context.Background())
}

func (o KeyTimeoutsOutput) ToKeyTimeoutsPtrOutputWithContext(ctx context.Context) KeyTimeoutsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v KeyTimeouts) *KeyTimeouts {
		return &v
	}).(KeyTimeoutsPtrOutput)
}

// A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
func (o KeyTimeoutsOutput) Create() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KeyTimeouts) *string { return v.Create }).(pulumi.StringPtrOutput)
}

// A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
func (o KeyTimeoutsOutput) Delete() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KeyTimeouts) *string { return v.Delete }).(pulumi.StringPtrOutput)
}

// A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
func (o KeyTimeoutsOutput) Update() pulumi.StringPtrOutput {
	return o.ApplyT(func(v KeyTimeouts) *string { return v.Update }).(pulumi.StringPtrOutput)
}

type KeyTimeoutsPtrOutput struct{ *pulumi.OutputState }

func (KeyTimeoutsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KeyTimeouts)(nil)).Elem()
}

func (o KeyTimeoutsPtrOutput) ToKeyTimeoutsPtrOutput() KeyTimeoutsPtrOutput {
	return o
}

func (o KeyTimeoutsPtrOutput) ToKeyTimeoutsPtrOutputWithContext(ctx context.Context) KeyTimeoutsPtrOutput {
	return o
}

func (o KeyTimeoutsPtrOutput) Elem() KeyTimeoutsOutput {
	return o.ApplyT(func(v *KeyTimeouts) KeyTimeouts {
		if v != nil {
			return *v
		}
		var ret KeyTimeouts
		return ret
	}).(KeyTimeoutsOutput)
}

// A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
func (o KeyTimeoutsPtrOutput) Create() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KeyTimeouts) *string {
		if v == nil {
			return nil
		}
		return v.Create
	}).(pulumi.StringPtrOutput)
}

// A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
func (o KeyTimeoutsPtrOutput) Delete() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KeyTimeouts) *string {
		if v == nil {
			return nil
		}
		return v.Delete
	}).(pulumi.StringPtrOutput)
}

// A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
func (o KeyTimeoutsPtrOutput) Update() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KeyTimeouts) *string {
		if v == nil {
			return nil
		}
		return v.Update
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*KeyKeyAttributeInput)(nil)).Elem(), KeyKeyAttributeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KeyKeyAttributeArrayInput)(nil)).Elem(), KeyKeyAttributeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KeyKeyAttributeKeyModesOfUseInput)(nil)).Elem(), KeyKeyAttributeKeyModesOfUseArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KeyKeyAttributeKeyModesOfUseArrayInput)(nil)).Elem(), KeyKeyAttributeKeyModesOfUseArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KeyTimeoutsInput)(nil)).Elem(), KeyTimeoutsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KeyTimeoutsPtrInput)(nil)).Elem(), KeyTimeoutsArgs{})
	pulumi.RegisterOutputType(KeyKeyAttributeOutput{})
	pulumi.RegisterOutputType(KeyKeyAttributeArrayOutput{})
	pulumi.RegisterOutputType(KeyKeyAttributeKeyModesOfUseOutput{})
	pulumi.RegisterOutputType(KeyKeyAttributeKeyModesOfUseArrayOutput{})
	pulumi.RegisterOutputType(KeyTimeoutsOutput{})
	pulumi.RegisterOutputType(KeyTimeoutsPtrOutput{})
}
