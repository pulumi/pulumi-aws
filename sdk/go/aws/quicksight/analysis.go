// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package quicksight

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Resource for managing a QuickSight Analysis.
//
// ## Example Usage
//
// ## Import
//
// A QuickSight Analysis can be imported using the AWS account ID and analysis ID separated by a comma (`,`) e.g.,
//
// ```sh
//
//	$ pulumi import aws:quicksight/analysis:Analysis example 123456789012,example-id
//
// ```
type Analysis struct {
	pulumi.CustomResourceState
}

// NewAnalysis registers a new resource with the given unique name, arguments, and options.
func NewAnalysis(ctx *pulumi.Context,
	name string, args *AnalysisArgs, opts ...pulumi.ResourceOption) (*Analysis, error) {
	if args == nil {
		args = &AnalysisArgs{}
	}

	var resource Analysis
	err := ctx.RegisterResource("aws:quicksight/analysis:Analysis", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAnalysis gets an existing Analysis resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAnalysis(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AnalysisState, opts ...pulumi.ResourceOption) (*Analysis, error) {
	var resource Analysis
	err := ctx.ReadResource("aws:quicksight/analysis:Analysis", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Analysis resources.
type analysisState struct {
}

type AnalysisState struct {
}

func (AnalysisState) ElementType() reflect.Type {
	return reflect.TypeOf((*analysisState)(nil)).Elem()
}

type analysisArgs struct {
}

// The set of arguments for constructing a Analysis resource.
type AnalysisArgs struct {
}

func (AnalysisArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*analysisArgs)(nil)).Elem()
}

type AnalysisInput interface {
	pulumi.Input

	ToAnalysisOutput() AnalysisOutput
	ToAnalysisOutputWithContext(ctx context.Context) AnalysisOutput
}

func (*Analysis) ElementType() reflect.Type {
	return reflect.TypeOf((**Analysis)(nil)).Elem()
}

func (i *Analysis) ToAnalysisOutput() AnalysisOutput {
	return i.ToAnalysisOutputWithContext(context.Background())
}

func (i *Analysis) ToAnalysisOutputWithContext(ctx context.Context) AnalysisOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AnalysisOutput)
}

// AnalysisArrayInput is an input type that accepts AnalysisArray and AnalysisArrayOutput values.
// You can construct a concrete instance of `AnalysisArrayInput` via:
//
//	AnalysisArray{ AnalysisArgs{...} }
type AnalysisArrayInput interface {
	pulumi.Input

	ToAnalysisArrayOutput() AnalysisArrayOutput
	ToAnalysisArrayOutputWithContext(context.Context) AnalysisArrayOutput
}

type AnalysisArray []AnalysisInput

func (AnalysisArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Analysis)(nil)).Elem()
}

func (i AnalysisArray) ToAnalysisArrayOutput() AnalysisArrayOutput {
	return i.ToAnalysisArrayOutputWithContext(context.Background())
}

func (i AnalysisArray) ToAnalysisArrayOutputWithContext(ctx context.Context) AnalysisArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AnalysisArrayOutput)
}

// AnalysisMapInput is an input type that accepts AnalysisMap and AnalysisMapOutput values.
// You can construct a concrete instance of `AnalysisMapInput` via:
//
//	AnalysisMap{ "key": AnalysisArgs{...} }
type AnalysisMapInput interface {
	pulumi.Input

	ToAnalysisMapOutput() AnalysisMapOutput
	ToAnalysisMapOutputWithContext(context.Context) AnalysisMapOutput
}

type AnalysisMap map[string]AnalysisInput

func (AnalysisMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Analysis)(nil)).Elem()
}

func (i AnalysisMap) ToAnalysisMapOutput() AnalysisMapOutput {
	return i.ToAnalysisMapOutputWithContext(context.Background())
}

func (i AnalysisMap) ToAnalysisMapOutputWithContext(ctx context.Context) AnalysisMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AnalysisMapOutput)
}

type AnalysisOutput struct{ *pulumi.OutputState }

func (AnalysisOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Analysis)(nil)).Elem()
}

func (o AnalysisOutput) ToAnalysisOutput() AnalysisOutput {
	return o
}

func (o AnalysisOutput) ToAnalysisOutputWithContext(ctx context.Context) AnalysisOutput {
	return o
}

type AnalysisArrayOutput struct{ *pulumi.OutputState }

func (AnalysisArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Analysis)(nil)).Elem()
}

func (o AnalysisArrayOutput) ToAnalysisArrayOutput() AnalysisArrayOutput {
	return o
}

func (o AnalysisArrayOutput) ToAnalysisArrayOutputWithContext(ctx context.Context) AnalysisArrayOutput {
	return o
}

func (o AnalysisArrayOutput) Index(i pulumi.IntInput) AnalysisOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Analysis {
		return vs[0].([]*Analysis)[vs[1].(int)]
	}).(AnalysisOutput)
}

type AnalysisMapOutput struct{ *pulumi.OutputState }

func (AnalysisMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Analysis)(nil)).Elem()
}

func (o AnalysisMapOutput) ToAnalysisMapOutput() AnalysisMapOutput {
	return o
}

func (o AnalysisMapOutput) ToAnalysisMapOutputWithContext(ctx context.Context) AnalysisMapOutput {
	return o
}

func (o AnalysisMapOutput) MapIndex(k pulumi.StringInput) AnalysisOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Analysis {
		return vs[0].(map[string]*Analysis)[vs[1].(string)]
	}).(AnalysisOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AnalysisInput)(nil)).Elem(), &Analysis{})
	pulumi.RegisterInputType(reflect.TypeOf((*AnalysisArrayInput)(nil)).Elem(), AnalysisArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AnalysisMapInput)(nil)).Elem(), AnalysisMap{})
	pulumi.RegisterOutputType(AnalysisOutput{})
	pulumi.RegisterOutputType(AnalysisArrayOutput{})
	pulumi.RegisterOutputType(AnalysisMapOutput{})
}
