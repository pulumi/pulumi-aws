// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package lambda

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v7/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages an AWS Lambda Function Recursion Config. Use this resource to control how Lambda handles recursive function invocations to prevent infinite loops.
//
// > **Note:** Destruction of this resource will return the `recursiveLoop` configuration back to the default value of `Terminate`.
//
// ## Example Usage
//
// ### Allow Recursive Invocations
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-aws/sdk/v7/go/aws/lambda"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Lambda function that may need to call itself
//			example, err := lambda.NewFunction(ctx, "example", &lambda.FunctionArgs{
//				Code:    pulumi.NewFileArchive("function.zip"),
//				Name:    pulumi.String("recursive_processor"),
//				Role:    pulumi.Any(lambdaRole.Arn),
//				Handler: pulumi.String("index.handler"),
//				Runtime: pulumi.String(lambda.RuntimePython3d12),
//			})
//			if err != nil {
//				return err
//			}
//			// Allow the function to invoke itself recursively
//			_, err = lambda.NewFunctionRecursionConfig(ctx, "example", &lambda.FunctionRecursionConfigArgs{
//				FunctionName:  example.Name,
//				RecursiveLoop: pulumi.String("Allow"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Production Safety Configuration
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-aws/sdk/v7/go/aws/lambda"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Production function with recursion protection
//			productionProcessor, err := lambda.NewFunction(ctx, "production_processor", &lambda.FunctionArgs{
//				Code:    pulumi.NewFileArchive("processor.zip"),
//				Name:    pulumi.String("production-data-processor"),
//				Role:    pulumi.Any(lambdaRole.Arn),
//				Handler: pulumi.String("app.handler"),
//				Runtime: pulumi.String(lambda.RuntimeNodeJS20dX),
//				Tags: pulumi.StringMap{
//					"Environment": pulumi.String("production"),
//					"Purpose":     pulumi.String("data-processing"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			// Prevent infinite loops in production
//			_, err = lambda.NewFunctionRecursionConfig(ctx, "example", &lambda.FunctionRecursionConfigArgs{
//				FunctionName:  productionProcessor.Name,
//				RecursiveLoop: pulumi.String("Terminate"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// For backwards compatibility, the following legacy `pulumi import` command is also supported:
//
// ```sh
// $ pulumi import aws:lambda/functionRecursionConfig:FunctionRecursionConfig example recursive_processor
// ```
type FunctionRecursionConfig struct {
	pulumi.CustomResourceState

	// Name of the Lambda function.
	FunctionName pulumi.StringOutput `pulumi:"functionName"`
	// Lambda function recursion configuration. Valid values are `Allow` or `Terminate`.
	//
	// The following arguments are optional:
	RecursiveLoop pulumi.StringOutput `pulumi:"recursiveLoop"`
	// Region where this resource will be [managed](https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints). Defaults to the Region set in the provider configuration.
	Region pulumi.StringOutput `pulumi:"region"`
}

// NewFunctionRecursionConfig registers a new resource with the given unique name, arguments, and options.
func NewFunctionRecursionConfig(ctx *pulumi.Context,
	name string, args *FunctionRecursionConfigArgs, opts ...pulumi.ResourceOption) (*FunctionRecursionConfig, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.FunctionName == nil {
		return nil, errors.New("invalid value for required argument 'FunctionName'")
	}
	if args.RecursiveLoop == nil {
		return nil, errors.New("invalid value for required argument 'RecursiveLoop'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource FunctionRecursionConfig
	err := ctx.RegisterResource("aws:lambda/functionRecursionConfig:FunctionRecursionConfig", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFunctionRecursionConfig gets an existing FunctionRecursionConfig resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFunctionRecursionConfig(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FunctionRecursionConfigState, opts ...pulumi.ResourceOption) (*FunctionRecursionConfig, error) {
	var resource FunctionRecursionConfig
	err := ctx.ReadResource("aws:lambda/functionRecursionConfig:FunctionRecursionConfig", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering FunctionRecursionConfig resources.
type functionRecursionConfigState struct {
	// Name of the Lambda function.
	FunctionName *string `pulumi:"functionName"`
	// Lambda function recursion configuration. Valid values are `Allow` or `Terminate`.
	//
	// The following arguments are optional:
	RecursiveLoop *string `pulumi:"recursiveLoop"`
	// Region where this resource will be [managed](https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints). Defaults to the Region set in the provider configuration.
	Region *string `pulumi:"region"`
}

type FunctionRecursionConfigState struct {
	// Name of the Lambda function.
	FunctionName pulumi.StringPtrInput
	// Lambda function recursion configuration. Valid values are `Allow` or `Terminate`.
	//
	// The following arguments are optional:
	RecursiveLoop pulumi.StringPtrInput
	// Region where this resource will be [managed](https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints). Defaults to the Region set in the provider configuration.
	Region pulumi.StringPtrInput
}

func (FunctionRecursionConfigState) ElementType() reflect.Type {
	return reflect.TypeOf((*functionRecursionConfigState)(nil)).Elem()
}

type functionRecursionConfigArgs struct {
	// Name of the Lambda function.
	FunctionName string `pulumi:"functionName"`
	// Lambda function recursion configuration. Valid values are `Allow` or `Terminate`.
	//
	// The following arguments are optional:
	RecursiveLoop string `pulumi:"recursiveLoop"`
	// Region where this resource will be [managed](https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints). Defaults to the Region set in the provider configuration.
	Region *string `pulumi:"region"`
}

// The set of arguments for constructing a FunctionRecursionConfig resource.
type FunctionRecursionConfigArgs struct {
	// Name of the Lambda function.
	FunctionName pulumi.StringInput
	// Lambda function recursion configuration. Valid values are `Allow` or `Terminate`.
	//
	// The following arguments are optional:
	RecursiveLoop pulumi.StringInput
	// Region where this resource will be [managed](https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints). Defaults to the Region set in the provider configuration.
	Region pulumi.StringPtrInput
}

func (FunctionRecursionConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*functionRecursionConfigArgs)(nil)).Elem()
}

type FunctionRecursionConfigInput interface {
	pulumi.Input

	ToFunctionRecursionConfigOutput() FunctionRecursionConfigOutput
	ToFunctionRecursionConfigOutputWithContext(ctx context.Context) FunctionRecursionConfigOutput
}

func (*FunctionRecursionConfig) ElementType() reflect.Type {
	return reflect.TypeOf((**FunctionRecursionConfig)(nil)).Elem()
}

func (i *FunctionRecursionConfig) ToFunctionRecursionConfigOutput() FunctionRecursionConfigOutput {
	return i.ToFunctionRecursionConfigOutputWithContext(context.Background())
}

func (i *FunctionRecursionConfig) ToFunctionRecursionConfigOutputWithContext(ctx context.Context) FunctionRecursionConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FunctionRecursionConfigOutput)
}

// FunctionRecursionConfigArrayInput is an input type that accepts FunctionRecursionConfigArray and FunctionRecursionConfigArrayOutput values.
// You can construct a concrete instance of `FunctionRecursionConfigArrayInput` via:
//
//	FunctionRecursionConfigArray{ FunctionRecursionConfigArgs{...} }
type FunctionRecursionConfigArrayInput interface {
	pulumi.Input

	ToFunctionRecursionConfigArrayOutput() FunctionRecursionConfigArrayOutput
	ToFunctionRecursionConfigArrayOutputWithContext(context.Context) FunctionRecursionConfigArrayOutput
}

type FunctionRecursionConfigArray []FunctionRecursionConfigInput

func (FunctionRecursionConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FunctionRecursionConfig)(nil)).Elem()
}

func (i FunctionRecursionConfigArray) ToFunctionRecursionConfigArrayOutput() FunctionRecursionConfigArrayOutput {
	return i.ToFunctionRecursionConfigArrayOutputWithContext(context.Background())
}

func (i FunctionRecursionConfigArray) ToFunctionRecursionConfigArrayOutputWithContext(ctx context.Context) FunctionRecursionConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FunctionRecursionConfigArrayOutput)
}

// FunctionRecursionConfigMapInput is an input type that accepts FunctionRecursionConfigMap and FunctionRecursionConfigMapOutput values.
// You can construct a concrete instance of `FunctionRecursionConfigMapInput` via:
//
//	FunctionRecursionConfigMap{ "key": FunctionRecursionConfigArgs{...} }
type FunctionRecursionConfigMapInput interface {
	pulumi.Input

	ToFunctionRecursionConfigMapOutput() FunctionRecursionConfigMapOutput
	ToFunctionRecursionConfigMapOutputWithContext(context.Context) FunctionRecursionConfigMapOutput
}

type FunctionRecursionConfigMap map[string]FunctionRecursionConfigInput

func (FunctionRecursionConfigMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FunctionRecursionConfig)(nil)).Elem()
}

func (i FunctionRecursionConfigMap) ToFunctionRecursionConfigMapOutput() FunctionRecursionConfigMapOutput {
	return i.ToFunctionRecursionConfigMapOutputWithContext(context.Background())
}

func (i FunctionRecursionConfigMap) ToFunctionRecursionConfigMapOutputWithContext(ctx context.Context) FunctionRecursionConfigMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FunctionRecursionConfigMapOutput)
}

type FunctionRecursionConfigOutput struct{ *pulumi.OutputState }

func (FunctionRecursionConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FunctionRecursionConfig)(nil)).Elem()
}

func (o FunctionRecursionConfigOutput) ToFunctionRecursionConfigOutput() FunctionRecursionConfigOutput {
	return o
}

func (o FunctionRecursionConfigOutput) ToFunctionRecursionConfigOutputWithContext(ctx context.Context) FunctionRecursionConfigOutput {
	return o
}

// Name of the Lambda function.
func (o FunctionRecursionConfigOutput) FunctionName() pulumi.StringOutput {
	return o.ApplyT(func(v *FunctionRecursionConfig) pulumi.StringOutput { return v.FunctionName }).(pulumi.StringOutput)
}

// Lambda function recursion configuration. Valid values are `Allow` or `Terminate`.
//
// The following arguments are optional:
func (o FunctionRecursionConfigOutput) RecursiveLoop() pulumi.StringOutput {
	return o.ApplyT(func(v *FunctionRecursionConfig) pulumi.StringOutput { return v.RecursiveLoop }).(pulumi.StringOutput)
}

// Region where this resource will be [managed](https://docs.aws.amazon.com/general/latest/gr/rande.html#regional-endpoints). Defaults to the Region set in the provider configuration.
func (o FunctionRecursionConfigOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *FunctionRecursionConfig) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

type FunctionRecursionConfigArrayOutput struct{ *pulumi.OutputState }

func (FunctionRecursionConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FunctionRecursionConfig)(nil)).Elem()
}

func (o FunctionRecursionConfigArrayOutput) ToFunctionRecursionConfigArrayOutput() FunctionRecursionConfigArrayOutput {
	return o
}

func (o FunctionRecursionConfigArrayOutput) ToFunctionRecursionConfigArrayOutputWithContext(ctx context.Context) FunctionRecursionConfigArrayOutput {
	return o
}

func (o FunctionRecursionConfigArrayOutput) Index(i pulumi.IntInput) FunctionRecursionConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *FunctionRecursionConfig {
		return vs[0].([]*FunctionRecursionConfig)[vs[1].(int)]
	}).(FunctionRecursionConfigOutput)
}

type FunctionRecursionConfigMapOutput struct{ *pulumi.OutputState }

func (FunctionRecursionConfigMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FunctionRecursionConfig)(nil)).Elem()
}

func (o FunctionRecursionConfigMapOutput) ToFunctionRecursionConfigMapOutput() FunctionRecursionConfigMapOutput {
	return o
}

func (o FunctionRecursionConfigMapOutput) ToFunctionRecursionConfigMapOutputWithContext(ctx context.Context) FunctionRecursionConfigMapOutput {
	return o
}

func (o FunctionRecursionConfigMapOutput) MapIndex(k pulumi.StringInput) FunctionRecursionConfigOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *FunctionRecursionConfig {
		return vs[0].(map[string]*FunctionRecursionConfig)[vs[1].(string)]
	}).(FunctionRecursionConfigOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FunctionRecursionConfigInput)(nil)).Elem(), &FunctionRecursionConfig{})
	pulumi.RegisterInputType(reflect.TypeOf((*FunctionRecursionConfigArrayInput)(nil)).Elem(), FunctionRecursionConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FunctionRecursionConfigMapInput)(nil)).Elem(), FunctionRecursionConfigMap{})
	pulumi.RegisterOutputType(FunctionRecursionConfigOutput{})
	pulumi.RegisterOutputType(FunctionRecursionConfigArrayOutput{})
	pulumi.RegisterOutputType(FunctionRecursionConfigMapOutput{})
}
