// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package redshift

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Resource for managing an AWS Redshift Logging configuration.
//
// ## Example Usage
//
// ### Basic Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/redshift"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := redshift.NewLogging(ctx, "example", &redshift.LoggingArgs{
//				ClusterIdentifier:  pulumi.Any(exampleAwsRedshiftCluster.Id),
//				LogDestinationType: pulumi.String("cloudwatch"),
//				LogExports: pulumi.StringArray{
//					pulumi.String("connectionlog"),
//					pulumi.String("userlog"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### S3 Destination Type
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/redshift"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := redshift.NewLogging(ctx, "example", &redshift.LoggingArgs{
//				ClusterIdentifier:  pulumi.Any(exampleAwsRedshiftCluster.Id),
//				LogDestinationType: pulumi.String("s3"),
//				BucketName:         pulumi.Any(exampleAwsS3Bucket.Id),
//				S3KeyPrefix:        pulumi.String("example-prefix/"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Using `pulumi import`, import Redshift Logging using the `id`. For example:
//
// ```sh
// $ pulumi import aws:redshift/logging:Logging example cluster-id-12345678
// ```
type Logging struct {
	pulumi.CustomResourceState

	// Name of an existing S3 bucket where the log files are to be stored. Required when `logDestinationType` is `s3`. Must be in the same region as the cluster and the cluster must have read bucket and put object permissions. For more information on the permissions required for the bucket, please read the AWS [documentation](http://docs.aws.amazon.com/redshift/latest/mgmt/db-auditing.html#db-auditing-enable-logging)
	BucketName pulumi.StringPtrOutput `pulumi:"bucketName"`
	// Identifier of the source cluster.
	//
	// The following arguments are optional:
	ClusterIdentifier pulumi.StringOutput `pulumi:"clusterIdentifier"`
	// Log destination type. Valid values are `s3` and `cloudwatch`.
	LogDestinationType pulumi.StringPtrOutput `pulumi:"logDestinationType"`
	// Collection of exported log types. Required when `logDestinationType` is `cloudwatch`. Valid values are `connectionlog`, `useractivitylog`, and `userlog`.
	LogExports pulumi.StringArrayOutput `pulumi:"logExports"`
	// Prefix applied to the log file names.
	S3KeyPrefix pulumi.StringPtrOutput `pulumi:"s3KeyPrefix"`
}

// NewLogging registers a new resource with the given unique name, arguments, and options.
func NewLogging(ctx *pulumi.Context,
	name string, args *LoggingArgs, opts ...pulumi.ResourceOption) (*Logging, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterIdentifier == nil {
		return nil, errors.New("invalid value for required argument 'ClusterIdentifier'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Logging
	err := ctx.RegisterResource("aws:redshift/logging:Logging", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLogging gets an existing Logging resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLogging(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LoggingState, opts ...pulumi.ResourceOption) (*Logging, error) {
	var resource Logging
	err := ctx.ReadResource("aws:redshift/logging:Logging", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Logging resources.
type loggingState struct {
	// Name of an existing S3 bucket where the log files are to be stored. Required when `logDestinationType` is `s3`. Must be in the same region as the cluster and the cluster must have read bucket and put object permissions. For more information on the permissions required for the bucket, please read the AWS [documentation](http://docs.aws.amazon.com/redshift/latest/mgmt/db-auditing.html#db-auditing-enable-logging)
	BucketName *string `pulumi:"bucketName"`
	// Identifier of the source cluster.
	//
	// The following arguments are optional:
	ClusterIdentifier *string `pulumi:"clusterIdentifier"`
	// Log destination type. Valid values are `s3` and `cloudwatch`.
	LogDestinationType *string `pulumi:"logDestinationType"`
	// Collection of exported log types. Required when `logDestinationType` is `cloudwatch`. Valid values are `connectionlog`, `useractivitylog`, and `userlog`.
	LogExports []string `pulumi:"logExports"`
	// Prefix applied to the log file names.
	S3KeyPrefix *string `pulumi:"s3KeyPrefix"`
}

type LoggingState struct {
	// Name of an existing S3 bucket where the log files are to be stored. Required when `logDestinationType` is `s3`. Must be in the same region as the cluster and the cluster must have read bucket and put object permissions. For more information on the permissions required for the bucket, please read the AWS [documentation](http://docs.aws.amazon.com/redshift/latest/mgmt/db-auditing.html#db-auditing-enable-logging)
	BucketName pulumi.StringPtrInput
	// Identifier of the source cluster.
	//
	// The following arguments are optional:
	ClusterIdentifier pulumi.StringPtrInput
	// Log destination type. Valid values are `s3` and `cloudwatch`.
	LogDestinationType pulumi.StringPtrInput
	// Collection of exported log types. Required when `logDestinationType` is `cloudwatch`. Valid values are `connectionlog`, `useractivitylog`, and `userlog`.
	LogExports pulumi.StringArrayInput
	// Prefix applied to the log file names.
	S3KeyPrefix pulumi.StringPtrInput
}

func (LoggingState) ElementType() reflect.Type {
	return reflect.TypeOf((*loggingState)(nil)).Elem()
}

type loggingArgs struct {
	// Name of an existing S3 bucket where the log files are to be stored. Required when `logDestinationType` is `s3`. Must be in the same region as the cluster and the cluster must have read bucket and put object permissions. For more information on the permissions required for the bucket, please read the AWS [documentation](http://docs.aws.amazon.com/redshift/latest/mgmt/db-auditing.html#db-auditing-enable-logging)
	BucketName *string `pulumi:"bucketName"`
	// Identifier of the source cluster.
	//
	// The following arguments are optional:
	ClusterIdentifier string `pulumi:"clusterIdentifier"`
	// Log destination type. Valid values are `s3` and `cloudwatch`.
	LogDestinationType *string `pulumi:"logDestinationType"`
	// Collection of exported log types. Required when `logDestinationType` is `cloudwatch`. Valid values are `connectionlog`, `useractivitylog`, and `userlog`.
	LogExports []string `pulumi:"logExports"`
	// Prefix applied to the log file names.
	S3KeyPrefix *string `pulumi:"s3KeyPrefix"`
}

// The set of arguments for constructing a Logging resource.
type LoggingArgs struct {
	// Name of an existing S3 bucket where the log files are to be stored. Required when `logDestinationType` is `s3`. Must be in the same region as the cluster and the cluster must have read bucket and put object permissions. For more information on the permissions required for the bucket, please read the AWS [documentation](http://docs.aws.amazon.com/redshift/latest/mgmt/db-auditing.html#db-auditing-enable-logging)
	BucketName pulumi.StringPtrInput
	// Identifier of the source cluster.
	//
	// The following arguments are optional:
	ClusterIdentifier pulumi.StringInput
	// Log destination type. Valid values are `s3` and `cloudwatch`.
	LogDestinationType pulumi.StringPtrInput
	// Collection of exported log types. Required when `logDestinationType` is `cloudwatch`. Valid values are `connectionlog`, `useractivitylog`, and `userlog`.
	LogExports pulumi.StringArrayInput
	// Prefix applied to the log file names.
	S3KeyPrefix pulumi.StringPtrInput
}

func (LoggingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*loggingArgs)(nil)).Elem()
}

type LoggingInput interface {
	pulumi.Input

	ToLoggingOutput() LoggingOutput
	ToLoggingOutputWithContext(ctx context.Context) LoggingOutput
}

func (*Logging) ElementType() reflect.Type {
	return reflect.TypeOf((**Logging)(nil)).Elem()
}

func (i *Logging) ToLoggingOutput() LoggingOutput {
	return i.ToLoggingOutputWithContext(context.Background())
}

func (i *Logging) ToLoggingOutputWithContext(ctx context.Context) LoggingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingOutput)
}

// LoggingArrayInput is an input type that accepts LoggingArray and LoggingArrayOutput values.
// You can construct a concrete instance of `LoggingArrayInput` via:
//
//	LoggingArray{ LoggingArgs{...} }
type LoggingArrayInput interface {
	pulumi.Input

	ToLoggingArrayOutput() LoggingArrayOutput
	ToLoggingArrayOutputWithContext(context.Context) LoggingArrayOutput
}

type LoggingArray []LoggingInput

func (LoggingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Logging)(nil)).Elem()
}

func (i LoggingArray) ToLoggingArrayOutput() LoggingArrayOutput {
	return i.ToLoggingArrayOutputWithContext(context.Background())
}

func (i LoggingArray) ToLoggingArrayOutputWithContext(ctx context.Context) LoggingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingArrayOutput)
}

// LoggingMapInput is an input type that accepts LoggingMap and LoggingMapOutput values.
// You can construct a concrete instance of `LoggingMapInput` via:
//
//	LoggingMap{ "key": LoggingArgs{...} }
type LoggingMapInput interface {
	pulumi.Input

	ToLoggingMapOutput() LoggingMapOutput
	ToLoggingMapOutputWithContext(context.Context) LoggingMapOutput
}

type LoggingMap map[string]LoggingInput

func (LoggingMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Logging)(nil)).Elem()
}

func (i LoggingMap) ToLoggingMapOutput() LoggingMapOutput {
	return i.ToLoggingMapOutputWithContext(context.Background())
}

func (i LoggingMap) ToLoggingMapOutputWithContext(ctx context.Context) LoggingMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingMapOutput)
}

type LoggingOutput struct{ *pulumi.OutputState }

func (LoggingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Logging)(nil)).Elem()
}

func (o LoggingOutput) ToLoggingOutput() LoggingOutput {
	return o
}

func (o LoggingOutput) ToLoggingOutputWithContext(ctx context.Context) LoggingOutput {
	return o
}

// Name of an existing S3 bucket where the log files are to be stored. Required when `logDestinationType` is `s3`. Must be in the same region as the cluster and the cluster must have read bucket and put object permissions. For more information on the permissions required for the bucket, please read the AWS [documentation](http://docs.aws.amazon.com/redshift/latest/mgmt/db-auditing.html#db-auditing-enable-logging)
func (o LoggingOutput) BucketName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Logging) pulumi.StringPtrOutput { return v.BucketName }).(pulumi.StringPtrOutput)
}

// Identifier of the source cluster.
//
// The following arguments are optional:
func (o LoggingOutput) ClusterIdentifier() pulumi.StringOutput {
	return o.ApplyT(func(v *Logging) pulumi.StringOutput { return v.ClusterIdentifier }).(pulumi.StringOutput)
}

// Log destination type. Valid values are `s3` and `cloudwatch`.
func (o LoggingOutput) LogDestinationType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Logging) pulumi.StringPtrOutput { return v.LogDestinationType }).(pulumi.StringPtrOutput)
}

// Collection of exported log types. Required when `logDestinationType` is `cloudwatch`. Valid values are `connectionlog`, `useractivitylog`, and `userlog`.
func (o LoggingOutput) LogExports() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Logging) pulumi.StringArrayOutput { return v.LogExports }).(pulumi.StringArrayOutput)
}

// Prefix applied to the log file names.
func (o LoggingOutput) S3KeyPrefix() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Logging) pulumi.StringPtrOutput { return v.S3KeyPrefix }).(pulumi.StringPtrOutput)
}

type LoggingArrayOutput struct{ *pulumi.OutputState }

func (LoggingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Logging)(nil)).Elem()
}

func (o LoggingArrayOutput) ToLoggingArrayOutput() LoggingArrayOutput {
	return o
}

func (o LoggingArrayOutput) ToLoggingArrayOutputWithContext(ctx context.Context) LoggingArrayOutput {
	return o
}

func (o LoggingArrayOutput) Index(i pulumi.IntInput) LoggingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Logging {
		return vs[0].([]*Logging)[vs[1].(int)]
	}).(LoggingOutput)
}

type LoggingMapOutput struct{ *pulumi.OutputState }

func (LoggingMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Logging)(nil)).Elem()
}

func (o LoggingMapOutput) ToLoggingMapOutput() LoggingMapOutput {
	return o
}

func (o LoggingMapOutput) ToLoggingMapOutputWithContext(ctx context.Context) LoggingMapOutput {
	return o
}

func (o LoggingMapOutput) MapIndex(k pulumi.StringInput) LoggingOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Logging {
		return vs[0].(map[string]*Logging)[vs[1].(string)]
	}).(LoggingOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LoggingInput)(nil)).Elem(), &Logging{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoggingArrayInput)(nil)).Elem(), LoggingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoggingMapInput)(nil)).Elem(), LoggingMap{})
	pulumi.RegisterOutputType(LoggingOutput{})
	pulumi.RegisterOutputType(LoggingArrayOutput{})
	pulumi.RegisterOutputType(LoggingMapOutput{})
}
