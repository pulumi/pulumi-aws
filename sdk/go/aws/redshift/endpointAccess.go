// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package redshift

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Creates a new Amazon Redshift endpoint access.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-aws/sdk/v5/go/aws/redshift"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := redshift.NewEndpointAccess(ctx, "example", &redshift.EndpointAccessArgs{
//				EndpointName:      pulumi.String("example"),
//				SubnetGroupName:   pulumi.Any(aws_redshift_subnet_group.Example.Id),
//				ClusterIdentifier: pulumi.Any(aws_redshift_cluster.Example.Cluster_identifier),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Redshift endpoint access can be imported using the `name`, e.g.,
//
// ```sh
//
//	$ pulumi import aws:redshift/endpointAccess:EndpointAccess example example
//
// ```
type EndpointAccess struct {
	pulumi.CustomResourceState

	// The DNS address of the endpoint.
	Address pulumi.StringOutput `pulumi:"address"`
	// The cluster identifier of the cluster to access.
	ClusterIdentifier pulumi.StringOutput `pulumi:"clusterIdentifier"`
	// The Redshift-managed VPC endpoint name.
	EndpointName pulumi.StringOutput `pulumi:"endpointName"`
	// The port number on which the cluster accepts incoming connections.
	Port pulumi.IntOutput `pulumi:"port"`
	// The Amazon Web Services account ID of the owner of the cluster. This is only required if the cluster is in another Amazon Web Services account.
	ResourceOwner pulumi.StringOutput `pulumi:"resourceOwner"`
	// The subnet group from which Amazon Redshift chooses the subnet to deploy the endpoint.
	SubnetGroupName pulumi.StringOutput `pulumi:"subnetGroupName"`
	// The connection endpoint for connecting to an Amazon Redshift cluster through the proxy. See details below.
	VpcEndpoints EndpointAccessVpcEndpointArrayOutput `pulumi:"vpcEndpoints"`
	// The security group that defines the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
	VpcSecurityGroupIds pulumi.StringArrayOutput `pulumi:"vpcSecurityGroupIds"`
}

// NewEndpointAccess registers a new resource with the given unique name, arguments, and options.
func NewEndpointAccess(ctx *pulumi.Context,
	name string, args *EndpointAccessArgs, opts ...pulumi.ResourceOption) (*EndpointAccess, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterIdentifier == nil {
		return nil, errors.New("invalid value for required argument 'ClusterIdentifier'")
	}
	if args.EndpointName == nil {
		return nil, errors.New("invalid value for required argument 'EndpointName'")
	}
	if args.SubnetGroupName == nil {
		return nil, errors.New("invalid value for required argument 'SubnetGroupName'")
	}
	var resource EndpointAccess
	err := ctx.RegisterResource("aws:redshift/endpointAccess:EndpointAccess", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetEndpointAccess gets an existing EndpointAccess resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetEndpointAccess(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *EndpointAccessState, opts ...pulumi.ResourceOption) (*EndpointAccess, error) {
	var resource EndpointAccess
	err := ctx.ReadResource("aws:redshift/endpointAccess:EndpointAccess", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering EndpointAccess resources.
type endpointAccessState struct {
	// The DNS address of the endpoint.
	Address *string `pulumi:"address"`
	// The cluster identifier of the cluster to access.
	ClusterIdentifier *string `pulumi:"clusterIdentifier"`
	// The Redshift-managed VPC endpoint name.
	EndpointName *string `pulumi:"endpointName"`
	// The port number on which the cluster accepts incoming connections.
	Port *int `pulumi:"port"`
	// The Amazon Web Services account ID of the owner of the cluster. This is only required if the cluster is in another Amazon Web Services account.
	ResourceOwner *string `pulumi:"resourceOwner"`
	// The subnet group from which Amazon Redshift chooses the subnet to deploy the endpoint.
	SubnetGroupName *string `pulumi:"subnetGroupName"`
	// The connection endpoint for connecting to an Amazon Redshift cluster through the proxy. See details below.
	VpcEndpoints []EndpointAccessVpcEndpoint `pulumi:"vpcEndpoints"`
	// The security group that defines the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
	VpcSecurityGroupIds []string `pulumi:"vpcSecurityGroupIds"`
}

type EndpointAccessState struct {
	// The DNS address of the endpoint.
	Address pulumi.StringPtrInput
	// The cluster identifier of the cluster to access.
	ClusterIdentifier pulumi.StringPtrInput
	// The Redshift-managed VPC endpoint name.
	EndpointName pulumi.StringPtrInput
	// The port number on which the cluster accepts incoming connections.
	Port pulumi.IntPtrInput
	// The Amazon Web Services account ID of the owner of the cluster. This is only required if the cluster is in another Amazon Web Services account.
	ResourceOwner pulumi.StringPtrInput
	// The subnet group from which Amazon Redshift chooses the subnet to deploy the endpoint.
	SubnetGroupName pulumi.StringPtrInput
	// The connection endpoint for connecting to an Amazon Redshift cluster through the proxy. See details below.
	VpcEndpoints EndpointAccessVpcEndpointArrayInput
	// The security group that defines the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
	VpcSecurityGroupIds pulumi.StringArrayInput
}

func (EndpointAccessState) ElementType() reflect.Type {
	return reflect.TypeOf((*endpointAccessState)(nil)).Elem()
}

type endpointAccessArgs struct {
	// The cluster identifier of the cluster to access.
	ClusterIdentifier string `pulumi:"clusterIdentifier"`
	// The Redshift-managed VPC endpoint name.
	EndpointName string `pulumi:"endpointName"`
	// The Amazon Web Services account ID of the owner of the cluster. This is only required if the cluster is in another Amazon Web Services account.
	ResourceOwner *string `pulumi:"resourceOwner"`
	// The subnet group from which Amazon Redshift chooses the subnet to deploy the endpoint.
	SubnetGroupName string `pulumi:"subnetGroupName"`
	// The security group that defines the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
	VpcSecurityGroupIds []string `pulumi:"vpcSecurityGroupIds"`
}

// The set of arguments for constructing a EndpointAccess resource.
type EndpointAccessArgs struct {
	// The cluster identifier of the cluster to access.
	ClusterIdentifier pulumi.StringInput
	// The Redshift-managed VPC endpoint name.
	EndpointName pulumi.StringInput
	// The Amazon Web Services account ID of the owner of the cluster. This is only required if the cluster is in another Amazon Web Services account.
	ResourceOwner pulumi.StringPtrInput
	// The subnet group from which Amazon Redshift chooses the subnet to deploy the endpoint.
	SubnetGroupName pulumi.StringInput
	// The security group that defines the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
	VpcSecurityGroupIds pulumi.StringArrayInput
}

func (EndpointAccessArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*endpointAccessArgs)(nil)).Elem()
}

type EndpointAccessInput interface {
	pulumi.Input

	ToEndpointAccessOutput() EndpointAccessOutput
	ToEndpointAccessOutputWithContext(ctx context.Context) EndpointAccessOutput
}

func (*EndpointAccess) ElementType() reflect.Type {
	return reflect.TypeOf((**EndpointAccess)(nil)).Elem()
}

func (i *EndpointAccess) ToEndpointAccessOutput() EndpointAccessOutput {
	return i.ToEndpointAccessOutputWithContext(context.Background())
}

func (i *EndpointAccess) ToEndpointAccessOutputWithContext(ctx context.Context) EndpointAccessOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointAccessOutput)
}

// EndpointAccessArrayInput is an input type that accepts EndpointAccessArray and EndpointAccessArrayOutput values.
// You can construct a concrete instance of `EndpointAccessArrayInput` via:
//
//	EndpointAccessArray{ EndpointAccessArgs{...} }
type EndpointAccessArrayInput interface {
	pulumi.Input

	ToEndpointAccessArrayOutput() EndpointAccessArrayOutput
	ToEndpointAccessArrayOutputWithContext(context.Context) EndpointAccessArrayOutput
}

type EndpointAccessArray []EndpointAccessInput

func (EndpointAccessArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*EndpointAccess)(nil)).Elem()
}

func (i EndpointAccessArray) ToEndpointAccessArrayOutput() EndpointAccessArrayOutput {
	return i.ToEndpointAccessArrayOutputWithContext(context.Background())
}

func (i EndpointAccessArray) ToEndpointAccessArrayOutputWithContext(ctx context.Context) EndpointAccessArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointAccessArrayOutput)
}

// EndpointAccessMapInput is an input type that accepts EndpointAccessMap and EndpointAccessMapOutput values.
// You can construct a concrete instance of `EndpointAccessMapInput` via:
//
//	EndpointAccessMap{ "key": EndpointAccessArgs{...} }
type EndpointAccessMapInput interface {
	pulumi.Input

	ToEndpointAccessMapOutput() EndpointAccessMapOutput
	ToEndpointAccessMapOutputWithContext(context.Context) EndpointAccessMapOutput
}

type EndpointAccessMap map[string]EndpointAccessInput

func (EndpointAccessMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*EndpointAccess)(nil)).Elem()
}

func (i EndpointAccessMap) ToEndpointAccessMapOutput() EndpointAccessMapOutput {
	return i.ToEndpointAccessMapOutputWithContext(context.Background())
}

func (i EndpointAccessMap) ToEndpointAccessMapOutputWithContext(ctx context.Context) EndpointAccessMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EndpointAccessMapOutput)
}

type EndpointAccessOutput struct{ *pulumi.OutputState }

func (EndpointAccessOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EndpointAccess)(nil)).Elem()
}

func (o EndpointAccessOutput) ToEndpointAccessOutput() EndpointAccessOutput {
	return o
}

func (o EndpointAccessOutput) ToEndpointAccessOutputWithContext(ctx context.Context) EndpointAccessOutput {
	return o
}

// The DNS address of the endpoint.
func (o EndpointAccessOutput) Address() pulumi.StringOutput {
	return o.ApplyT(func(v *EndpointAccess) pulumi.StringOutput { return v.Address }).(pulumi.StringOutput)
}

// The cluster identifier of the cluster to access.
func (o EndpointAccessOutput) ClusterIdentifier() pulumi.StringOutput {
	return o.ApplyT(func(v *EndpointAccess) pulumi.StringOutput { return v.ClusterIdentifier }).(pulumi.StringOutput)
}

// The Redshift-managed VPC endpoint name.
func (o EndpointAccessOutput) EndpointName() pulumi.StringOutput {
	return o.ApplyT(func(v *EndpointAccess) pulumi.StringOutput { return v.EndpointName }).(pulumi.StringOutput)
}

// The port number on which the cluster accepts incoming connections.
func (o EndpointAccessOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v *EndpointAccess) pulumi.IntOutput { return v.Port }).(pulumi.IntOutput)
}

// The Amazon Web Services account ID of the owner of the cluster. This is only required if the cluster is in another Amazon Web Services account.
func (o EndpointAccessOutput) ResourceOwner() pulumi.StringOutput {
	return o.ApplyT(func(v *EndpointAccess) pulumi.StringOutput { return v.ResourceOwner }).(pulumi.StringOutput)
}

// The subnet group from which Amazon Redshift chooses the subnet to deploy the endpoint.
func (o EndpointAccessOutput) SubnetGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v *EndpointAccess) pulumi.StringOutput { return v.SubnetGroupName }).(pulumi.StringOutput)
}

// The connection endpoint for connecting to an Amazon Redshift cluster through the proxy. See details below.
func (o EndpointAccessOutput) VpcEndpoints() EndpointAccessVpcEndpointArrayOutput {
	return o.ApplyT(func(v *EndpointAccess) EndpointAccessVpcEndpointArrayOutput { return v.VpcEndpoints }).(EndpointAccessVpcEndpointArrayOutput)
}

// The security group that defines the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
func (o EndpointAccessOutput) VpcSecurityGroupIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *EndpointAccess) pulumi.StringArrayOutput { return v.VpcSecurityGroupIds }).(pulumi.StringArrayOutput)
}

type EndpointAccessArrayOutput struct{ *pulumi.OutputState }

func (EndpointAccessArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*EndpointAccess)(nil)).Elem()
}

func (o EndpointAccessArrayOutput) ToEndpointAccessArrayOutput() EndpointAccessArrayOutput {
	return o
}

func (o EndpointAccessArrayOutput) ToEndpointAccessArrayOutputWithContext(ctx context.Context) EndpointAccessArrayOutput {
	return o
}

func (o EndpointAccessArrayOutput) Index(i pulumi.IntInput) EndpointAccessOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *EndpointAccess {
		return vs[0].([]*EndpointAccess)[vs[1].(int)]
	}).(EndpointAccessOutput)
}

type EndpointAccessMapOutput struct{ *pulumi.OutputState }

func (EndpointAccessMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*EndpointAccess)(nil)).Elem()
}

func (o EndpointAccessMapOutput) ToEndpointAccessMapOutput() EndpointAccessMapOutput {
	return o
}

func (o EndpointAccessMapOutput) ToEndpointAccessMapOutputWithContext(ctx context.Context) EndpointAccessMapOutput {
	return o
}

func (o EndpointAccessMapOutput) MapIndex(k pulumi.StringInput) EndpointAccessOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *EndpointAccess {
		return vs[0].(map[string]*EndpointAccess)[vs[1].(string)]
	}).(EndpointAccessOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*EndpointAccessInput)(nil)).Elem(), &EndpointAccess{})
	pulumi.RegisterInputType(reflect.TypeOf((*EndpointAccessArrayInput)(nil)).Elem(), EndpointAccessArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*EndpointAccessMapInput)(nil)).Elem(), EndpointAccessMap{})
	pulumi.RegisterOutputType(EndpointAccessOutput{})
	pulumi.RegisterOutputType(EndpointAccessArrayOutput{})
	pulumi.RegisterOutputType(EndpointAccessMapOutput{})
}
