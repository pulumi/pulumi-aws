// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package cloudformation

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Import
//
// `aws_cloudformation_type` can be imported with their type version Amazon Resource Name (ARN), e.g.
//
// ```sh
//  $ pulumi import aws:cloudformation/cFType:CFType example arn:aws:cloudformation:us-east-1:123456789012:type/resource/ExampleCompany-ExampleService-ExampleType/1
// ```
type CFType struct {
	pulumi.CustomResourceState

	// (Optional) Amazon Resource Name (ARN) of the CloudFormation Type version. See also `typeArn`.
	Arn pulumi.StringOutput `pulumi:"arn"`
	// Identifier of the CloudFormation Type default version.
	DefaultVersionId pulumi.StringOutput `pulumi:"defaultVersionId"`
	// Deprecation status of the version.
	DeprecatedStatus pulumi.StringOutput `pulumi:"deprecatedStatus"`
	// Description of the version.
	Description pulumi.StringOutput `pulumi:"description"`
	// URL of the documentation for the CloudFormation Type.
	DocumentationUrl pulumi.StringOutput `pulumi:"documentationUrl"`
	// Amazon Resource Name (ARN) of the IAM Role for CloudFormation to assume when invoking the extension. If your extension calls AWS APIs in any of its handlers, you must create an IAM execution role that includes the necessary permissions to call those AWS APIs, and provision that execution role in your account. When CloudFormation needs to invoke the extension handler, CloudFormation assumes this execution role to create a temporary session token, which it then passes to the extension handler, thereby supplying your extension with the appropriate credentials.
	ExecutionRoleArn pulumi.StringPtrOutput `pulumi:"executionRoleArn"`
	// Whether the CloudFormation Type version is the default version.
	IsDefaultVersion pulumi.BoolOutput `pulumi:"isDefaultVersion"`
	// Configuration block containing logging configuration.
	LoggingConfig CFTypeLoggingConfigPtrOutput `pulumi:"loggingConfig"`
	// Provisioning behavior of the CloudFormation Type.
	ProvisioningType pulumi.StringOutput `pulumi:"provisioningType"`
	// JSON document of the CloudFormation Type schema.
	Schema pulumi.StringOutput `pulumi:"schema"`
	// URL to the S3 bucket containing the extension project package that contains the necessary files for the extension you want to register. Must begin with `s3://` or `https://`. For example, `s3://example-bucket/example-object`.
	SchemaHandlerPackage pulumi.StringOutput `pulumi:"schemaHandlerPackage"`
	// URL of the source code for the CloudFormation Type.
	SourceUrl pulumi.StringOutput `pulumi:"sourceUrl"`
	// CloudFormation Registry Type. For example, `RESOURCE` or `MODULE`.
	Type pulumi.StringOutput `pulumi:"type"`
	// (Optional) Amazon Resource Name (ARN) of the CloudFormation Type. See also `arn`.
	TypeArn pulumi.StringOutput `pulumi:"typeArn"`
	// CloudFormation Type name. For example, `ExampleCompany::ExampleService::ExampleResource`.
	TypeName pulumi.StringOutput `pulumi:"typeName"`
	// (Optional) Identifier of the CloudFormation Type version.
	VersionId pulumi.StringOutput `pulumi:"versionId"`
	// Scope of the CloudFormation Type.
	Visibility pulumi.StringOutput `pulumi:"visibility"`
}

// NewCFType registers a new resource with the given unique name, arguments, and options.
func NewCFType(ctx *pulumi.Context,
	name string, args *CFTypeArgs, opts ...pulumi.ResourceOption) (*CFType, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.SchemaHandlerPackage == nil {
		return nil, errors.New("invalid value for required argument 'SchemaHandlerPackage'")
	}
	if args.TypeName == nil {
		return nil, errors.New("invalid value for required argument 'TypeName'")
	}
	var resource CFType
	err := ctx.RegisterResource("aws:cloudformation/cFType:CFType", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCFType gets an existing CFType resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCFType(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CFTypeState, opts ...pulumi.ResourceOption) (*CFType, error) {
	var resource CFType
	err := ctx.ReadResource("aws:cloudformation/cFType:CFType", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering CFType resources.
type cftypeState struct {
	// (Optional) Amazon Resource Name (ARN) of the CloudFormation Type version. See also `typeArn`.
	Arn *string `pulumi:"arn"`
	// Identifier of the CloudFormation Type default version.
	DefaultVersionId *string `pulumi:"defaultVersionId"`
	// Deprecation status of the version.
	DeprecatedStatus *string `pulumi:"deprecatedStatus"`
	// Description of the version.
	Description *string `pulumi:"description"`
	// URL of the documentation for the CloudFormation Type.
	DocumentationUrl *string `pulumi:"documentationUrl"`
	// Amazon Resource Name (ARN) of the IAM Role for CloudFormation to assume when invoking the extension. If your extension calls AWS APIs in any of its handlers, you must create an IAM execution role that includes the necessary permissions to call those AWS APIs, and provision that execution role in your account. When CloudFormation needs to invoke the extension handler, CloudFormation assumes this execution role to create a temporary session token, which it then passes to the extension handler, thereby supplying your extension with the appropriate credentials.
	ExecutionRoleArn *string `pulumi:"executionRoleArn"`
	// Whether the CloudFormation Type version is the default version.
	IsDefaultVersion *bool `pulumi:"isDefaultVersion"`
	// Configuration block containing logging configuration.
	LoggingConfig *CFTypeLoggingConfig `pulumi:"loggingConfig"`
	// Provisioning behavior of the CloudFormation Type.
	ProvisioningType *string `pulumi:"provisioningType"`
	// JSON document of the CloudFormation Type schema.
	Schema *string `pulumi:"schema"`
	// URL to the S3 bucket containing the extension project package that contains the necessary files for the extension you want to register. Must begin with `s3://` or `https://`. For example, `s3://example-bucket/example-object`.
	SchemaHandlerPackage *string `pulumi:"schemaHandlerPackage"`
	// URL of the source code for the CloudFormation Type.
	SourceUrl *string `pulumi:"sourceUrl"`
	// CloudFormation Registry Type. For example, `RESOURCE` or `MODULE`.
	Type *string `pulumi:"type"`
	// (Optional) Amazon Resource Name (ARN) of the CloudFormation Type. See also `arn`.
	TypeArn *string `pulumi:"typeArn"`
	// CloudFormation Type name. For example, `ExampleCompany::ExampleService::ExampleResource`.
	TypeName *string `pulumi:"typeName"`
	// (Optional) Identifier of the CloudFormation Type version.
	VersionId *string `pulumi:"versionId"`
	// Scope of the CloudFormation Type.
	Visibility *string `pulumi:"visibility"`
}

type CFTypeState struct {
	// (Optional) Amazon Resource Name (ARN) of the CloudFormation Type version. See also `typeArn`.
	Arn pulumi.StringPtrInput
	// Identifier of the CloudFormation Type default version.
	DefaultVersionId pulumi.StringPtrInput
	// Deprecation status of the version.
	DeprecatedStatus pulumi.StringPtrInput
	// Description of the version.
	Description pulumi.StringPtrInput
	// URL of the documentation for the CloudFormation Type.
	DocumentationUrl pulumi.StringPtrInput
	// Amazon Resource Name (ARN) of the IAM Role for CloudFormation to assume when invoking the extension. If your extension calls AWS APIs in any of its handlers, you must create an IAM execution role that includes the necessary permissions to call those AWS APIs, and provision that execution role in your account. When CloudFormation needs to invoke the extension handler, CloudFormation assumes this execution role to create a temporary session token, which it then passes to the extension handler, thereby supplying your extension with the appropriate credentials.
	ExecutionRoleArn pulumi.StringPtrInput
	// Whether the CloudFormation Type version is the default version.
	IsDefaultVersion pulumi.BoolPtrInput
	// Configuration block containing logging configuration.
	LoggingConfig CFTypeLoggingConfigPtrInput
	// Provisioning behavior of the CloudFormation Type.
	ProvisioningType pulumi.StringPtrInput
	// JSON document of the CloudFormation Type schema.
	Schema pulumi.StringPtrInput
	// URL to the S3 bucket containing the extension project package that contains the necessary files for the extension you want to register. Must begin with `s3://` or `https://`. For example, `s3://example-bucket/example-object`.
	SchemaHandlerPackage pulumi.StringPtrInput
	// URL of the source code for the CloudFormation Type.
	SourceUrl pulumi.StringPtrInput
	// CloudFormation Registry Type. For example, `RESOURCE` or `MODULE`.
	Type pulumi.StringPtrInput
	// (Optional) Amazon Resource Name (ARN) of the CloudFormation Type. See also `arn`.
	TypeArn pulumi.StringPtrInput
	// CloudFormation Type name. For example, `ExampleCompany::ExampleService::ExampleResource`.
	TypeName pulumi.StringPtrInput
	// (Optional) Identifier of the CloudFormation Type version.
	VersionId pulumi.StringPtrInput
	// Scope of the CloudFormation Type.
	Visibility pulumi.StringPtrInput
}

func (CFTypeState) ElementType() reflect.Type {
	return reflect.TypeOf((*cftypeState)(nil)).Elem()
}

type cftypeArgs struct {
	// Amazon Resource Name (ARN) of the IAM Role for CloudFormation to assume when invoking the extension. If your extension calls AWS APIs in any of its handlers, you must create an IAM execution role that includes the necessary permissions to call those AWS APIs, and provision that execution role in your account. When CloudFormation needs to invoke the extension handler, CloudFormation assumes this execution role to create a temporary session token, which it then passes to the extension handler, thereby supplying your extension with the appropriate credentials.
	ExecutionRoleArn *string `pulumi:"executionRoleArn"`
	// Configuration block containing logging configuration.
	LoggingConfig *CFTypeLoggingConfig `pulumi:"loggingConfig"`
	// URL to the S3 bucket containing the extension project package that contains the necessary files for the extension you want to register. Must begin with `s3://` or `https://`. For example, `s3://example-bucket/example-object`.
	SchemaHandlerPackage string `pulumi:"schemaHandlerPackage"`
	// CloudFormation Registry Type. For example, `RESOURCE` or `MODULE`.
	Type *string `pulumi:"type"`
	// CloudFormation Type name. For example, `ExampleCompany::ExampleService::ExampleResource`.
	TypeName string `pulumi:"typeName"`
}

// The set of arguments for constructing a CFType resource.
type CFTypeArgs struct {
	// Amazon Resource Name (ARN) of the IAM Role for CloudFormation to assume when invoking the extension. If your extension calls AWS APIs in any of its handlers, you must create an IAM execution role that includes the necessary permissions to call those AWS APIs, and provision that execution role in your account. When CloudFormation needs to invoke the extension handler, CloudFormation assumes this execution role to create a temporary session token, which it then passes to the extension handler, thereby supplying your extension with the appropriate credentials.
	ExecutionRoleArn pulumi.StringPtrInput
	// Configuration block containing logging configuration.
	LoggingConfig CFTypeLoggingConfigPtrInput
	// URL to the S3 bucket containing the extension project package that contains the necessary files for the extension you want to register. Must begin with `s3://` or `https://`. For example, `s3://example-bucket/example-object`.
	SchemaHandlerPackage pulumi.StringInput
	// CloudFormation Registry Type. For example, `RESOURCE` or `MODULE`.
	Type pulumi.StringPtrInput
	// CloudFormation Type name. For example, `ExampleCompany::ExampleService::ExampleResource`.
	TypeName pulumi.StringInput
}

func (CFTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*cftypeArgs)(nil)).Elem()
}

type CFTypeInput interface {
	pulumi.Input

	ToCFTypeOutput() CFTypeOutput
	ToCFTypeOutputWithContext(ctx context.Context) CFTypeOutput
}

func (*CFType) ElementType() reflect.Type {
	return reflect.TypeOf((*CFType)(nil))
}

func (i *CFType) ToCFTypeOutput() CFTypeOutput {
	return i.ToCFTypeOutputWithContext(context.Background())
}

func (i *CFType) ToCFTypeOutputWithContext(ctx context.Context) CFTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CFTypeOutput)
}

func (i *CFType) ToCFTypePtrOutput() CFTypePtrOutput {
	return i.ToCFTypePtrOutputWithContext(context.Background())
}

func (i *CFType) ToCFTypePtrOutputWithContext(ctx context.Context) CFTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CFTypePtrOutput)
}

type CFTypePtrInput interface {
	pulumi.Input

	ToCFTypePtrOutput() CFTypePtrOutput
	ToCFTypePtrOutputWithContext(ctx context.Context) CFTypePtrOutput
}

type cftypePtrType CFTypeArgs

func (*cftypePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CFType)(nil))
}

func (i *cftypePtrType) ToCFTypePtrOutput() CFTypePtrOutput {
	return i.ToCFTypePtrOutputWithContext(context.Background())
}

func (i *cftypePtrType) ToCFTypePtrOutputWithContext(ctx context.Context) CFTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CFTypePtrOutput)
}

// CFTypeArrayInput is an input type that accepts CFTypeArray and CFTypeArrayOutput values.
// You can construct a concrete instance of `CFTypeArrayInput` via:
//
//          CFTypeArray{ CFTypeArgs{...} }
type CFTypeArrayInput interface {
	pulumi.Input

	ToCFTypeArrayOutput() CFTypeArrayOutput
	ToCFTypeArrayOutputWithContext(context.Context) CFTypeArrayOutput
}

type CFTypeArray []CFTypeInput

func (CFTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*CFType)(nil))
}

func (i CFTypeArray) ToCFTypeArrayOutput() CFTypeArrayOutput {
	return i.ToCFTypeArrayOutputWithContext(context.Background())
}

func (i CFTypeArray) ToCFTypeArrayOutputWithContext(ctx context.Context) CFTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CFTypeArrayOutput)
}

// CFTypeMapInput is an input type that accepts CFTypeMap and CFTypeMapOutput values.
// You can construct a concrete instance of `CFTypeMapInput` via:
//
//          CFTypeMap{ "key": CFTypeArgs{...} }
type CFTypeMapInput interface {
	pulumi.Input

	ToCFTypeMapOutput() CFTypeMapOutput
	ToCFTypeMapOutputWithContext(context.Context) CFTypeMapOutput
}

type CFTypeMap map[string]CFTypeInput

func (CFTypeMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*CFType)(nil))
}

func (i CFTypeMap) ToCFTypeMapOutput() CFTypeMapOutput {
	return i.ToCFTypeMapOutputWithContext(context.Background())
}

func (i CFTypeMap) ToCFTypeMapOutputWithContext(ctx context.Context) CFTypeMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CFTypeMapOutput)
}

type CFTypeOutput struct {
	*pulumi.OutputState
}

func (CFTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CFType)(nil))
}

func (o CFTypeOutput) ToCFTypeOutput() CFTypeOutput {
	return o
}

func (o CFTypeOutput) ToCFTypeOutputWithContext(ctx context.Context) CFTypeOutput {
	return o
}

func (o CFTypeOutput) ToCFTypePtrOutput() CFTypePtrOutput {
	return o.ToCFTypePtrOutputWithContext(context.Background())
}

func (o CFTypeOutput) ToCFTypePtrOutputWithContext(ctx context.Context) CFTypePtrOutput {
	return o.ApplyT(func(v CFType) *CFType {
		return &v
	}).(CFTypePtrOutput)
}

type CFTypePtrOutput struct {
	*pulumi.OutputState
}

func (CFTypePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CFType)(nil))
}

func (o CFTypePtrOutput) ToCFTypePtrOutput() CFTypePtrOutput {
	return o
}

func (o CFTypePtrOutput) ToCFTypePtrOutputWithContext(ctx context.Context) CFTypePtrOutput {
	return o
}

type CFTypeArrayOutput struct{ *pulumi.OutputState }

func (CFTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CFType)(nil))
}

func (o CFTypeArrayOutput) ToCFTypeArrayOutput() CFTypeArrayOutput {
	return o
}

func (o CFTypeArrayOutput) ToCFTypeArrayOutputWithContext(ctx context.Context) CFTypeArrayOutput {
	return o
}

func (o CFTypeArrayOutput) Index(i pulumi.IntInput) CFTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CFType {
		return vs[0].([]CFType)[vs[1].(int)]
	}).(CFTypeOutput)
}

type CFTypeMapOutput struct{ *pulumi.OutputState }

func (CFTypeMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]CFType)(nil))
}

func (o CFTypeMapOutput) ToCFTypeMapOutput() CFTypeMapOutput {
	return o
}

func (o CFTypeMapOutput) ToCFTypeMapOutputWithContext(ctx context.Context) CFTypeMapOutput {
	return o
}

func (o CFTypeMapOutput) MapIndex(k pulumi.StringInput) CFTypeOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) CFType {
		return vs[0].(map[string]CFType)[vs[1].(string)]
	}).(CFTypeOutput)
}

func init() {
	pulumi.RegisterOutputType(CFTypeOutput{})
	pulumi.RegisterOutputType(CFTypePtrOutput{})
	pulumi.RegisterOutputType(CFTypeArrayOutput{})
	pulumi.RegisterOutputType(CFTypeMapOutput{})
}
