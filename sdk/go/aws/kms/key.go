// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package kms

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws/sdk/v7/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type Key struct {
	pulumi.CustomResourceState

	Arn                            pulumi.StringOutput    `pulumi:"arn"`
	BypassPolicyLockoutSafetyCheck pulumi.BoolPtrOutput   `pulumi:"bypassPolicyLockoutSafetyCheck"`
	CustomKeyStoreId               pulumi.StringPtrOutput `pulumi:"customKeyStoreId"`
	CustomerMasterKeySpec          pulumi.StringPtrOutput `pulumi:"customerMasterKeySpec"`
	DeletionWindowInDays           pulumi.IntPtrOutput    `pulumi:"deletionWindowInDays"`
	Description                    pulumi.StringOutput    `pulumi:"description"`
	EnableKeyRotation              pulumi.BoolPtrOutput   `pulumi:"enableKeyRotation"`
	IsEnabled                      pulumi.BoolPtrOutput   `pulumi:"isEnabled"`
	KeyId                          pulumi.StringOutput    `pulumi:"keyId"`
	KeyUsage                       pulumi.StringPtrOutput `pulumi:"keyUsage"`
	MultiRegion                    pulumi.BoolOutput      `pulumi:"multiRegion"`
	Policy                         pulumi.StringOutput    `pulumi:"policy"`
	Region                         pulumi.StringOutput    `pulumi:"region"`
	RotationPeriodInDays           pulumi.IntOutput       `pulumi:"rotationPeriodInDays"`
	Tags                           pulumi.StringMapOutput `pulumi:"tags"`
	TagsAll                        pulumi.StringMapOutput `pulumi:"tagsAll"`
	XksKeyId                       pulumi.StringPtrOutput `pulumi:"xksKeyId"`
}

// NewKey registers a new resource with the given unique name, arguments, and options.
func NewKey(ctx *pulumi.Context,
	name string, args *KeyArgs, opts ...pulumi.ResourceOption) (*Key, error) {
	if args == nil {
		args = &KeyArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Key
	err := ctx.RegisterResource("aws:kms/key:Key", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetKey gets an existing Key resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetKey(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *KeyState, opts ...pulumi.ResourceOption) (*Key, error) {
	var resource Key
	err := ctx.ReadResource("aws:kms/key:Key", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Key resources.
type keyState struct {
	Arn                            *string           `pulumi:"arn"`
	BypassPolicyLockoutSafetyCheck *bool             `pulumi:"bypassPolicyLockoutSafetyCheck"`
	CustomKeyStoreId               *string           `pulumi:"customKeyStoreId"`
	CustomerMasterKeySpec          *string           `pulumi:"customerMasterKeySpec"`
	DeletionWindowInDays           *int              `pulumi:"deletionWindowInDays"`
	Description                    *string           `pulumi:"description"`
	EnableKeyRotation              *bool             `pulumi:"enableKeyRotation"`
	IsEnabled                      *bool             `pulumi:"isEnabled"`
	KeyId                          *string           `pulumi:"keyId"`
	KeyUsage                       *string           `pulumi:"keyUsage"`
	MultiRegion                    *bool             `pulumi:"multiRegion"`
	Policy                         *string           `pulumi:"policy"`
	Region                         *string           `pulumi:"region"`
	RotationPeriodInDays           *int              `pulumi:"rotationPeriodInDays"`
	Tags                           map[string]string `pulumi:"tags"`
	TagsAll                        map[string]string `pulumi:"tagsAll"`
	XksKeyId                       *string           `pulumi:"xksKeyId"`
}

type KeyState struct {
	Arn                            pulumi.StringPtrInput
	BypassPolicyLockoutSafetyCheck pulumi.BoolPtrInput
	CustomKeyStoreId               pulumi.StringPtrInput
	CustomerMasterKeySpec          pulumi.StringPtrInput
	DeletionWindowInDays           pulumi.IntPtrInput
	Description                    pulumi.StringPtrInput
	EnableKeyRotation              pulumi.BoolPtrInput
	IsEnabled                      pulumi.BoolPtrInput
	KeyId                          pulumi.StringPtrInput
	KeyUsage                       pulumi.StringPtrInput
	MultiRegion                    pulumi.BoolPtrInput
	Policy                         pulumi.StringPtrInput
	Region                         pulumi.StringPtrInput
	RotationPeriodInDays           pulumi.IntPtrInput
	Tags                           pulumi.StringMapInput
	TagsAll                        pulumi.StringMapInput
	XksKeyId                       pulumi.StringPtrInput
}

func (KeyState) ElementType() reflect.Type {
	return reflect.TypeOf((*keyState)(nil)).Elem()
}

type keyArgs struct {
	BypassPolicyLockoutSafetyCheck *bool             `pulumi:"bypassPolicyLockoutSafetyCheck"`
	CustomKeyStoreId               *string           `pulumi:"customKeyStoreId"`
	CustomerMasterKeySpec          *string           `pulumi:"customerMasterKeySpec"`
	DeletionWindowInDays           *int              `pulumi:"deletionWindowInDays"`
	Description                    *string           `pulumi:"description"`
	EnableKeyRotation              *bool             `pulumi:"enableKeyRotation"`
	IsEnabled                      *bool             `pulumi:"isEnabled"`
	KeyUsage                       *string           `pulumi:"keyUsage"`
	MultiRegion                    *bool             `pulumi:"multiRegion"`
	Policy                         *string           `pulumi:"policy"`
	Region                         *string           `pulumi:"region"`
	RotationPeriodInDays           *int              `pulumi:"rotationPeriodInDays"`
	Tags                           map[string]string `pulumi:"tags"`
	XksKeyId                       *string           `pulumi:"xksKeyId"`
}

// The set of arguments for constructing a Key resource.
type KeyArgs struct {
	BypassPolicyLockoutSafetyCheck pulumi.BoolPtrInput
	CustomKeyStoreId               pulumi.StringPtrInput
	CustomerMasterKeySpec          pulumi.StringPtrInput
	DeletionWindowInDays           pulumi.IntPtrInput
	Description                    pulumi.StringPtrInput
	EnableKeyRotation              pulumi.BoolPtrInput
	IsEnabled                      pulumi.BoolPtrInput
	KeyUsage                       pulumi.StringPtrInput
	MultiRegion                    pulumi.BoolPtrInput
	Policy                         pulumi.StringPtrInput
	Region                         pulumi.StringPtrInput
	RotationPeriodInDays           pulumi.IntPtrInput
	Tags                           pulumi.StringMapInput
	XksKeyId                       pulumi.StringPtrInput
}

func (KeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*keyArgs)(nil)).Elem()
}

type KeyInput interface {
	pulumi.Input

	ToKeyOutput() KeyOutput
	ToKeyOutputWithContext(ctx context.Context) KeyOutput
}

func (*Key) ElementType() reflect.Type {
	return reflect.TypeOf((**Key)(nil)).Elem()
}

func (i *Key) ToKeyOutput() KeyOutput {
	return i.ToKeyOutputWithContext(context.Background())
}

func (i *Key) ToKeyOutputWithContext(ctx context.Context) KeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyOutput)
}

// KeyArrayInput is an input type that accepts KeyArray and KeyArrayOutput values.
// You can construct a concrete instance of `KeyArrayInput` via:
//
//	KeyArray{ KeyArgs{...} }
type KeyArrayInput interface {
	pulumi.Input

	ToKeyArrayOutput() KeyArrayOutput
	ToKeyArrayOutputWithContext(context.Context) KeyArrayOutput
}

type KeyArray []KeyInput

func (KeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Key)(nil)).Elem()
}

func (i KeyArray) ToKeyArrayOutput() KeyArrayOutput {
	return i.ToKeyArrayOutputWithContext(context.Background())
}

func (i KeyArray) ToKeyArrayOutputWithContext(ctx context.Context) KeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyArrayOutput)
}

// KeyMapInput is an input type that accepts KeyMap and KeyMapOutput values.
// You can construct a concrete instance of `KeyMapInput` via:
//
//	KeyMap{ "key": KeyArgs{...} }
type KeyMapInput interface {
	pulumi.Input

	ToKeyMapOutput() KeyMapOutput
	ToKeyMapOutputWithContext(context.Context) KeyMapOutput
}

type KeyMap map[string]KeyInput

func (KeyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Key)(nil)).Elem()
}

func (i KeyMap) ToKeyMapOutput() KeyMapOutput {
	return i.ToKeyMapOutputWithContext(context.Background())
}

func (i KeyMap) ToKeyMapOutputWithContext(ctx context.Context) KeyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyMapOutput)
}

type KeyOutput struct{ *pulumi.OutputState }

func (KeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Key)(nil)).Elem()
}

func (o KeyOutput) ToKeyOutput() KeyOutput {
	return o
}

func (o KeyOutput) ToKeyOutputWithContext(ctx context.Context) KeyOutput {
	return o
}

func (o KeyOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v *Key) pulumi.StringOutput { return v.Arn }).(pulumi.StringOutput)
}

func (o KeyOutput) BypassPolicyLockoutSafetyCheck() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Key) pulumi.BoolPtrOutput { return v.BypassPolicyLockoutSafetyCheck }).(pulumi.BoolPtrOutput)
}

func (o KeyOutput) CustomKeyStoreId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Key) pulumi.StringPtrOutput { return v.CustomKeyStoreId }).(pulumi.StringPtrOutput)
}

func (o KeyOutput) CustomerMasterKeySpec() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Key) pulumi.StringPtrOutput { return v.CustomerMasterKeySpec }).(pulumi.StringPtrOutput)
}

func (o KeyOutput) DeletionWindowInDays() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Key) pulumi.IntPtrOutput { return v.DeletionWindowInDays }).(pulumi.IntPtrOutput)
}

func (o KeyOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v *Key) pulumi.StringOutput { return v.Description }).(pulumi.StringOutput)
}

func (o KeyOutput) EnableKeyRotation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Key) pulumi.BoolPtrOutput { return v.EnableKeyRotation }).(pulumi.BoolPtrOutput)
}

func (o KeyOutput) IsEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Key) pulumi.BoolPtrOutput { return v.IsEnabled }).(pulumi.BoolPtrOutput)
}

func (o KeyOutput) KeyId() pulumi.StringOutput {
	return o.ApplyT(func(v *Key) pulumi.StringOutput { return v.KeyId }).(pulumi.StringOutput)
}

func (o KeyOutput) KeyUsage() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Key) pulumi.StringPtrOutput { return v.KeyUsage }).(pulumi.StringPtrOutput)
}

func (o KeyOutput) MultiRegion() pulumi.BoolOutput {
	return o.ApplyT(func(v *Key) pulumi.BoolOutput { return v.MultiRegion }).(pulumi.BoolOutput)
}

func (o KeyOutput) Policy() pulumi.StringOutput {
	return o.ApplyT(func(v *Key) pulumi.StringOutput { return v.Policy }).(pulumi.StringOutput)
}

func (o KeyOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *Key) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

func (o KeyOutput) RotationPeriodInDays() pulumi.IntOutput {
	return o.ApplyT(func(v *Key) pulumi.IntOutput { return v.RotationPeriodInDays }).(pulumi.IntOutput)
}

func (o KeyOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Key) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

func (o KeyOutput) TagsAll() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Key) pulumi.StringMapOutput { return v.TagsAll }).(pulumi.StringMapOutput)
}

func (o KeyOutput) XksKeyId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Key) pulumi.StringPtrOutput { return v.XksKeyId }).(pulumi.StringPtrOutput)
}

type KeyArrayOutput struct{ *pulumi.OutputState }

func (KeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Key)(nil)).Elem()
}

func (o KeyArrayOutput) ToKeyArrayOutput() KeyArrayOutput {
	return o
}

func (o KeyArrayOutput) ToKeyArrayOutputWithContext(ctx context.Context) KeyArrayOutput {
	return o
}

func (o KeyArrayOutput) Index(i pulumi.IntInput) KeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Key {
		return vs[0].([]*Key)[vs[1].(int)]
	}).(KeyOutput)
}

type KeyMapOutput struct{ *pulumi.OutputState }

func (KeyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Key)(nil)).Elem()
}

func (o KeyMapOutput) ToKeyMapOutput() KeyMapOutput {
	return o
}

func (o KeyMapOutput) ToKeyMapOutputWithContext(ctx context.Context) KeyMapOutput {
	return o
}

func (o KeyMapOutput) MapIndex(k pulumi.StringInput) KeyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Key {
		return vs[0].(map[string]*Key)[vs[1].(string)]
	}).(KeyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*KeyInput)(nil)).Elem(), &Key{})
	pulumi.RegisterInputType(reflect.TypeOf((*KeyArrayInput)(nil)).Elem(), KeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KeyMapInput)(nil)).Elem(), KeyMap{})
	pulumi.RegisterOutputType(KeyOutput{})
	pulumi.RegisterOutputType(KeyArrayOutput{})
	pulumi.RegisterOutputType(KeyMapOutput{})
}
