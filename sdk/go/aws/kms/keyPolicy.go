// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package kms

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v7/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type KeyPolicy struct {
	pulumi.CustomResourceState

	BypassPolicyLockoutSafetyCheck pulumi.BoolPtrOutput `pulumi:"bypassPolicyLockoutSafetyCheck"`
	KeyId                          pulumi.StringOutput  `pulumi:"keyId"`
	Policy                         pulumi.StringOutput  `pulumi:"policy"`
	Region                         pulumi.StringOutput  `pulumi:"region"`
}

// NewKeyPolicy registers a new resource with the given unique name, arguments, and options.
func NewKeyPolicy(ctx *pulumi.Context,
	name string, args *KeyPolicyArgs, opts ...pulumi.ResourceOption) (*KeyPolicy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.KeyId == nil {
		return nil, errors.New("invalid value for required argument 'KeyId'")
	}
	if args.Policy == nil {
		return nil, errors.New("invalid value for required argument 'Policy'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource KeyPolicy
	err := ctx.RegisterResource("aws:kms/keyPolicy:KeyPolicy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetKeyPolicy gets an existing KeyPolicy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetKeyPolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *KeyPolicyState, opts ...pulumi.ResourceOption) (*KeyPolicy, error) {
	var resource KeyPolicy
	err := ctx.ReadResource("aws:kms/keyPolicy:KeyPolicy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering KeyPolicy resources.
type keyPolicyState struct {
	BypassPolicyLockoutSafetyCheck *bool   `pulumi:"bypassPolicyLockoutSafetyCheck"`
	KeyId                          *string `pulumi:"keyId"`
	Policy                         *string `pulumi:"policy"`
	Region                         *string `pulumi:"region"`
}

type KeyPolicyState struct {
	BypassPolicyLockoutSafetyCheck pulumi.BoolPtrInput
	KeyId                          pulumi.StringPtrInput
	Policy                         pulumi.StringPtrInput
	Region                         pulumi.StringPtrInput
}

func (KeyPolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*keyPolicyState)(nil)).Elem()
}

type keyPolicyArgs struct {
	BypassPolicyLockoutSafetyCheck *bool   `pulumi:"bypassPolicyLockoutSafetyCheck"`
	KeyId                          string  `pulumi:"keyId"`
	Policy                         string  `pulumi:"policy"`
	Region                         *string `pulumi:"region"`
}

// The set of arguments for constructing a KeyPolicy resource.
type KeyPolicyArgs struct {
	BypassPolicyLockoutSafetyCheck pulumi.BoolPtrInput
	KeyId                          pulumi.StringInput
	Policy                         pulumi.StringInput
	Region                         pulumi.StringPtrInput
}

func (KeyPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*keyPolicyArgs)(nil)).Elem()
}

type KeyPolicyInput interface {
	pulumi.Input

	ToKeyPolicyOutput() KeyPolicyOutput
	ToKeyPolicyOutputWithContext(ctx context.Context) KeyPolicyOutput
}

func (*KeyPolicy) ElementType() reflect.Type {
	return reflect.TypeOf((**KeyPolicy)(nil)).Elem()
}

func (i *KeyPolicy) ToKeyPolicyOutput() KeyPolicyOutput {
	return i.ToKeyPolicyOutputWithContext(context.Background())
}

func (i *KeyPolicy) ToKeyPolicyOutputWithContext(ctx context.Context) KeyPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyPolicyOutput)
}

// KeyPolicyArrayInput is an input type that accepts KeyPolicyArray and KeyPolicyArrayOutput values.
// You can construct a concrete instance of `KeyPolicyArrayInput` via:
//
//	KeyPolicyArray{ KeyPolicyArgs{...} }
type KeyPolicyArrayInput interface {
	pulumi.Input

	ToKeyPolicyArrayOutput() KeyPolicyArrayOutput
	ToKeyPolicyArrayOutputWithContext(context.Context) KeyPolicyArrayOutput
}

type KeyPolicyArray []KeyPolicyInput

func (KeyPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KeyPolicy)(nil)).Elem()
}

func (i KeyPolicyArray) ToKeyPolicyArrayOutput() KeyPolicyArrayOutput {
	return i.ToKeyPolicyArrayOutputWithContext(context.Background())
}

func (i KeyPolicyArray) ToKeyPolicyArrayOutputWithContext(ctx context.Context) KeyPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyPolicyArrayOutput)
}

// KeyPolicyMapInput is an input type that accepts KeyPolicyMap and KeyPolicyMapOutput values.
// You can construct a concrete instance of `KeyPolicyMapInput` via:
//
//	KeyPolicyMap{ "key": KeyPolicyArgs{...} }
type KeyPolicyMapInput interface {
	pulumi.Input

	ToKeyPolicyMapOutput() KeyPolicyMapOutput
	ToKeyPolicyMapOutputWithContext(context.Context) KeyPolicyMapOutput
}

type KeyPolicyMap map[string]KeyPolicyInput

func (KeyPolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KeyPolicy)(nil)).Elem()
}

func (i KeyPolicyMap) ToKeyPolicyMapOutput() KeyPolicyMapOutput {
	return i.ToKeyPolicyMapOutputWithContext(context.Background())
}

func (i KeyPolicyMap) ToKeyPolicyMapOutputWithContext(ctx context.Context) KeyPolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KeyPolicyMapOutput)
}

type KeyPolicyOutput struct{ *pulumi.OutputState }

func (KeyPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KeyPolicy)(nil)).Elem()
}

func (o KeyPolicyOutput) ToKeyPolicyOutput() KeyPolicyOutput {
	return o
}

func (o KeyPolicyOutput) ToKeyPolicyOutputWithContext(ctx context.Context) KeyPolicyOutput {
	return o
}

func (o KeyPolicyOutput) BypassPolicyLockoutSafetyCheck() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *KeyPolicy) pulumi.BoolPtrOutput { return v.BypassPolicyLockoutSafetyCheck }).(pulumi.BoolPtrOutput)
}

func (o KeyPolicyOutput) KeyId() pulumi.StringOutput {
	return o.ApplyT(func(v *KeyPolicy) pulumi.StringOutput { return v.KeyId }).(pulumi.StringOutput)
}

func (o KeyPolicyOutput) Policy() pulumi.StringOutput {
	return o.ApplyT(func(v *KeyPolicy) pulumi.StringOutput { return v.Policy }).(pulumi.StringOutput)
}

func (o KeyPolicyOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *KeyPolicy) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

type KeyPolicyArrayOutput struct{ *pulumi.OutputState }

func (KeyPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KeyPolicy)(nil)).Elem()
}

func (o KeyPolicyArrayOutput) ToKeyPolicyArrayOutput() KeyPolicyArrayOutput {
	return o
}

func (o KeyPolicyArrayOutput) ToKeyPolicyArrayOutputWithContext(ctx context.Context) KeyPolicyArrayOutput {
	return o
}

func (o KeyPolicyArrayOutput) Index(i pulumi.IntInput) KeyPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *KeyPolicy {
		return vs[0].([]*KeyPolicy)[vs[1].(int)]
	}).(KeyPolicyOutput)
}

type KeyPolicyMapOutput struct{ *pulumi.OutputState }

func (KeyPolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KeyPolicy)(nil)).Elem()
}

func (o KeyPolicyMapOutput) ToKeyPolicyMapOutput() KeyPolicyMapOutput {
	return o
}

func (o KeyPolicyMapOutput) ToKeyPolicyMapOutputWithContext(ctx context.Context) KeyPolicyMapOutput {
	return o
}

func (o KeyPolicyMapOutput) MapIndex(k pulumi.StringInput) KeyPolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *KeyPolicy {
		return vs[0].(map[string]*KeyPolicy)[vs[1].(string)]
	}).(KeyPolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*KeyPolicyInput)(nil)).Elem(), &KeyPolicy{})
	pulumi.RegisterInputType(reflect.TypeOf((*KeyPolicyArrayInput)(nil)).Elem(), KeyPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KeyPolicyMapInput)(nil)).Elem(), KeyPolicyMap{})
	pulumi.RegisterOutputType(KeyPolicyOutput{})
	pulumi.RegisterOutputType(KeyPolicyArrayOutput{})
	pulumi.RegisterOutputType(KeyPolicyMapOutput{})
}
