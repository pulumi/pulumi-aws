// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package glue

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v7/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type CatalogTable struct {
	pulumi.CustomResourceState

	Arn                  pulumi.StringOutput                       `pulumi:"arn"`
	CatalogId            pulumi.StringOutput                       `pulumi:"catalogId"`
	DatabaseName         pulumi.StringOutput                       `pulumi:"databaseName"`
	Description          pulumi.StringPtrOutput                    `pulumi:"description"`
	Name                 pulumi.StringOutput                       `pulumi:"name"`
	OpenTableFormatInput CatalogTableOpenTableFormatInputPtrOutput `pulumi:"openTableFormatInput"`
	Owner                pulumi.StringPtrOutput                    `pulumi:"owner"`
	Parameters           pulumi.StringMapOutput                    `pulumi:"parameters"`
	PartitionIndices     CatalogTablePartitionIndexArrayOutput     `pulumi:"partitionIndices"`
	PartitionKeys        CatalogTablePartitionKeyArrayOutput       `pulumi:"partitionKeys"`
	Region               pulumi.StringOutput                       `pulumi:"region"`
	Retention            pulumi.IntPtrOutput                       `pulumi:"retention"`
	StorageDescriptor    CatalogTableStorageDescriptorPtrOutput    `pulumi:"storageDescriptor"`
	TableType            pulumi.StringPtrOutput                    `pulumi:"tableType"`
	TargetTable          CatalogTableTargetTablePtrOutput          `pulumi:"targetTable"`
	ViewExpandedText     pulumi.StringPtrOutput                    `pulumi:"viewExpandedText"`
	ViewOriginalText     pulumi.StringPtrOutput                    `pulumi:"viewOriginalText"`
}

// NewCatalogTable registers a new resource with the given unique name, arguments, and options.
func NewCatalogTable(ctx *pulumi.Context,
	name string, args *CatalogTableArgs, opts ...pulumi.ResourceOption) (*CatalogTable, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DatabaseName == nil {
		return nil, errors.New("invalid value for required argument 'DatabaseName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource CatalogTable
	err := ctx.RegisterResource("aws:glue/catalogTable:CatalogTable", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCatalogTable gets an existing CatalogTable resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCatalogTable(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CatalogTableState, opts ...pulumi.ResourceOption) (*CatalogTable, error) {
	var resource CatalogTable
	err := ctx.ReadResource("aws:glue/catalogTable:CatalogTable", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering CatalogTable resources.
type catalogTableState struct {
	Arn                  *string                           `pulumi:"arn"`
	CatalogId            *string                           `pulumi:"catalogId"`
	DatabaseName         *string                           `pulumi:"databaseName"`
	Description          *string                           `pulumi:"description"`
	Name                 *string                           `pulumi:"name"`
	OpenTableFormatInput *CatalogTableOpenTableFormatInput `pulumi:"openTableFormatInput"`
	Owner                *string                           `pulumi:"owner"`
	Parameters           map[string]string                 `pulumi:"parameters"`
	PartitionIndices     []CatalogTablePartitionIndex      `pulumi:"partitionIndices"`
	PartitionKeys        []CatalogTablePartitionKey        `pulumi:"partitionKeys"`
	Region               *string                           `pulumi:"region"`
	Retention            *int                              `pulumi:"retention"`
	StorageDescriptor    *CatalogTableStorageDescriptor    `pulumi:"storageDescriptor"`
	TableType            *string                           `pulumi:"tableType"`
	TargetTable          *CatalogTableTargetTable          `pulumi:"targetTable"`
	ViewExpandedText     *string                           `pulumi:"viewExpandedText"`
	ViewOriginalText     *string                           `pulumi:"viewOriginalText"`
}

type CatalogTableState struct {
	Arn                  pulumi.StringPtrInput
	CatalogId            pulumi.StringPtrInput
	DatabaseName         pulumi.StringPtrInput
	Description          pulumi.StringPtrInput
	Name                 pulumi.StringPtrInput
	OpenTableFormatInput CatalogTableOpenTableFormatInputPtrInput
	Owner                pulumi.StringPtrInput
	Parameters           pulumi.StringMapInput
	PartitionIndices     CatalogTablePartitionIndexArrayInput
	PartitionKeys        CatalogTablePartitionKeyArrayInput
	Region               pulumi.StringPtrInput
	Retention            pulumi.IntPtrInput
	StorageDescriptor    CatalogTableStorageDescriptorPtrInput
	TableType            pulumi.StringPtrInput
	TargetTable          CatalogTableTargetTablePtrInput
	ViewExpandedText     pulumi.StringPtrInput
	ViewOriginalText     pulumi.StringPtrInput
}

func (CatalogTableState) ElementType() reflect.Type {
	return reflect.TypeOf((*catalogTableState)(nil)).Elem()
}

type catalogTableArgs struct {
	CatalogId            *string                           `pulumi:"catalogId"`
	DatabaseName         string                            `pulumi:"databaseName"`
	Description          *string                           `pulumi:"description"`
	Name                 *string                           `pulumi:"name"`
	OpenTableFormatInput *CatalogTableOpenTableFormatInput `pulumi:"openTableFormatInput"`
	Owner                *string                           `pulumi:"owner"`
	Parameters           map[string]string                 `pulumi:"parameters"`
	PartitionIndices     []CatalogTablePartitionIndex      `pulumi:"partitionIndices"`
	PartitionKeys        []CatalogTablePartitionKey        `pulumi:"partitionKeys"`
	Region               *string                           `pulumi:"region"`
	Retention            *int                              `pulumi:"retention"`
	StorageDescriptor    *CatalogTableStorageDescriptor    `pulumi:"storageDescriptor"`
	TableType            *string                           `pulumi:"tableType"`
	TargetTable          *CatalogTableTargetTable          `pulumi:"targetTable"`
	ViewExpandedText     *string                           `pulumi:"viewExpandedText"`
	ViewOriginalText     *string                           `pulumi:"viewOriginalText"`
}

// The set of arguments for constructing a CatalogTable resource.
type CatalogTableArgs struct {
	CatalogId            pulumi.StringPtrInput
	DatabaseName         pulumi.StringInput
	Description          pulumi.StringPtrInput
	Name                 pulumi.StringPtrInput
	OpenTableFormatInput CatalogTableOpenTableFormatInputPtrInput
	Owner                pulumi.StringPtrInput
	Parameters           pulumi.StringMapInput
	PartitionIndices     CatalogTablePartitionIndexArrayInput
	PartitionKeys        CatalogTablePartitionKeyArrayInput
	Region               pulumi.StringPtrInput
	Retention            pulumi.IntPtrInput
	StorageDescriptor    CatalogTableStorageDescriptorPtrInput
	TableType            pulumi.StringPtrInput
	TargetTable          CatalogTableTargetTablePtrInput
	ViewExpandedText     pulumi.StringPtrInput
	ViewOriginalText     pulumi.StringPtrInput
}

func (CatalogTableArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*catalogTableArgs)(nil)).Elem()
}

type CatalogTableInput interface {
	pulumi.Input

	ToCatalogTableOutput() CatalogTableOutput
	ToCatalogTableOutputWithContext(ctx context.Context) CatalogTableOutput
}

func (*CatalogTable) ElementType() reflect.Type {
	return reflect.TypeOf((**CatalogTable)(nil)).Elem()
}

func (i *CatalogTable) ToCatalogTableOutput() CatalogTableOutput {
	return i.ToCatalogTableOutputWithContext(context.Background())
}

func (i *CatalogTable) ToCatalogTableOutputWithContext(ctx context.Context) CatalogTableOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CatalogTableOutput)
}

// CatalogTableArrayInput is an input type that accepts CatalogTableArray and CatalogTableArrayOutput values.
// You can construct a concrete instance of `CatalogTableArrayInput` via:
//
//	CatalogTableArray{ CatalogTableArgs{...} }
type CatalogTableArrayInput interface {
	pulumi.Input

	ToCatalogTableArrayOutput() CatalogTableArrayOutput
	ToCatalogTableArrayOutputWithContext(context.Context) CatalogTableArrayOutput
}

type CatalogTableArray []CatalogTableInput

func (CatalogTableArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CatalogTable)(nil)).Elem()
}

func (i CatalogTableArray) ToCatalogTableArrayOutput() CatalogTableArrayOutput {
	return i.ToCatalogTableArrayOutputWithContext(context.Background())
}

func (i CatalogTableArray) ToCatalogTableArrayOutputWithContext(ctx context.Context) CatalogTableArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CatalogTableArrayOutput)
}

// CatalogTableMapInput is an input type that accepts CatalogTableMap and CatalogTableMapOutput values.
// You can construct a concrete instance of `CatalogTableMapInput` via:
//
//	CatalogTableMap{ "key": CatalogTableArgs{...} }
type CatalogTableMapInput interface {
	pulumi.Input

	ToCatalogTableMapOutput() CatalogTableMapOutput
	ToCatalogTableMapOutputWithContext(context.Context) CatalogTableMapOutput
}

type CatalogTableMap map[string]CatalogTableInput

func (CatalogTableMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CatalogTable)(nil)).Elem()
}

func (i CatalogTableMap) ToCatalogTableMapOutput() CatalogTableMapOutput {
	return i.ToCatalogTableMapOutputWithContext(context.Background())
}

func (i CatalogTableMap) ToCatalogTableMapOutputWithContext(ctx context.Context) CatalogTableMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CatalogTableMapOutput)
}

type CatalogTableOutput struct{ *pulumi.OutputState }

func (CatalogTableOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CatalogTable)(nil)).Elem()
}

func (o CatalogTableOutput) ToCatalogTableOutput() CatalogTableOutput {
	return o
}

func (o CatalogTableOutput) ToCatalogTableOutputWithContext(ctx context.Context) CatalogTableOutput {
	return o
}

func (o CatalogTableOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v *CatalogTable) pulumi.StringOutput { return v.Arn }).(pulumi.StringOutput)
}

func (o CatalogTableOutput) CatalogId() pulumi.StringOutput {
	return o.ApplyT(func(v *CatalogTable) pulumi.StringOutput { return v.CatalogId }).(pulumi.StringOutput)
}

func (o CatalogTableOutput) DatabaseName() pulumi.StringOutput {
	return o.ApplyT(func(v *CatalogTable) pulumi.StringOutput { return v.DatabaseName }).(pulumi.StringOutput)
}

func (o CatalogTableOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CatalogTable) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

func (o CatalogTableOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *CatalogTable) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o CatalogTableOutput) OpenTableFormatInput() CatalogTableOpenTableFormatInputPtrOutput {
	return o.ApplyT(func(v *CatalogTable) CatalogTableOpenTableFormatInputPtrOutput { return v.OpenTableFormatInput }).(CatalogTableOpenTableFormatInputPtrOutput)
}

func (o CatalogTableOutput) Owner() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CatalogTable) pulumi.StringPtrOutput { return v.Owner }).(pulumi.StringPtrOutput)
}

func (o CatalogTableOutput) Parameters() pulumi.StringMapOutput {
	return o.ApplyT(func(v *CatalogTable) pulumi.StringMapOutput { return v.Parameters }).(pulumi.StringMapOutput)
}

func (o CatalogTableOutput) PartitionIndices() CatalogTablePartitionIndexArrayOutput {
	return o.ApplyT(func(v *CatalogTable) CatalogTablePartitionIndexArrayOutput { return v.PartitionIndices }).(CatalogTablePartitionIndexArrayOutput)
}

func (o CatalogTableOutput) PartitionKeys() CatalogTablePartitionKeyArrayOutput {
	return o.ApplyT(func(v *CatalogTable) CatalogTablePartitionKeyArrayOutput { return v.PartitionKeys }).(CatalogTablePartitionKeyArrayOutput)
}

func (o CatalogTableOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *CatalogTable) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

func (o CatalogTableOutput) Retention() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CatalogTable) pulumi.IntPtrOutput { return v.Retention }).(pulumi.IntPtrOutput)
}

func (o CatalogTableOutput) StorageDescriptor() CatalogTableStorageDescriptorPtrOutput {
	return o.ApplyT(func(v *CatalogTable) CatalogTableStorageDescriptorPtrOutput { return v.StorageDescriptor }).(CatalogTableStorageDescriptorPtrOutput)
}

func (o CatalogTableOutput) TableType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CatalogTable) pulumi.StringPtrOutput { return v.TableType }).(pulumi.StringPtrOutput)
}

func (o CatalogTableOutput) TargetTable() CatalogTableTargetTablePtrOutput {
	return o.ApplyT(func(v *CatalogTable) CatalogTableTargetTablePtrOutput { return v.TargetTable }).(CatalogTableTargetTablePtrOutput)
}

func (o CatalogTableOutput) ViewExpandedText() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CatalogTable) pulumi.StringPtrOutput { return v.ViewExpandedText }).(pulumi.StringPtrOutput)
}

func (o CatalogTableOutput) ViewOriginalText() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CatalogTable) pulumi.StringPtrOutput { return v.ViewOriginalText }).(pulumi.StringPtrOutput)
}

type CatalogTableArrayOutput struct{ *pulumi.OutputState }

func (CatalogTableArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CatalogTable)(nil)).Elem()
}

func (o CatalogTableArrayOutput) ToCatalogTableArrayOutput() CatalogTableArrayOutput {
	return o
}

func (o CatalogTableArrayOutput) ToCatalogTableArrayOutputWithContext(ctx context.Context) CatalogTableArrayOutput {
	return o
}

func (o CatalogTableArrayOutput) Index(i pulumi.IntInput) CatalogTableOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *CatalogTable {
		return vs[0].([]*CatalogTable)[vs[1].(int)]
	}).(CatalogTableOutput)
}

type CatalogTableMapOutput struct{ *pulumi.OutputState }

func (CatalogTableMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CatalogTable)(nil)).Elem()
}

func (o CatalogTableMapOutput) ToCatalogTableMapOutput() CatalogTableMapOutput {
	return o
}

func (o CatalogTableMapOutput) ToCatalogTableMapOutputWithContext(ctx context.Context) CatalogTableMapOutput {
	return o
}

func (o CatalogTableMapOutput) MapIndex(k pulumi.StringInput) CatalogTableOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *CatalogTable {
		return vs[0].(map[string]*CatalogTable)[vs[1].(string)]
	}).(CatalogTableOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CatalogTableInput)(nil)).Elem(), &CatalogTable{})
	pulumi.RegisterInputType(reflect.TypeOf((*CatalogTableArrayInput)(nil)).Elem(), CatalogTableArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CatalogTableMapInput)(nil)).Elem(), CatalogTableMap{})
	pulumi.RegisterOutputType(CatalogTableOutput{})
	pulumi.RegisterOutputType(CatalogTableArrayOutput{})
	pulumi.RegisterOutputType(CatalogTableMapOutput{})
}
