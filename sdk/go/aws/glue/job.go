// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package glue

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type Job struct {
	pulumi.CustomResourceState

	Arn                     pulumi.StringOutput           `pulumi:"arn"`
	Command                 JobCommandOutput              `pulumi:"command"`
	Connections             pulumi.StringArrayOutput      `pulumi:"connections"`
	DefaultArguments        pulumi.StringMapOutput        `pulumi:"defaultArguments"`
	Description             pulumi.StringPtrOutput        `pulumi:"description"`
	ExecutionClass          pulumi.StringPtrOutput        `pulumi:"executionClass"`
	ExecutionProperty       JobExecutionPropertyOutput    `pulumi:"executionProperty"`
	GlueVersion             pulumi.StringOutput           `pulumi:"glueVersion"`
	MaxCapacity             pulumi.Float64Output          `pulumi:"maxCapacity"`
	MaxRetries              pulumi.IntPtrOutput           `pulumi:"maxRetries"`
	Name                    pulumi.StringOutput           `pulumi:"name"`
	NonOverridableArguments pulumi.StringMapOutput        `pulumi:"nonOverridableArguments"`
	NotificationProperty    JobNotificationPropertyOutput `pulumi:"notificationProperty"`
	NumberOfWorkers         pulumi.IntPtrOutput           `pulumi:"numberOfWorkers"`
	RoleArn                 pulumi.StringOutput           `pulumi:"roleArn"`
	SecurityConfiguration   pulumi.StringPtrOutput        `pulumi:"securityConfiguration"`
	Tags                    pulumi.StringMapOutput        `pulumi:"tags"`
	TagsAll                 pulumi.StringMapOutput        `pulumi:"tagsAll"`
	Timeout                 pulumi.IntOutput              `pulumi:"timeout"`
	WorkerType              pulumi.StringPtrOutput        `pulumi:"workerType"`
}

// NewJob registers a new resource with the given unique name, arguments, and options.
func NewJob(ctx *pulumi.Context,
	name string, args *JobArgs, opts ...pulumi.ResourceOption) (*Job, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Command == nil {
		return nil, errors.New("invalid value for required argument 'Command'")
	}
	if args.RoleArn == nil {
		return nil, errors.New("invalid value for required argument 'RoleArn'")
	}
	var resource Job
	err := ctx.RegisterResource("aws:glue/job:Job", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetJob gets an existing Job resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetJob(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *JobState, opts ...pulumi.ResourceOption) (*Job, error) {
	var resource Job
	err := ctx.ReadResource("aws:glue/job:Job", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Job resources.
type jobState struct {
	Arn                     *string                  `pulumi:"arn"`
	Command                 *JobCommand              `pulumi:"command"`
	Connections             []string                 `pulumi:"connections"`
	DefaultArguments        map[string]string        `pulumi:"defaultArguments"`
	Description             *string                  `pulumi:"description"`
	ExecutionClass          *string                  `pulumi:"executionClass"`
	ExecutionProperty       *JobExecutionProperty    `pulumi:"executionProperty"`
	GlueVersion             *string                  `pulumi:"glueVersion"`
	MaxCapacity             *float64                 `pulumi:"maxCapacity"`
	MaxRetries              *int                     `pulumi:"maxRetries"`
	Name                    *string                  `pulumi:"name"`
	NonOverridableArguments map[string]string        `pulumi:"nonOverridableArguments"`
	NotificationProperty    *JobNotificationProperty `pulumi:"notificationProperty"`
	NumberOfWorkers         *int                     `pulumi:"numberOfWorkers"`
	RoleArn                 *string                  `pulumi:"roleArn"`
	SecurityConfiguration   *string                  `pulumi:"securityConfiguration"`
	Tags                    map[string]string        `pulumi:"tags"`
	TagsAll                 map[string]string        `pulumi:"tagsAll"`
	Timeout                 *int                     `pulumi:"timeout"`
	WorkerType              *string                  `pulumi:"workerType"`
}

type JobState struct {
	Arn                     pulumi.StringPtrInput
	Command                 JobCommandPtrInput
	Connections             pulumi.StringArrayInput
	DefaultArguments        pulumi.StringMapInput
	Description             pulumi.StringPtrInput
	ExecutionClass          pulumi.StringPtrInput
	ExecutionProperty       JobExecutionPropertyPtrInput
	GlueVersion             pulumi.StringPtrInput
	MaxCapacity             pulumi.Float64PtrInput
	MaxRetries              pulumi.IntPtrInput
	Name                    pulumi.StringPtrInput
	NonOverridableArguments pulumi.StringMapInput
	NotificationProperty    JobNotificationPropertyPtrInput
	NumberOfWorkers         pulumi.IntPtrInput
	RoleArn                 pulumi.StringPtrInput
	SecurityConfiguration   pulumi.StringPtrInput
	Tags                    pulumi.StringMapInput
	TagsAll                 pulumi.StringMapInput
	Timeout                 pulumi.IntPtrInput
	WorkerType              pulumi.StringPtrInput
}

func (JobState) ElementType() reflect.Type {
	return reflect.TypeOf((*jobState)(nil)).Elem()
}

type jobArgs struct {
	Command                 JobCommand               `pulumi:"command"`
	Connections             []string                 `pulumi:"connections"`
	DefaultArguments        map[string]string        `pulumi:"defaultArguments"`
	Description             *string                  `pulumi:"description"`
	ExecutionClass          *string                  `pulumi:"executionClass"`
	ExecutionProperty       *JobExecutionProperty    `pulumi:"executionProperty"`
	GlueVersion             *string                  `pulumi:"glueVersion"`
	MaxCapacity             *float64                 `pulumi:"maxCapacity"`
	MaxRetries              *int                     `pulumi:"maxRetries"`
	Name                    *string                  `pulumi:"name"`
	NonOverridableArguments map[string]string        `pulumi:"nonOverridableArguments"`
	NotificationProperty    *JobNotificationProperty `pulumi:"notificationProperty"`
	NumberOfWorkers         *int                     `pulumi:"numberOfWorkers"`
	RoleArn                 string                   `pulumi:"roleArn"`
	SecurityConfiguration   *string                  `pulumi:"securityConfiguration"`
	Tags                    map[string]string        `pulumi:"tags"`
	Timeout                 *int                     `pulumi:"timeout"`
	WorkerType              *string                  `pulumi:"workerType"`
}

// The set of arguments for constructing a Job resource.
type JobArgs struct {
	Command                 JobCommandInput
	Connections             pulumi.StringArrayInput
	DefaultArguments        pulumi.StringMapInput
	Description             pulumi.StringPtrInput
	ExecutionClass          pulumi.StringPtrInput
	ExecutionProperty       JobExecutionPropertyPtrInput
	GlueVersion             pulumi.StringPtrInput
	MaxCapacity             pulumi.Float64PtrInput
	MaxRetries              pulumi.IntPtrInput
	Name                    pulumi.StringPtrInput
	NonOverridableArguments pulumi.StringMapInput
	NotificationProperty    JobNotificationPropertyPtrInput
	NumberOfWorkers         pulumi.IntPtrInput
	RoleArn                 pulumi.StringInput
	SecurityConfiguration   pulumi.StringPtrInput
	Tags                    pulumi.StringMapInput
	Timeout                 pulumi.IntPtrInput
	WorkerType              pulumi.StringPtrInput
}

func (JobArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*jobArgs)(nil)).Elem()
}

type JobInput interface {
	pulumi.Input

	ToJobOutput() JobOutput
	ToJobOutputWithContext(ctx context.Context) JobOutput
}

func (*Job) ElementType() reflect.Type {
	return reflect.TypeOf((**Job)(nil)).Elem()
}

func (i *Job) ToJobOutput() JobOutput {
	return i.ToJobOutputWithContext(context.Background())
}

func (i *Job) ToJobOutputWithContext(ctx context.Context) JobOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobOutput)
}

// JobArrayInput is an input type that accepts JobArray and JobArrayOutput values.
// You can construct a concrete instance of `JobArrayInput` via:
//
//	JobArray{ JobArgs{...} }
type JobArrayInput interface {
	pulumi.Input

	ToJobArrayOutput() JobArrayOutput
	ToJobArrayOutputWithContext(context.Context) JobArrayOutput
}

type JobArray []JobInput

func (JobArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Job)(nil)).Elem()
}

func (i JobArray) ToJobArrayOutput() JobArrayOutput {
	return i.ToJobArrayOutputWithContext(context.Background())
}

func (i JobArray) ToJobArrayOutputWithContext(ctx context.Context) JobArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobArrayOutput)
}

// JobMapInput is an input type that accepts JobMap and JobMapOutput values.
// You can construct a concrete instance of `JobMapInput` via:
//
//	JobMap{ "key": JobArgs{...} }
type JobMapInput interface {
	pulumi.Input

	ToJobMapOutput() JobMapOutput
	ToJobMapOutputWithContext(context.Context) JobMapOutput
}

type JobMap map[string]JobInput

func (JobMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Job)(nil)).Elem()
}

func (i JobMap) ToJobMapOutput() JobMapOutput {
	return i.ToJobMapOutputWithContext(context.Background())
}

func (i JobMap) ToJobMapOutputWithContext(ctx context.Context) JobMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(JobMapOutput)
}

type JobOutput struct{ *pulumi.OutputState }

func (JobOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Job)(nil)).Elem()
}

func (o JobOutput) ToJobOutput() JobOutput {
	return o
}

func (o JobOutput) ToJobOutputWithContext(ctx context.Context) JobOutput {
	return o
}

func (o JobOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v *Job) pulumi.StringOutput { return v.Arn }).(pulumi.StringOutput)
}

func (o JobOutput) Command() JobCommandOutput {
	return o.ApplyT(func(v *Job) JobCommandOutput { return v.Command }).(JobCommandOutput)
}

func (o JobOutput) Connections() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Job) pulumi.StringArrayOutput { return v.Connections }).(pulumi.StringArrayOutput)
}

func (o JobOutput) DefaultArguments() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Job) pulumi.StringMapOutput { return v.DefaultArguments }).(pulumi.StringMapOutput)
}

func (o JobOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Job) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

func (o JobOutput) ExecutionClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Job) pulumi.StringPtrOutput { return v.ExecutionClass }).(pulumi.StringPtrOutput)
}

func (o JobOutput) ExecutionProperty() JobExecutionPropertyOutput {
	return o.ApplyT(func(v *Job) JobExecutionPropertyOutput { return v.ExecutionProperty }).(JobExecutionPropertyOutput)
}

func (o JobOutput) GlueVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *Job) pulumi.StringOutput { return v.GlueVersion }).(pulumi.StringOutput)
}

func (o JobOutput) MaxCapacity() pulumi.Float64Output {
	return o.ApplyT(func(v *Job) pulumi.Float64Output { return v.MaxCapacity }).(pulumi.Float64Output)
}

func (o JobOutput) MaxRetries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Job) pulumi.IntPtrOutput { return v.MaxRetries }).(pulumi.IntPtrOutput)
}

func (o JobOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Job) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o JobOutput) NonOverridableArguments() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Job) pulumi.StringMapOutput { return v.NonOverridableArguments }).(pulumi.StringMapOutput)
}

func (o JobOutput) NotificationProperty() JobNotificationPropertyOutput {
	return o.ApplyT(func(v *Job) JobNotificationPropertyOutput { return v.NotificationProperty }).(JobNotificationPropertyOutput)
}

func (o JobOutput) NumberOfWorkers() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Job) pulumi.IntPtrOutput { return v.NumberOfWorkers }).(pulumi.IntPtrOutput)
}

func (o JobOutput) RoleArn() pulumi.StringOutput {
	return o.ApplyT(func(v *Job) pulumi.StringOutput { return v.RoleArn }).(pulumi.StringOutput)
}

func (o JobOutput) SecurityConfiguration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Job) pulumi.StringPtrOutput { return v.SecurityConfiguration }).(pulumi.StringPtrOutput)
}

func (o JobOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Job) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

func (o JobOutput) TagsAll() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Job) pulumi.StringMapOutput { return v.TagsAll }).(pulumi.StringMapOutput)
}

func (o JobOutput) Timeout() pulumi.IntOutput {
	return o.ApplyT(func(v *Job) pulumi.IntOutput { return v.Timeout }).(pulumi.IntOutput)
}

func (o JobOutput) WorkerType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Job) pulumi.StringPtrOutput { return v.WorkerType }).(pulumi.StringPtrOutput)
}

type JobArrayOutput struct{ *pulumi.OutputState }

func (JobArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Job)(nil)).Elem()
}

func (o JobArrayOutput) ToJobArrayOutput() JobArrayOutput {
	return o
}

func (o JobArrayOutput) ToJobArrayOutputWithContext(ctx context.Context) JobArrayOutput {
	return o
}

func (o JobArrayOutput) Index(i pulumi.IntInput) JobOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Job {
		return vs[0].([]*Job)[vs[1].(int)]
	}).(JobOutput)
}

type JobMapOutput struct{ *pulumi.OutputState }

func (JobMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Job)(nil)).Elem()
}

func (o JobMapOutput) ToJobMapOutput() JobMapOutput {
	return o
}

func (o JobMapOutput) ToJobMapOutputWithContext(ctx context.Context) JobMapOutput {
	return o
}

func (o JobMapOutput) MapIndex(k pulumi.StringInput) JobOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Job {
		return vs[0].(map[string]*Job)[vs[1].(string)]
	}).(JobOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*JobInput)(nil)).Elem(), &Job{})
	pulumi.RegisterInputType(reflect.TypeOf((*JobArrayInput)(nil)).Elem(), JobArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*JobMapInput)(nil)).Elem(), JobMap{})
	pulumi.RegisterOutputType(JobOutput{})
	pulumi.RegisterOutputType(JobArrayOutput{})
	pulumi.RegisterOutputType(JobMapOutput{})
}
