// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package glue

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type MLTransform struct {
	pulumi.CustomResourceState

	Arn               pulumi.StringOutput                    `pulumi:"arn"`
	Description       pulumi.StringPtrOutput                 `pulumi:"description"`
	GlueVersion       pulumi.StringOutput                    `pulumi:"glueVersion"`
	InputRecordTables MLTransformInputRecordTableArrayOutput `pulumi:"inputRecordTables"`
	LabelCount        pulumi.IntOutput                       `pulumi:"labelCount"`
	MaxCapacity       pulumi.Float64Output                   `pulumi:"maxCapacity"`
	MaxRetries        pulumi.IntPtrOutput                    `pulumi:"maxRetries"`
	Name              pulumi.StringOutput                    `pulumi:"name"`
	NumberOfWorkers   pulumi.IntPtrOutput                    `pulumi:"numberOfWorkers"`
	Parameters        MLTransformParametersOutput            `pulumi:"parameters"`
	RoleArn           pulumi.StringOutput                    `pulumi:"roleArn"`
	Schemas           MLTransformSchemaArrayOutput           `pulumi:"schemas"`
	Tags              pulumi.StringMapOutput                 `pulumi:"tags"`
	TagsAll           pulumi.StringMapOutput                 `pulumi:"tagsAll"`
	Timeout           pulumi.IntPtrOutput                    `pulumi:"timeout"`
	WorkerType        pulumi.StringPtrOutput                 `pulumi:"workerType"`
}

// NewMLTransform registers a new resource with the given unique name, arguments, and options.
func NewMLTransform(ctx *pulumi.Context,
	name string, args *MLTransformArgs, opts ...pulumi.ResourceOption) (*MLTransform, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.InputRecordTables == nil {
		return nil, errors.New("invalid value for required argument 'InputRecordTables'")
	}
	if args.Parameters == nil {
		return nil, errors.New("invalid value for required argument 'Parameters'")
	}
	if args.RoleArn == nil {
		return nil, errors.New("invalid value for required argument 'RoleArn'")
	}
	var resource MLTransform
	err := ctx.RegisterResource("aws:glue/mLTransform:MLTransform", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMLTransform gets an existing MLTransform resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMLTransform(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MLTransformState, opts ...pulumi.ResourceOption) (*MLTransform, error) {
	var resource MLTransform
	err := ctx.ReadResource("aws:glue/mLTransform:MLTransform", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering MLTransform resources.
type mltransformState struct {
	Arn               *string                       `pulumi:"arn"`
	Description       *string                       `pulumi:"description"`
	GlueVersion       *string                       `pulumi:"glueVersion"`
	InputRecordTables []MLTransformInputRecordTable `pulumi:"inputRecordTables"`
	LabelCount        *int                          `pulumi:"labelCount"`
	MaxCapacity       *float64                      `pulumi:"maxCapacity"`
	MaxRetries        *int                          `pulumi:"maxRetries"`
	Name              *string                       `pulumi:"name"`
	NumberOfWorkers   *int                          `pulumi:"numberOfWorkers"`
	Parameters        *MLTransformParameters        `pulumi:"parameters"`
	RoleArn           *string                       `pulumi:"roleArn"`
	Schemas           []MLTransformSchema           `pulumi:"schemas"`
	Tags              map[string]string             `pulumi:"tags"`
	TagsAll           map[string]string             `pulumi:"tagsAll"`
	Timeout           *int                          `pulumi:"timeout"`
	WorkerType        *string                       `pulumi:"workerType"`
}

type MLTransformState struct {
	Arn               pulumi.StringPtrInput
	Description       pulumi.StringPtrInput
	GlueVersion       pulumi.StringPtrInput
	InputRecordTables MLTransformInputRecordTableArrayInput
	LabelCount        pulumi.IntPtrInput
	MaxCapacity       pulumi.Float64PtrInput
	MaxRetries        pulumi.IntPtrInput
	Name              pulumi.StringPtrInput
	NumberOfWorkers   pulumi.IntPtrInput
	Parameters        MLTransformParametersPtrInput
	RoleArn           pulumi.StringPtrInput
	Schemas           MLTransformSchemaArrayInput
	Tags              pulumi.StringMapInput
	TagsAll           pulumi.StringMapInput
	Timeout           pulumi.IntPtrInput
	WorkerType        pulumi.StringPtrInput
}

func (MLTransformState) ElementType() reflect.Type {
	return reflect.TypeOf((*mltransformState)(nil)).Elem()
}

type mltransformArgs struct {
	Description       *string                       `pulumi:"description"`
	GlueVersion       *string                       `pulumi:"glueVersion"`
	InputRecordTables []MLTransformInputRecordTable `pulumi:"inputRecordTables"`
	MaxCapacity       *float64                      `pulumi:"maxCapacity"`
	MaxRetries        *int                          `pulumi:"maxRetries"`
	Name              *string                       `pulumi:"name"`
	NumberOfWorkers   *int                          `pulumi:"numberOfWorkers"`
	Parameters        MLTransformParameters         `pulumi:"parameters"`
	RoleArn           string                        `pulumi:"roleArn"`
	Tags              map[string]string             `pulumi:"tags"`
	Timeout           *int                          `pulumi:"timeout"`
	WorkerType        *string                       `pulumi:"workerType"`
}

// The set of arguments for constructing a MLTransform resource.
type MLTransformArgs struct {
	Description       pulumi.StringPtrInput
	GlueVersion       pulumi.StringPtrInput
	InputRecordTables MLTransformInputRecordTableArrayInput
	MaxCapacity       pulumi.Float64PtrInput
	MaxRetries        pulumi.IntPtrInput
	Name              pulumi.StringPtrInput
	NumberOfWorkers   pulumi.IntPtrInput
	Parameters        MLTransformParametersInput
	RoleArn           pulumi.StringInput
	Tags              pulumi.StringMapInput
	Timeout           pulumi.IntPtrInput
	WorkerType        pulumi.StringPtrInput
}

func (MLTransformArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*mltransformArgs)(nil)).Elem()
}

type MLTransformInput interface {
	pulumi.Input

	ToMLTransformOutput() MLTransformOutput
	ToMLTransformOutputWithContext(ctx context.Context) MLTransformOutput
}

func (*MLTransform) ElementType() reflect.Type {
	return reflect.TypeOf((**MLTransform)(nil)).Elem()
}

func (i *MLTransform) ToMLTransformOutput() MLTransformOutput {
	return i.ToMLTransformOutputWithContext(context.Background())
}

func (i *MLTransform) ToMLTransformOutputWithContext(ctx context.Context) MLTransformOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MLTransformOutput)
}

// MLTransformArrayInput is an input type that accepts MLTransformArray and MLTransformArrayOutput values.
// You can construct a concrete instance of `MLTransformArrayInput` via:
//
//	MLTransformArray{ MLTransformArgs{...} }
type MLTransformArrayInput interface {
	pulumi.Input

	ToMLTransformArrayOutput() MLTransformArrayOutput
	ToMLTransformArrayOutputWithContext(context.Context) MLTransformArrayOutput
}

type MLTransformArray []MLTransformInput

func (MLTransformArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MLTransform)(nil)).Elem()
}

func (i MLTransformArray) ToMLTransformArrayOutput() MLTransformArrayOutput {
	return i.ToMLTransformArrayOutputWithContext(context.Background())
}

func (i MLTransformArray) ToMLTransformArrayOutputWithContext(ctx context.Context) MLTransformArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MLTransformArrayOutput)
}

// MLTransformMapInput is an input type that accepts MLTransformMap and MLTransformMapOutput values.
// You can construct a concrete instance of `MLTransformMapInput` via:
//
//	MLTransformMap{ "key": MLTransformArgs{...} }
type MLTransformMapInput interface {
	pulumi.Input

	ToMLTransformMapOutput() MLTransformMapOutput
	ToMLTransformMapOutputWithContext(context.Context) MLTransformMapOutput
}

type MLTransformMap map[string]MLTransformInput

func (MLTransformMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MLTransform)(nil)).Elem()
}

func (i MLTransformMap) ToMLTransformMapOutput() MLTransformMapOutput {
	return i.ToMLTransformMapOutputWithContext(context.Background())
}

func (i MLTransformMap) ToMLTransformMapOutputWithContext(ctx context.Context) MLTransformMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MLTransformMapOutput)
}

type MLTransformOutput struct{ *pulumi.OutputState }

func (MLTransformOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MLTransform)(nil)).Elem()
}

func (o MLTransformOutput) ToMLTransformOutput() MLTransformOutput {
	return o
}

func (o MLTransformOutput) ToMLTransformOutputWithContext(ctx context.Context) MLTransformOutput {
	return o
}

func (o MLTransformOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v *MLTransform) pulumi.StringOutput { return v.Arn }).(pulumi.StringOutput)
}

func (o MLTransformOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MLTransform) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

func (o MLTransformOutput) GlueVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *MLTransform) pulumi.StringOutput { return v.GlueVersion }).(pulumi.StringOutput)
}

func (o MLTransformOutput) InputRecordTables() MLTransformInputRecordTableArrayOutput {
	return o.ApplyT(func(v *MLTransform) MLTransformInputRecordTableArrayOutput { return v.InputRecordTables }).(MLTransformInputRecordTableArrayOutput)
}

func (o MLTransformOutput) LabelCount() pulumi.IntOutput {
	return o.ApplyT(func(v *MLTransform) pulumi.IntOutput { return v.LabelCount }).(pulumi.IntOutput)
}

func (o MLTransformOutput) MaxCapacity() pulumi.Float64Output {
	return o.ApplyT(func(v *MLTransform) pulumi.Float64Output { return v.MaxCapacity }).(pulumi.Float64Output)
}

func (o MLTransformOutput) MaxRetries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *MLTransform) pulumi.IntPtrOutput { return v.MaxRetries }).(pulumi.IntPtrOutput)
}

func (o MLTransformOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *MLTransform) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o MLTransformOutput) NumberOfWorkers() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *MLTransform) pulumi.IntPtrOutput { return v.NumberOfWorkers }).(pulumi.IntPtrOutput)
}

func (o MLTransformOutput) Parameters() MLTransformParametersOutput {
	return o.ApplyT(func(v *MLTransform) MLTransformParametersOutput { return v.Parameters }).(MLTransformParametersOutput)
}

func (o MLTransformOutput) RoleArn() pulumi.StringOutput {
	return o.ApplyT(func(v *MLTransform) pulumi.StringOutput { return v.RoleArn }).(pulumi.StringOutput)
}

func (o MLTransformOutput) Schemas() MLTransformSchemaArrayOutput {
	return o.ApplyT(func(v *MLTransform) MLTransformSchemaArrayOutput { return v.Schemas }).(MLTransformSchemaArrayOutput)
}

func (o MLTransformOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *MLTransform) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

func (o MLTransformOutput) TagsAll() pulumi.StringMapOutput {
	return o.ApplyT(func(v *MLTransform) pulumi.StringMapOutput { return v.TagsAll }).(pulumi.StringMapOutput)
}

func (o MLTransformOutput) Timeout() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *MLTransform) pulumi.IntPtrOutput { return v.Timeout }).(pulumi.IntPtrOutput)
}

func (o MLTransformOutput) WorkerType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MLTransform) pulumi.StringPtrOutput { return v.WorkerType }).(pulumi.StringPtrOutput)
}

type MLTransformArrayOutput struct{ *pulumi.OutputState }

func (MLTransformArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MLTransform)(nil)).Elem()
}

func (o MLTransformArrayOutput) ToMLTransformArrayOutput() MLTransformArrayOutput {
	return o
}

func (o MLTransformArrayOutput) ToMLTransformArrayOutputWithContext(ctx context.Context) MLTransformArrayOutput {
	return o
}

func (o MLTransformArrayOutput) Index(i pulumi.IntInput) MLTransformOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *MLTransform {
		return vs[0].([]*MLTransform)[vs[1].(int)]
	}).(MLTransformOutput)
}

type MLTransformMapOutput struct{ *pulumi.OutputState }

func (MLTransformMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MLTransform)(nil)).Elem()
}

func (o MLTransformMapOutput) ToMLTransformMapOutput() MLTransformMapOutput {
	return o
}

func (o MLTransformMapOutput) ToMLTransformMapOutputWithContext(ctx context.Context) MLTransformMapOutput {
	return o
}

func (o MLTransformMapOutput) MapIndex(k pulumi.StringInput) MLTransformOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *MLTransform {
		return vs[0].(map[string]*MLTransform)[vs[1].(string)]
	}).(MLTransformOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*MLTransformInput)(nil)).Elem(), &MLTransform{})
	pulumi.RegisterInputType(reflect.TypeOf((*MLTransformArrayInput)(nil)).Elem(), MLTransformArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MLTransformMapInput)(nil)).Elem(), MLTransformMap{})
	pulumi.RegisterOutputType(MLTransformOutput{})
	pulumi.RegisterOutputType(MLTransformArrayOutput{})
	pulumi.RegisterOutputType(MLTransformMapOutput{})
}
