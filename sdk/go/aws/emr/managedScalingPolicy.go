// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package emr

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// Provides a Managed Scaling policy for EMR Cluster. With Amazon EMR versions 5.30.0 and later (except for Amazon EMR 6.0.0), you can enable EMR managed scaling to automatically increase or decrease the number of instances or units in your cluster based on workload. See [Using EMR Managed Scaling in Amazon EMR](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-managed-scaling.html) for more information.
type ManagedScalingPolicy struct {
	pulumi.CustomResourceState

	// ID of the EMR cluster
	ClusterId pulumi.StringOutput `pulumi:"clusterId"`
	// Configuration block with compute limit settings. Described below.
	ComputeLimits ManagedScalingPolicyComputeLimitArrayOutput `pulumi:"computeLimits"`
}

// NewManagedScalingPolicy registers a new resource with the given unique name, arguments, and options.
func NewManagedScalingPolicy(ctx *pulumi.Context,
	name string, args *ManagedScalingPolicyArgs, opts ...pulumi.ResourceOption) (*ManagedScalingPolicy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterId == nil {
		return nil, errors.New("invalid value for required argument 'ClusterId'")
	}
	if args.ComputeLimits == nil {
		return nil, errors.New("invalid value for required argument 'ComputeLimits'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ManagedScalingPolicy
	err := ctx.RegisterResource("aws:emr/managedScalingPolicy:ManagedScalingPolicy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetManagedScalingPolicy gets an existing ManagedScalingPolicy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetManagedScalingPolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ManagedScalingPolicyState, opts ...pulumi.ResourceOption) (*ManagedScalingPolicy, error) {
	var resource ManagedScalingPolicy
	err := ctx.ReadResource("aws:emr/managedScalingPolicy:ManagedScalingPolicy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ManagedScalingPolicy resources.
type managedScalingPolicyState struct {
	// ID of the EMR cluster
	ClusterId *string `pulumi:"clusterId"`
	// Configuration block with compute limit settings. Described below.
	ComputeLimits []ManagedScalingPolicyComputeLimit `pulumi:"computeLimits"`
}

type ManagedScalingPolicyState struct {
	// ID of the EMR cluster
	ClusterId pulumi.StringPtrInput
	// Configuration block with compute limit settings. Described below.
	ComputeLimits ManagedScalingPolicyComputeLimitArrayInput
}

func (ManagedScalingPolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*managedScalingPolicyState)(nil)).Elem()
}

type managedScalingPolicyArgs struct {
	// ID of the EMR cluster
	ClusterId string `pulumi:"clusterId"`
	// Configuration block with compute limit settings. Described below.
	ComputeLimits []ManagedScalingPolicyComputeLimit `pulumi:"computeLimits"`
}

// The set of arguments for constructing a ManagedScalingPolicy resource.
type ManagedScalingPolicyArgs struct {
	// ID of the EMR cluster
	ClusterId pulumi.StringInput
	// Configuration block with compute limit settings. Described below.
	ComputeLimits ManagedScalingPolicyComputeLimitArrayInput
}

func (ManagedScalingPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*managedScalingPolicyArgs)(nil)).Elem()
}

type ManagedScalingPolicyInput interface {
	pulumi.Input

	ToManagedScalingPolicyOutput() ManagedScalingPolicyOutput
	ToManagedScalingPolicyOutputWithContext(ctx context.Context) ManagedScalingPolicyOutput
}

func (*ManagedScalingPolicy) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedScalingPolicy)(nil)).Elem()
}

func (i *ManagedScalingPolicy) ToManagedScalingPolicyOutput() ManagedScalingPolicyOutput {
	return i.ToManagedScalingPolicyOutputWithContext(context.Background())
}

func (i *ManagedScalingPolicy) ToManagedScalingPolicyOutputWithContext(ctx context.Context) ManagedScalingPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedScalingPolicyOutput)
}

func (i *ManagedScalingPolicy) ToOutput(ctx context.Context) pulumix.Output[*ManagedScalingPolicy] {
	return pulumix.Output[*ManagedScalingPolicy]{
		OutputState: i.ToManagedScalingPolicyOutputWithContext(ctx).OutputState,
	}
}

// ManagedScalingPolicyArrayInput is an input type that accepts ManagedScalingPolicyArray and ManagedScalingPolicyArrayOutput values.
// You can construct a concrete instance of `ManagedScalingPolicyArrayInput` via:
//
//	ManagedScalingPolicyArray{ ManagedScalingPolicyArgs{...} }
type ManagedScalingPolicyArrayInput interface {
	pulumi.Input

	ToManagedScalingPolicyArrayOutput() ManagedScalingPolicyArrayOutput
	ToManagedScalingPolicyArrayOutputWithContext(context.Context) ManagedScalingPolicyArrayOutput
}

type ManagedScalingPolicyArray []ManagedScalingPolicyInput

func (ManagedScalingPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ManagedScalingPolicy)(nil)).Elem()
}

func (i ManagedScalingPolicyArray) ToManagedScalingPolicyArrayOutput() ManagedScalingPolicyArrayOutput {
	return i.ToManagedScalingPolicyArrayOutputWithContext(context.Background())
}

func (i ManagedScalingPolicyArray) ToManagedScalingPolicyArrayOutputWithContext(ctx context.Context) ManagedScalingPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedScalingPolicyArrayOutput)
}

func (i ManagedScalingPolicyArray) ToOutput(ctx context.Context) pulumix.Output[[]*ManagedScalingPolicy] {
	return pulumix.Output[[]*ManagedScalingPolicy]{
		OutputState: i.ToManagedScalingPolicyArrayOutputWithContext(ctx).OutputState,
	}
}

// ManagedScalingPolicyMapInput is an input type that accepts ManagedScalingPolicyMap and ManagedScalingPolicyMapOutput values.
// You can construct a concrete instance of `ManagedScalingPolicyMapInput` via:
//
//	ManagedScalingPolicyMap{ "key": ManagedScalingPolicyArgs{...} }
type ManagedScalingPolicyMapInput interface {
	pulumi.Input

	ToManagedScalingPolicyMapOutput() ManagedScalingPolicyMapOutput
	ToManagedScalingPolicyMapOutputWithContext(context.Context) ManagedScalingPolicyMapOutput
}

type ManagedScalingPolicyMap map[string]ManagedScalingPolicyInput

func (ManagedScalingPolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ManagedScalingPolicy)(nil)).Elem()
}

func (i ManagedScalingPolicyMap) ToManagedScalingPolicyMapOutput() ManagedScalingPolicyMapOutput {
	return i.ToManagedScalingPolicyMapOutputWithContext(context.Background())
}

func (i ManagedScalingPolicyMap) ToManagedScalingPolicyMapOutputWithContext(ctx context.Context) ManagedScalingPolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedScalingPolicyMapOutput)
}

func (i ManagedScalingPolicyMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*ManagedScalingPolicy] {
	return pulumix.Output[map[string]*ManagedScalingPolicy]{
		OutputState: i.ToManagedScalingPolicyMapOutputWithContext(ctx).OutputState,
	}
}

type ManagedScalingPolicyOutput struct{ *pulumi.OutputState }

func (ManagedScalingPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedScalingPolicy)(nil)).Elem()
}

func (o ManagedScalingPolicyOutput) ToManagedScalingPolicyOutput() ManagedScalingPolicyOutput {
	return o
}

func (o ManagedScalingPolicyOutput) ToManagedScalingPolicyOutputWithContext(ctx context.Context) ManagedScalingPolicyOutput {
	return o
}

func (o ManagedScalingPolicyOutput) ToOutput(ctx context.Context) pulumix.Output[*ManagedScalingPolicy] {
	return pulumix.Output[*ManagedScalingPolicy]{
		OutputState: o.OutputState,
	}
}

// ID of the EMR cluster
func (o ManagedScalingPolicyOutput) ClusterId() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedScalingPolicy) pulumi.StringOutput { return v.ClusterId }).(pulumi.StringOutput)
}

// Configuration block with compute limit settings. Described below.
func (o ManagedScalingPolicyOutput) ComputeLimits() ManagedScalingPolicyComputeLimitArrayOutput {
	return o.ApplyT(func(v *ManagedScalingPolicy) ManagedScalingPolicyComputeLimitArrayOutput { return v.ComputeLimits }).(ManagedScalingPolicyComputeLimitArrayOutput)
}

type ManagedScalingPolicyArrayOutput struct{ *pulumi.OutputState }

func (ManagedScalingPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ManagedScalingPolicy)(nil)).Elem()
}

func (o ManagedScalingPolicyArrayOutput) ToManagedScalingPolicyArrayOutput() ManagedScalingPolicyArrayOutput {
	return o
}

func (o ManagedScalingPolicyArrayOutput) ToManagedScalingPolicyArrayOutputWithContext(ctx context.Context) ManagedScalingPolicyArrayOutput {
	return o
}

func (o ManagedScalingPolicyArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*ManagedScalingPolicy] {
	return pulumix.Output[[]*ManagedScalingPolicy]{
		OutputState: o.OutputState,
	}
}

func (o ManagedScalingPolicyArrayOutput) Index(i pulumi.IntInput) ManagedScalingPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ManagedScalingPolicy {
		return vs[0].([]*ManagedScalingPolicy)[vs[1].(int)]
	}).(ManagedScalingPolicyOutput)
}

type ManagedScalingPolicyMapOutput struct{ *pulumi.OutputState }

func (ManagedScalingPolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ManagedScalingPolicy)(nil)).Elem()
}

func (o ManagedScalingPolicyMapOutput) ToManagedScalingPolicyMapOutput() ManagedScalingPolicyMapOutput {
	return o
}

func (o ManagedScalingPolicyMapOutput) ToManagedScalingPolicyMapOutputWithContext(ctx context.Context) ManagedScalingPolicyMapOutput {
	return o
}

func (o ManagedScalingPolicyMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*ManagedScalingPolicy] {
	return pulumix.Output[map[string]*ManagedScalingPolicy]{
		OutputState: o.OutputState,
	}
}

func (o ManagedScalingPolicyMapOutput) MapIndex(k pulumi.StringInput) ManagedScalingPolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ManagedScalingPolicy {
		return vs[0].(map[string]*ManagedScalingPolicy)[vs[1].(string)]
	}).(ManagedScalingPolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedScalingPolicyInput)(nil)).Elem(), &ManagedScalingPolicy{})
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedScalingPolicyArrayInput)(nil)).Elem(), ManagedScalingPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedScalingPolicyMapInput)(nil)).Elem(), ManagedScalingPolicyMap{})
	pulumi.RegisterOutputType(ManagedScalingPolicyOutput{})
	pulumi.RegisterOutputType(ManagedScalingPolicyArrayOutput{})
	pulumi.RegisterOutputType(ManagedScalingPolicyMapOutput{})
}
