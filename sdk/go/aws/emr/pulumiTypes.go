// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package emr

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

type ClusterBootstrapAction struct {
	// List of command line arguments passed to the JAR file's main function when executed.
	Args []string `pulumi:"args"`
	// The name of the step.
	Name string `pulumi:"name"`
	// Location of the script to run during a bootstrap action. Can be either a location in Amazon S3 or on a local file system
	Path string `pulumi:"path"`
}

// ClusterBootstrapActionInput is an input type that accepts ClusterBootstrapActionArgs and ClusterBootstrapActionOutput values.
// You can construct a concrete instance of `ClusterBootstrapActionInput` via:
//
//          ClusterBootstrapActionArgs{...}
type ClusterBootstrapActionInput interface {
	pulumi.Input

	ToClusterBootstrapActionOutput() ClusterBootstrapActionOutput
	ToClusterBootstrapActionOutputWithContext(context.Context) ClusterBootstrapActionOutput
}

type ClusterBootstrapActionArgs struct {
	// List of command line arguments passed to the JAR file's main function when executed.
	Args pulumi.StringArrayInput `pulumi:"args"`
	// The name of the step.
	Name pulumi.StringInput `pulumi:"name"`
	// Location of the script to run during a bootstrap action. Can be either a location in Amazon S3 or on a local file system
	Path pulumi.StringInput `pulumi:"path"`
}

func (ClusterBootstrapActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterBootstrapAction)(nil)).Elem()
}

func (i ClusterBootstrapActionArgs) ToClusterBootstrapActionOutput() ClusterBootstrapActionOutput {
	return i.ToClusterBootstrapActionOutputWithContext(context.Background())
}

func (i ClusterBootstrapActionArgs) ToClusterBootstrapActionOutputWithContext(ctx context.Context) ClusterBootstrapActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterBootstrapActionOutput)
}

// ClusterBootstrapActionArrayInput is an input type that accepts ClusterBootstrapActionArray and ClusterBootstrapActionArrayOutput values.
// You can construct a concrete instance of `ClusterBootstrapActionArrayInput` via:
//
//          ClusterBootstrapActionArray{ ClusterBootstrapActionArgs{...} }
type ClusterBootstrapActionArrayInput interface {
	pulumi.Input

	ToClusterBootstrapActionArrayOutput() ClusterBootstrapActionArrayOutput
	ToClusterBootstrapActionArrayOutputWithContext(context.Context) ClusterBootstrapActionArrayOutput
}

type ClusterBootstrapActionArray []ClusterBootstrapActionInput

func (ClusterBootstrapActionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterBootstrapAction)(nil)).Elem()
}

func (i ClusterBootstrapActionArray) ToClusterBootstrapActionArrayOutput() ClusterBootstrapActionArrayOutput {
	return i.ToClusterBootstrapActionArrayOutputWithContext(context.Background())
}

func (i ClusterBootstrapActionArray) ToClusterBootstrapActionArrayOutputWithContext(ctx context.Context) ClusterBootstrapActionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterBootstrapActionArrayOutput)
}

type ClusterBootstrapActionOutput struct{ *pulumi.OutputState }

func (ClusterBootstrapActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterBootstrapAction)(nil)).Elem()
}

func (o ClusterBootstrapActionOutput) ToClusterBootstrapActionOutput() ClusterBootstrapActionOutput {
	return o
}

func (o ClusterBootstrapActionOutput) ToClusterBootstrapActionOutputWithContext(ctx context.Context) ClusterBootstrapActionOutput {
	return o
}

// List of command line arguments passed to the JAR file's main function when executed.
func (o ClusterBootstrapActionOutput) Args() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ClusterBootstrapAction) []string { return v.Args }).(pulumi.StringArrayOutput)
}

// The name of the step.
func (o ClusterBootstrapActionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterBootstrapAction) string { return v.Name }).(pulumi.StringOutput)
}

// Location of the script to run during a bootstrap action. Can be either a location in Amazon S3 or on a local file system
func (o ClusterBootstrapActionOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterBootstrapAction) string { return v.Path }).(pulumi.StringOutput)
}

type ClusterBootstrapActionArrayOutput struct{ *pulumi.OutputState }

func (ClusterBootstrapActionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterBootstrapAction)(nil)).Elem()
}

func (o ClusterBootstrapActionArrayOutput) ToClusterBootstrapActionArrayOutput() ClusterBootstrapActionArrayOutput {
	return o
}

func (o ClusterBootstrapActionArrayOutput) ToClusterBootstrapActionArrayOutputWithContext(ctx context.Context) ClusterBootstrapActionArrayOutput {
	return o
}

func (o ClusterBootstrapActionArrayOutput) Index(i pulumi.IntInput) ClusterBootstrapActionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterBootstrapAction {
		return vs[0].([]ClusterBootstrapAction)[vs[1].(int)]
	}).(ClusterBootstrapActionOutput)
}

type ClusterCoreInstanceGroup struct {
	// The autoscaling policy document. This is a JSON formatted string. See [EMR Auto Scaling](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-automatic-scaling.html)
	AutoscalingPolicy *string `pulumi:"autoscalingPolicy"`
	// Bid price for each EC2 instance in the instance group, expressed in USD. By setting this attribute, the instance group is being declared as a Spot Instance, and will implicitly create a Spot request. Leave this blank to use On-Demand Instances.
	BidPrice *string `pulumi:"bidPrice"`
	// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
	EbsConfigs []ClusterCoreInstanceGroupEbsConfig `pulumi:"ebsConfigs"`
	// The ID of the EMR Cluster
	Id *string `pulumi:"id"`
	// Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have `map public IP on launch` enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
	InstanceCount *int `pulumi:"instanceCount"`
	// EC2 instance type for all instances in the instance group.
	InstanceType string `pulumi:"instanceType"`
	// The name of the step.
	Name *string `pulumi:"name"`
}

// ClusterCoreInstanceGroupInput is an input type that accepts ClusterCoreInstanceGroupArgs and ClusterCoreInstanceGroupOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceGroupInput` via:
//
//          ClusterCoreInstanceGroupArgs{...}
type ClusterCoreInstanceGroupInput interface {
	pulumi.Input

	ToClusterCoreInstanceGroupOutput() ClusterCoreInstanceGroupOutput
	ToClusterCoreInstanceGroupOutputWithContext(context.Context) ClusterCoreInstanceGroupOutput
}

type ClusterCoreInstanceGroupArgs struct {
	// The autoscaling policy document. This is a JSON formatted string. See [EMR Auto Scaling](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-automatic-scaling.html)
	AutoscalingPolicy pulumi.StringPtrInput `pulumi:"autoscalingPolicy"`
	// Bid price for each EC2 instance in the instance group, expressed in USD. By setting this attribute, the instance group is being declared as a Spot Instance, and will implicitly create a Spot request. Leave this blank to use On-Demand Instances.
	BidPrice pulumi.StringPtrInput `pulumi:"bidPrice"`
	// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
	EbsConfigs ClusterCoreInstanceGroupEbsConfigArrayInput `pulumi:"ebsConfigs"`
	// The ID of the EMR Cluster
	Id pulumi.StringPtrInput `pulumi:"id"`
	// Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have `map public IP on launch` enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
	InstanceCount pulumi.IntPtrInput `pulumi:"instanceCount"`
	// EC2 instance type for all instances in the instance group.
	InstanceType pulumi.StringInput `pulumi:"instanceType"`
	// The name of the step.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ClusterCoreInstanceGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceGroup)(nil)).Elem()
}

func (i ClusterCoreInstanceGroupArgs) ToClusterCoreInstanceGroupOutput() ClusterCoreInstanceGroupOutput {
	return i.ToClusterCoreInstanceGroupOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceGroupArgs) ToClusterCoreInstanceGroupOutputWithContext(ctx context.Context) ClusterCoreInstanceGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceGroupOutput)
}

func (i ClusterCoreInstanceGroupArgs) ToClusterCoreInstanceGroupPtrOutput() ClusterCoreInstanceGroupPtrOutput {
	return i.ToClusterCoreInstanceGroupPtrOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceGroupArgs) ToClusterCoreInstanceGroupPtrOutputWithContext(ctx context.Context) ClusterCoreInstanceGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceGroupOutput).ToClusterCoreInstanceGroupPtrOutputWithContext(ctx)
}

// ClusterCoreInstanceGroupPtrInput is an input type that accepts ClusterCoreInstanceGroupArgs, ClusterCoreInstanceGroupPtr and ClusterCoreInstanceGroupPtrOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceGroupPtrInput` via:
//
//          ClusterCoreInstanceGroupArgs{...}
//
//  or:
//
//          nil
type ClusterCoreInstanceGroupPtrInput interface {
	pulumi.Input

	ToClusterCoreInstanceGroupPtrOutput() ClusterCoreInstanceGroupPtrOutput
	ToClusterCoreInstanceGroupPtrOutputWithContext(context.Context) ClusterCoreInstanceGroupPtrOutput
}

type clusterCoreInstanceGroupPtrType ClusterCoreInstanceGroupArgs

func ClusterCoreInstanceGroupPtr(v *ClusterCoreInstanceGroupArgs) ClusterCoreInstanceGroupPtrInput {
	return (*clusterCoreInstanceGroupPtrType)(v)
}

func (*clusterCoreInstanceGroupPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterCoreInstanceGroup)(nil)).Elem()
}

func (i *clusterCoreInstanceGroupPtrType) ToClusterCoreInstanceGroupPtrOutput() ClusterCoreInstanceGroupPtrOutput {
	return i.ToClusterCoreInstanceGroupPtrOutputWithContext(context.Background())
}

func (i *clusterCoreInstanceGroupPtrType) ToClusterCoreInstanceGroupPtrOutputWithContext(ctx context.Context) ClusterCoreInstanceGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceGroupPtrOutput)
}

type ClusterCoreInstanceGroupOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceGroup)(nil)).Elem()
}

func (o ClusterCoreInstanceGroupOutput) ToClusterCoreInstanceGroupOutput() ClusterCoreInstanceGroupOutput {
	return o
}

func (o ClusterCoreInstanceGroupOutput) ToClusterCoreInstanceGroupOutputWithContext(ctx context.Context) ClusterCoreInstanceGroupOutput {
	return o
}

func (o ClusterCoreInstanceGroupOutput) ToClusterCoreInstanceGroupPtrOutput() ClusterCoreInstanceGroupPtrOutput {
	return o.ToClusterCoreInstanceGroupPtrOutputWithContext(context.Background())
}

func (o ClusterCoreInstanceGroupOutput) ToClusterCoreInstanceGroupPtrOutputWithContext(ctx context.Context) ClusterCoreInstanceGroupPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroup) *ClusterCoreInstanceGroup {
		return &v
	}).(ClusterCoreInstanceGroupPtrOutput)
}

// The autoscaling policy document. This is a JSON formatted string. See [EMR Auto Scaling](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-automatic-scaling.html)
func (o ClusterCoreInstanceGroupOutput) AutoscalingPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroup) *string { return v.AutoscalingPolicy }).(pulumi.StringPtrOutput)
}

// Bid price for each EC2 instance in the instance group, expressed in USD. By setting this attribute, the instance group is being declared as a Spot Instance, and will implicitly create a Spot request. Leave this blank to use On-Demand Instances.
func (o ClusterCoreInstanceGroupOutput) BidPrice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroup) *string { return v.BidPrice }).(pulumi.StringPtrOutput)
}

// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
func (o ClusterCoreInstanceGroupOutput) EbsConfigs() ClusterCoreInstanceGroupEbsConfigArrayOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroup) []ClusterCoreInstanceGroupEbsConfig { return v.EbsConfigs }).(ClusterCoreInstanceGroupEbsConfigArrayOutput)
}

// The ID of the EMR Cluster
func (o ClusterCoreInstanceGroupOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroup) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have `map public IP on launch` enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
func (o ClusterCoreInstanceGroupOutput) InstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroup) *int { return v.InstanceCount }).(pulumi.IntPtrOutput)
}

// EC2 instance type for all instances in the instance group.
func (o ClusterCoreInstanceGroupOutput) InstanceType() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroup) string { return v.InstanceType }).(pulumi.StringOutput)
}

// The name of the step.
func (o ClusterCoreInstanceGroupOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroup) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ClusterCoreInstanceGroupPtrOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceGroupPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterCoreInstanceGroup)(nil)).Elem()
}

func (o ClusterCoreInstanceGroupPtrOutput) ToClusterCoreInstanceGroupPtrOutput() ClusterCoreInstanceGroupPtrOutput {
	return o
}

func (o ClusterCoreInstanceGroupPtrOutput) ToClusterCoreInstanceGroupPtrOutputWithContext(ctx context.Context) ClusterCoreInstanceGroupPtrOutput {
	return o
}

func (o ClusterCoreInstanceGroupPtrOutput) Elem() ClusterCoreInstanceGroupOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceGroup) ClusterCoreInstanceGroup { return *v }).(ClusterCoreInstanceGroupOutput)
}

// The autoscaling policy document. This is a JSON formatted string. See [EMR Auto Scaling](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-automatic-scaling.html)
func (o ClusterCoreInstanceGroupPtrOutput) AutoscalingPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceGroup) *string {
		if v == nil {
			return nil
		}
		return v.AutoscalingPolicy
	}).(pulumi.StringPtrOutput)
}

// Bid price for each EC2 instance in the instance group, expressed in USD. By setting this attribute, the instance group is being declared as a Spot Instance, and will implicitly create a Spot request. Leave this blank to use On-Demand Instances.
func (o ClusterCoreInstanceGroupPtrOutput) BidPrice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceGroup) *string {
		if v == nil {
			return nil
		}
		return v.BidPrice
	}).(pulumi.StringPtrOutput)
}

// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
func (o ClusterCoreInstanceGroupPtrOutput) EbsConfigs() ClusterCoreInstanceGroupEbsConfigArrayOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceGroup) []ClusterCoreInstanceGroupEbsConfig {
		if v == nil {
			return nil
		}
		return v.EbsConfigs
	}).(ClusterCoreInstanceGroupEbsConfigArrayOutput)
}

// The ID of the EMR Cluster
func (o ClusterCoreInstanceGroupPtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceGroup) *string {
		if v == nil {
			return nil
		}
		return v.Id
	}).(pulumi.StringPtrOutput)
}

// Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have `map public IP on launch` enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
func (o ClusterCoreInstanceGroupPtrOutput) InstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceGroup) *int {
		if v == nil {
			return nil
		}
		return v.InstanceCount
	}).(pulumi.IntPtrOutput)
}

// EC2 instance type for all instances in the instance group.
func (o ClusterCoreInstanceGroupPtrOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceGroup) *string {
		if v == nil {
			return nil
		}
		return &v.InstanceType
	}).(pulumi.StringPtrOutput)
}

// The name of the step.
func (o ClusterCoreInstanceGroupPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceGroup) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

type ClusterCoreInstanceGroupEbsConfig struct {
	// The number of I/O operations per second (IOPS) that the volume supports
	Iops *int `pulumi:"iops"`
	// The volume size, in gibibytes (GiB).
	Size int `pulumi:"size"`
	// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
	Type string `pulumi:"type"`
	// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
	VolumesPerInstance *int `pulumi:"volumesPerInstance"`
}

// ClusterCoreInstanceGroupEbsConfigInput is an input type that accepts ClusterCoreInstanceGroupEbsConfigArgs and ClusterCoreInstanceGroupEbsConfigOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceGroupEbsConfigInput` via:
//
//          ClusterCoreInstanceGroupEbsConfigArgs{...}
type ClusterCoreInstanceGroupEbsConfigInput interface {
	pulumi.Input

	ToClusterCoreInstanceGroupEbsConfigOutput() ClusterCoreInstanceGroupEbsConfigOutput
	ToClusterCoreInstanceGroupEbsConfigOutputWithContext(context.Context) ClusterCoreInstanceGroupEbsConfigOutput
}

type ClusterCoreInstanceGroupEbsConfigArgs struct {
	// The number of I/O operations per second (IOPS) that the volume supports
	Iops pulumi.IntPtrInput `pulumi:"iops"`
	// The volume size, in gibibytes (GiB).
	Size pulumi.IntInput `pulumi:"size"`
	// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
	Type pulumi.StringInput `pulumi:"type"`
	// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
	VolumesPerInstance pulumi.IntPtrInput `pulumi:"volumesPerInstance"`
}

func (ClusterCoreInstanceGroupEbsConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceGroupEbsConfig)(nil)).Elem()
}

func (i ClusterCoreInstanceGroupEbsConfigArgs) ToClusterCoreInstanceGroupEbsConfigOutput() ClusterCoreInstanceGroupEbsConfigOutput {
	return i.ToClusterCoreInstanceGroupEbsConfigOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceGroupEbsConfigArgs) ToClusterCoreInstanceGroupEbsConfigOutputWithContext(ctx context.Context) ClusterCoreInstanceGroupEbsConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceGroupEbsConfigOutput)
}

// ClusterCoreInstanceGroupEbsConfigArrayInput is an input type that accepts ClusterCoreInstanceGroupEbsConfigArray and ClusterCoreInstanceGroupEbsConfigArrayOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceGroupEbsConfigArrayInput` via:
//
//          ClusterCoreInstanceGroupEbsConfigArray{ ClusterCoreInstanceGroupEbsConfigArgs{...} }
type ClusterCoreInstanceGroupEbsConfigArrayInput interface {
	pulumi.Input

	ToClusterCoreInstanceGroupEbsConfigArrayOutput() ClusterCoreInstanceGroupEbsConfigArrayOutput
	ToClusterCoreInstanceGroupEbsConfigArrayOutputWithContext(context.Context) ClusterCoreInstanceGroupEbsConfigArrayOutput
}

type ClusterCoreInstanceGroupEbsConfigArray []ClusterCoreInstanceGroupEbsConfigInput

func (ClusterCoreInstanceGroupEbsConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterCoreInstanceGroupEbsConfig)(nil)).Elem()
}

func (i ClusterCoreInstanceGroupEbsConfigArray) ToClusterCoreInstanceGroupEbsConfigArrayOutput() ClusterCoreInstanceGroupEbsConfigArrayOutput {
	return i.ToClusterCoreInstanceGroupEbsConfigArrayOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceGroupEbsConfigArray) ToClusterCoreInstanceGroupEbsConfigArrayOutputWithContext(ctx context.Context) ClusterCoreInstanceGroupEbsConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceGroupEbsConfigArrayOutput)
}

type ClusterCoreInstanceGroupEbsConfigOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceGroupEbsConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceGroupEbsConfig)(nil)).Elem()
}

func (o ClusterCoreInstanceGroupEbsConfigOutput) ToClusterCoreInstanceGroupEbsConfigOutput() ClusterCoreInstanceGroupEbsConfigOutput {
	return o
}

func (o ClusterCoreInstanceGroupEbsConfigOutput) ToClusterCoreInstanceGroupEbsConfigOutputWithContext(ctx context.Context) ClusterCoreInstanceGroupEbsConfigOutput {
	return o
}

// The number of I/O operations per second (IOPS) that the volume supports
func (o ClusterCoreInstanceGroupEbsConfigOutput) Iops() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroupEbsConfig) *int { return v.Iops }).(pulumi.IntPtrOutput)
}

// The volume size, in gibibytes (GiB).
func (o ClusterCoreInstanceGroupEbsConfigOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroupEbsConfig) int { return v.Size }).(pulumi.IntOutput)
}

// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
func (o ClusterCoreInstanceGroupEbsConfigOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroupEbsConfig) string { return v.Type }).(pulumi.StringOutput)
}

// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
func (o ClusterCoreInstanceGroupEbsConfigOutput) VolumesPerInstance() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroupEbsConfig) *int { return v.VolumesPerInstance }).(pulumi.IntPtrOutput)
}

type ClusterCoreInstanceGroupEbsConfigArrayOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceGroupEbsConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterCoreInstanceGroupEbsConfig)(nil)).Elem()
}

func (o ClusterCoreInstanceGroupEbsConfigArrayOutput) ToClusterCoreInstanceGroupEbsConfigArrayOutput() ClusterCoreInstanceGroupEbsConfigArrayOutput {
	return o
}

func (o ClusterCoreInstanceGroupEbsConfigArrayOutput) ToClusterCoreInstanceGroupEbsConfigArrayOutputWithContext(ctx context.Context) ClusterCoreInstanceGroupEbsConfigArrayOutput {
	return o
}

func (o ClusterCoreInstanceGroupEbsConfigArrayOutput) Index(i pulumi.IntInput) ClusterCoreInstanceGroupEbsConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterCoreInstanceGroupEbsConfig {
		return vs[0].([]ClusterCoreInstanceGroupEbsConfig)[vs[1].(int)]
	}).(ClusterCoreInstanceGroupEbsConfigOutput)
}

type ClusterEc2Attributes struct {
	// String containing a comma separated list of additional Amazon EC2 security group IDs for the master node
	AdditionalMasterSecurityGroups *string `pulumi:"additionalMasterSecurityGroups"`
	// String containing a comma separated list of additional Amazon EC2 security group IDs for the slave nodes as a comma separated string
	AdditionalSlaveSecurityGroups *string `pulumi:"additionalSlaveSecurityGroups"`
	// Identifier of the Amazon EC2 EMR-Managed security group for the master node
	EmrManagedMasterSecurityGroup *string `pulumi:"emrManagedMasterSecurityGroup"`
	// Identifier of the Amazon EC2 EMR-Managed security group for the slave nodes
	EmrManagedSlaveSecurityGroup *string `pulumi:"emrManagedSlaveSecurityGroup"`
	// Instance Profile for EC2 instances of the cluster assume this role
	InstanceProfile string `pulumi:"instanceProfile"`
	// Amazon EC2 key pair that can be used to ssh to the master node as the user called `hadoop`
	KeyName *string `pulumi:"keyName"`
	// Identifier of the Amazon EC2 service-access security group - required when the cluster runs on a private subnet
	ServiceAccessSecurityGroup *string `pulumi:"serviceAccessSecurityGroup"`
	// VPC subnet id where you want the job flow to launch. Cannot specify the `cc1.4xlarge` instance type for nodes of a job flow launched in a Amazon VPC
	SubnetId *string `pulumi:"subnetId"`
}

// ClusterEc2AttributesInput is an input type that accepts ClusterEc2AttributesArgs and ClusterEc2AttributesOutput values.
// You can construct a concrete instance of `ClusterEc2AttributesInput` via:
//
//          ClusterEc2AttributesArgs{...}
type ClusterEc2AttributesInput interface {
	pulumi.Input

	ToClusterEc2AttributesOutput() ClusterEc2AttributesOutput
	ToClusterEc2AttributesOutputWithContext(context.Context) ClusterEc2AttributesOutput
}

type ClusterEc2AttributesArgs struct {
	// String containing a comma separated list of additional Amazon EC2 security group IDs for the master node
	AdditionalMasterSecurityGroups pulumi.StringPtrInput `pulumi:"additionalMasterSecurityGroups"`
	// String containing a comma separated list of additional Amazon EC2 security group IDs for the slave nodes as a comma separated string
	AdditionalSlaveSecurityGroups pulumi.StringPtrInput `pulumi:"additionalSlaveSecurityGroups"`
	// Identifier of the Amazon EC2 EMR-Managed security group for the master node
	EmrManagedMasterSecurityGroup pulumi.StringPtrInput `pulumi:"emrManagedMasterSecurityGroup"`
	// Identifier of the Amazon EC2 EMR-Managed security group for the slave nodes
	EmrManagedSlaveSecurityGroup pulumi.StringPtrInput `pulumi:"emrManagedSlaveSecurityGroup"`
	// Instance Profile for EC2 instances of the cluster assume this role
	InstanceProfile pulumi.StringInput `pulumi:"instanceProfile"`
	// Amazon EC2 key pair that can be used to ssh to the master node as the user called `hadoop`
	KeyName pulumi.StringPtrInput `pulumi:"keyName"`
	// Identifier of the Amazon EC2 service-access security group - required when the cluster runs on a private subnet
	ServiceAccessSecurityGroup pulumi.StringPtrInput `pulumi:"serviceAccessSecurityGroup"`
	// VPC subnet id where you want the job flow to launch. Cannot specify the `cc1.4xlarge` instance type for nodes of a job flow launched in a Amazon VPC
	SubnetId pulumi.StringPtrInput `pulumi:"subnetId"`
}

func (ClusterEc2AttributesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterEc2Attributes)(nil)).Elem()
}

func (i ClusterEc2AttributesArgs) ToClusterEc2AttributesOutput() ClusterEc2AttributesOutput {
	return i.ToClusterEc2AttributesOutputWithContext(context.Background())
}

func (i ClusterEc2AttributesArgs) ToClusterEc2AttributesOutputWithContext(ctx context.Context) ClusterEc2AttributesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterEc2AttributesOutput)
}

func (i ClusterEc2AttributesArgs) ToClusterEc2AttributesPtrOutput() ClusterEc2AttributesPtrOutput {
	return i.ToClusterEc2AttributesPtrOutputWithContext(context.Background())
}

func (i ClusterEc2AttributesArgs) ToClusterEc2AttributesPtrOutputWithContext(ctx context.Context) ClusterEc2AttributesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterEc2AttributesOutput).ToClusterEc2AttributesPtrOutputWithContext(ctx)
}

// ClusterEc2AttributesPtrInput is an input type that accepts ClusterEc2AttributesArgs, ClusterEc2AttributesPtr and ClusterEc2AttributesPtrOutput values.
// You can construct a concrete instance of `ClusterEc2AttributesPtrInput` via:
//
//          ClusterEc2AttributesArgs{...}
//
//  or:
//
//          nil
type ClusterEc2AttributesPtrInput interface {
	pulumi.Input

	ToClusterEc2AttributesPtrOutput() ClusterEc2AttributesPtrOutput
	ToClusterEc2AttributesPtrOutputWithContext(context.Context) ClusterEc2AttributesPtrOutput
}

type clusterEc2AttributesPtrType ClusterEc2AttributesArgs

func ClusterEc2AttributesPtr(v *ClusterEc2AttributesArgs) ClusterEc2AttributesPtrInput {
	return (*clusterEc2AttributesPtrType)(v)
}

func (*clusterEc2AttributesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterEc2Attributes)(nil)).Elem()
}

func (i *clusterEc2AttributesPtrType) ToClusterEc2AttributesPtrOutput() ClusterEc2AttributesPtrOutput {
	return i.ToClusterEc2AttributesPtrOutputWithContext(context.Background())
}

func (i *clusterEc2AttributesPtrType) ToClusterEc2AttributesPtrOutputWithContext(ctx context.Context) ClusterEc2AttributesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterEc2AttributesPtrOutput)
}

type ClusterEc2AttributesOutput struct{ *pulumi.OutputState }

func (ClusterEc2AttributesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterEc2Attributes)(nil)).Elem()
}

func (o ClusterEc2AttributesOutput) ToClusterEc2AttributesOutput() ClusterEc2AttributesOutput {
	return o
}

func (o ClusterEc2AttributesOutput) ToClusterEc2AttributesOutputWithContext(ctx context.Context) ClusterEc2AttributesOutput {
	return o
}

func (o ClusterEc2AttributesOutput) ToClusterEc2AttributesPtrOutput() ClusterEc2AttributesPtrOutput {
	return o.ToClusterEc2AttributesPtrOutputWithContext(context.Background())
}

func (o ClusterEc2AttributesOutput) ToClusterEc2AttributesPtrOutputWithContext(ctx context.Context) ClusterEc2AttributesPtrOutput {
	return o.ApplyT(func(v ClusterEc2Attributes) *ClusterEc2Attributes {
		return &v
	}).(ClusterEc2AttributesPtrOutput)
}

// String containing a comma separated list of additional Amazon EC2 security group IDs for the master node
func (o ClusterEc2AttributesOutput) AdditionalMasterSecurityGroups() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterEc2Attributes) *string { return v.AdditionalMasterSecurityGroups }).(pulumi.StringPtrOutput)
}

// String containing a comma separated list of additional Amazon EC2 security group IDs for the slave nodes as a comma separated string
func (o ClusterEc2AttributesOutput) AdditionalSlaveSecurityGroups() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterEc2Attributes) *string { return v.AdditionalSlaveSecurityGroups }).(pulumi.StringPtrOutput)
}

// Identifier of the Amazon EC2 EMR-Managed security group for the master node
func (o ClusterEc2AttributesOutput) EmrManagedMasterSecurityGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterEc2Attributes) *string { return v.EmrManagedMasterSecurityGroup }).(pulumi.StringPtrOutput)
}

// Identifier of the Amazon EC2 EMR-Managed security group for the slave nodes
func (o ClusterEc2AttributesOutput) EmrManagedSlaveSecurityGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterEc2Attributes) *string { return v.EmrManagedSlaveSecurityGroup }).(pulumi.StringPtrOutput)
}

// Instance Profile for EC2 instances of the cluster assume this role
func (o ClusterEc2AttributesOutput) InstanceProfile() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterEc2Attributes) string { return v.InstanceProfile }).(pulumi.StringOutput)
}

// Amazon EC2 key pair that can be used to ssh to the master node as the user called `hadoop`
func (o ClusterEc2AttributesOutput) KeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterEc2Attributes) *string { return v.KeyName }).(pulumi.StringPtrOutput)
}

// Identifier of the Amazon EC2 service-access security group - required when the cluster runs on a private subnet
func (o ClusterEc2AttributesOutput) ServiceAccessSecurityGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterEc2Attributes) *string { return v.ServiceAccessSecurityGroup }).(pulumi.StringPtrOutput)
}

// VPC subnet id where you want the job flow to launch. Cannot specify the `cc1.4xlarge` instance type for nodes of a job flow launched in a Amazon VPC
func (o ClusterEc2AttributesOutput) SubnetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterEc2Attributes) *string { return v.SubnetId }).(pulumi.StringPtrOutput)
}

type ClusterEc2AttributesPtrOutput struct{ *pulumi.OutputState }

func (ClusterEc2AttributesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterEc2Attributes)(nil)).Elem()
}

func (o ClusterEc2AttributesPtrOutput) ToClusterEc2AttributesPtrOutput() ClusterEc2AttributesPtrOutput {
	return o
}

func (o ClusterEc2AttributesPtrOutput) ToClusterEc2AttributesPtrOutputWithContext(ctx context.Context) ClusterEc2AttributesPtrOutput {
	return o
}

func (o ClusterEc2AttributesPtrOutput) Elem() ClusterEc2AttributesOutput {
	return o.ApplyT(func(v *ClusterEc2Attributes) ClusterEc2Attributes { return *v }).(ClusterEc2AttributesOutput)
}

// String containing a comma separated list of additional Amazon EC2 security group IDs for the master node
func (o ClusterEc2AttributesPtrOutput) AdditionalMasterSecurityGroups() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterEc2Attributes) *string {
		if v == nil {
			return nil
		}
		return v.AdditionalMasterSecurityGroups
	}).(pulumi.StringPtrOutput)
}

// String containing a comma separated list of additional Amazon EC2 security group IDs for the slave nodes as a comma separated string
func (o ClusterEc2AttributesPtrOutput) AdditionalSlaveSecurityGroups() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterEc2Attributes) *string {
		if v == nil {
			return nil
		}
		return v.AdditionalSlaveSecurityGroups
	}).(pulumi.StringPtrOutput)
}

// Identifier of the Amazon EC2 EMR-Managed security group for the master node
func (o ClusterEc2AttributesPtrOutput) EmrManagedMasterSecurityGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterEc2Attributes) *string {
		if v == nil {
			return nil
		}
		return v.EmrManagedMasterSecurityGroup
	}).(pulumi.StringPtrOutput)
}

// Identifier of the Amazon EC2 EMR-Managed security group for the slave nodes
func (o ClusterEc2AttributesPtrOutput) EmrManagedSlaveSecurityGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterEc2Attributes) *string {
		if v == nil {
			return nil
		}
		return v.EmrManagedSlaveSecurityGroup
	}).(pulumi.StringPtrOutput)
}

// Instance Profile for EC2 instances of the cluster assume this role
func (o ClusterEc2AttributesPtrOutput) InstanceProfile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterEc2Attributes) *string {
		if v == nil {
			return nil
		}
		return &v.InstanceProfile
	}).(pulumi.StringPtrOutput)
}

// Amazon EC2 key pair that can be used to ssh to the master node as the user called `hadoop`
func (o ClusterEc2AttributesPtrOutput) KeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterEc2Attributes) *string {
		if v == nil {
			return nil
		}
		return v.KeyName
	}).(pulumi.StringPtrOutput)
}

// Identifier of the Amazon EC2 service-access security group - required when the cluster runs on a private subnet
func (o ClusterEc2AttributesPtrOutput) ServiceAccessSecurityGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterEc2Attributes) *string {
		if v == nil {
			return nil
		}
		return v.ServiceAccessSecurityGroup
	}).(pulumi.StringPtrOutput)
}

// VPC subnet id where you want the job flow to launch. Cannot specify the `cc1.4xlarge` instance type for nodes of a job flow launched in a Amazon VPC
func (o ClusterEc2AttributesPtrOutput) SubnetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterEc2Attributes) *string {
		if v == nil {
			return nil
		}
		return v.SubnetId
	}).(pulumi.StringPtrOutput)
}

type ClusterInstanceGroup struct {
	// The autoscaling policy document. This is a JSON formatted string. See [EMR Auto Scaling](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-automatic-scaling.html)
	AutoscalingPolicy *string `pulumi:"autoscalingPolicy"`
	// Bid price for each EC2 instance in the instance group, expressed in USD. By setting this attribute, the instance group is being declared as a Spot Instance, and will implicitly create a Spot request. Leave this blank to use On-Demand Instances.
	BidPrice *string `pulumi:"bidPrice"`
	// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
	EbsConfigs []ClusterInstanceGroupEbsConfig `pulumi:"ebsConfigs"`
	// The ID of the EMR Cluster
	Id *string `pulumi:"id"`
	// Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have `map public IP on launch` enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
	InstanceCount *int `pulumi:"instanceCount"`
	// The role of the instance group in the cluster. Valid values are: `MASTER`, `CORE`, and `TASK`.
	InstanceRole string `pulumi:"instanceRole"`
	// EC2 instance type for all instances in the instance group.
	InstanceType string `pulumi:"instanceType"`
	// The name of the step.
	Name *string `pulumi:"name"`
}

// ClusterInstanceGroupInput is an input type that accepts ClusterInstanceGroupArgs and ClusterInstanceGroupOutput values.
// You can construct a concrete instance of `ClusterInstanceGroupInput` via:
//
//          ClusterInstanceGroupArgs{...}
type ClusterInstanceGroupInput interface {
	pulumi.Input

	ToClusterInstanceGroupOutput() ClusterInstanceGroupOutput
	ToClusterInstanceGroupOutputWithContext(context.Context) ClusterInstanceGroupOutput
}

type ClusterInstanceGroupArgs struct {
	// The autoscaling policy document. This is a JSON formatted string. See [EMR Auto Scaling](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-automatic-scaling.html)
	AutoscalingPolicy pulumi.StringPtrInput `pulumi:"autoscalingPolicy"`
	// Bid price for each EC2 instance in the instance group, expressed in USD. By setting this attribute, the instance group is being declared as a Spot Instance, and will implicitly create a Spot request. Leave this blank to use On-Demand Instances.
	BidPrice pulumi.StringPtrInput `pulumi:"bidPrice"`
	// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
	EbsConfigs ClusterInstanceGroupEbsConfigArrayInput `pulumi:"ebsConfigs"`
	// The ID of the EMR Cluster
	Id pulumi.StringPtrInput `pulumi:"id"`
	// Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have `map public IP on launch` enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
	InstanceCount pulumi.IntPtrInput `pulumi:"instanceCount"`
	// The role of the instance group in the cluster. Valid values are: `MASTER`, `CORE`, and `TASK`.
	InstanceRole pulumi.StringInput `pulumi:"instanceRole"`
	// EC2 instance type for all instances in the instance group.
	InstanceType pulumi.StringInput `pulumi:"instanceType"`
	// The name of the step.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ClusterInstanceGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterInstanceGroup)(nil)).Elem()
}

func (i ClusterInstanceGroupArgs) ToClusterInstanceGroupOutput() ClusterInstanceGroupOutput {
	return i.ToClusterInstanceGroupOutputWithContext(context.Background())
}

func (i ClusterInstanceGroupArgs) ToClusterInstanceGroupOutputWithContext(ctx context.Context) ClusterInstanceGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterInstanceGroupOutput)
}

// ClusterInstanceGroupArrayInput is an input type that accepts ClusterInstanceGroupArray and ClusterInstanceGroupArrayOutput values.
// You can construct a concrete instance of `ClusterInstanceGroupArrayInput` via:
//
//          ClusterInstanceGroupArray{ ClusterInstanceGroupArgs{...} }
type ClusterInstanceGroupArrayInput interface {
	pulumi.Input

	ToClusterInstanceGroupArrayOutput() ClusterInstanceGroupArrayOutput
	ToClusterInstanceGroupArrayOutputWithContext(context.Context) ClusterInstanceGroupArrayOutput
}

type ClusterInstanceGroupArray []ClusterInstanceGroupInput

func (ClusterInstanceGroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterInstanceGroup)(nil)).Elem()
}

func (i ClusterInstanceGroupArray) ToClusterInstanceGroupArrayOutput() ClusterInstanceGroupArrayOutput {
	return i.ToClusterInstanceGroupArrayOutputWithContext(context.Background())
}

func (i ClusterInstanceGroupArray) ToClusterInstanceGroupArrayOutputWithContext(ctx context.Context) ClusterInstanceGroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterInstanceGroupArrayOutput)
}

type ClusterInstanceGroupOutput struct{ *pulumi.OutputState }

func (ClusterInstanceGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterInstanceGroup)(nil)).Elem()
}

func (o ClusterInstanceGroupOutput) ToClusterInstanceGroupOutput() ClusterInstanceGroupOutput {
	return o
}

func (o ClusterInstanceGroupOutput) ToClusterInstanceGroupOutputWithContext(ctx context.Context) ClusterInstanceGroupOutput {
	return o
}

// The autoscaling policy document. This is a JSON formatted string. See [EMR Auto Scaling](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-automatic-scaling.html)
func (o ClusterInstanceGroupOutput) AutoscalingPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterInstanceGroup) *string { return v.AutoscalingPolicy }).(pulumi.StringPtrOutput)
}

// Bid price for each EC2 instance in the instance group, expressed in USD. By setting this attribute, the instance group is being declared as a Spot Instance, and will implicitly create a Spot request. Leave this blank to use On-Demand Instances.
func (o ClusterInstanceGroupOutput) BidPrice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterInstanceGroup) *string { return v.BidPrice }).(pulumi.StringPtrOutput)
}

// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
func (o ClusterInstanceGroupOutput) EbsConfigs() ClusterInstanceGroupEbsConfigArrayOutput {
	return o.ApplyT(func(v ClusterInstanceGroup) []ClusterInstanceGroupEbsConfig { return v.EbsConfigs }).(ClusterInstanceGroupEbsConfigArrayOutput)
}

// The ID of the EMR Cluster
func (o ClusterInstanceGroupOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterInstanceGroup) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have `map public IP on launch` enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
func (o ClusterInstanceGroupOutput) InstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterInstanceGroup) *int { return v.InstanceCount }).(pulumi.IntPtrOutput)
}

// The role of the instance group in the cluster. Valid values are: `MASTER`, `CORE`, and `TASK`.
func (o ClusterInstanceGroupOutput) InstanceRole() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterInstanceGroup) string { return v.InstanceRole }).(pulumi.StringOutput)
}

// EC2 instance type for all instances in the instance group.
func (o ClusterInstanceGroupOutput) InstanceType() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterInstanceGroup) string { return v.InstanceType }).(pulumi.StringOutput)
}

// The name of the step.
func (o ClusterInstanceGroupOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterInstanceGroup) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ClusterInstanceGroupArrayOutput struct{ *pulumi.OutputState }

func (ClusterInstanceGroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterInstanceGroup)(nil)).Elem()
}

func (o ClusterInstanceGroupArrayOutput) ToClusterInstanceGroupArrayOutput() ClusterInstanceGroupArrayOutput {
	return o
}

func (o ClusterInstanceGroupArrayOutput) ToClusterInstanceGroupArrayOutputWithContext(ctx context.Context) ClusterInstanceGroupArrayOutput {
	return o
}

func (o ClusterInstanceGroupArrayOutput) Index(i pulumi.IntInput) ClusterInstanceGroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterInstanceGroup {
		return vs[0].([]ClusterInstanceGroup)[vs[1].(int)]
	}).(ClusterInstanceGroupOutput)
}

type ClusterInstanceGroupEbsConfig struct {
	// The number of I/O operations per second (IOPS) that the volume supports
	Iops *int `pulumi:"iops"`
	// The volume size, in gibibytes (GiB).
	Size int `pulumi:"size"`
	// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
	Type string `pulumi:"type"`
	// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
	VolumesPerInstance *int `pulumi:"volumesPerInstance"`
}

// ClusterInstanceGroupEbsConfigInput is an input type that accepts ClusterInstanceGroupEbsConfigArgs and ClusterInstanceGroupEbsConfigOutput values.
// You can construct a concrete instance of `ClusterInstanceGroupEbsConfigInput` via:
//
//          ClusterInstanceGroupEbsConfigArgs{...}
type ClusterInstanceGroupEbsConfigInput interface {
	pulumi.Input

	ToClusterInstanceGroupEbsConfigOutput() ClusterInstanceGroupEbsConfigOutput
	ToClusterInstanceGroupEbsConfigOutputWithContext(context.Context) ClusterInstanceGroupEbsConfigOutput
}

type ClusterInstanceGroupEbsConfigArgs struct {
	// The number of I/O operations per second (IOPS) that the volume supports
	Iops pulumi.IntPtrInput `pulumi:"iops"`
	// The volume size, in gibibytes (GiB).
	Size pulumi.IntInput `pulumi:"size"`
	// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
	Type pulumi.StringInput `pulumi:"type"`
	// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
	VolumesPerInstance pulumi.IntPtrInput `pulumi:"volumesPerInstance"`
}

func (ClusterInstanceGroupEbsConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterInstanceGroupEbsConfig)(nil)).Elem()
}

func (i ClusterInstanceGroupEbsConfigArgs) ToClusterInstanceGroupEbsConfigOutput() ClusterInstanceGroupEbsConfigOutput {
	return i.ToClusterInstanceGroupEbsConfigOutputWithContext(context.Background())
}

func (i ClusterInstanceGroupEbsConfigArgs) ToClusterInstanceGroupEbsConfigOutputWithContext(ctx context.Context) ClusterInstanceGroupEbsConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterInstanceGroupEbsConfigOutput)
}

// ClusterInstanceGroupEbsConfigArrayInput is an input type that accepts ClusterInstanceGroupEbsConfigArray and ClusterInstanceGroupEbsConfigArrayOutput values.
// You can construct a concrete instance of `ClusterInstanceGroupEbsConfigArrayInput` via:
//
//          ClusterInstanceGroupEbsConfigArray{ ClusterInstanceGroupEbsConfigArgs{...} }
type ClusterInstanceGroupEbsConfigArrayInput interface {
	pulumi.Input

	ToClusterInstanceGroupEbsConfigArrayOutput() ClusterInstanceGroupEbsConfigArrayOutput
	ToClusterInstanceGroupEbsConfigArrayOutputWithContext(context.Context) ClusterInstanceGroupEbsConfigArrayOutput
}

type ClusterInstanceGroupEbsConfigArray []ClusterInstanceGroupEbsConfigInput

func (ClusterInstanceGroupEbsConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterInstanceGroupEbsConfig)(nil)).Elem()
}

func (i ClusterInstanceGroupEbsConfigArray) ToClusterInstanceGroupEbsConfigArrayOutput() ClusterInstanceGroupEbsConfigArrayOutput {
	return i.ToClusterInstanceGroupEbsConfigArrayOutputWithContext(context.Background())
}

func (i ClusterInstanceGroupEbsConfigArray) ToClusterInstanceGroupEbsConfigArrayOutputWithContext(ctx context.Context) ClusterInstanceGroupEbsConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterInstanceGroupEbsConfigArrayOutput)
}

type ClusterInstanceGroupEbsConfigOutput struct{ *pulumi.OutputState }

func (ClusterInstanceGroupEbsConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterInstanceGroupEbsConfig)(nil)).Elem()
}

func (o ClusterInstanceGroupEbsConfigOutput) ToClusterInstanceGroupEbsConfigOutput() ClusterInstanceGroupEbsConfigOutput {
	return o
}

func (o ClusterInstanceGroupEbsConfigOutput) ToClusterInstanceGroupEbsConfigOutputWithContext(ctx context.Context) ClusterInstanceGroupEbsConfigOutput {
	return o
}

// The number of I/O operations per second (IOPS) that the volume supports
func (o ClusterInstanceGroupEbsConfigOutput) Iops() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterInstanceGroupEbsConfig) *int { return v.Iops }).(pulumi.IntPtrOutput)
}

// The volume size, in gibibytes (GiB).
func (o ClusterInstanceGroupEbsConfigOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v ClusterInstanceGroupEbsConfig) int { return v.Size }).(pulumi.IntOutput)
}

// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
func (o ClusterInstanceGroupEbsConfigOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterInstanceGroupEbsConfig) string { return v.Type }).(pulumi.StringOutput)
}

// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
func (o ClusterInstanceGroupEbsConfigOutput) VolumesPerInstance() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterInstanceGroupEbsConfig) *int { return v.VolumesPerInstance }).(pulumi.IntPtrOutput)
}

type ClusterInstanceGroupEbsConfigArrayOutput struct{ *pulumi.OutputState }

func (ClusterInstanceGroupEbsConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterInstanceGroupEbsConfig)(nil)).Elem()
}

func (o ClusterInstanceGroupEbsConfigArrayOutput) ToClusterInstanceGroupEbsConfigArrayOutput() ClusterInstanceGroupEbsConfigArrayOutput {
	return o
}

func (o ClusterInstanceGroupEbsConfigArrayOutput) ToClusterInstanceGroupEbsConfigArrayOutputWithContext(ctx context.Context) ClusterInstanceGroupEbsConfigArrayOutput {
	return o
}

func (o ClusterInstanceGroupEbsConfigArrayOutput) Index(i pulumi.IntInput) ClusterInstanceGroupEbsConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterInstanceGroupEbsConfig {
		return vs[0].([]ClusterInstanceGroupEbsConfig)[vs[1].(int)]
	}).(ClusterInstanceGroupEbsConfigOutput)
}

type ClusterKerberosAttributes struct {
	// The Active Directory password for `adDomainJoinUser`. This provider cannot perform drift detection of this configuration.
	AdDomainJoinPassword *string `pulumi:"adDomainJoinPassword"`
	// Required only when establishing a cross-realm trust with an Active Directory domain. A user with sufficient privileges to join resources to the domain. This provider cannot perform drift detection of this configuration.
	AdDomainJoinUser *string `pulumi:"adDomainJoinUser"`
	// Required only when establishing a cross-realm trust with a KDC in a different realm. The cross-realm principal password, which must be identical across realms. This provider cannot perform drift detection of this configuration.
	CrossRealmTrustPrincipalPassword *string `pulumi:"crossRealmTrustPrincipalPassword"`
	// The password used within the cluster for the kadmin service on the cluster-dedicated KDC, which maintains Kerberos principals, password policies, and keytabs for the cluster. This provider cannot perform drift detection of this configuration.
	KdcAdminPassword string `pulumi:"kdcAdminPassword"`
	// The name of the Kerberos realm to which all nodes in a cluster belong. For example, `EC2.INTERNAL`
	Realm string `pulumi:"realm"`
}

// ClusterKerberosAttributesInput is an input type that accepts ClusterKerberosAttributesArgs and ClusterKerberosAttributesOutput values.
// You can construct a concrete instance of `ClusterKerberosAttributesInput` via:
//
//          ClusterKerberosAttributesArgs{...}
type ClusterKerberosAttributesInput interface {
	pulumi.Input

	ToClusterKerberosAttributesOutput() ClusterKerberosAttributesOutput
	ToClusterKerberosAttributesOutputWithContext(context.Context) ClusterKerberosAttributesOutput
}

type ClusterKerberosAttributesArgs struct {
	// The Active Directory password for `adDomainJoinUser`. This provider cannot perform drift detection of this configuration.
	AdDomainJoinPassword pulumi.StringPtrInput `pulumi:"adDomainJoinPassword"`
	// Required only when establishing a cross-realm trust with an Active Directory domain. A user with sufficient privileges to join resources to the domain. This provider cannot perform drift detection of this configuration.
	AdDomainJoinUser pulumi.StringPtrInput `pulumi:"adDomainJoinUser"`
	// Required only when establishing a cross-realm trust with a KDC in a different realm. The cross-realm principal password, which must be identical across realms. This provider cannot perform drift detection of this configuration.
	CrossRealmTrustPrincipalPassword pulumi.StringPtrInput `pulumi:"crossRealmTrustPrincipalPassword"`
	// The password used within the cluster for the kadmin service on the cluster-dedicated KDC, which maintains Kerberos principals, password policies, and keytabs for the cluster. This provider cannot perform drift detection of this configuration.
	KdcAdminPassword pulumi.StringInput `pulumi:"kdcAdminPassword"`
	// The name of the Kerberos realm to which all nodes in a cluster belong. For example, `EC2.INTERNAL`
	Realm pulumi.StringInput `pulumi:"realm"`
}

func (ClusterKerberosAttributesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterKerberosAttributes)(nil)).Elem()
}

func (i ClusterKerberosAttributesArgs) ToClusterKerberosAttributesOutput() ClusterKerberosAttributesOutput {
	return i.ToClusterKerberosAttributesOutputWithContext(context.Background())
}

func (i ClusterKerberosAttributesArgs) ToClusterKerberosAttributesOutputWithContext(ctx context.Context) ClusterKerberosAttributesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterKerberosAttributesOutput)
}

func (i ClusterKerberosAttributesArgs) ToClusterKerberosAttributesPtrOutput() ClusterKerberosAttributesPtrOutput {
	return i.ToClusterKerberosAttributesPtrOutputWithContext(context.Background())
}

func (i ClusterKerberosAttributesArgs) ToClusterKerberosAttributesPtrOutputWithContext(ctx context.Context) ClusterKerberosAttributesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterKerberosAttributesOutput).ToClusterKerberosAttributesPtrOutputWithContext(ctx)
}

// ClusterKerberosAttributesPtrInput is an input type that accepts ClusterKerberosAttributesArgs, ClusterKerberosAttributesPtr and ClusterKerberosAttributesPtrOutput values.
// You can construct a concrete instance of `ClusterKerberosAttributesPtrInput` via:
//
//          ClusterKerberosAttributesArgs{...}
//
//  or:
//
//          nil
type ClusterKerberosAttributesPtrInput interface {
	pulumi.Input

	ToClusterKerberosAttributesPtrOutput() ClusterKerberosAttributesPtrOutput
	ToClusterKerberosAttributesPtrOutputWithContext(context.Context) ClusterKerberosAttributesPtrOutput
}

type clusterKerberosAttributesPtrType ClusterKerberosAttributesArgs

func ClusterKerberosAttributesPtr(v *ClusterKerberosAttributesArgs) ClusterKerberosAttributesPtrInput {
	return (*clusterKerberosAttributesPtrType)(v)
}

func (*clusterKerberosAttributesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterKerberosAttributes)(nil)).Elem()
}

func (i *clusterKerberosAttributesPtrType) ToClusterKerberosAttributesPtrOutput() ClusterKerberosAttributesPtrOutput {
	return i.ToClusterKerberosAttributesPtrOutputWithContext(context.Background())
}

func (i *clusterKerberosAttributesPtrType) ToClusterKerberosAttributesPtrOutputWithContext(ctx context.Context) ClusterKerberosAttributesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterKerberosAttributesPtrOutput)
}

type ClusterKerberosAttributesOutput struct{ *pulumi.OutputState }

func (ClusterKerberosAttributesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterKerberosAttributes)(nil)).Elem()
}

func (o ClusterKerberosAttributesOutput) ToClusterKerberosAttributesOutput() ClusterKerberosAttributesOutput {
	return o
}

func (o ClusterKerberosAttributesOutput) ToClusterKerberosAttributesOutputWithContext(ctx context.Context) ClusterKerberosAttributesOutput {
	return o
}

func (o ClusterKerberosAttributesOutput) ToClusterKerberosAttributesPtrOutput() ClusterKerberosAttributesPtrOutput {
	return o.ToClusterKerberosAttributesPtrOutputWithContext(context.Background())
}

func (o ClusterKerberosAttributesOutput) ToClusterKerberosAttributesPtrOutputWithContext(ctx context.Context) ClusterKerberosAttributesPtrOutput {
	return o.ApplyT(func(v ClusterKerberosAttributes) *ClusterKerberosAttributes {
		return &v
	}).(ClusterKerberosAttributesPtrOutput)
}

// The Active Directory password for `adDomainJoinUser`. This provider cannot perform drift detection of this configuration.
func (o ClusterKerberosAttributesOutput) AdDomainJoinPassword() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterKerberosAttributes) *string { return v.AdDomainJoinPassword }).(pulumi.StringPtrOutput)
}

// Required only when establishing a cross-realm trust with an Active Directory domain. A user with sufficient privileges to join resources to the domain. This provider cannot perform drift detection of this configuration.
func (o ClusterKerberosAttributesOutput) AdDomainJoinUser() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterKerberosAttributes) *string { return v.AdDomainJoinUser }).(pulumi.StringPtrOutput)
}

// Required only when establishing a cross-realm trust with a KDC in a different realm. The cross-realm principal password, which must be identical across realms. This provider cannot perform drift detection of this configuration.
func (o ClusterKerberosAttributesOutput) CrossRealmTrustPrincipalPassword() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterKerberosAttributes) *string { return v.CrossRealmTrustPrincipalPassword }).(pulumi.StringPtrOutput)
}

// The password used within the cluster for the kadmin service on the cluster-dedicated KDC, which maintains Kerberos principals, password policies, and keytabs for the cluster. This provider cannot perform drift detection of this configuration.
func (o ClusterKerberosAttributesOutput) KdcAdminPassword() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterKerberosAttributes) string { return v.KdcAdminPassword }).(pulumi.StringOutput)
}

// The name of the Kerberos realm to which all nodes in a cluster belong. For example, `EC2.INTERNAL`
func (o ClusterKerberosAttributesOutput) Realm() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterKerberosAttributes) string { return v.Realm }).(pulumi.StringOutput)
}

type ClusterKerberosAttributesPtrOutput struct{ *pulumi.OutputState }

func (ClusterKerberosAttributesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterKerberosAttributes)(nil)).Elem()
}

func (o ClusterKerberosAttributesPtrOutput) ToClusterKerberosAttributesPtrOutput() ClusterKerberosAttributesPtrOutput {
	return o
}

func (o ClusterKerberosAttributesPtrOutput) ToClusterKerberosAttributesPtrOutputWithContext(ctx context.Context) ClusterKerberosAttributesPtrOutput {
	return o
}

func (o ClusterKerberosAttributesPtrOutput) Elem() ClusterKerberosAttributesOutput {
	return o.ApplyT(func(v *ClusterKerberosAttributes) ClusterKerberosAttributes { return *v }).(ClusterKerberosAttributesOutput)
}

// The Active Directory password for `adDomainJoinUser`. This provider cannot perform drift detection of this configuration.
func (o ClusterKerberosAttributesPtrOutput) AdDomainJoinPassword() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterKerberosAttributes) *string {
		if v == nil {
			return nil
		}
		return v.AdDomainJoinPassword
	}).(pulumi.StringPtrOutput)
}

// Required only when establishing a cross-realm trust with an Active Directory domain. A user with sufficient privileges to join resources to the domain. This provider cannot perform drift detection of this configuration.
func (o ClusterKerberosAttributesPtrOutput) AdDomainJoinUser() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterKerberosAttributes) *string {
		if v == nil {
			return nil
		}
		return v.AdDomainJoinUser
	}).(pulumi.StringPtrOutput)
}

// Required only when establishing a cross-realm trust with a KDC in a different realm. The cross-realm principal password, which must be identical across realms. This provider cannot perform drift detection of this configuration.
func (o ClusterKerberosAttributesPtrOutput) CrossRealmTrustPrincipalPassword() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterKerberosAttributes) *string {
		if v == nil {
			return nil
		}
		return v.CrossRealmTrustPrincipalPassword
	}).(pulumi.StringPtrOutput)
}

// The password used within the cluster for the kadmin service on the cluster-dedicated KDC, which maintains Kerberos principals, password policies, and keytabs for the cluster. This provider cannot perform drift detection of this configuration.
func (o ClusterKerberosAttributesPtrOutput) KdcAdminPassword() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterKerberosAttributes) *string {
		if v == nil {
			return nil
		}
		return &v.KdcAdminPassword
	}).(pulumi.StringPtrOutput)
}

// The name of the Kerberos realm to which all nodes in a cluster belong. For example, `EC2.INTERNAL`
func (o ClusterKerberosAttributesPtrOutput) Realm() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterKerberosAttributes) *string {
		if v == nil {
			return nil
		}
		return &v.Realm
	}).(pulumi.StringPtrOutput)
}

type ClusterMasterInstanceGroup struct {
	// Bid price for each EC2 instance in the instance group, expressed in USD. By setting this attribute, the instance group is being declared as a Spot Instance, and will implicitly create a Spot request. Leave this blank to use On-Demand Instances.
	BidPrice *string `pulumi:"bidPrice"`
	// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
	EbsConfigs []ClusterMasterInstanceGroupEbsConfig `pulumi:"ebsConfigs"`
	// The ID of the EMR Cluster
	Id *string `pulumi:"id"`
	// Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have `map public IP on launch` enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
	InstanceCount *int `pulumi:"instanceCount"`
	// EC2 instance type for all instances in the instance group.
	InstanceType string `pulumi:"instanceType"`
	// The name of the step.
	Name *string `pulumi:"name"`
}

// ClusterMasterInstanceGroupInput is an input type that accepts ClusterMasterInstanceGroupArgs and ClusterMasterInstanceGroupOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceGroupInput` via:
//
//          ClusterMasterInstanceGroupArgs{...}
type ClusterMasterInstanceGroupInput interface {
	pulumi.Input

	ToClusterMasterInstanceGroupOutput() ClusterMasterInstanceGroupOutput
	ToClusterMasterInstanceGroupOutputWithContext(context.Context) ClusterMasterInstanceGroupOutput
}

type ClusterMasterInstanceGroupArgs struct {
	// Bid price for each EC2 instance in the instance group, expressed in USD. By setting this attribute, the instance group is being declared as a Spot Instance, and will implicitly create a Spot request. Leave this blank to use On-Demand Instances.
	BidPrice pulumi.StringPtrInput `pulumi:"bidPrice"`
	// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
	EbsConfigs ClusterMasterInstanceGroupEbsConfigArrayInput `pulumi:"ebsConfigs"`
	// The ID of the EMR Cluster
	Id pulumi.StringPtrInput `pulumi:"id"`
	// Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have `map public IP on launch` enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
	InstanceCount pulumi.IntPtrInput `pulumi:"instanceCount"`
	// EC2 instance type for all instances in the instance group.
	InstanceType pulumi.StringInput `pulumi:"instanceType"`
	// The name of the step.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ClusterMasterInstanceGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceGroup)(nil)).Elem()
}

func (i ClusterMasterInstanceGroupArgs) ToClusterMasterInstanceGroupOutput() ClusterMasterInstanceGroupOutput {
	return i.ToClusterMasterInstanceGroupOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceGroupArgs) ToClusterMasterInstanceGroupOutputWithContext(ctx context.Context) ClusterMasterInstanceGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceGroupOutput)
}

func (i ClusterMasterInstanceGroupArgs) ToClusterMasterInstanceGroupPtrOutput() ClusterMasterInstanceGroupPtrOutput {
	return i.ToClusterMasterInstanceGroupPtrOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceGroupArgs) ToClusterMasterInstanceGroupPtrOutputWithContext(ctx context.Context) ClusterMasterInstanceGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceGroupOutput).ToClusterMasterInstanceGroupPtrOutputWithContext(ctx)
}

// ClusterMasterInstanceGroupPtrInput is an input type that accepts ClusterMasterInstanceGroupArgs, ClusterMasterInstanceGroupPtr and ClusterMasterInstanceGroupPtrOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceGroupPtrInput` via:
//
//          ClusterMasterInstanceGroupArgs{...}
//
//  or:
//
//          nil
type ClusterMasterInstanceGroupPtrInput interface {
	pulumi.Input

	ToClusterMasterInstanceGroupPtrOutput() ClusterMasterInstanceGroupPtrOutput
	ToClusterMasterInstanceGroupPtrOutputWithContext(context.Context) ClusterMasterInstanceGroupPtrOutput
}

type clusterMasterInstanceGroupPtrType ClusterMasterInstanceGroupArgs

func ClusterMasterInstanceGroupPtr(v *ClusterMasterInstanceGroupArgs) ClusterMasterInstanceGroupPtrInput {
	return (*clusterMasterInstanceGroupPtrType)(v)
}

func (*clusterMasterInstanceGroupPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterMasterInstanceGroup)(nil)).Elem()
}

func (i *clusterMasterInstanceGroupPtrType) ToClusterMasterInstanceGroupPtrOutput() ClusterMasterInstanceGroupPtrOutput {
	return i.ToClusterMasterInstanceGroupPtrOutputWithContext(context.Background())
}

func (i *clusterMasterInstanceGroupPtrType) ToClusterMasterInstanceGroupPtrOutputWithContext(ctx context.Context) ClusterMasterInstanceGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceGroupPtrOutput)
}

type ClusterMasterInstanceGroupOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceGroup)(nil)).Elem()
}

func (o ClusterMasterInstanceGroupOutput) ToClusterMasterInstanceGroupOutput() ClusterMasterInstanceGroupOutput {
	return o
}

func (o ClusterMasterInstanceGroupOutput) ToClusterMasterInstanceGroupOutputWithContext(ctx context.Context) ClusterMasterInstanceGroupOutput {
	return o
}

func (o ClusterMasterInstanceGroupOutput) ToClusterMasterInstanceGroupPtrOutput() ClusterMasterInstanceGroupPtrOutput {
	return o.ToClusterMasterInstanceGroupPtrOutputWithContext(context.Background())
}

func (o ClusterMasterInstanceGroupOutput) ToClusterMasterInstanceGroupPtrOutputWithContext(ctx context.Context) ClusterMasterInstanceGroupPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroup) *ClusterMasterInstanceGroup {
		return &v
	}).(ClusterMasterInstanceGroupPtrOutput)
}

// Bid price for each EC2 instance in the instance group, expressed in USD. By setting this attribute, the instance group is being declared as a Spot Instance, and will implicitly create a Spot request. Leave this blank to use On-Demand Instances.
func (o ClusterMasterInstanceGroupOutput) BidPrice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroup) *string { return v.BidPrice }).(pulumi.StringPtrOutput)
}

// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
func (o ClusterMasterInstanceGroupOutput) EbsConfigs() ClusterMasterInstanceGroupEbsConfigArrayOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroup) []ClusterMasterInstanceGroupEbsConfig { return v.EbsConfigs }).(ClusterMasterInstanceGroupEbsConfigArrayOutput)
}

// The ID of the EMR Cluster
func (o ClusterMasterInstanceGroupOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroup) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have `map public IP on launch` enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
func (o ClusterMasterInstanceGroupOutput) InstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroup) *int { return v.InstanceCount }).(pulumi.IntPtrOutput)
}

// EC2 instance type for all instances in the instance group.
func (o ClusterMasterInstanceGroupOutput) InstanceType() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroup) string { return v.InstanceType }).(pulumi.StringOutput)
}

// The name of the step.
func (o ClusterMasterInstanceGroupOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroup) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ClusterMasterInstanceGroupPtrOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceGroupPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterMasterInstanceGroup)(nil)).Elem()
}

func (o ClusterMasterInstanceGroupPtrOutput) ToClusterMasterInstanceGroupPtrOutput() ClusterMasterInstanceGroupPtrOutput {
	return o
}

func (o ClusterMasterInstanceGroupPtrOutput) ToClusterMasterInstanceGroupPtrOutputWithContext(ctx context.Context) ClusterMasterInstanceGroupPtrOutput {
	return o
}

func (o ClusterMasterInstanceGroupPtrOutput) Elem() ClusterMasterInstanceGroupOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceGroup) ClusterMasterInstanceGroup { return *v }).(ClusterMasterInstanceGroupOutput)
}

// Bid price for each EC2 instance in the instance group, expressed in USD. By setting this attribute, the instance group is being declared as a Spot Instance, and will implicitly create a Spot request. Leave this blank to use On-Demand Instances.
func (o ClusterMasterInstanceGroupPtrOutput) BidPrice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceGroup) *string {
		if v == nil {
			return nil
		}
		return v.BidPrice
	}).(pulumi.StringPtrOutput)
}

// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
func (o ClusterMasterInstanceGroupPtrOutput) EbsConfigs() ClusterMasterInstanceGroupEbsConfigArrayOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceGroup) []ClusterMasterInstanceGroupEbsConfig {
		if v == nil {
			return nil
		}
		return v.EbsConfigs
	}).(ClusterMasterInstanceGroupEbsConfigArrayOutput)
}

// The ID of the EMR Cluster
func (o ClusterMasterInstanceGroupPtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceGroup) *string {
		if v == nil {
			return nil
		}
		return v.Id
	}).(pulumi.StringPtrOutput)
}

// Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have `map public IP on launch` enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
func (o ClusterMasterInstanceGroupPtrOutput) InstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceGroup) *int {
		if v == nil {
			return nil
		}
		return v.InstanceCount
	}).(pulumi.IntPtrOutput)
}

// EC2 instance type for all instances in the instance group.
func (o ClusterMasterInstanceGroupPtrOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceGroup) *string {
		if v == nil {
			return nil
		}
		return &v.InstanceType
	}).(pulumi.StringPtrOutput)
}

// The name of the step.
func (o ClusterMasterInstanceGroupPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceGroup) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

type ClusterMasterInstanceGroupEbsConfig struct {
	// The number of I/O operations per second (IOPS) that the volume supports
	Iops *int `pulumi:"iops"`
	// The volume size, in gibibytes (GiB).
	Size int `pulumi:"size"`
	// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
	Type string `pulumi:"type"`
	// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
	VolumesPerInstance *int `pulumi:"volumesPerInstance"`
}

// ClusterMasterInstanceGroupEbsConfigInput is an input type that accepts ClusterMasterInstanceGroupEbsConfigArgs and ClusterMasterInstanceGroupEbsConfigOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceGroupEbsConfigInput` via:
//
//          ClusterMasterInstanceGroupEbsConfigArgs{...}
type ClusterMasterInstanceGroupEbsConfigInput interface {
	pulumi.Input

	ToClusterMasterInstanceGroupEbsConfigOutput() ClusterMasterInstanceGroupEbsConfigOutput
	ToClusterMasterInstanceGroupEbsConfigOutputWithContext(context.Context) ClusterMasterInstanceGroupEbsConfigOutput
}

type ClusterMasterInstanceGroupEbsConfigArgs struct {
	// The number of I/O operations per second (IOPS) that the volume supports
	Iops pulumi.IntPtrInput `pulumi:"iops"`
	// The volume size, in gibibytes (GiB).
	Size pulumi.IntInput `pulumi:"size"`
	// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
	Type pulumi.StringInput `pulumi:"type"`
	// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
	VolumesPerInstance pulumi.IntPtrInput `pulumi:"volumesPerInstance"`
}

func (ClusterMasterInstanceGroupEbsConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceGroupEbsConfig)(nil)).Elem()
}

func (i ClusterMasterInstanceGroupEbsConfigArgs) ToClusterMasterInstanceGroupEbsConfigOutput() ClusterMasterInstanceGroupEbsConfigOutput {
	return i.ToClusterMasterInstanceGroupEbsConfigOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceGroupEbsConfigArgs) ToClusterMasterInstanceGroupEbsConfigOutputWithContext(ctx context.Context) ClusterMasterInstanceGroupEbsConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceGroupEbsConfigOutput)
}

// ClusterMasterInstanceGroupEbsConfigArrayInput is an input type that accepts ClusterMasterInstanceGroupEbsConfigArray and ClusterMasterInstanceGroupEbsConfigArrayOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceGroupEbsConfigArrayInput` via:
//
//          ClusterMasterInstanceGroupEbsConfigArray{ ClusterMasterInstanceGroupEbsConfigArgs{...} }
type ClusterMasterInstanceGroupEbsConfigArrayInput interface {
	pulumi.Input

	ToClusterMasterInstanceGroupEbsConfigArrayOutput() ClusterMasterInstanceGroupEbsConfigArrayOutput
	ToClusterMasterInstanceGroupEbsConfigArrayOutputWithContext(context.Context) ClusterMasterInstanceGroupEbsConfigArrayOutput
}

type ClusterMasterInstanceGroupEbsConfigArray []ClusterMasterInstanceGroupEbsConfigInput

func (ClusterMasterInstanceGroupEbsConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterMasterInstanceGroupEbsConfig)(nil)).Elem()
}

func (i ClusterMasterInstanceGroupEbsConfigArray) ToClusterMasterInstanceGroupEbsConfigArrayOutput() ClusterMasterInstanceGroupEbsConfigArrayOutput {
	return i.ToClusterMasterInstanceGroupEbsConfigArrayOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceGroupEbsConfigArray) ToClusterMasterInstanceGroupEbsConfigArrayOutputWithContext(ctx context.Context) ClusterMasterInstanceGroupEbsConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceGroupEbsConfigArrayOutput)
}

type ClusterMasterInstanceGroupEbsConfigOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceGroupEbsConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceGroupEbsConfig)(nil)).Elem()
}

func (o ClusterMasterInstanceGroupEbsConfigOutput) ToClusterMasterInstanceGroupEbsConfigOutput() ClusterMasterInstanceGroupEbsConfigOutput {
	return o
}

func (o ClusterMasterInstanceGroupEbsConfigOutput) ToClusterMasterInstanceGroupEbsConfigOutputWithContext(ctx context.Context) ClusterMasterInstanceGroupEbsConfigOutput {
	return o
}

// The number of I/O operations per second (IOPS) that the volume supports
func (o ClusterMasterInstanceGroupEbsConfigOutput) Iops() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroupEbsConfig) *int { return v.Iops }).(pulumi.IntPtrOutput)
}

// The volume size, in gibibytes (GiB).
func (o ClusterMasterInstanceGroupEbsConfigOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroupEbsConfig) int { return v.Size }).(pulumi.IntOutput)
}

// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
func (o ClusterMasterInstanceGroupEbsConfigOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroupEbsConfig) string { return v.Type }).(pulumi.StringOutput)
}

// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
func (o ClusterMasterInstanceGroupEbsConfigOutput) VolumesPerInstance() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroupEbsConfig) *int { return v.VolumesPerInstance }).(pulumi.IntPtrOutput)
}

type ClusterMasterInstanceGroupEbsConfigArrayOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceGroupEbsConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterMasterInstanceGroupEbsConfig)(nil)).Elem()
}

func (o ClusterMasterInstanceGroupEbsConfigArrayOutput) ToClusterMasterInstanceGroupEbsConfigArrayOutput() ClusterMasterInstanceGroupEbsConfigArrayOutput {
	return o
}

func (o ClusterMasterInstanceGroupEbsConfigArrayOutput) ToClusterMasterInstanceGroupEbsConfigArrayOutputWithContext(ctx context.Context) ClusterMasterInstanceGroupEbsConfigArrayOutput {
	return o
}

func (o ClusterMasterInstanceGroupEbsConfigArrayOutput) Index(i pulumi.IntInput) ClusterMasterInstanceGroupEbsConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterMasterInstanceGroupEbsConfig {
		return vs[0].([]ClusterMasterInstanceGroupEbsConfig)[vs[1].(int)]
	}).(ClusterMasterInstanceGroupEbsConfigOutput)
}

type ClusterStep struct {
	// The action to take if the step fails. Valid values: `TERMINATE_JOB_FLOW`, `TERMINATE_CLUSTER`, `CANCEL_AND_WAIT`, and `CONTINUE`
	ActionOnFailure string `pulumi:"actionOnFailure"`
	// The JAR file used for the step. Defined below.
	HadoopJarStep ClusterStepHadoopJarStep `pulumi:"hadoopJarStep"`
	// The name of the step.
	Name string `pulumi:"name"`
}

// ClusterStepInput is an input type that accepts ClusterStepArgs and ClusterStepOutput values.
// You can construct a concrete instance of `ClusterStepInput` via:
//
//          ClusterStepArgs{...}
type ClusterStepInput interface {
	pulumi.Input

	ToClusterStepOutput() ClusterStepOutput
	ToClusterStepOutputWithContext(context.Context) ClusterStepOutput
}

type ClusterStepArgs struct {
	// The action to take if the step fails. Valid values: `TERMINATE_JOB_FLOW`, `TERMINATE_CLUSTER`, `CANCEL_AND_WAIT`, and `CONTINUE`
	ActionOnFailure pulumi.StringInput `pulumi:"actionOnFailure"`
	// The JAR file used for the step. Defined below.
	HadoopJarStep ClusterStepHadoopJarStepInput `pulumi:"hadoopJarStep"`
	// The name of the step.
	Name pulumi.StringInput `pulumi:"name"`
}

func (ClusterStepArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterStep)(nil)).Elem()
}

func (i ClusterStepArgs) ToClusterStepOutput() ClusterStepOutput {
	return i.ToClusterStepOutputWithContext(context.Background())
}

func (i ClusterStepArgs) ToClusterStepOutputWithContext(ctx context.Context) ClusterStepOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterStepOutput)
}

// ClusterStepArrayInput is an input type that accepts ClusterStepArray and ClusterStepArrayOutput values.
// You can construct a concrete instance of `ClusterStepArrayInput` via:
//
//          ClusterStepArray{ ClusterStepArgs{...} }
type ClusterStepArrayInput interface {
	pulumi.Input

	ToClusterStepArrayOutput() ClusterStepArrayOutput
	ToClusterStepArrayOutputWithContext(context.Context) ClusterStepArrayOutput
}

type ClusterStepArray []ClusterStepInput

func (ClusterStepArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterStep)(nil)).Elem()
}

func (i ClusterStepArray) ToClusterStepArrayOutput() ClusterStepArrayOutput {
	return i.ToClusterStepArrayOutputWithContext(context.Background())
}

func (i ClusterStepArray) ToClusterStepArrayOutputWithContext(ctx context.Context) ClusterStepArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterStepArrayOutput)
}

type ClusterStepOutput struct{ *pulumi.OutputState }

func (ClusterStepOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterStep)(nil)).Elem()
}

func (o ClusterStepOutput) ToClusterStepOutput() ClusterStepOutput {
	return o
}

func (o ClusterStepOutput) ToClusterStepOutputWithContext(ctx context.Context) ClusterStepOutput {
	return o
}

// The action to take if the step fails. Valid values: `TERMINATE_JOB_FLOW`, `TERMINATE_CLUSTER`, `CANCEL_AND_WAIT`, and `CONTINUE`
func (o ClusterStepOutput) ActionOnFailure() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterStep) string { return v.ActionOnFailure }).(pulumi.StringOutput)
}

// The JAR file used for the step. Defined below.
func (o ClusterStepOutput) HadoopJarStep() ClusterStepHadoopJarStepOutput {
	return o.ApplyT(func(v ClusterStep) ClusterStepHadoopJarStep { return v.HadoopJarStep }).(ClusterStepHadoopJarStepOutput)
}

// The name of the step.
func (o ClusterStepOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterStep) string { return v.Name }).(pulumi.StringOutput)
}

type ClusterStepArrayOutput struct{ *pulumi.OutputState }

func (ClusterStepArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterStep)(nil)).Elem()
}

func (o ClusterStepArrayOutput) ToClusterStepArrayOutput() ClusterStepArrayOutput {
	return o
}

func (o ClusterStepArrayOutput) ToClusterStepArrayOutputWithContext(ctx context.Context) ClusterStepArrayOutput {
	return o
}

func (o ClusterStepArrayOutput) Index(i pulumi.IntInput) ClusterStepOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterStep {
		return vs[0].([]ClusterStep)[vs[1].(int)]
	}).(ClusterStepOutput)
}

type ClusterStepHadoopJarStep struct {
	// List of command line arguments passed to the JAR file's main function when executed.
	Args []string `pulumi:"args"`
	// Path to a JAR file run during the step.
	Jar string `pulumi:"jar"`
	// Name of the main class in the specified Java file. If not specified, the JAR file should specify a Main-Class in its manifest file.
	MainClass *string `pulumi:"mainClass"`
	// Key-Value map of Java properties that are set when the step runs. You can use these properties to pass key value pairs to your main function.
	Properties map[string]string `pulumi:"properties"`
}

// ClusterStepHadoopJarStepInput is an input type that accepts ClusterStepHadoopJarStepArgs and ClusterStepHadoopJarStepOutput values.
// You can construct a concrete instance of `ClusterStepHadoopJarStepInput` via:
//
//          ClusterStepHadoopJarStepArgs{...}
type ClusterStepHadoopJarStepInput interface {
	pulumi.Input

	ToClusterStepHadoopJarStepOutput() ClusterStepHadoopJarStepOutput
	ToClusterStepHadoopJarStepOutputWithContext(context.Context) ClusterStepHadoopJarStepOutput
}

type ClusterStepHadoopJarStepArgs struct {
	// List of command line arguments passed to the JAR file's main function when executed.
	Args pulumi.StringArrayInput `pulumi:"args"`
	// Path to a JAR file run during the step.
	Jar pulumi.StringInput `pulumi:"jar"`
	// Name of the main class in the specified Java file. If not specified, the JAR file should specify a Main-Class in its manifest file.
	MainClass pulumi.StringPtrInput `pulumi:"mainClass"`
	// Key-Value map of Java properties that are set when the step runs. You can use these properties to pass key value pairs to your main function.
	Properties pulumi.StringMapInput `pulumi:"properties"`
}

func (ClusterStepHadoopJarStepArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterStepHadoopJarStep)(nil)).Elem()
}

func (i ClusterStepHadoopJarStepArgs) ToClusterStepHadoopJarStepOutput() ClusterStepHadoopJarStepOutput {
	return i.ToClusterStepHadoopJarStepOutputWithContext(context.Background())
}

func (i ClusterStepHadoopJarStepArgs) ToClusterStepHadoopJarStepOutputWithContext(ctx context.Context) ClusterStepHadoopJarStepOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterStepHadoopJarStepOutput)
}

type ClusterStepHadoopJarStepOutput struct{ *pulumi.OutputState }

func (ClusterStepHadoopJarStepOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterStepHadoopJarStep)(nil)).Elem()
}

func (o ClusterStepHadoopJarStepOutput) ToClusterStepHadoopJarStepOutput() ClusterStepHadoopJarStepOutput {
	return o
}

func (o ClusterStepHadoopJarStepOutput) ToClusterStepHadoopJarStepOutputWithContext(ctx context.Context) ClusterStepHadoopJarStepOutput {
	return o
}

// List of command line arguments passed to the JAR file's main function when executed.
func (o ClusterStepHadoopJarStepOutput) Args() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ClusterStepHadoopJarStep) []string { return v.Args }).(pulumi.StringArrayOutput)
}

// Path to a JAR file run during the step.
func (o ClusterStepHadoopJarStepOutput) Jar() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterStepHadoopJarStep) string { return v.Jar }).(pulumi.StringOutput)
}

// Name of the main class in the specified Java file. If not specified, the JAR file should specify a Main-Class in its manifest file.
func (o ClusterStepHadoopJarStepOutput) MainClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterStepHadoopJarStep) *string { return v.MainClass }).(pulumi.StringPtrOutput)
}

// Key-Value map of Java properties that are set when the step runs. You can use these properties to pass key value pairs to your main function.
func (o ClusterStepHadoopJarStepOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v ClusterStepHadoopJarStep) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

type InstanceGroupEbsConfig struct {
	// The number of I/O operations per second (IOPS) that the volume supports.
	Iops *int `pulumi:"iops"`
	// The volume size, in gibibytes (GiB). This can be a number from 1 - 1024. If the volume type is EBS-optimized, the minimum value is 10.
	Size int `pulumi:"size"`
	// The volume type. Valid options are 'gp2', 'io1' and 'standard'.
	Type string `pulumi:"type"`
	// The number of EBS Volumes to attach per instance.
	VolumesPerInstance *int `pulumi:"volumesPerInstance"`
}

// InstanceGroupEbsConfigInput is an input type that accepts InstanceGroupEbsConfigArgs and InstanceGroupEbsConfigOutput values.
// You can construct a concrete instance of `InstanceGroupEbsConfigInput` via:
//
//          InstanceGroupEbsConfigArgs{...}
type InstanceGroupEbsConfigInput interface {
	pulumi.Input

	ToInstanceGroupEbsConfigOutput() InstanceGroupEbsConfigOutput
	ToInstanceGroupEbsConfigOutputWithContext(context.Context) InstanceGroupEbsConfigOutput
}

type InstanceGroupEbsConfigArgs struct {
	// The number of I/O operations per second (IOPS) that the volume supports.
	Iops pulumi.IntPtrInput `pulumi:"iops"`
	// The volume size, in gibibytes (GiB). This can be a number from 1 - 1024. If the volume type is EBS-optimized, the minimum value is 10.
	Size pulumi.IntInput `pulumi:"size"`
	// The volume type. Valid options are 'gp2', 'io1' and 'standard'.
	Type pulumi.StringInput `pulumi:"type"`
	// The number of EBS Volumes to attach per instance.
	VolumesPerInstance pulumi.IntPtrInput `pulumi:"volumesPerInstance"`
}

func (InstanceGroupEbsConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceGroupEbsConfig)(nil)).Elem()
}

func (i InstanceGroupEbsConfigArgs) ToInstanceGroupEbsConfigOutput() InstanceGroupEbsConfigOutput {
	return i.ToInstanceGroupEbsConfigOutputWithContext(context.Background())
}

func (i InstanceGroupEbsConfigArgs) ToInstanceGroupEbsConfigOutputWithContext(ctx context.Context) InstanceGroupEbsConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceGroupEbsConfigOutput)
}

// InstanceGroupEbsConfigArrayInput is an input type that accepts InstanceGroupEbsConfigArray and InstanceGroupEbsConfigArrayOutput values.
// You can construct a concrete instance of `InstanceGroupEbsConfigArrayInput` via:
//
//          InstanceGroupEbsConfigArray{ InstanceGroupEbsConfigArgs{...} }
type InstanceGroupEbsConfigArrayInput interface {
	pulumi.Input

	ToInstanceGroupEbsConfigArrayOutput() InstanceGroupEbsConfigArrayOutput
	ToInstanceGroupEbsConfigArrayOutputWithContext(context.Context) InstanceGroupEbsConfigArrayOutput
}

type InstanceGroupEbsConfigArray []InstanceGroupEbsConfigInput

func (InstanceGroupEbsConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceGroupEbsConfig)(nil)).Elem()
}

func (i InstanceGroupEbsConfigArray) ToInstanceGroupEbsConfigArrayOutput() InstanceGroupEbsConfigArrayOutput {
	return i.ToInstanceGroupEbsConfigArrayOutputWithContext(context.Background())
}

func (i InstanceGroupEbsConfigArray) ToInstanceGroupEbsConfigArrayOutputWithContext(ctx context.Context) InstanceGroupEbsConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceGroupEbsConfigArrayOutput)
}

type InstanceGroupEbsConfigOutput struct{ *pulumi.OutputState }

func (InstanceGroupEbsConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceGroupEbsConfig)(nil)).Elem()
}

func (o InstanceGroupEbsConfigOutput) ToInstanceGroupEbsConfigOutput() InstanceGroupEbsConfigOutput {
	return o
}

func (o InstanceGroupEbsConfigOutput) ToInstanceGroupEbsConfigOutputWithContext(ctx context.Context) InstanceGroupEbsConfigOutput {
	return o
}

// The number of I/O operations per second (IOPS) that the volume supports.
func (o InstanceGroupEbsConfigOutput) Iops() pulumi.IntPtrOutput {
	return o.ApplyT(func(v InstanceGroupEbsConfig) *int { return v.Iops }).(pulumi.IntPtrOutput)
}

// The volume size, in gibibytes (GiB). This can be a number from 1 - 1024. If the volume type is EBS-optimized, the minimum value is 10.
func (o InstanceGroupEbsConfigOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v InstanceGroupEbsConfig) int { return v.Size }).(pulumi.IntOutput)
}

// The volume type. Valid options are 'gp2', 'io1' and 'standard'.
func (o InstanceGroupEbsConfigOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v InstanceGroupEbsConfig) string { return v.Type }).(pulumi.StringOutput)
}

// The number of EBS Volumes to attach per instance.
func (o InstanceGroupEbsConfigOutput) VolumesPerInstance() pulumi.IntPtrOutput {
	return o.ApplyT(func(v InstanceGroupEbsConfig) *int { return v.VolumesPerInstance }).(pulumi.IntPtrOutput)
}

type InstanceGroupEbsConfigArrayOutput struct{ *pulumi.OutputState }

func (InstanceGroupEbsConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceGroupEbsConfig)(nil)).Elem()
}

func (o InstanceGroupEbsConfigArrayOutput) ToInstanceGroupEbsConfigArrayOutput() InstanceGroupEbsConfigArrayOutput {
	return o
}

func (o InstanceGroupEbsConfigArrayOutput) ToInstanceGroupEbsConfigArrayOutputWithContext(ctx context.Context) InstanceGroupEbsConfigArrayOutput {
	return o
}

func (o InstanceGroupEbsConfigArrayOutput) Index(i pulumi.IntInput) InstanceGroupEbsConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InstanceGroupEbsConfig {
		return vs[0].([]InstanceGroupEbsConfig)[vs[1].(int)]
	}).(InstanceGroupEbsConfigOutput)
}

func init() {
	pulumi.RegisterOutputType(ClusterBootstrapActionOutput{})
	pulumi.RegisterOutputType(ClusterBootstrapActionArrayOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceGroupOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceGroupPtrOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceGroupEbsConfigOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceGroupEbsConfigArrayOutput{})
	pulumi.RegisterOutputType(ClusterEc2AttributesOutput{})
	pulumi.RegisterOutputType(ClusterEc2AttributesPtrOutput{})
	pulumi.RegisterOutputType(ClusterInstanceGroupOutput{})
	pulumi.RegisterOutputType(ClusterInstanceGroupArrayOutput{})
	pulumi.RegisterOutputType(ClusterInstanceGroupEbsConfigOutput{})
	pulumi.RegisterOutputType(ClusterInstanceGroupEbsConfigArrayOutput{})
	pulumi.RegisterOutputType(ClusterKerberosAttributesOutput{})
	pulumi.RegisterOutputType(ClusterKerberosAttributesPtrOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceGroupOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceGroupPtrOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceGroupEbsConfigOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceGroupEbsConfigArrayOutput{})
	pulumi.RegisterOutputType(ClusterStepOutput{})
	pulumi.RegisterOutputType(ClusterStepArrayOutput{})
	pulumi.RegisterOutputType(ClusterStepHadoopJarStepOutput{})
	pulumi.RegisterOutputType(InstanceGroupEbsConfigOutput{})
	pulumi.RegisterOutputType(InstanceGroupEbsConfigArrayOutput{})
}
