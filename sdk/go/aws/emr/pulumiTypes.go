// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package emr

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

type ClusterBootstrapAction struct {
	// List of command line arguments passed to the JAR file's main function when executed.
	Args []string `pulumi:"args"`
	// Friendly name given to the instance fleet.
	Name string `pulumi:"name"`
	// Location of the script to run during a bootstrap action. Can be either a location in Amazon S3 or on a local file system
	Path string `pulumi:"path"`
}

// ClusterBootstrapActionInput is an input type that accepts ClusterBootstrapActionArgs and ClusterBootstrapActionOutput values.
// You can construct a concrete instance of `ClusterBootstrapActionInput` via:
//
//          ClusterBootstrapActionArgs{...}
type ClusterBootstrapActionInput interface {
	pulumi.Input

	ToClusterBootstrapActionOutput() ClusterBootstrapActionOutput
	ToClusterBootstrapActionOutputWithContext(context.Context) ClusterBootstrapActionOutput
}

type ClusterBootstrapActionArgs struct {
	// List of command line arguments passed to the JAR file's main function when executed.
	Args pulumi.StringArrayInput `pulumi:"args"`
	// Friendly name given to the instance fleet.
	Name pulumi.StringInput `pulumi:"name"`
	// Location of the script to run during a bootstrap action. Can be either a location in Amazon S3 or on a local file system
	Path pulumi.StringInput `pulumi:"path"`
}

func (ClusterBootstrapActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterBootstrapAction)(nil)).Elem()
}

func (i ClusterBootstrapActionArgs) ToClusterBootstrapActionOutput() ClusterBootstrapActionOutput {
	return i.ToClusterBootstrapActionOutputWithContext(context.Background())
}

func (i ClusterBootstrapActionArgs) ToClusterBootstrapActionOutputWithContext(ctx context.Context) ClusterBootstrapActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterBootstrapActionOutput)
}

// ClusterBootstrapActionArrayInput is an input type that accepts ClusterBootstrapActionArray and ClusterBootstrapActionArrayOutput values.
// You can construct a concrete instance of `ClusterBootstrapActionArrayInput` via:
//
//          ClusterBootstrapActionArray{ ClusterBootstrapActionArgs{...} }
type ClusterBootstrapActionArrayInput interface {
	pulumi.Input

	ToClusterBootstrapActionArrayOutput() ClusterBootstrapActionArrayOutput
	ToClusterBootstrapActionArrayOutputWithContext(context.Context) ClusterBootstrapActionArrayOutput
}

type ClusterBootstrapActionArray []ClusterBootstrapActionInput

func (ClusterBootstrapActionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterBootstrapAction)(nil)).Elem()
}

func (i ClusterBootstrapActionArray) ToClusterBootstrapActionArrayOutput() ClusterBootstrapActionArrayOutput {
	return i.ToClusterBootstrapActionArrayOutputWithContext(context.Background())
}

func (i ClusterBootstrapActionArray) ToClusterBootstrapActionArrayOutputWithContext(ctx context.Context) ClusterBootstrapActionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterBootstrapActionArrayOutput)
}

type ClusterBootstrapActionOutput struct{ *pulumi.OutputState }

func (ClusterBootstrapActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterBootstrapAction)(nil)).Elem()
}

func (o ClusterBootstrapActionOutput) ToClusterBootstrapActionOutput() ClusterBootstrapActionOutput {
	return o
}

func (o ClusterBootstrapActionOutput) ToClusterBootstrapActionOutputWithContext(ctx context.Context) ClusterBootstrapActionOutput {
	return o
}

// List of command line arguments passed to the JAR file's main function when executed.
func (o ClusterBootstrapActionOutput) Args() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ClusterBootstrapAction) []string { return v.Args }).(pulumi.StringArrayOutput)
}

// Friendly name given to the instance fleet.
func (o ClusterBootstrapActionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterBootstrapAction) string { return v.Name }).(pulumi.StringOutput)
}

// Location of the script to run during a bootstrap action. Can be either a location in Amazon S3 or on a local file system
func (o ClusterBootstrapActionOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterBootstrapAction) string { return v.Path }).(pulumi.StringOutput)
}

type ClusterBootstrapActionArrayOutput struct{ *pulumi.OutputState }

func (ClusterBootstrapActionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterBootstrapAction)(nil)).Elem()
}

func (o ClusterBootstrapActionArrayOutput) ToClusterBootstrapActionArrayOutput() ClusterBootstrapActionArrayOutput {
	return o
}

func (o ClusterBootstrapActionArrayOutput) ToClusterBootstrapActionArrayOutputWithContext(ctx context.Context) ClusterBootstrapActionArrayOutput {
	return o
}

func (o ClusterBootstrapActionArrayOutput) Index(i pulumi.IntInput) ClusterBootstrapActionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterBootstrapAction {
		return vs[0].([]ClusterBootstrapAction)[vs[1].(int)]
	}).(ClusterBootstrapActionOutput)
}

type ClusterCoreInstanceFleet struct {
	// The ID of the EMR Cluster
	Id *string `pulumi:"id"`
	// Configuration block for instance fleet
	InstanceTypeConfigs []ClusterCoreInstanceFleetInstanceTypeConfig `pulumi:"instanceTypeConfigs"`
	// Configuration block for launch specification
	LaunchSpecifications *ClusterCoreInstanceFleetLaunchSpecifications `pulumi:"launchSpecifications"`
	// Friendly name given to the instance fleet.
	Name                        *string `pulumi:"name"`
	ProvisionedOnDemandCapacity *int    `pulumi:"provisionedOnDemandCapacity"`
	ProvisionedSpotCapacity     *int    `pulumi:"provisionedSpotCapacity"`
	// The target capacity of On-Demand units for the instance fleet, which determines how many On-Demand instances to provision.
	TargetOnDemandCapacity *int `pulumi:"targetOnDemandCapacity"`
	// The target capacity of Spot units for the instance fleet, which determines how many Spot instances to provision.
	TargetSpotCapacity *int `pulumi:"targetSpotCapacity"`
}

// ClusterCoreInstanceFleetInput is an input type that accepts ClusterCoreInstanceFleetArgs and ClusterCoreInstanceFleetOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceFleetInput` via:
//
//          ClusterCoreInstanceFleetArgs{...}
type ClusterCoreInstanceFleetInput interface {
	pulumi.Input

	ToClusterCoreInstanceFleetOutput() ClusterCoreInstanceFleetOutput
	ToClusterCoreInstanceFleetOutputWithContext(context.Context) ClusterCoreInstanceFleetOutput
}

type ClusterCoreInstanceFleetArgs struct {
	// The ID of the EMR Cluster
	Id pulumi.StringPtrInput `pulumi:"id"`
	// Configuration block for instance fleet
	InstanceTypeConfigs ClusterCoreInstanceFleetInstanceTypeConfigArrayInput `pulumi:"instanceTypeConfigs"`
	// Configuration block for launch specification
	LaunchSpecifications ClusterCoreInstanceFleetLaunchSpecificationsPtrInput `pulumi:"launchSpecifications"`
	// Friendly name given to the instance fleet.
	Name                        pulumi.StringPtrInput `pulumi:"name"`
	ProvisionedOnDemandCapacity pulumi.IntPtrInput    `pulumi:"provisionedOnDemandCapacity"`
	ProvisionedSpotCapacity     pulumi.IntPtrInput    `pulumi:"provisionedSpotCapacity"`
	// The target capacity of On-Demand units for the instance fleet, which determines how many On-Demand instances to provision.
	TargetOnDemandCapacity pulumi.IntPtrInput `pulumi:"targetOnDemandCapacity"`
	// The target capacity of Spot units for the instance fleet, which determines how many Spot instances to provision.
	TargetSpotCapacity pulumi.IntPtrInput `pulumi:"targetSpotCapacity"`
}

func (ClusterCoreInstanceFleetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceFleet)(nil)).Elem()
}

func (i ClusterCoreInstanceFleetArgs) ToClusterCoreInstanceFleetOutput() ClusterCoreInstanceFleetOutput {
	return i.ToClusterCoreInstanceFleetOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceFleetArgs) ToClusterCoreInstanceFleetOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceFleetOutput)
}

func (i ClusterCoreInstanceFleetArgs) ToClusterCoreInstanceFleetPtrOutput() ClusterCoreInstanceFleetPtrOutput {
	return i.ToClusterCoreInstanceFleetPtrOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceFleetArgs) ToClusterCoreInstanceFleetPtrOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceFleetOutput).ToClusterCoreInstanceFleetPtrOutputWithContext(ctx)
}

// ClusterCoreInstanceFleetPtrInput is an input type that accepts ClusterCoreInstanceFleetArgs, ClusterCoreInstanceFleetPtr and ClusterCoreInstanceFleetPtrOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceFleetPtrInput` via:
//
//          ClusterCoreInstanceFleetArgs{...}
//
//  or:
//
//          nil
type ClusterCoreInstanceFleetPtrInput interface {
	pulumi.Input

	ToClusterCoreInstanceFleetPtrOutput() ClusterCoreInstanceFleetPtrOutput
	ToClusterCoreInstanceFleetPtrOutputWithContext(context.Context) ClusterCoreInstanceFleetPtrOutput
}

type clusterCoreInstanceFleetPtrType ClusterCoreInstanceFleetArgs

func ClusterCoreInstanceFleetPtr(v *ClusterCoreInstanceFleetArgs) ClusterCoreInstanceFleetPtrInput {
	return (*clusterCoreInstanceFleetPtrType)(v)
}

func (*clusterCoreInstanceFleetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterCoreInstanceFleet)(nil)).Elem()
}

func (i *clusterCoreInstanceFleetPtrType) ToClusterCoreInstanceFleetPtrOutput() ClusterCoreInstanceFleetPtrOutput {
	return i.ToClusterCoreInstanceFleetPtrOutputWithContext(context.Background())
}

func (i *clusterCoreInstanceFleetPtrType) ToClusterCoreInstanceFleetPtrOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceFleetPtrOutput)
}

type ClusterCoreInstanceFleetOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceFleetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceFleet)(nil)).Elem()
}

func (o ClusterCoreInstanceFleetOutput) ToClusterCoreInstanceFleetOutput() ClusterCoreInstanceFleetOutput {
	return o
}

func (o ClusterCoreInstanceFleetOutput) ToClusterCoreInstanceFleetOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetOutput {
	return o
}

func (o ClusterCoreInstanceFleetOutput) ToClusterCoreInstanceFleetPtrOutput() ClusterCoreInstanceFleetPtrOutput {
	return o.ToClusterCoreInstanceFleetPtrOutputWithContext(context.Background())
}

func (o ClusterCoreInstanceFleetOutput) ToClusterCoreInstanceFleetPtrOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleet) *ClusterCoreInstanceFleet {
		return &v
	}).(ClusterCoreInstanceFleetPtrOutput)
}

// The ID of the EMR Cluster
func (o ClusterCoreInstanceFleetOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleet) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// Configuration block for instance fleet
func (o ClusterCoreInstanceFleetOutput) InstanceTypeConfigs() ClusterCoreInstanceFleetInstanceTypeConfigArrayOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleet) []ClusterCoreInstanceFleetInstanceTypeConfig {
		return v.InstanceTypeConfigs
	}).(ClusterCoreInstanceFleetInstanceTypeConfigArrayOutput)
}

// Configuration block for launch specification
func (o ClusterCoreInstanceFleetOutput) LaunchSpecifications() ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleet) *ClusterCoreInstanceFleetLaunchSpecifications {
		return v.LaunchSpecifications
	}).(ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput)
}

// Friendly name given to the instance fleet.
func (o ClusterCoreInstanceFleetOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleet) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o ClusterCoreInstanceFleetOutput) ProvisionedOnDemandCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleet) *int { return v.ProvisionedOnDemandCapacity }).(pulumi.IntPtrOutput)
}

func (o ClusterCoreInstanceFleetOutput) ProvisionedSpotCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleet) *int { return v.ProvisionedSpotCapacity }).(pulumi.IntPtrOutput)
}

// The target capacity of On-Demand units for the instance fleet, which determines how many On-Demand instances to provision.
func (o ClusterCoreInstanceFleetOutput) TargetOnDemandCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleet) *int { return v.TargetOnDemandCapacity }).(pulumi.IntPtrOutput)
}

// The target capacity of Spot units for the instance fleet, which determines how many Spot instances to provision.
func (o ClusterCoreInstanceFleetOutput) TargetSpotCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleet) *int { return v.TargetSpotCapacity }).(pulumi.IntPtrOutput)
}

type ClusterCoreInstanceFleetPtrOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceFleetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterCoreInstanceFleet)(nil)).Elem()
}

func (o ClusterCoreInstanceFleetPtrOutput) ToClusterCoreInstanceFleetPtrOutput() ClusterCoreInstanceFleetPtrOutput {
	return o
}

func (o ClusterCoreInstanceFleetPtrOutput) ToClusterCoreInstanceFleetPtrOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetPtrOutput {
	return o
}

func (o ClusterCoreInstanceFleetPtrOutput) Elem() ClusterCoreInstanceFleetOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceFleet) ClusterCoreInstanceFleet { return *v }).(ClusterCoreInstanceFleetOutput)
}

// The ID of the EMR Cluster
func (o ClusterCoreInstanceFleetPtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceFleet) *string {
		if v == nil {
			return nil
		}
		return v.Id
	}).(pulumi.StringPtrOutput)
}

// Configuration block for instance fleet
func (o ClusterCoreInstanceFleetPtrOutput) InstanceTypeConfigs() ClusterCoreInstanceFleetInstanceTypeConfigArrayOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceFleet) []ClusterCoreInstanceFleetInstanceTypeConfig {
		if v == nil {
			return nil
		}
		return v.InstanceTypeConfigs
	}).(ClusterCoreInstanceFleetInstanceTypeConfigArrayOutput)
}

// Configuration block for launch specification
func (o ClusterCoreInstanceFleetPtrOutput) LaunchSpecifications() ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceFleet) *ClusterCoreInstanceFleetLaunchSpecifications {
		if v == nil {
			return nil
		}
		return v.LaunchSpecifications
	}).(ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput)
}

// Friendly name given to the instance fleet.
func (o ClusterCoreInstanceFleetPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceFleet) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o ClusterCoreInstanceFleetPtrOutput) ProvisionedOnDemandCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceFleet) *int {
		if v == nil {
			return nil
		}
		return v.ProvisionedOnDemandCapacity
	}).(pulumi.IntPtrOutput)
}

func (o ClusterCoreInstanceFleetPtrOutput) ProvisionedSpotCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceFleet) *int {
		if v == nil {
			return nil
		}
		return v.ProvisionedSpotCapacity
	}).(pulumi.IntPtrOutput)
}

// The target capacity of On-Demand units for the instance fleet, which determines how many On-Demand instances to provision.
func (o ClusterCoreInstanceFleetPtrOutput) TargetOnDemandCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceFleet) *int {
		if v == nil {
			return nil
		}
		return v.TargetOnDemandCapacity
	}).(pulumi.IntPtrOutput)
}

// The target capacity of Spot units for the instance fleet, which determines how many Spot instances to provision.
func (o ClusterCoreInstanceFleetPtrOutput) TargetSpotCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceFleet) *int {
		if v == nil {
			return nil
		}
		return v.TargetSpotCapacity
	}).(pulumi.IntPtrOutput)
}

type ClusterCoreInstanceFleetInstanceTypeConfig struct {
	// The bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
	BidPrice *string `pulumi:"bidPrice"`
	// The bid price, as a percentage of On-Demand price, for each EC2 Spot instance as defined by `instanceType`. Expressed as a number (for example, 20 specifies 20%). If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
	BidPriceAsPercentageOfOnDemandPrice *float64 `pulumi:"bidPriceAsPercentageOfOnDemandPrice"`
	// A configuration classification that applies when provisioning cluster instances, which can include configurations for applications and software that run on the cluster. List of `configuration` blocks.
	Configurations []ClusterCoreInstanceFleetInstanceTypeConfigConfiguration `pulumi:"configurations"`
	// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
	EbsConfigs []ClusterCoreInstanceFleetInstanceTypeConfigEbsConfig `pulumi:"ebsConfigs"`
	// An EC2 instance type, such as m4.xlarge.
	InstanceType string `pulumi:"instanceType"`
	// The number of units that a provisioned instance of this type provides toward fulfilling the target capacities defined in `emr.InstanceFleet`.
	WeightedCapacity *int `pulumi:"weightedCapacity"`
}

// ClusterCoreInstanceFleetInstanceTypeConfigInput is an input type that accepts ClusterCoreInstanceFleetInstanceTypeConfigArgs and ClusterCoreInstanceFleetInstanceTypeConfigOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceFleetInstanceTypeConfigInput` via:
//
//          ClusterCoreInstanceFleetInstanceTypeConfigArgs{...}
type ClusterCoreInstanceFleetInstanceTypeConfigInput interface {
	pulumi.Input

	ToClusterCoreInstanceFleetInstanceTypeConfigOutput() ClusterCoreInstanceFleetInstanceTypeConfigOutput
	ToClusterCoreInstanceFleetInstanceTypeConfigOutputWithContext(context.Context) ClusterCoreInstanceFleetInstanceTypeConfigOutput
}

type ClusterCoreInstanceFleetInstanceTypeConfigArgs struct {
	// The bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
	BidPrice pulumi.StringPtrInput `pulumi:"bidPrice"`
	// The bid price, as a percentage of On-Demand price, for each EC2 Spot instance as defined by `instanceType`. Expressed as a number (for example, 20 specifies 20%). If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
	BidPriceAsPercentageOfOnDemandPrice pulumi.Float64PtrInput `pulumi:"bidPriceAsPercentageOfOnDemandPrice"`
	// A configuration classification that applies when provisioning cluster instances, which can include configurations for applications and software that run on the cluster. List of `configuration` blocks.
	Configurations ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayInput `pulumi:"configurations"`
	// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
	EbsConfigs ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayInput `pulumi:"ebsConfigs"`
	// An EC2 instance type, such as m4.xlarge.
	InstanceType pulumi.StringInput `pulumi:"instanceType"`
	// The number of units that a provisioned instance of this type provides toward fulfilling the target capacities defined in `emr.InstanceFleet`.
	WeightedCapacity pulumi.IntPtrInput `pulumi:"weightedCapacity"`
}

func (ClusterCoreInstanceFleetInstanceTypeConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceFleetInstanceTypeConfig)(nil)).Elem()
}

func (i ClusterCoreInstanceFleetInstanceTypeConfigArgs) ToClusterCoreInstanceFleetInstanceTypeConfigOutput() ClusterCoreInstanceFleetInstanceTypeConfigOutput {
	return i.ToClusterCoreInstanceFleetInstanceTypeConfigOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceFleetInstanceTypeConfigArgs) ToClusterCoreInstanceFleetInstanceTypeConfigOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetInstanceTypeConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceFleetInstanceTypeConfigOutput)
}

// ClusterCoreInstanceFleetInstanceTypeConfigArrayInput is an input type that accepts ClusterCoreInstanceFleetInstanceTypeConfigArray and ClusterCoreInstanceFleetInstanceTypeConfigArrayOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceFleetInstanceTypeConfigArrayInput` via:
//
//          ClusterCoreInstanceFleetInstanceTypeConfigArray{ ClusterCoreInstanceFleetInstanceTypeConfigArgs{...} }
type ClusterCoreInstanceFleetInstanceTypeConfigArrayInput interface {
	pulumi.Input

	ToClusterCoreInstanceFleetInstanceTypeConfigArrayOutput() ClusterCoreInstanceFleetInstanceTypeConfigArrayOutput
	ToClusterCoreInstanceFleetInstanceTypeConfigArrayOutputWithContext(context.Context) ClusterCoreInstanceFleetInstanceTypeConfigArrayOutput
}

type ClusterCoreInstanceFleetInstanceTypeConfigArray []ClusterCoreInstanceFleetInstanceTypeConfigInput

func (ClusterCoreInstanceFleetInstanceTypeConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterCoreInstanceFleetInstanceTypeConfig)(nil)).Elem()
}

func (i ClusterCoreInstanceFleetInstanceTypeConfigArray) ToClusterCoreInstanceFleetInstanceTypeConfigArrayOutput() ClusterCoreInstanceFleetInstanceTypeConfigArrayOutput {
	return i.ToClusterCoreInstanceFleetInstanceTypeConfigArrayOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceFleetInstanceTypeConfigArray) ToClusterCoreInstanceFleetInstanceTypeConfigArrayOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetInstanceTypeConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceFleetInstanceTypeConfigArrayOutput)
}

type ClusterCoreInstanceFleetInstanceTypeConfigOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceFleetInstanceTypeConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceFleetInstanceTypeConfig)(nil)).Elem()
}

func (o ClusterCoreInstanceFleetInstanceTypeConfigOutput) ToClusterCoreInstanceFleetInstanceTypeConfigOutput() ClusterCoreInstanceFleetInstanceTypeConfigOutput {
	return o
}

func (o ClusterCoreInstanceFleetInstanceTypeConfigOutput) ToClusterCoreInstanceFleetInstanceTypeConfigOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetInstanceTypeConfigOutput {
	return o
}

// The bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
func (o ClusterCoreInstanceFleetInstanceTypeConfigOutput) BidPrice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleetInstanceTypeConfig) *string { return v.BidPrice }).(pulumi.StringPtrOutput)
}

// The bid price, as a percentage of On-Demand price, for each EC2 Spot instance as defined by `instanceType`. Expressed as a number (for example, 20 specifies 20%). If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
func (o ClusterCoreInstanceFleetInstanceTypeConfigOutput) BidPriceAsPercentageOfOnDemandPrice() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleetInstanceTypeConfig) *float64 {
		return v.BidPriceAsPercentageOfOnDemandPrice
	}).(pulumi.Float64PtrOutput)
}

// A configuration classification that applies when provisioning cluster instances, which can include configurations for applications and software that run on the cluster. List of `configuration` blocks.
func (o ClusterCoreInstanceFleetInstanceTypeConfigOutput) Configurations() ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleetInstanceTypeConfig) []ClusterCoreInstanceFleetInstanceTypeConfigConfiguration {
		return v.Configurations
	}).(ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutput)
}

// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
func (o ClusterCoreInstanceFleetInstanceTypeConfigOutput) EbsConfigs() ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleetInstanceTypeConfig) []ClusterCoreInstanceFleetInstanceTypeConfigEbsConfig {
		return v.EbsConfigs
	}).(ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutput)
}

// An EC2 instance type, such as m4.xlarge.
func (o ClusterCoreInstanceFleetInstanceTypeConfigOutput) InstanceType() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleetInstanceTypeConfig) string { return v.InstanceType }).(pulumi.StringOutput)
}

// The number of units that a provisioned instance of this type provides toward fulfilling the target capacities defined in `emr.InstanceFleet`.
func (o ClusterCoreInstanceFleetInstanceTypeConfigOutput) WeightedCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleetInstanceTypeConfig) *int { return v.WeightedCapacity }).(pulumi.IntPtrOutput)
}

type ClusterCoreInstanceFleetInstanceTypeConfigArrayOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceFleetInstanceTypeConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterCoreInstanceFleetInstanceTypeConfig)(nil)).Elem()
}

func (o ClusterCoreInstanceFleetInstanceTypeConfigArrayOutput) ToClusterCoreInstanceFleetInstanceTypeConfigArrayOutput() ClusterCoreInstanceFleetInstanceTypeConfigArrayOutput {
	return o
}

func (o ClusterCoreInstanceFleetInstanceTypeConfigArrayOutput) ToClusterCoreInstanceFleetInstanceTypeConfigArrayOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetInstanceTypeConfigArrayOutput {
	return o
}

func (o ClusterCoreInstanceFleetInstanceTypeConfigArrayOutput) Index(i pulumi.IntInput) ClusterCoreInstanceFleetInstanceTypeConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterCoreInstanceFleetInstanceTypeConfig {
		return vs[0].([]ClusterCoreInstanceFleetInstanceTypeConfig)[vs[1].(int)]
	}).(ClusterCoreInstanceFleetInstanceTypeConfigOutput)
}

type ClusterCoreInstanceFleetInstanceTypeConfigConfiguration struct {
	// The classification within a configuration.
	Classification *string `pulumi:"classification"`
	// A map of properties specified within a configuration classification
	Properties map[string]interface{} `pulumi:"properties"`
}

// ClusterCoreInstanceFleetInstanceTypeConfigConfigurationInput is an input type that accepts ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArgs and ClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceFleetInstanceTypeConfigConfigurationInput` via:
//
//          ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArgs{...}
type ClusterCoreInstanceFleetInstanceTypeConfigConfigurationInput interface {
	pulumi.Input

	ToClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutput() ClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutput
	ToClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutputWithContext(context.Context) ClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutput
}

type ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArgs struct {
	// The classification within a configuration.
	Classification pulumi.StringPtrInput `pulumi:"classification"`
	// A map of properties specified within a configuration classification
	Properties pulumi.MapInput `pulumi:"properties"`
}

func (ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceFleetInstanceTypeConfigConfiguration)(nil)).Elem()
}

func (i ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArgs) ToClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutput() ClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutput {
	return i.ToClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArgs) ToClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutput)
}

// ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayInput is an input type that accepts ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArray and ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayInput` via:
//
//          ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArray{ ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArgs{...} }
type ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayInput interface {
	pulumi.Input

	ToClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutput() ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutput
	ToClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutputWithContext(context.Context) ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutput
}

type ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArray []ClusterCoreInstanceFleetInstanceTypeConfigConfigurationInput

func (ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterCoreInstanceFleetInstanceTypeConfigConfiguration)(nil)).Elem()
}

func (i ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArray) ToClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutput() ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutput {
	return i.ToClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArray) ToClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutput)
}

type ClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceFleetInstanceTypeConfigConfiguration)(nil)).Elem()
}

func (o ClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutput) ToClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutput() ClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutput {
	return o
}

func (o ClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutput) ToClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutput {
	return o
}

// The classification within a configuration.
func (o ClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutput) Classification() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleetInstanceTypeConfigConfiguration) *string { return v.Classification }).(pulumi.StringPtrOutput)
}

// A map of properties specified within a configuration classification
func (o ClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutput) Properties() pulumi.MapOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleetInstanceTypeConfigConfiguration) map[string]interface{} {
		return v.Properties
	}).(pulumi.MapOutput)
}

type ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterCoreInstanceFleetInstanceTypeConfigConfiguration)(nil)).Elem()
}

func (o ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutput) ToClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutput() ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutput {
	return o
}

func (o ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutput) ToClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutput {
	return o
}

func (o ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutput) Index(i pulumi.IntInput) ClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterCoreInstanceFleetInstanceTypeConfigConfiguration {
		return vs[0].([]ClusterCoreInstanceFleetInstanceTypeConfigConfiguration)[vs[1].(int)]
	}).(ClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutput)
}

type ClusterCoreInstanceFleetInstanceTypeConfigEbsConfig struct {
	// The number of I/O operations per second (IOPS) that the volume supports
	Iops *int `pulumi:"iops"`
	// The volume size, in gibibytes (GiB).
	Size int `pulumi:"size"`
	// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
	Type string `pulumi:"type"`
	// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
	VolumesPerInstance *int `pulumi:"volumesPerInstance"`
}

// ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigInput is an input type that accepts ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs and ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigInput` via:
//
//          ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs{...}
type ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigInput interface {
	pulumi.Input

	ToClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput() ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput
	ToClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutputWithContext(context.Context) ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput
}

type ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs struct {
	// The number of I/O operations per second (IOPS) that the volume supports
	Iops pulumi.IntPtrInput `pulumi:"iops"`
	// The volume size, in gibibytes (GiB).
	Size pulumi.IntInput `pulumi:"size"`
	// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
	Type pulumi.StringInput `pulumi:"type"`
	// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
	VolumesPerInstance pulumi.IntPtrInput `pulumi:"volumesPerInstance"`
}

func (ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceFleetInstanceTypeConfigEbsConfig)(nil)).Elem()
}

func (i ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs) ToClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput() ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput {
	return i.ToClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs) ToClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput)
}

// ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayInput is an input type that accepts ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArray and ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayInput` via:
//
//          ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArray{ ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs{...} }
type ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayInput interface {
	pulumi.Input

	ToClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutput() ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutput
	ToClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutputWithContext(context.Context) ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutput
}

type ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArray []ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigInput

func (ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterCoreInstanceFleetInstanceTypeConfigEbsConfig)(nil)).Elem()
}

func (i ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArray) ToClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutput() ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutput {
	return i.ToClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArray) ToClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutput)
}

type ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceFleetInstanceTypeConfigEbsConfig)(nil)).Elem()
}

func (o ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput) ToClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput() ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput {
	return o
}

func (o ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput) ToClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput {
	return o
}

// The number of I/O operations per second (IOPS) that the volume supports
func (o ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput) Iops() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleetInstanceTypeConfigEbsConfig) *int { return v.Iops }).(pulumi.IntPtrOutput)
}

// The volume size, in gibibytes (GiB).
func (o ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleetInstanceTypeConfigEbsConfig) int { return v.Size }).(pulumi.IntOutput)
}

// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
func (o ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleetInstanceTypeConfigEbsConfig) string { return v.Type }).(pulumi.StringOutput)
}

// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
func (o ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput) VolumesPerInstance() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleetInstanceTypeConfigEbsConfig) *int { return v.VolumesPerInstance }).(pulumi.IntPtrOutput)
}

type ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterCoreInstanceFleetInstanceTypeConfigEbsConfig)(nil)).Elem()
}

func (o ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutput) ToClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutput() ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutput {
	return o
}

func (o ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutput) ToClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutput {
	return o
}

func (o ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutput) Index(i pulumi.IntInput) ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterCoreInstanceFleetInstanceTypeConfigEbsConfig {
		return vs[0].([]ClusterCoreInstanceFleetInstanceTypeConfigEbsConfig)[vs[1].(int)]
	}).(ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput)
}

type ClusterCoreInstanceFleetLaunchSpecifications struct {
	// Configuration block for on demand instances launch specifications
	OnDemandSpecifications []ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecification `pulumi:"onDemandSpecifications"`
	// Configuration block for spot instances launch specifications
	SpotSpecifications []ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecification `pulumi:"spotSpecifications"`
}

// ClusterCoreInstanceFleetLaunchSpecificationsInput is an input type that accepts ClusterCoreInstanceFleetLaunchSpecificationsArgs and ClusterCoreInstanceFleetLaunchSpecificationsOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceFleetLaunchSpecificationsInput` via:
//
//          ClusterCoreInstanceFleetLaunchSpecificationsArgs{...}
type ClusterCoreInstanceFleetLaunchSpecificationsInput interface {
	pulumi.Input

	ToClusterCoreInstanceFleetLaunchSpecificationsOutput() ClusterCoreInstanceFleetLaunchSpecificationsOutput
	ToClusterCoreInstanceFleetLaunchSpecificationsOutputWithContext(context.Context) ClusterCoreInstanceFleetLaunchSpecificationsOutput
}

type ClusterCoreInstanceFleetLaunchSpecificationsArgs struct {
	// Configuration block for on demand instances launch specifications
	OnDemandSpecifications ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayInput `pulumi:"onDemandSpecifications"`
	// Configuration block for spot instances launch specifications
	SpotSpecifications ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayInput `pulumi:"spotSpecifications"`
}

func (ClusterCoreInstanceFleetLaunchSpecificationsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceFleetLaunchSpecifications)(nil)).Elem()
}

func (i ClusterCoreInstanceFleetLaunchSpecificationsArgs) ToClusterCoreInstanceFleetLaunchSpecificationsOutput() ClusterCoreInstanceFleetLaunchSpecificationsOutput {
	return i.ToClusterCoreInstanceFleetLaunchSpecificationsOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceFleetLaunchSpecificationsArgs) ToClusterCoreInstanceFleetLaunchSpecificationsOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetLaunchSpecificationsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceFleetLaunchSpecificationsOutput)
}

func (i ClusterCoreInstanceFleetLaunchSpecificationsArgs) ToClusterCoreInstanceFleetLaunchSpecificationsPtrOutput() ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput {
	return i.ToClusterCoreInstanceFleetLaunchSpecificationsPtrOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceFleetLaunchSpecificationsArgs) ToClusterCoreInstanceFleetLaunchSpecificationsPtrOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceFleetLaunchSpecificationsOutput).ToClusterCoreInstanceFleetLaunchSpecificationsPtrOutputWithContext(ctx)
}

// ClusterCoreInstanceFleetLaunchSpecificationsPtrInput is an input type that accepts ClusterCoreInstanceFleetLaunchSpecificationsArgs, ClusterCoreInstanceFleetLaunchSpecificationsPtr and ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceFleetLaunchSpecificationsPtrInput` via:
//
//          ClusterCoreInstanceFleetLaunchSpecificationsArgs{...}
//
//  or:
//
//          nil
type ClusterCoreInstanceFleetLaunchSpecificationsPtrInput interface {
	pulumi.Input

	ToClusterCoreInstanceFleetLaunchSpecificationsPtrOutput() ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput
	ToClusterCoreInstanceFleetLaunchSpecificationsPtrOutputWithContext(context.Context) ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput
}

type clusterCoreInstanceFleetLaunchSpecificationsPtrType ClusterCoreInstanceFleetLaunchSpecificationsArgs

func ClusterCoreInstanceFleetLaunchSpecificationsPtr(v *ClusterCoreInstanceFleetLaunchSpecificationsArgs) ClusterCoreInstanceFleetLaunchSpecificationsPtrInput {
	return (*clusterCoreInstanceFleetLaunchSpecificationsPtrType)(v)
}

func (*clusterCoreInstanceFleetLaunchSpecificationsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterCoreInstanceFleetLaunchSpecifications)(nil)).Elem()
}

func (i *clusterCoreInstanceFleetLaunchSpecificationsPtrType) ToClusterCoreInstanceFleetLaunchSpecificationsPtrOutput() ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput {
	return i.ToClusterCoreInstanceFleetLaunchSpecificationsPtrOutputWithContext(context.Background())
}

func (i *clusterCoreInstanceFleetLaunchSpecificationsPtrType) ToClusterCoreInstanceFleetLaunchSpecificationsPtrOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput)
}

type ClusterCoreInstanceFleetLaunchSpecificationsOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceFleetLaunchSpecificationsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceFleetLaunchSpecifications)(nil)).Elem()
}

func (o ClusterCoreInstanceFleetLaunchSpecificationsOutput) ToClusterCoreInstanceFleetLaunchSpecificationsOutput() ClusterCoreInstanceFleetLaunchSpecificationsOutput {
	return o
}

func (o ClusterCoreInstanceFleetLaunchSpecificationsOutput) ToClusterCoreInstanceFleetLaunchSpecificationsOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetLaunchSpecificationsOutput {
	return o
}

func (o ClusterCoreInstanceFleetLaunchSpecificationsOutput) ToClusterCoreInstanceFleetLaunchSpecificationsPtrOutput() ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput {
	return o.ToClusterCoreInstanceFleetLaunchSpecificationsPtrOutputWithContext(context.Background())
}

func (o ClusterCoreInstanceFleetLaunchSpecificationsOutput) ToClusterCoreInstanceFleetLaunchSpecificationsPtrOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleetLaunchSpecifications) *ClusterCoreInstanceFleetLaunchSpecifications {
		return &v
	}).(ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput)
}

// Configuration block for on demand instances launch specifications
func (o ClusterCoreInstanceFleetLaunchSpecificationsOutput) OnDemandSpecifications() ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleetLaunchSpecifications) []ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecification {
		return v.OnDemandSpecifications
	}).(ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput)
}

// Configuration block for spot instances launch specifications
func (o ClusterCoreInstanceFleetLaunchSpecificationsOutput) SpotSpecifications() ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleetLaunchSpecifications) []ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecification {
		return v.SpotSpecifications
	}).(ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput)
}

type ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterCoreInstanceFleetLaunchSpecifications)(nil)).Elem()
}

func (o ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput) ToClusterCoreInstanceFleetLaunchSpecificationsPtrOutput() ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput {
	return o
}

func (o ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput) ToClusterCoreInstanceFleetLaunchSpecificationsPtrOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput {
	return o
}

func (o ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput) Elem() ClusterCoreInstanceFleetLaunchSpecificationsOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceFleetLaunchSpecifications) ClusterCoreInstanceFleetLaunchSpecifications {
		return *v
	}).(ClusterCoreInstanceFleetLaunchSpecificationsOutput)
}

// Configuration block for on demand instances launch specifications
func (o ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput) OnDemandSpecifications() ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceFleetLaunchSpecifications) []ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecification {
		if v == nil {
			return nil
		}
		return v.OnDemandSpecifications
	}).(ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput)
}

// Configuration block for spot instances launch specifications
func (o ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput) SpotSpecifications() ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceFleetLaunchSpecifications) []ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecification {
		if v == nil {
			return nil
		}
		return v.SpotSpecifications
	}).(ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput)
}

type ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecification struct {
	// Specifies the strategy to use in launching Spot instance fleets. Currently, the only option is `capacity-optimized` (the default), which launches instances from Spot instance pools with optimal capacity for the number of instances that are launching.
	AllocationStrategy string `pulumi:"allocationStrategy"`
}

// ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationInput is an input type that accepts ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs and ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationInput` via:
//
//          ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs{...}
type ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationInput interface {
	pulumi.Input

	ToClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput() ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput
	ToClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutputWithContext(context.Context) ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput
}

type ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs struct {
	// Specifies the strategy to use in launching Spot instance fleets. Currently, the only option is `capacity-optimized` (the default), which launches instances from Spot instance pools with optimal capacity for the number of instances that are launching.
	AllocationStrategy pulumi.StringInput `pulumi:"allocationStrategy"`
}

func (ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecification)(nil)).Elem()
}

func (i ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs) ToClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput() ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput {
	return i.ToClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs) ToClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput)
}

// ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayInput is an input type that accepts ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArray and ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayInput` via:
//
//          ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArray{ ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs{...} }
type ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayInput interface {
	pulumi.Input

	ToClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput() ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput
	ToClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutputWithContext(context.Context) ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput
}

type ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArray []ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationInput

func (ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecification)(nil)).Elem()
}

func (i ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArray) ToClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput() ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput {
	return i.ToClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArray) ToClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput)
}

type ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecification)(nil)).Elem()
}

func (o ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput) ToClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput() ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput {
	return o
}

func (o ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput) ToClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput {
	return o
}

// Specifies the strategy to use in launching Spot instance fleets. Currently, the only option is `capacity-optimized` (the default), which launches instances from Spot instance pools with optimal capacity for the number of instances that are launching.
func (o ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput) AllocationStrategy() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecification) string {
		return v.AllocationStrategy
	}).(pulumi.StringOutput)
}

type ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecification)(nil)).Elem()
}

func (o ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput) ToClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput() ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput {
	return o
}

func (o ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput) ToClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput {
	return o
}

func (o ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput) Index(i pulumi.IntInput) ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecification {
		return vs[0].([]ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecification)[vs[1].(int)]
	}).(ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput)
}

type ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecification struct {
	// Specifies the strategy to use in launching Spot instance fleets. Currently, the only option is `capacity-optimized` (the default), which launches instances from Spot instance pools with optimal capacity for the number of instances that are launching.
	AllocationStrategy string `pulumi:"allocationStrategy"`
	// The defined duration for Spot instances (also known as Spot blocks) in minutes. When specified, the Spot instance does not terminate before the defined duration expires, and defined duration pricing for Spot instances applies. Valid values are 60, 120, 180, 240, 300, or 360. The duration period starts as soon as a Spot instance receives its instance ID. At the end of the duration, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates.
	BlockDurationMinutes *int `pulumi:"blockDurationMinutes"`
	// The action to take when TargetSpotCapacity has not been fulfilled when the TimeoutDurationMinutes has expired; that is, when all Spot instances could not be provisioned within the Spot provisioning timeout. Valid values are `TERMINATE_CLUSTER` and `SWITCH_TO_ON_DEMAND`. SWITCH_TO_ON_DEMAND specifies that if no Spot instances are available, On-Demand Instances should be provisioned to fulfill any remaining Spot capacity.
	TimeoutAction string `pulumi:"timeoutAction"`
	// The spot provisioning timeout period in minutes. If Spot instances are not provisioned within this time period, the TimeOutAction is taken. Minimum value is 5 and maximum value is 1440. The timeout applies only during initial provisioning, when the cluster is first created.
	TimeoutDurationMinutes int `pulumi:"timeoutDurationMinutes"`
}

// ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationInput is an input type that accepts ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArgs and ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationInput` via:
//
//          ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArgs{...}
type ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationInput interface {
	pulumi.Input

	ToClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput() ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput
	ToClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutputWithContext(context.Context) ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput
}

type ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArgs struct {
	// Specifies the strategy to use in launching Spot instance fleets. Currently, the only option is `capacity-optimized` (the default), which launches instances from Spot instance pools with optimal capacity for the number of instances that are launching.
	AllocationStrategy pulumi.StringInput `pulumi:"allocationStrategy"`
	// The defined duration for Spot instances (also known as Spot blocks) in minutes. When specified, the Spot instance does not terminate before the defined duration expires, and defined duration pricing for Spot instances applies. Valid values are 60, 120, 180, 240, 300, or 360. The duration period starts as soon as a Spot instance receives its instance ID. At the end of the duration, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates.
	BlockDurationMinutes pulumi.IntPtrInput `pulumi:"blockDurationMinutes"`
	// The action to take when TargetSpotCapacity has not been fulfilled when the TimeoutDurationMinutes has expired; that is, when all Spot instances could not be provisioned within the Spot provisioning timeout. Valid values are `TERMINATE_CLUSTER` and `SWITCH_TO_ON_DEMAND`. SWITCH_TO_ON_DEMAND specifies that if no Spot instances are available, On-Demand Instances should be provisioned to fulfill any remaining Spot capacity.
	TimeoutAction pulumi.StringInput `pulumi:"timeoutAction"`
	// The spot provisioning timeout period in minutes. If Spot instances are not provisioned within this time period, the TimeOutAction is taken. Minimum value is 5 and maximum value is 1440. The timeout applies only during initial provisioning, when the cluster is first created.
	TimeoutDurationMinutes pulumi.IntInput `pulumi:"timeoutDurationMinutes"`
}

func (ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecification)(nil)).Elem()
}

func (i ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArgs) ToClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput() ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput {
	return i.ToClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArgs) ToClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput)
}

// ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayInput is an input type that accepts ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArray and ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayInput` via:
//
//          ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArray{ ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArgs{...} }
type ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayInput interface {
	pulumi.Input

	ToClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput() ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput
	ToClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutputWithContext(context.Context) ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput
}

type ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArray []ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationInput

func (ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecification)(nil)).Elem()
}

func (i ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArray) ToClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput() ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput {
	return i.ToClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArray) ToClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput)
}

type ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecification)(nil)).Elem()
}

func (o ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput) ToClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput() ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput {
	return o
}

func (o ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput) ToClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput {
	return o
}

// Specifies the strategy to use in launching Spot instance fleets. Currently, the only option is `capacity-optimized` (the default), which launches instances from Spot instance pools with optimal capacity for the number of instances that are launching.
func (o ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput) AllocationStrategy() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecification) string {
		return v.AllocationStrategy
	}).(pulumi.StringOutput)
}

// The defined duration for Spot instances (also known as Spot blocks) in minutes. When specified, the Spot instance does not terminate before the defined duration expires, and defined duration pricing for Spot instances applies. Valid values are 60, 120, 180, 240, 300, or 360. The duration period starts as soon as a Spot instance receives its instance ID. At the end of the duration, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates.
func (o ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput) BlockDurationMinutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecification) *int {
		return v.BlockDurationMinutes
	}).(pulumi.IntPtrOutput)
}

// The action to take when TargetSpotCapacity has not been fulfilled when the TimeoutDurationMinutes has expired; that is, when all Spot instances could not be provisioned within the Spot provisioning timeout. Valid values are `TERMINATE_CLUSTER` and `SWITCH_TO_ON_DEMAND`. SWITCH_TO_ON_DEMAND specifies that if no Spot instances are available, On-Demand Instances should be provisioned to fulfill any remaining Spot capacity.
func (o ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput) TimeoutAction() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecification) string { return v.TimeoutAction }).(pulumi.StringOutput)
}

// The spot provisioning timeout period in minutes. If Spot instances are not provisioned within this time period, the TimeOutAction is taken. Minimum value is 5 and maximum value is 1440. The timeout applies only during initial provisioning, when the cluster is first created.
func (o ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput) TimeoutDurationMinutes() pulumi.IntOutput {
	return o.ApplyT(func(v ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecification) int {
		return v.TimeoutDurationMinutes
	}).(pulumi.IntOutput)
}

type ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecification)(nil)).Elem()
}

func (o ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput) ToClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput() ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput {
	return o
}

func (o ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput) ToClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutputWithContext(ctx context.Context) ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput {
	return o
}

func (o ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput) Index(i pulumi.IntInput) ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecification {
		return vs[0].([]ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecification)[vs[1].(int)]
	}).(ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput)
}

type ClusterCoreInstanceGroup struct {
	// String containing the [EMR Auto Scaling Policy](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-automatic-scaling.html) JSON.
	AutoscalingPolicy *string `pulumi:"autoscalingPolicy"`
	// The bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
	BidPrice *string `pulumi:"bidPrice"`
	// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
	EbsConfigs []ClusterCoreInstanceGroupEbsConfig `pulumi:"ebsConfigs"`
	// The ID of the EMR Cluster
	Id *string `pulumi:"id"`
	// Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have `map public IP on launch` enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
	InstanceCount *int `pulumi:"instanceCount"`
	// An EC2 instance type, such as m4.xlarge.
	InstanceType string `pulumi:"instanceType"`
	// Friendly name given to the instance fleet.
	Name *string `pulumi:"name"`
}

// ClusterCoreInstanceGroupInput is an input type that accepts ClusterCoreInstanceGroupArgs and ClusterCoreInstanceGroupOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceGroupInput` via:
//
//          ClusterCoreInstanceGroupArgs{...}
type ClusterCoreInstanceGroupInput interface {
	pulumi.Input

	ToClusterCoreInstanceGroupOutput() ClusterCoreInstanceGroupOutput
	ToClusterCoreInstanceGroupOutputWithContext(context.Context) ClusterCoreInstanceGroupOutput
}

type ClusterCoreInstanceGroupArgs struct {
	// String containing the [EMR Auto Scaling Policy](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-automatic-scaling.html) JSON.
	AutoscalingPolicy pulumi.StringPtrInput `pulumi:"autoscalingPolicy"`
	// The bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
	BidPrice pulumi.StringPtrInput `pulumi:"bidPrice"`
	// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
	EbsConfigs ClusterCoreInstanceGroupEbsConfigArrayInput `pulumi:"ebsConfigs"`
	// The ID of the EMR Cluster
	Id pulumi.StringPtrInput `pulumi:"id"`
	// Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have `map public IP on launch` enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
	InstanceCount pulumi.IntPtrInput `pulumi:"instanceCount"`
	// An EC2 instance type, such as m4.xlarge.
	InstanceType pulumi.StringInput `pulumi:"instanceType"`
	// Friendly name given to the instance fleet.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ClusterCoreInstanceGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceGroup)(nil)).Elem()
}

func (i ClusterCoreInstanceGroupArgs) ToClusterCoreInstanceGroupOutput() ClusterCoreInstanceGroupOutput {
	return i.ToClusterCoreInstanceGroupOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceGroupArgs) ToClusterCoreInstanceGroupOutputWithContext(ctx context.Context) ClusterCoreInstanceGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceGroupOutput)
}

func (i ClusterCoreInstanceGroupArgs) ToClusterCoreInstanceGroupPtrOutput() ClusterCoreInstanceGroupPtrOutput {
	return i.ToClusterCoreInstanceGroupPtrOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceGroupArgs) ToClusterCoreInstanceGroupPtrOutputWithContext(ctx context.Context) ClusterCoreInstanceGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceGroupOutput).ToClusterCoreInstanceGroupPtrOutputWithContext(ctx)
}

// ClusterCoreInstanceGroupPtrInput is an input type that accepts ClusterCoreInstanceGroupArgs, ClusterCoreInstanceGroupPtr and ClusterCoreInstanceGroupPtrOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceGroupPtrInput` via:
//
//          ClusterCoreInstanceGroupArgs{...}
//
//  or:
//
//          nil
type ClusterCoreInstanceGroupPtrInput interface {
	pulumi.Input

	ToClusterCoreInstanceGroupPtrOutput() ClusterCoreInstanceGroupPtrOutput
	ToClusterCoreInstanceGroupPtrOutputWithContext(context.Context) ClusterCoreInstanceGroupPtrOutput
}

type clusterCoreInstanceGroupPtrType ClusterCoreInstanceGroupArgs

func ClusterCoreInstanceGroupPtr(v *ClusterCoreInstanceGroupArgs) ClusterCoreInstanceGroupPtrInput {
	return (*clusterCoreInstanceGroupPtrType)(v)
}

func (*clusterCoreInstanceGroupPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterCoreInstanceGroup)(nil)).Elem()
}

func (i *clusterCoreInstanceGroupPtrType) ToClusterCoreInstanceGroupPtrOutput() ClusterCoreInstanceGroupPtrOutput {
	return i.ToClusterCoreInstanceGroupPtrOutputWithContext(context.Background())
}

func (i *clusterCoreInstanceGroupPtrType) ToClusterCoreInstanceGroupPtrOutputWithContext(ctx context.Context) ClusterCoreInstanceGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceGroupPtrOutput)
}

type ClusterCoreInstanceGroupOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceGroup)(nil)).Elem()
}

func (o ClusterCoreInstanceGroupOutput) ToClusterCoreInstanceGroupOutput() ClusterCoreInstanceGroupOutput {
	return o
}

func (o ClusterCoreInstanceGroupOutput) ToClusterCoreInstanceGroupOutputWithContext(ctx context.Context) ClusterCoreInstanceGroupOutput {
	return o
}

func (o ClusterCoreInstanceGroupOutput) ToClusterCoreInstanceGroupPtrOutput() ClusterCoreInstanceGroupPtrOutput {
	return o.ToClusterCoreInstanceGroupPtrOutputWithContext(context.Background())
}

func (o ClusterCoreInstanceGroupOutput) ToClusterCoreInstanceGroupPtrOutputWithContext(ctx context.Context) ClusterCoreInstanceGroupPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroup) *ClusterCoreInstanceGroup {
		return &v
	}).(ClusterCoreInstanceGroupPtrOutput)
}

// String containing the [EMR Auto Scaling Policy](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-automatic-scaling.html) JSON.
func (o ClusterCoreInstanceGroupOutput) AutoscalingPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroup) *string { return v.AutoscalingPolicy }).(pulumi.StringPtrOutput)
}

// The bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
func (o ClusterCoreInstanceGroupOutput) BidPrice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroup) *string { return v.BidPrice }).(pulumi.StringPtrOutput)
}

// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
func (o ClusterCoreInstanceGroupOutput) EbsConfigs() ClusterCoreInstanceGroupEbsConfigArrayOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroup) []ClusterCoreInstanceGroupEbsConfig { return v.EbsConfigs }).(ClusterCoreInstanceGroupEbsConfigArrayOutput)
}

// The ID of the EMR Cluster
func (o ClusterCoreInstanceGroupOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroup) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have `map public IP on launch` enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
func (o ClusterCoreInstanceGroupOutput) InstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroup) *int { return v.InstanceCount }).(pulumi.IntPtrOutput)
}

// An EC2 instance type, such as m4.xlarge.
func (o ClusterCoreInstanceGroupOutput) InstanceType() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroup) string { return v.InstanceType }).(pulumi.StringOutput)
}

// Friendly name given to the instance fleet.
func (o ClusterCoreInstanceGroupOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroup) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ClusterCoreInstanceGroupPtrOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceGroupPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterCoreInstanceGroup)(nil)).Elem()
}

func (o ClusterCoreInstanceGroupPtrOutput) ToClusterCoreInstanceGroupPtrOutput() ClusterCoreInstanceGroupPtrOutput {
	return o
}

func (o ClusterCoreInstanceGroupPtrOutput) ToClusterCoreInstanceGroupPtrOutputWithContext(ctx context.Context) ClusterCoreInstanceGroupPtrOutput {
	return o
}

func (o ClusterCoreInstanceGroupPtrOutput) Elem() ClusterCoreInstanceGroupOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceGroup) ClusterCoreInstanceGroup { return *v }).(ClusterCoreInstanceGroupOutput)
}

// String containing the [EMR Auto Scaling Policy](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-automatic-scaling.html) JSON.
func (o ClusterCoreInstanceGroupPtrOutput) AutoscalingPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceGroup) *string {
		if v == nil {
			return nil
		}
		return v.AutoscalingPolicy
	}).(pulumi.StringPtrOutput)
}

// The bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
func (o ClusterCoreInstanceGroupPtrOutput) BidPrice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceGroup) *string {
		if v == nil {
			return nil
		}
		return v.BidPrice
	}).(pulumi.StringPtrOutput)
}

// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
func (o ClusterCoreInstanceGroupPtrOutput) EbsConfigs() ClusterCoreInstanceGroupEbsConfigArrayOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceGroup) []ClusterCoreInstanceGroupEbsConfig {
		if v == nil {
			return nil
		}
		return v.EbsConfigs
	}).(ClusterCoreInstanceGroupEbsConfigArrayOutput)
}

// The ID of the EMR Cluster
func (o ClusterCoreInstanceGroupPtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceGroup) *string {
		if v == nil {
			return nil
		}
		return v.Id
	}).(pulumi.StringPtrOutput)
}

// Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have `map public IP on launch` enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
func (o ClusterCoreInstanceGroupPtrOutput) InstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceGroup) *int {
		if v == nil {
			return nil
		}
		return v.InstanceCount
	}).(pulumi.IntPtrOutput)
}

// An EC2 instance type, such as m4.xlarge.
func (o ClusterCoreInstanceGroupPtrOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceGroup) *string {
		if v == nil {
			return nil
		}
		return &v.InstanceType
	}).(pulumi.StringPtrOutput)
}

// Friendly name given to the instance fleet.
func (o ClusterCoreInstanceGroupPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterCoreInstanceGroup) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

type ClusterCoreInstanceGroupEbsConfig struct {
	// The number of I/O operations per second (IOPS) that the volume supports
	Iops *int `pulumi:"iops"`
	// The volume size, in gibibytes (GiB).
	Size int `pulumi:"size"`
	// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
	Type string `pulumi:"type"`
	// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
	VolumesPerInstance *int `pulumi:"volumesPerInstance"`
}

// ClusterCoreInstanceGroupEbsConfigInput is an input type that accepts ClusterCoreInstanceGroupEbsConfigArgs and ClusterCoreInstanceGroupEbsConfigOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceGroupEbsConfigInput` via:
//
//          ClusterCoreInstanceGroupEbsConfigArgs{...}
type ClusterCoreInstanceGroupEbsConfigInput interface {
	pulumi.Input

	ToClusterCoreInstanceGroupEbsConfigOutput() ClusterCoreInstanceGroupEbsConfigOutput
	ToClusterCoreInstanceGroupEbsConfigOutputWithContext(context.Context) ClusterCoreInstanceGroupEbsConfigOutput
}

type ClusterCoreInstanceGroupEbsConfigArgs struct {
	// The number of I/O operations per second (IOPS) that the volume supports
	Iops pulumi.IntPtrInput `pulumi:"iops"`
	// The volume size, in gibibytes (GiB).
	Size pulumi.IntInput `pulumi:"size"`
	// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
	Type pulumi.StringInput `pulumi:"type"`
	// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
	VolumesPerInstance pulumi.IntPtrInput `pulumi:"volumesPerInstance"`
}

func (ClusterCoreInstanceGroupEbsConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceGroupEbsConfig)(nil)).Elem()
}

func (i ClusterCoreInstanceGroupEbsConfigArgs) ToClusterCoreInstanceGroupEbsConfigOutput() ClusterCoreInstanceGroupEbsConfigOutput {
	return i.ToClusterCoreInstanceGroupEbsConfigOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceGroupEbsConfigArgs) ToClusterCoreInstanceGroupEbsConfigOutputWithContext(ctx context.Context) ClusterCoreInstanceGroupEbsConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceGroupEbsConfigOutput)
}

// ClusterCoreInstanceGroupEbsConfigArrayInput is an input type that accepts ClusterCoreInstanceGroupEbsConfigArray and ClusterCoreInstanceGroupEbsConfigArrayOutput values.
// You can construct a concrete instance of `ClusterCoreInstanceGroupEbsConfigArrayInput` via:
//
//          ClusterCoreInstanceGroupEbsConfigArray{ ClusterCoreInstanceGroupEbsConfigArgs{...} }
type ClusterCoreInstanceGroupEbsConfigArrayInput interface {
	pulumi.Input

	ToClusterCoreInstanceGroupEbsConfigArrayOutput() ClusterCoreInstanceGroupEbsConfigArrayOutput
	ToClusterCoreInstanceGroupEbsConfigArrayOutputWithContext(context.Context) ClusterCoreInstanceGroupEbsConfigArrayOutput
}

type ClusterCoreInstanceGroupEbsConfigArray []ClusterCoreInstanceGroupEbsConfigInput

func (ClusterCoreInstanceGroupEbsConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterCoreInstanceGroupEbsConfig)(nil)).Elem()
}

func (i ClusterCoreInstanceGroupEbsConfigArray) ToClusterCoreInstanceGroupEbsConfigArrayOutput() ClusterCoreInstanceGroupEbsConfigArrayOutput {
	return i.ToClusterCoreInstanceGroupEbsConfigArrayOutputWithContext(context.Background())
}

func (i ClusterCoreInstanceGroupEbsConfigArray) ToClusterCoreInstanceGroupEbsConfigArrayOutputWithContext(ctx context.Context) ClusterCoreInstanceGroupEbsConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterCoreInstanceGroupEbsConfigArrayOutput)
}

type ClusterCoreInstanceGroupEbsConfigOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceGroupEbsConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterCoreInstanceGroupEbsConfig)(nil)).Elem()
}

func (o ClusterCoreInstanceGroupEbsConfigOutput) ToClusterCoreInstanceGroupEbsConfigOutput() ClusterCoreInstanceGroupEbsConfigOutput {
	return o
}

func (o ClusterCoreInstanceGroupEbsConfigOutput) ToClusterCoreInstanceGroupEbsConfigOutputWithContext(ctx context.Context) ClusterCoreInstanceGroupEbsConfigOutput {
	return o
}

// The number of I/O operations per second (IOPS) that the volume supports
func (o ClusterCoreInstanceGroupEbsConfigOutput) Iops() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroupEbsConfig) *int { return v.Iops }).(pulumi.IntPtrOutput)
}

// The volume size, in gibibytes (GiB).
func (o ClusterCoreInstanceGroupEbsConfigOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroupEbsConfig) int { return v.Size }).(pulumi.IntOutput)
}

// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
func (o ClusterCoreInstanceGroupEbsConfigOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroupEbsConfig) string { return v.Type }).(pulumi.StringOutput)
}

// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
func (o ClusterCoreInstanceGroupEbsConfigOutput) VolumesPerInstance() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterCoreInstanceGroupEbsConfig) *int { return v.VolumesPerInstance }).(pulumi.IntPtrOutput)
}

type ClusterCoreInstanceGroupEbsConfigArrayOutput struct{ *pulumi.OutputState }

func (ClusterCoreInstanceGroupEbsConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterCoreInstanceGroupEbsConfig)(nil)).Elem()
}

func (o ClusterCoreInstanceGroupEbsConfigArrayOutput) ToClusterCoreInstanceGroupEbsConfigArrayOutput() ClusterCoreInstanceGroupEbsConfigArrayOutput {
	return o
}

func (o ClusterCoreInstanceGroupEbsConfigArrayOutput) ToClusterCoreInstanceGroupEbsConfigArrayOutputWithContext(ctx context.Context) ClusterCoreInstanceGroupEbsConfigArrayOutput {
	return o
}

func (o ClusterCoreInstanceGroupEbsConfigArrayOutput) Index(i pulumi.IntInput) ClusterCoreInstanceGroupEbsConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterCoreInstanceGroupEbsConfig {
		return vs[0].([]ClusterCoreInstanceGroupEbsConfig)[vs[1].(int)]
	}).(ClusterCoreInstanceGroupEbsConfigOutput)
}

type ClusterEc2Attributes struct {
	// String containing a comma separated list of additional Amazon EC2 security group IDs for the master node
	AdditionalMasterSecurityGroups *string `pulumi:"additionalMasterSecurityGroups"`
	// String containing a comma separated list of additional Amazon EC2 security group IDs for the slave nodes as a comma separated string
	AdditionalSlaveSecurityGroups *string `pulumi:"additionalSlaveSecurityGroups"`
	// Identifier of the Amazon EC2 EMR-Managed security group for the master node
	EmrManagedMasterSecurityGroup *string `pulumi:"emrManagedMasterSecurityGroup"`
	// Identifier of the Amazon EC2 EMR-Managed security group for the slave nodes
	EmrManagedSlaveSecurityGroup *string `pulumi:"emrManagedSlaveSecurityGroup"`
	// Instance Profile for EC2 instances of the cluster assume this role
	InstanceProfile string `pulumi:"instanceProfile"`
	// Amazon EC2 key pair that can be used to ssh to the master node as the user called `hadoop`
	KeyName *string `pulumi:"keyName"`
	// Identifier of the Amazon EC2 service-access security group - required when the cluster runs on a private subnet
	ServiceAccessSecurityGroup *string `pulumi:"serviceAccessSecurityGroup"`
	// VPC subnet id where you want the job flow to launch. Cannot specify the `cc1.4xlarge` instance type for nodes of a job flow launched in a Amazon VPC
	SubnetId *string `pulumi:"subnetId"`
}

// ClusterEc2AttributesInput is an input type that accepts ClusterEc2AttributesArgs and ClusterEc2AttributesOutput values.
// You can construct a concrete instance of `ClusterEc2AttributesInput` via:
//
//          ClusterEc2AttributesArgs{...}
type ClusterEc2AttributesInput interface {
	pulumi.Input

	ToClusterEc2AttributesOutput() ClusterEc2AttributesOutput
	ToClusterEc2AttributesOutputWithContext(context.Context) ClusterEc2AttributesOutput
}

type ClusterEc2AttributesArgs struct {
	// String containing a comma separated list of additional Amazon EC2 security group IDs for the master node
	AdditionalMasterSecurityGroups pulumi.StringPtrInput `pulumi:"additionalMasterSecurityGroups"`
	// String containing a comma separated list of additional Amazon EC2 security group IDs for the slave nodes as a comma separated string
	AdditionalSlaveSecurityGroups pulumi.StringPtrInput `pulumi:"additionalSlaveSecurityGroups"`
	// Identifier of the Amazon EC2 EMR-Managed security group for the master node
	EmrManagedMasterSecurityGroup pulumi.StringPtrInput `pulumi:"emrManagedMasterSecurityGroup"`
	// Identifier of the Amazon EC2 EMR-Managed security group for the slave nodes
	EmrManagedSlaveSecurityGroup pulumi.StringPtrInput `pulumi:"emrManagedSlaveSecurityGroup"`
	// Instance Profile for EC2 instances of the cluster assume this role
	InstanceProfile pulumi.StringInput `pulumi:"instanceProfile"`
	// Amazon EC2 key pair that can be used to ssh to the master node as the user called `hadoop`
	KeyName pulumi.StringPtrInput `pulumi:"keyName"`
	// Identifier of the Amazon EC2 service-access security group - required when the cluster runs on a private subnet
	ServiceAccessSecurityGroup pulumi.StringPtrInput `pulumi:"serviceAccessSecurityGroup"`
	// VPC subnet id where you want the job flow to launch. Cannot specify the `cc1.4xlarge` instance type for nodes of a job flow launched in a Amazon VPC
	SubnetId pulumi.StringPtrInput `pulumi:"subnetId"`
}

func (ClusterEc2AttributesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterEc2Attributes)(nil)).Elem()
}

func (i ClusterEc2AttributesArgs) ToClusterEc2AttributesOutput() ClusterEc2AttributesOutput {
	return i.ToClusterEc2AttributesOutputWithContext(context.Background())
}

func (i ClusterEc2AttributesArgs) ToClusterEc2AttributesOutputWithContext(ctx context.Context) ClusterEc2AttributesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterEc2AttributesOutput)
}

func (i ClusterEc2AttributesArgs) ToClusterEc2AttributesPtrOutput() ClusterEc2AttributesPtrOutput {
	return i.ToClusterEc2AttributesPtrOutputWithContext(context.Background())
}

func (i ClusterEc2AttributesArgs) ToClusterEc2AttributesPtrOutputWithContext(ctx context.Context) ClusterEc2AttributesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterEc2AttributesOutput).ToClusterEc2AttributesPtrOutputWithContext(ctx)
}

// ClusterEc2AttributesPtrInput is an input type that accepts ClusterEc2AttributesArgs, ClusterEc2AttributesPtr and ClusterEc2AttributesPtrOutput values.
// You can construct a concrete instance of `ClusterEc2AttributesPtrInput` via:
//
//          ClusterEc2AttributesArgs{...}
//
//  or:
//
//          nil
type ClusterEc2AttributesPtrInput interface {
	pulumi.Input

	ToClusterEc2AttributesPtrOutput() ClusterEc2AttributesPtrOutput
	ToClusterEc2AttributesPtrOutputWithContext(context.Context) ClusterEc2AttributesPtrOutput
}

type clusterEc2AttributesPtrType ClusterEc2AttributesArgs

func ClusterEc2AttributesPtr(v *ClusterEc2AttributesArgs) ClusterEc2AttributesPtrInput {
	return (*clusterEc2AttributesPtrType)(v)
}

func (*clusterEc2AttributesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterEc2Attributes)(nil)).Elem()
}

func (i *clusterEc2AttributesPtrType) ToClusterEc2AttributesPtrOutput() ClusterEc2AttributesPtrOutput {
	return i.ToClusterEc2AttributesPtrOutputWithContext(context.Background())
}

func (i *clusterEc2AttributesPtrType) ToClusterEc2AttributesPtrOutputWithContext(ctx context.Context) ClusterEc2AttributesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterEc2AttributesPtrOutput)
}

type ClusterEc2AttributesOutput struct{ *pulumi.OutputState }

func (ClusterEc2AttributesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterEc2Attributes)(nil)).Elem()
}

func (o ClusterEc2AttributesOutput) ToClusterEc2AttributesOutput() ClusterEc2AttributesOutput {
	return o
}

func (o ClusterEc2AttributesOutput) ToClusterEc2AttributesOutputWithContext(ctx context.Context) ClusterEc2AttributesOutput {
	return o
}

func (o ClusterEc2AttributesOutput) ToClusterEc2AttributesPtrOutput() ClusterEc2AttributesPtrOutput {
	return o.ToClusterEc2AttributesPtrOutputWithContext(context.Background())
}

func (o ClusterEc2AttributesOutput) ToClusterEc2AttributesPtrOutputWithContext(ctx context.Context) ClusterEc2AttributesPtrOutput {
	return o.ApplyT(func(v ClusterEc2Attributes) *ClusterEc2Attributes {
		return &v
	}).(ClusterEc2AttributesPtrOutput)
}

// String containing a comma separated list of additional Amazon EC2 security group IDs for the master node
func (o ClusterEc2AttributesOutput) AdditionalMasterSecurityGroups() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterEc2Attributes) *string { return v.AdditionalMasterSecurityGroups }).(pulumi.StringPtrOutput)
}

// String containing a comma separated list of additional Amazon EC2 security group IDs for the slave nodes as a comma separated string
func (o ClusterEc2AttributesOutput) AdditionalSlaveSecurityGroups() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterEc2Attributes) *string { return v.AdditionalSlaveSecurityGroups }).(pulumi.StringPtrOutput)
}

// Identifier of the Amazon EC2 EMR-Managed security group for the master node
func (o ClusterEc2AttributesOutput) EmrManagedMasterSecurityGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterEc2Attributes) *string { return v.EmrManagedMasterSecurityGroup }).(pulumi.StringPtrOutput)
}

// Identifier of the Amazon EC2 EMR-Managed security group for the slave nodes
func (o ClusterEc2AttributesOutput) EmrManagedSlaveSecurityGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterEc2Attributes) *string { return v.EmrManagedSlaveSecurityGroup }).(pulumi.StringPtrOutput)
}

// Instance Profile for EC2 instances of the cluster assume this role
func (o ClusterEc2AttributesOutput) InstanceProfile() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterEc2Attributes) string { return v.InstanceProfile }).(pulumi.StringOutput)
}

// Amazon EC2 key pair that can be used to ssh to the master node as the user called `hadoop`
func (o ClusterEc2AttributesOutput) KeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterEc2Attributes) *string { return v.KeyName }).(pulumi.StringPtrOutput)
}

// Identifier of the Amazon EC2 service-access security group - required when the cluster runs on a private subnet
func (o ClusterEc2AttributesOutput) ServiceAccessSecurityGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterEc2Attributes) *string { return v.ServiceAccessSecurityGroup }).(pulumi.StringPtrOutput)
}

// VPC subnet id where you want the job flow to launch. Cannot specify the `cc1.4xlarge` instance type for nodes of a job flow launched in a Amazon VPC
func (o ClusterEc2AttributesOutput) SubnetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterEc2Attributes) *string { return v.SubnetId }).(pulumi.StringPtrOutput)
}

type ClusterEc2AttributesPtrOutput struct{ *pulumi.OutputState }

func (ClusterEc2AttributesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterEc2Attributes)(nil)).Elem()
}

func (o ClusterEc2AttributesPtrOutput) ToClusterEc2AttributesPtrOutput() ClusterEc2AttributesPtrOutput {
	return o
}

func (o ClusterEc2AttributesPtrOutput) ToClusterEc2AttributesPtrOutputWithContext(ctx context.Context) ClusterEc2AttributesPtrOutput {
	return o
}

func (o ClusterEc2AttributesPtrOutput) Elem() ClusterEc2AttributesOutput {
	return o.ApplyT(func(v *ClusterEc2Attributes) ClusterEc2Attributes { return *v }).(ClusterEc2AttributesOutput)
}

// String containing a comma separated list of additional Amazon EC2 security group IDs for the master node
func (o ClusterEc2AttributesPtrOutput) AdditionalMasterSecurityGroups() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterEc2Attributes) *string {
		if v == nil {
			return nil
		}
		return v.AdditionalMasterSecurityGroups
	}).(pulumi.StringPtrOutput)
}

// String containing a comma separated list of additional Amazon EC2 security group IDs for the slave nodes as a comma separated string
func (o ClusterEc2AttributesPtrOutput) AdditionalSlaveSecurityGroups() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterEc2Attributes) *string {
		if v == nil {
			return nil
		}
		return v.AdditionalSlaveSecurityGroups
	}).(pulumi.StringPtrOutput)
}

// Identifier of the Amazon EC2 EMR-Managed security group for the master node
func (o ClusterEc2AttributesPtrOutput) EmrManagedMasterSecurityGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterEc2Attributes) *string {
		if v == nil {
			return nil
		}
		return v.EmrManagedMasterSecurityGroup
	}).(pulumi.StringPtrOutput)
}

// Identifier of the Amazon EC2 EMR-Managed security group for the slave nodes
func (o ClusterEc2AttributesPtrOutput) EmrManagedSlaveSecurityGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterEc2Attributes) *string {
		if v == nil {
			return nil
		}
		return v.EmrManagedSlaveSecurityGroup
	}).(pulumi.StringPtrOutput)
}

// Instance Profile for EC2 instances of the cluster assume this role
func (o ClusterEc2AttributesPtrOutput) InstanceProfile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterEc2Attributes) *string {
		if v == nil {
			return nil
		}
		return &v.InstanceProfile
	}).(pulumi.StringPtrOutput)
}

// Amazon EC2 key pair that can be used to ssh to the master node as the user called `hadoop`
func (o ClusterEc2AttributesPtrOutput) KeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterEc2Attributes) *string {
		if v == nil {
			return nil
		}
		return v.KeyName
	}).(pulumi.StringPtrOutput)
}

// Identifier of the Amazon EC2 service-access security group - required when the cluster runs on a private subnet
func (o ClusterEc2AttributesPtrOutput) ServiceAccessSecurityGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterEc2Attributes) *string {
		if v == nil {
			return nil
		}
		return v.ServiceAccessSecurityGroup
	}).(pulumi.StringPtrOutput)
}

// VPC subnet id where you want the job flow to launch. Cannot specify the `cc1.4xlarge` instance type for nodes of a job flow launched in a Amazon VPC
func (o ClusterEc2AttributesPtrOutput) SubnetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterEc2Attributes) *string {
		if v == nil {
			return nil
		}
		return v.SubnetId
	}).(pulumi.StringPtrOutput)
}

type ClusterKerberosAttributes struct {
	// The Active Directory password for `adDomainJoinUser`. This provider cannot perform drift detection of this configuration.
	AdDomainJoinPassword *string `pulumi:"adDomainJoinPassword"`
	// Required only when establishing a cross-realm trust with an Active Directory domain. A user with sufficient privileges to join resources to the domain. This provider cannot perform drift detection of this configuration.
	AdDomainJoinUser *string `pulumi:"adDomainJoinUser"`
	// Required only when establishing a cross-realm trust with a KDC in a different realm. The cross-realm principal password, which must be identical across realms. This provider cannot perform drift detection of this configuration.
	CrossRealmTrustPrincipalPassword *string `pulumi:"crossRealmTrustPrincipalPassword"`
	// The password used within the cluster for the kadmin service on the cluster-dedicated KDC, which maintains Kerberos principals, password policies, and keytabs for the cluster. This provider cannot perform drift detection of this configuration.
	KdcAdminPassword string `pulumi:"kdcAdminPassword"`
	// The name of the Kerberos realm to which all nodes in a cluster belong. For example, `EC2.INTERNAL`
	Realm string `pulumi:"realm"`
}

// ClusterKerberosAttributesInput is an input type that accepts ClusterKerberosAttributesArgs and ClusterKerberosAttributesOutput values.
// You can construct a concrete instance of `ClusterKerberosAttributesInput` via:
//
//          ClusterKerberosAttributesArgs{...}
type ClusterKerberosAttributesInput interface {
	pulumi.Input

	ToClusterKerberosAttributesOutput() ClusterKerberosAttributesOutput
	ToClusterKerberosAttributesOutputWithContext(context.Context) ClusterKerberosAttributesOutput
}

type ClusterKerberosAttributesArgs struct {
	// The Active Directory password for `adDomainJoinUser`. This provider cannot perform drift detection of this configuration.
	AdDomainJoinPassword pulumi.StringPtrInput `pulumi:"adDomainJoinPassword"`
	// Required only when establishing a cross-realm trust with an Active Directory domain. A user with sufficient privileges to join resources to the domain. This provider cannot perform drift detection of this configuration.
	AdDomainJoinUser pulumi.StringPtrInput `pulumi:"adDomainJoinUser"`
	// Required only when establishing a cross-realm trust with a KDC in a different realm. The cross-realm principal password, which must be identical across realms. This provider cannot perform drift detection of this configuration.
	CrossRealmTrustPrincipalPassword pulumi.StringPtrInput `pulumi:"crossRealmTrustPrincipalPassword"`
	// The password used within the cluster for the kadmin service on the cluster-dedicated KDC, which maintains Kerberos principals, password policies, and keytabs for the cluster. This provider cannot perform drift detection of this configuration.
	KdcAdminPassword pulumi.StringInput `pulumi:"kdcAdminPassword"`
	// The name of the Kerberos realm to which all nodes in a cluster belong. For example, `EC2.INTERNAL`
	Realm pulumi.StringInput `pulumi:"realm"`
}

func (ClusterKerberosAttributesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterKerberosAttributes)(nil)).Elem()
}

func (i ClusterKerberosAttributesArgs) ToClusterKerberosAttributesOutput() ClusterKerberosAttributesOutput {
	return i.ToClusterKerberosAttributesOutputWithContext(context.Background())
}

func (i ClusterKerberosAttributesArgs) ToClusterKerberosAttributesOutputWithContext(ctx context.Context) ClusterKerberosAttributesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterKerberosAttributesOutput)
}

func (i ClusterKerberosAttributesArgs) ToClusterKerberosAttributesPtrOutput() ClusterKerberosAttributesPtrOutput {
	return i.ToClusterKerberosAttributesPtrOutputWithContext(context.Background())
}

func (i ClusterKerberosAttributesArgs) ToClusterKerberosAttributesPtrOutputWithContext(ctx context.Context) ClusterKerberosAttributesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterKerberosAttributesOutput).ToClusterKerberosAttributesPtrOutputWithContext(ctx)
}

// ClusterKerberosAttributesPtrInput is an input type that accepts ClusterKerberosAttributesArgs, ClusterKerberosAttributesPtr and ClusterKerberosAttributesPtrOutput values.
// You can construct a concrete instance of `ClusterKerberosAttributesPtrInput` via:
//
//          ClusterKerberosAttributesArgs{...}
//
//  or:
//
//          nil
type ClusterKerberosAttributesPtrInput interface {
	pulumi.Input

	ToClusterKerberosAttributesPtrOutput() ClusterKerberosAttributesPtrOutput
	ToClusterKerberosAttributesPtrOutputWithContext(context.Context) ClusterKerberosAttributesPtrOutput
}

type clusterKerberosAttributesPtrType ClusterKerberosAttributesArgs

func ClusterKerberosAttributesPtr(v *ClusterKerberosAttributesArgs) ClusterKerberosAttributesPtrInput {
	return (*clusterKerberosAttributesPtrType)(v)
}

func (*clusterKerberosAttributesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterKerberosAttributes)(nil)).Elem()
}

func (i *clusterKerberosAttributesPtrType) ToClusterKerberosAttributesPtrOutput() ClusterKerberosAttributesPtrOutput {
	return i.ToClusterKerberosAttributesPtrOutputWithContext(context.Background())
}

func (i *clusterKerberosAttributesPtrType) ToClusterKerberosAttributesPtrOutputWithContext(ctx context.Context) ClusterKerberosAttributesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterKerberosAttributesPtrOutput)
}

type ClusterKerberosAttributesOutput struct{ *pulumi.OutputState }

func (ClusterKerberosAttributesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterKerberosAttributes)(nil)).Elem()
}

func (o ClusterKerberosAttributesOutput) ToClusterKerberosAttributesOutput() ClusterKerberosAttributesOutput {
	return o
}

func (o ClusterKerberosAttributesOutput) ToClusterKerberosAttributesOutputWithContext(ctx context.Context) ClusterKerberosAttributesOutput {
	return o
}

func (o ClusterKerberosAttributesOutput) ToClusterKerberosAttributesPtrOutput() ClusterKerberosAttributesPtrOutput {
	return o.ToClusterKerberosAttributesPtrOutputWithContext(context.Background())
}

func (o ClusterKerberosAttributesOutput) ToClusterKerberosAttributesPtrOutputWithContext(ctx context.Context) ClusterKerberosAttributesPtrOutput {
	return o.ApplyT(func(v ClusterKerberosAttributes) *ClusterKerberosAttributes {
		return &v
	}).(ClusterKerberosAttributesPtrOutput)
}

// The Active Directory password for `adDomainJoinUser`. This provider cannot perform drift detection of this configuration.
func (o ClusterKerberosAttributesOutput) AdDomainJoinPassword() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterKerberosAttributes) *string { return v.AdDomainJoinPassword }).(pulumi.StringPtrOutput)
}

// Required only when establishing a cross-realm trust with an Active Directory domain. A user with sufficient privileges to join resources to the domain. This provider cannot perform drift detection of this configuration.
func (o ClusterKerberosAttributesOutput) AdDomainJoinUser() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterKerberosAttributes) *string { return v.AdDomainJoinUser }).(pulumi.StringPtrOutput)
}

// Required only when establishing a cross-realm trust with a KDC in a different realm. The cross-realm principal password, which must be identical across realms. This provider cannot perform drift detection of this configuration.
func (o ClusterKerberosAttributesOutput) CrossRealmTrustPrincipalPassword() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterKerberosAttributes) *string { return v.CrossRealmTrustPrincipalPassword }).(pulumi.StringPtrOutput)
}

// The password used within the cluster for the kadmin service on the cluster-dedicated KDC, which maintains Kerberos principals, password policies, and keytabs for the cluster. This provider cannot perform drift detection of this configuration.
func (o ClusterKerberosAttributesOutput) KdcAdminPassword() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterKerberosAttributes) string { return v.KdcAdminPassword }).(pulumi.StringOutput)
}

// The name of the Kerberos realm to which all nodes in a cluster belong. For example, `EC2.INTERNAL`
func (o ClusterKerberosAttributesOutput) Realm() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterKerberosAttributes) string { return v.Realm }).(pulumi.StringOutput)
}

type ClusterKerberosAttributesPtrOutput struct{ *pulumi.OutputState }

func (ClusterKerberosAttributesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterKerberosAttributes)(nil)).Elem()
}

func (o ClusterKerberosAttributesPtrOutput) ToClusterKerberosAttributesPtrOutput() ClusterKerberosAttributesPtrOutput {
	return o
}

func (o ClusterKerberosAttributesPtrOutput) ToClusterKerberosAttributesPtrOutputWithContext(ctx context.Context) ClusterKerberosAttributesPtrOutput {
	return o
}

func (o ClusterKerberosAttributesPtrOutput) Elem() ClusterKerberosAttributesOutput {
	return o.ApplyT(func(v *ClusterKerberosAttributes) ClusterKerberosAttributes { return *v }).(ClusterKerberosAttributesOutput)
}

// The Active Directory password for `adDomainJoinUser`. This provider cannot perform drift detection of this configuration.
func (o ClusterKerberosAttributesPtrOutput) AdDomainJoinPassword() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterKerberosAttributes) *string {
		if v == nil {
			return nil
		}
		return v.AdDomainJoinPassword
	}).(pulumi.StringPtrOutput)
}

// Required only when establishing a cross-realm trust with an Active Directory domain. A user with sufficient privileges to join resources to the domain. This provider cannot perform drift detection of this configuration.
func (o ClusterKerberosAttributesPtrOutput) AdDomainJoinUser() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterKerberosAttributes) *string {
		if v == nil {
			return nil
		}
		return v.AdDomainJoinUser
	}).(pulumi.StringPtrOutput)
}

// Required only when establishing a cross-realm trust with a KDC in a different realm. The cross-realm principal password, which must be identical across realms. This provider cannot perform drift detection of this configuration.
func (o ClusterKerberosAttributesPtrOutput) CrossRealmTrustPrincipalPassword() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterKerberosAttributes) *string {
		if v == nil {
			return nil
		}
		return v.CrossRealmTrustPrincipalPassword
	}).(pulumi.StringPtrOutput)
}

// The password used within the cluster for the kadmin service on the cluster-dedicated KDC, which maintains Kerberos principals, password policies, and keytabs for the cluster. This provider cannot perform drift detection of this configuration.
func (o ClusterKerberosAttributesPtrOutput) KdcAdminPassword() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterKerberosAttributes) *string {
		if v == nil {
			return nil
		}
		return &v.KdcAdminPassword
	}).(pulumi.StringPtrOutput)
}

// The name of the Kerberos realm to which all nodes in a cluster belong. For example, `EC2.INTERNAL`
func (o ClusterKerberosAttributesPtrOutput) Realm() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterKerberosAttributes) *string {
		if v == nil {
			return nil
		}
		return &v.Realm
	}).(pulumi.StringPtrOutput)
}

type ClusterMasterInstanceFleet struct {
	// The ID of the EMR Cluster
	Id *string `pulumi:"id"`
	// Configuration block for instance fleet
	InstanceTypeConfigs []ClusterMasterInstanceFleetInstanceTypeConfig `pulumi:"instanceTypeConfigs"`
	// Configuration block for launch specification
	LaunchSpecifications *ClusterMasterInstanceFleetLaunchSpecifications `pulumi:"launchSpecifications"`
	// Friendly name given to the instance fleet.
	Name                        *string `pulumi:"name"`
	ProvisionedOnDemandCapacity *int    `pulumi:"provisionedOnDemandCapacity"`
	ProvisionedSpotCapacity     *int    `pulumi:"provisionedSpotCapacity"`
	// The target capacity of On-Demand units for the instance fleet, which determines how many On-Demand instances to provision.
	TargetOnDemandCapacity *int `pulumi:"targetOnDemandCapacity"`
	// The target capacity of Spot units for the instance fleet, which determines how many Spot instances to provision.
	TargetSpotCapacity *int `pulumi:"targetSpotCapacity"`
}

// ClusterMasterInstanceFleetInput is an input type that accepts ClusterMasterInstanceFleetArgs and ClusterMasterInstanceFleetOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceFleetInput` via:
//
//          ClusterMasterInstanceFleetArgs{...}
type ClusterMasterInstanceFleetInput interface {
	pulumi.Input

	ToClusterMasterInstanceFleetOutput() ClusterMasterInstanceFleetOutput
	ToClusterMasterInstanceFleetOutputWithContext(context.Context) ClusterMasterInstanceFleetOutput
}

type ClusterMasterInstanceFleetArgs struct {
	// The ID of the EMR Cluster
	Id pulumi.StringPtrInput `pulumi:"id"`
	// Configuration block for instance fleet
	InstanceTypeConfigs ClusterMasterInstanceFleetInstanceTypeConfigArrayInput `pulumi:"instanceTypeConfigs"`
	// Configuration block for launch specification
	LaunchSpecifications ClusterMasterInstanceFleetLaunchSpecificationsPtrInput `pulumi:"launchSpecifications"`
	// Friendly name given to the instance fleet.
	Name                        pulumi.StringPtrInput `pulumi:"name"`
	ProvisionedOnDemandCapacity pulumi.IntPtrInput    `pulumi:"provisionedOnDemandCapacity"`
	ProvisionedSpotCapacity     pulumi.IntPtrInput    `pulumi:"provisionedSpotCapacity"`
	// The target capacity of On-Demand units for the instance fleet, which determines how many On-Demand instances to provision.
	TargetOnDemandCapacity pulumi.IntPtrInput `pulumi:"targetOnDemandCapacity"`
	// The target capacity of Spot units for the instance fleet, which determines how many Spot instances to provision.
	TargetSpotCapacity pulumi.IntPtrInput `pulumi:"targetSpotCapacity"`
}

func (ClusterMasterInstanceFleetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceFleet)(nil)).Elem()
}

func (i ClusterMasterInstanceFleetArgs) ToClusterMasterInstanceFleetOutput() ClusterMasterInstanceFleetOutput {
	return i.ToClusterMasterInstanceFleetOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceFleetArgs) ToClusterMasterInstanceFleetOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceFleetOutput)
}

func (i ClusterMasterInstanceFleetArgs) ToClusterMasterInstanceFleetPtrOutput() ClusterMasterInstanceFleetPtrOutput {
	return i.ToClusterMasterInstanceFleetPtrOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceFleetArgs) ToClusterMasterInstanceFleetPtrOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceFleetOutput).ToClusterMasterInstanceFleetPtrOutputWithContext(ctx)
}

// ClusterMasterInstanceFleetPtrInput is an input type that accepts ClusterMasterInstanceFleetArgs, ClusterMasterInstanceFleetPtr and ClusterMasterInstanceFleetPtrOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceFleetPtrInput` via:
//
//          ClusterMasterInstanceFleetArgs{...}
//
//  or:
//
//          nil
type ClusterMasterInstanceFleetPtrInput interface {
	pulumi.Input

	ToClusterMasterInstanceFleetPtrOutput() ClusterMasterInstanceFleetPtrOutput
	ToClusterMasterInstanceFleetPtrOutputWithContext(context.Context) ClusterMasterInstanceFleetPtrOutput
}

type clusterMasterInstanceFleetPtrType ClusterMasterInstanceFleetArgs

func ClusterMasterInstanceFleetPtr(v *ClusterMasterInstanceFleetArgs) ClusterMasterInstanceFleetPtrInput {
	return (*clusterMasterInstanceFleetPtrType)(v)
}

func (*clusterMasterInstanceFleetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterMasterInstanceFleet)(nil)).Elem()
}

func (i *clusterMasterInstanceFleetPtrType) ToClusterMasterInstanceFleetPtrOutput() ClusterMasterInstanceFleetPtrOutput {
	return i.ToClusterMasterInstanceFleetPtrOutputWithContext(context.Background())
}

func (i *clusterMasterInstanceFleetPtrType) ToClusterMasterInstanceFleetPtrOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceFleetPtrOutput)
}

type ClusterMasterInstanceFleetOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceFleetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceFleet)(nil)).Elem()
}

func (o ClusterMasterInstanceFleetOutput) ToClusterMasterInstanceFleetOutput() ClusterMasterInstanceFleetOutput {
	return o
}

func (o ClusterMasterInstanceFleetOutput) ToClusterMasterInstanceFleetOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetOutput {
	return o
}

func (o ClusterMasterInstanceFleetOutput) ToClusterMasterInstanceFleetPtrOutput() ClusterMasterInstanceFleetPtrOutput {
	return o.ToClusterMasterInstanceFleetPtrOutputWithContext(context.Background())
}

func (o ClusterMasterInstanceFleetOutput) ToClusterMasterInstanceFleetPtrOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleet) *ClusterMasterInstanceFleet {
		return &v
	}).(ClusterMasterInstanceFleetPtrOutput)
}

// The ID of the EMR Cluster
func (o ClusterMasterInstanceFleetOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleet) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// Configuration block for instance fleet
func (o ClusterMasterInstanceFleetOutput) InstanceTypeConfigs() ClusterMasterInstanceFleetInstanceTypeConfigArrayOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleet) []ClusterMasterInstanceFleetInstanceTypeConfig {
		return v.InstanceTypeConfigs
	}).(ClusterMasterInstanceFleetInstanceTypeConfigArrayOutput)
}

// Configuration block for launch specification
func (o ClusterMasterInstanceFleetOutput) LaunchSpecifications() ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleet) *ClusterMasterInstanceFleetLaunchSpecifications {
		return v.LaunchSpecifications
	}).(ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput)
}

// Friendly name given to the instance fleet.
func (o ClusterMasterInstanceFleetOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleet) *string { return v.Name }).(pulumi.StringPtrOutput)
}

func (o ClusterMasterInstanceFleetOutput) ProvisionedOnDemandCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleet) *int { return v.ProvisionedOnDemandCapacity }).(pulumi.IntPtrOutput)
}

func (o ClusterMasterInstanceFleetOutput) ProvisionedSpotCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleet) *int { return v.ProvisionedSpotCapacity }).(pulumi.IntPtrOutput)
}

// The target capacity of On-Demand units for the instance fleet, which determines how many On-Demand instances to provision.
func (o ClusterMasterInstanceFleetOutput) TargetOnDemandCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleet) *int { return v.TargetOnDemandCapacity }).(pulumi.IntPtrOutput)
}

// The target capacity of Spot units for the instance fleet, which determines how many Spot instances to provision.
func (o ClusterMasterInstanceFleetOutput) TargetSpotCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleet) *int { return v.TargetSpotCapacity }).(pulumi.IntPtrOutput)
}

type ClusterMasterInstanceFleetPtrOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceFleetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterMasterInstanceFleet)(nil)).Elem()
}

func (o ClusterMasterInstanceFleetPtrOutput) ToClusterMasterInstanceFleetPtrOutput() ClusterMasterInstanceFleetPtrOutput {
	return o
}

func (o ClusterMasterInstanceFleetPtrOutput) ToClusterMasterInstanceFleetPtrOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetPtrOutput {
	return o
}

func (o ClusterMasterInstanceFleetPtrOutput) Elem() ClusterMasterInstanceFleetOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceFleet) ClusterMasterInstanceFleet { return *v }).(ClusterMasterInstanceFleetOutput)
}

// The ID of the EMR Cluster
func (o ClusterMasterInstanceFleetPtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceFleet) *string {
		if v == nil {
			return nil
		}
		return v.Id
	}).(pulumi.StringPtrOutput)
}

// Configuration block for instance fleet
func (o ClusterMasterInstanceFleetPtrOutput) InstanceTypeConfigs() ClusterMasterInstanceFleetInstanceTypeConfigArrayOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceFleet) []ClusterMasterInstanceFleetInstanceTypeConfig {
		if v == nil {
			return nil
		}
		return v.InstanceTypeConfigs
	}).(ClusterMasterInstanceFleetInstanceTypeConfigArrayOutput)
}

// Configuration block for launch specification
func (o ClusterMasterInstanceFleetPtrOutput) LaunchSpecifications() ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceFleet) *ClusterMasterInstanceFleetLaunchSpecifications {
		if v == nil {
			return nil
		}
		return v.LaunchSpecifications
	}).(ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput)
}

// Friendly name given to the instance fleet.
func (o ClusterMasterInstanceFleetPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceFleet) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

func (o ClusterMasterInstanceFleetPtrOutput) ProvisionedOnDemandCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceFleet) *int {
		if v == nil {
			return nil
		}
		return v.ProvisionedOnDemandCapacity
	}).(pulumi.IntPtrOutput)
}

func (o ClusterMasterInstanceFleetPtrOutput) ProvisionedSpotCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceFleet) *int {
		if v == nil {
			return nil
		}
		return v.ProvisionedSpotCapacity
	}).(pulumi.IntPtrOutput)
}

// The target capacity of On-Demand units for the instance fleet, which determines how many On-Demand instances to provision.
func (o ClusterMasterInstanceFleetPtrOutput) TargetOnDemandCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceFleet) *int {
		if v == nil {
			return nil
		}
		return v.TargetOnDemandCapacity
	}).(pulumi.IntPtrOutput)
}

// The target capacity of Spot units for the instance fleet, which determines how many Spot instances to provision.
func (o ClusterMasterInstanceFleetPtrOutput) TargetSpotCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceFleet) *int {
		if v == nil {
			return nil
		}
		return v.TargetSpotCapacity
	}).(pulumi.IntPtrOutput)
}

type ClusterMasterInstanceFleetInstanceTypeConfig struct {
	// The bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
	BidPrice *string `pulumi:"bidPrice"`
	// The bid price, as a percentage of On-Demand price, for each EC2 Spot instance as defined by `instanceType`. Expressed as a number (for example, 20 specifies 20%). If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
	BidPriceAsPercentageOfOnDemandPrice *float64 `pulumi:"bidPriceAsPercentageOfOnDemandPrice"`
	// A configuration classification that applies when provisioning cluster instances, which can include configurations for applications and software that run on the cluster. List of `configuration` blocks.
	Configurations []ClusterMasterInstanceFleetInstanceTypeConfigConfiguration `pulumi:"configurations"`
	// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
	EbsConfigs []ClusterMasterInstanceFleetInstanceTypeConfigEbsConfig `pulumi:"ebsConfigs"`
	// An EC2 instance type, such as m4.xlarge.
	InstanceType string `pulumi:"instanceType"`
	// The number of units that a provisioned instance of this type provides toward fulfilling the target capacities defined in `emr.InstanceFleet`.
	WeightedCapacity *int `pulumi:"weightedCapacity"`
}

// ClusterMasterInstanceFleetInstanceTypeConfigInput is an input type that accepts ClusterMasterInstanceFleetInstanceTypeConfigArgs and ClusterMasterInstanceFleetInstanceTypeConfigOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceFleetInstanceTypeConfigInput` via:
//
//          ClusterMasterInstanceFleetInstanceTypeConfigArgs{...}
type ClusterMasterInstanceFleetInstanceTypeConfigInput interface {
	pulumi.Input

	ToClusterMasterInstanceFleetInstanceTypeConfigOutput() ClusterMasterInstanceFleetInstanceTypeConfigOutput
	ToClusterMasterInstanceFleetInstanceTypeConfigOutputWithContext(context.Context) ClusterMasterInstanceFleetInstanceTypeConfigOutput
}

type ClusterMasterInstanceFleetInstanceTypeConfigArgs struct {
	// The bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
	BidPrice pulumi.StringPtrInput `pulumi:"bidPrice"`
	// The bid price, as a percentage of On-Demand price, for each EC2 Spot instance as defined by `instanceType`. Expressed as a number (for example, 20 specifies 20%). If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
	BidPriceAsPercentageOfOnDemandPrice pulumi.Float64PtrInput `pulumi:"bidPriceAsPercentageOfOnDemandPrice"`
	// A configuration classification that applies when provisioning cluster instances, which can include configurations for applications and software that run on the cluster. List of `configuration` blocks.
	Configurations ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayInput `pulumi:"configurations"`
	// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
	EbsConfigs ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayInput `pulumi:"ebsConfigs"`
	// An EC2 instance type, such as m4.xlarge.
	InstanceType pulumi.StringInput `pulumi:"instanceType"`
	// The number of units that a provisioned instance of this type provides toward fulfilling the target capacities defined in `emr.InstanceFleet`.
	WeightedCapacity pulumi.IntPtrInput `pulumi:"weightedCapacity"`
}

func (ClusterMasterInstanceFleetInstanceTypeConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceFleetInstanceTypeConfig)(nil)).Elem()
}

func (i ClusterMasterInstanceFleetInstanceTypeConfigArgs) ToClusterMasterInstanceFleetInstanceTypeConfigOutput() ClusterMasterInstanceFleetInstanceTypeConfigOutput {
	return i.ToClusterMasterInstanceFleetInstanceTypeConfigOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceFleetInstanceTypeConfigArgs) ToClusterMasterInstanceFleetInstanceTypeConfigOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetInstanceTypeConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceFleetInstanceTypeConfigOutput)
}

// ClusterMasterInstanceFleetInstanceTypeConfigArrayInput is an input type that accepts ClusterMasterInstanceFleetInstanceTypeConfigArray and ClusterMasterInstanceFleetInstanceTypeConfigArrayOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceFleetInstanceTypeConfigArrayInput` via:
//
//          ClusterMasterInstanceFleetInstanceTypeConfigArray{ ClusterMasterInstanceFleetInstanceTypeConfigArgs{...} }
type ClusterMasterInstanceFleetInstanceTypeConfigArrayInput interface {
	pulumi.Input

	ToClusterMasterInstanceFleetInstanceTypeConfigArrayOutput() ClusterMasterInstanceFleetInstanceTypeConfigArrayOutput
	ToClusterMasterInstanceFleetInstanceTypeConfigArrayOutputWithContext(context.Context) ClusterMasterInstanceFleetInstanceTypeConfigArrayOutput
}

type ClusterMasterInstanceFleetInstanceTypeConfigArray []ClusterMasterInstanceFleetInstanceTypeConfigInput

func (ClusterMasterInstanceFleetInstanceTypeConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterMasterInstanceFleetInstanceTypeConfig)(nil)).Elem()
}

func (i ClusterMasterInstanceFleetInstanceTypeConfigArray) ToClusterMasterInstanceFleetInstanceTypeConfigArrayOutput() ClusterMasterInstanceFleetInstanceTypeConfigArrayOutput {
	return i.ToClusterMasterInstanceFleetInstanceTypeConfigArrayOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceFleetInstanceTypeConfigArray) ToClusterMasterInstanceFleetInstanceTypeConfigArrayOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetInstanceTypeConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceFleetInstanceTypeConfigArrayOutput)
}

type ClusterMasterInstanceFleetInstanceTypeConfigOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceFleetInstanceTypeConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceFleetInstanceTypeConfig)(nil)).Elem()
}

func (o ClusterMasterInstanceFleetInstanceTypeConfigOutput) ToClusterMasterInstanceFleetInstanceTypeConfigOutput() ClusterMasterInstanceFleetInstanceTypeConfigOutput {
	return o
}

func (o ClusterMasterInstanceFleetInstanceTypeConfigOutput) ToClusterMasterInstanceFleetInstanceTypeConfigOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetInstanceTypeConfigOutput {
	return o
}

// The bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
func (o ClusterMasterInstanceFleetInstanceTypeConfigOutput) BidPrice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleetInstanceTypeConfig) *string { return v.BidPrice }).(pulumi.StringPtrOutput)
}

// The bid price, as a percentage of On-Demand price, for each EC2 Spot instance as defined by `instanceType`. Expressed as a number (for example, 20 specifies 20%). If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
func (o ClusterMasterInstanceFleetInstanceTypeConfigOutput) BidPriceAsPercentageOfOnDemandPrice() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleetInstanceTypeConfig) *float64 {
		return v.BidPriceAsPercentageOfOnDemandPrice
	}).(pulumi.Float64PtrOutput)
}

// A configuration classification that applies when provisioning cluster instances, which can include configurations for applications and software that run on the cluster. List of `configuration` blocks.
func (o ClusterMasterInstanceFleetInstanceTypeConfigOutput) Configurations() ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleetInstanceTypeConfig) []ClusterMasterInstanceFleetInstanceTypeConfigConfiguration {
		return v.Configurations
	}).(ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutput)
}

// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
func (o ClusterMasterInstanceFleetInstanceTypeConfigOutput) EbsConfigs() ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleetInstanceTypeConfig) []ClusterMasterInstanceFleetInstanceTypeConfigEbsConfig {
		return v.EbsConfigs
	}).(ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutput)
}

// An EC2 instance type, such as m4.xlarge.
func (o ClusterMasterInstanceFleetInstanceTypeConfigOutput) InstanceType() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleetInstanceTypeConfig) string { return v.InstanceType }).(pulumi.StringOutput)
}

// The number of units that a provisioned instance of this type provides toward fulfilling the target capacities defined in `emr.InstanceFleet`.
func (o ClusterMasterInstanceFleetInstanceTypeConfigOutput) WeightedCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleetInstanceTypeConfig) *int { return v.WeightedCapacity }).(pulumi.IntPtrOutput)
}

type ClusterMasterInstanceFleetInstanceTypeConfigArrayOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceFleetInstanceTypeConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterMasterInstanceFleetInstanceTypeConfig)(nil)).Elem()
}

func (o ClusterMasterInstanceFleetInstanceTypeConfigArrayOutput) ToClusterMasterInstanceFleetInstanceTypeConfigArrayOutput() ClusterMasterInstanceFleetInstanceTypeConfigArrayOutput {
	return o
}

func (o ClusterMasterInstanceFleetInstanceTypeConfigArrayOutput) ToClusterMasterInstanceFleetInstanceTypeConfigArrayOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetInstanceTypeConfigArrayOutput {
	return o
}

func (o ClusterMasterInstanceFleetInstanceTypeConfigArrayOutput) Index(i pulumi.IntInput) ClusterMasterInstanceFleetInstanceTypeConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterMasterInstanceFleetInstanceTypeConfig {
		return vs[0].([]ClusterMasterInstanceFleetInstanceTypeConfig)[vs[1].(int)]
	}).(ClusterMasterInstanceFleetInstanceTypeConfigOutput)
}

type ClusterMasterInstanceFleetInstanceTypeConfigConfiguration struct {
	// The classification within a configuration.
	Classification *string `pulumi:"classification"`
	// A map of properties specified within a configuration classification
	Properties map[string]interface{} `pulumi:"properties"`
}

// ClusterMasterInstanceFleetInstanceTypeConfigConfigurationInput is an input type that accepts ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArgs and ClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceFleetInstanceTypeConfigConfigurationInput` via:
//
//          ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArgs{...}
type ClusterMasterInstanceFleetInstanceTypeConfigConfigurationInput interface {
	pulumi.Input

	ToClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutput() ClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutput
	ToClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutputWithContext(context.Context) ClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutput
}

type ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArgs struct {
	// The classification within a configuration.
	Classification pulumi.StringPtrInput `pulumi:"classification"`
	// A map of properties specified within a configuration classification
	Properties pulumi.MapInput `pulumi:"properties"`
}

func (ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceFleetInstanceTypeConfigConfiguration)(nil)).Elem()
}

func (i ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArgs) ToClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutput() ClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutput {
	return i.ToClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArgs) ToClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutput)
}

// ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayInput is an input type that accepts ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArray and ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayInput` via:
//
//          ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArray{ ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArgs{...} }
type ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayInput interface {
	pulumi.Input

	ToClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutput() ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutput
	ToClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutputWithContext(context.Context) ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutput
}

type ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArray []ClusterMasterInstanceFleetInstanceTypeConfigConfigurationInput

func (ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterMasterInstanceFleetInstanceTypeConfigConfiguration)(nil)).Elem()
}

func (i ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArray) ToClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutput() ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutput {
	return i.ToClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArray) ToClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutput)
}

type ClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceFleetInstanceTypeConfigConfiguration)(nil)).Elem()
}

func (o ClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutput) ToClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutput() ClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutput {
	return o
}

func (o ClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutput) ToClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutput {
	return o
}

// The classification within a configuration.
func (o ClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutput) Classification() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleetInstanceTypeConfigConfiguration) *string { return v.Classification }).(pulumi.StringPtrOutput)
}

// A map of properties specified within a configuration classification
func (o ClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutput) Properties() pulumi.MapOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleetInstanceTypeConfigConfiguration) map[string]interface{} {
		return v.Properties
	}).(pulumi.MapOutput)
}

type ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterMasterInstanceFleetInstanceTypeConfigConfiguration)(nil)).Elem()
}

func (o ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutput) ToClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutput() ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutput {
	return o
}

func (o ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutput) ToClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutput {
	return o
}

func (o ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutput) Index(i pulumi.IntInput) ClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterMasterInstanceFleetInstanceTypeConfigConfiguration {
		return vs[0].([]ClusterMasterInstanceFleetInstanceTypeConfigConfiguration)[vs[1].(int)]
	}).(ClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutput)
}

type ClusterMasterInstanceFleetInstanceTypeConfigEbsConfig struct {
	// The number of I/O operations per second (IOPS) that the volume supports
	Iops *int `pulumi:"iops"`
	// The volume size, in gibibytes (GiB).
	Size int `pulumi:"size"`
	// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
	Type string `pulumi:"type"`
	// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
	VolumesPerInstance *int `pulumi:"volumesPerInstance"`
}

// ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigInput is an input type that accepts ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArgs and ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigInput` via:
//
//          ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArgs{...}
type ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigInput interface {
	pulumi.Input

	ToClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput() ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput
	ToClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutputWithContext(context.Context) ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput
}

type ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArgs struct {
	// The number of I/O operations per second (IOPS) that the volume supports
	Iops pulumi.IntPtrInput `pulumi:"iops"`
	// The volume size, in gibibytes (GiB).
	Size pulumi.IntInput `pulumi:"size"`
	// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
	Type pulumi.StringInput `pulumi:"type"`
	// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
	VolumesPerInstance pulumi.IntPtrInput `pulumi:"volumesPerInstance"`
}

func (ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceFleetInstanceTypeConfigEbsConfig)(nil)).Elem()
}

func (i ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArgs) ToClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput() ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput {
	return i.ToClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArgs) ToClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput)
}

// ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayInput is an input type that accepts ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArray and ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayInput` via:
//
//          ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArray{ ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArgs{...} }
type ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayInput interface {
	pulumi.Input

	ToClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutput() ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutput
	ToClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutputWithContext(context.Context) ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutput
}

type ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArray []ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigInput

func (ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterMasterInstanceFleetInstanceTypeConfigEbsConfig)(nil)).Elem()
}

func (i ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArray) ToClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutput() ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutput {
	return i.ToClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArray) ToClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutput)
}

type ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceFleetInstanceTypeConfigEbsConfig)(nil)).Elem()
}

func (o ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput) ToClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput() ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput {
	return o
}

func (o ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput) ToClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput {
	return o
}

// The number of I/O operations per second (IOPS) that the volume supports
func (o ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput) Iops() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleetInstanceTypeConfigEbsConfig) *int { return v.Iops }).(pulumi.IntPtrOutput)
}

// The volume size, in gibibytes (GiB).
func (o ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleetInstanceTypeConfigEbsConfig) int { return v.Size }).(pulumi.IntOutput)
}

// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
func (o ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleetInstanceTypeConfigEbsConfig) string { return v.Type }).(pulumi.StringOutput)
}

// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
func (o ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput) VolumesPerInstance() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleetInstanceTypeConfigEbsConfig) *int { return v.VolumesPerInstance }).(pulumi.IntPtrOutput)
}

type ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterMasterInstanceFleetInstanceTypeConfigEbsConfig)(nil)).Elem()
}

func (o ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutput) ToClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutput() ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutput {
	return o
}

func (o ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutput) ToClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutput {
	return o
}

func (o ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutput) Index(i pulumi.IntInput) ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterMasterInstanceFleetInstanceTypeConfigEbsConfig {
		return vs[0].([]ClusterMasterInstanceFleetInstanceTypeConfigEbsConfig)[vs[1].(int)]
	}).(ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput)
}

type ClusterMasterInstanceFleetLaunchSpecifications struct {
	// Configuration block for on demand instances launch specifications
	OnDemandSpecifications []ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecification `pulumi:"onDemandSpecifications"`
	// Configuration block for spot instances launch specifications
	SpotSpecifications []ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecification `pulumi:"spotSpecifications"`
}

// ClusterMasterInstanceFleetLaunchSpecificationsInput is an input type that accepts ClusterMasterInstanceFleetLaunchSpecificationsArgs and ClusterMasterInstanceFleetLaunchSpecificationsOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceFleetLaunchSpecificationsInput` via:
//
//          ClusterMasterInstanceFleetLaunchSpecificationsArgs{...}
type ClusterMasterInstanceFleetLaunchSpecificationsInput interface {
	pulumi.Input

	ToClusterMasterInstanceFleetLaunchSpecificationsOutput() ClusterMasterInstanceFleetLaunchSpecificationsOutput
	ToClusterMasterInstanceFleetLaunchSpecificationsOutputWithContext(context.Context) ClusterMasterInstanceFleetLaunchSpecificationsOutput
}

type ClusterMasterInstanceFleetLaunchSpecificationsArgs struct {
	// Configuration block for on demand instances launch specifications
	OnDemandSpecifications ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayInput `pulumi:"onDemandSpecifications"`
	// Configuration block for spot instances launch specifications
	SpotSpecifications ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayInput `pulumi:"spotSpecifications"`
}

func (ClusterMasterInstanceFleetLaunchSpecificationsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceFleetLaunchSpecifications)(nil)).Elem()
}

func (i ClusterMasterInstanceFleetLaunchSpecificationsArgs) ToClusterMasterInstanceFleetLaunchSpecificationsOutput() ClusterMasterInstanceFleetLaunchSpecificationsOutput {
	return i.ToClusterMasterInstanceFleetLaunchSpecificationsOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceFleetLaunchSpecificationsArgs) ToClusterMasterInstanceFleetLaunchSpecificationsOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetLaunchSpecificationsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceFleetLaunchSpecificationsOutput)
}

func (i ClusterMasterInstanceFleetLaunchSpecificationsArgs) ToClusterMasterInstanceFleetLaunchSpecificationsPtrOutput() ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput {
	return i.ToClusterMasterInstanceFleetLaunchSpecificationsPtrOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceFleetLaunchSpecificationsArgs) ToClusterMasterInstanceFleetLaunchSpecificationsPtrOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceFleetLaunchSpecificationsOutput).ToClusterMasterInstanceFleetLaunchSpecificationsPtrOutputWithContext(ctx)
}

// ClusterMasterInstanceFleetLaunchSpecificationsPtrInput is an input type that accepts ClusterMasterInstanceFleetLaunchSpecificationsArgs, ClusterMasterInstanceFleetLaunchSpecificationsPtr and ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceFleetLaunchSpecificationsPtrInput` via:
//
//          ClusterMasterInstanceFleetLaunchSpecificationsArgs{...}
//
//  or:
//
//          nil
type ClusterMasterInstanceFleetLaunchSpecificationsPtrInput interface {
	pulumi.Input

	ToClusterMasterInstanceFleetLaunchSpecificationsPtrOutput() ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput
	ToClusterMasterInstanceFleetLaunchSpecificationsPtrOutputWithContext(context.Context) ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput
}

type clusterMasterInstanceFleetLaunchSpecificationsPtrType ClusterMasterInstanceFleetLaunchSpecificationsArgs

func ClusterMasterInstanceFleetLaunchSpecificationsPtr(v *ClusterMasterInstanceFleetLaunchSpecificationsArgs) ClusterMasterInstanceFleetLaunchSpecificationsPtrInput {
	return (*clusterMasterInstanceFleetLaunchSpecificationsPtrType)(v)
}

func (*clusterMasterInstanceFleetLaunchSpecificationsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterMasterInstanceFleetLaunchSpecifications)(nil)).Elem()
}

func (i *clusterMasterInstanceFleetLaunchSpecificationsPtrType) ToClusterMasterInstanceFleetLaunchSpecificationsPtrOutput() ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput {
	return i.ToClusterMasterInstanceFleetLaunchSpecificationsPtrOutputWithContext(context.Background())
}

func (i *clusterMasterInstanceFleetLaunchSpecificationsPtrType) ToClusterMasterInstanceFleetLaunchSpecificationsPtrOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput)
}

type ClusterMasterInstanceFleetLaunchSpecificationsOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceFleetLaunchSpecificationsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceFleetLaunchSpecifications)(nil)).Elem()
}

func (o ClusterMasterInstanceFleetLaunchSpecificationsOutput) ToClusterMasterInstanceFleetLaunchSpecificationsOutput() ClusterMasterInstanceFleetLaunchSpecificationsOutput {
	return o
}

func (o ClusterMasterInstanceFleetLaunchSpecificationsOutput) ToClusterMasterInstanceFleetLaunchSpecificationsOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetLaunchSpecificationsOutput {
	return o
}

func (o ClusterMasterInstanceFleetLaunchSpecificationsOutput) ToClusterMasterInstanceFleetLaunchSpecificationsPtrOutput() ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput {
	return o.ToClusterMasterInstanceFleetLaunchSpecificationsPtrOutputWithContext(context.Background())
}

func (o ClusterMasterInstanceFleetLaunchSpecificationsOutput) ToClusterMasterInstanceFleetLaunchSpecificationsPtrOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleetLaunchSpecifications) *ClusterMasterInstanceFleetLaunchSpecifications {
		return &v
	}).(ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput)
}

// Configuration block for on demand instances launch specifications
func (o ClusterMasterInstanceFleetLaunchSpecificationsOutput) OnDemandSpecifications() ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleetLaunchSpecifications) []ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecification {
		return v.OnDemandSpecifications
	}).(ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput)
}

// Configuration block for spot instances launch specifications
func (o ClusterMasterInstanceFleetLaunchSpecificationsOutput) SpotSpecifications() ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleetLaunchSpecifications) []ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecification {
		return v.SpotSpecifications
	}).(ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput)
}

type ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterMasterInstanceFleetLaunchSpecifications)(nil)).Elem()
}

func (o ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput) ToClusterMasterInstanceFleetLaunchSpecificationsPtrOutput() ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput {
	return o
}

func (o ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput) ToClusterMasterInstanceFleetLaunchSpecificationsPtrOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput {
	return o
}

func (o ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput) Elem() ClusterMasterInstanceFleetLaunchSpecificationsOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceFleetLaunchSpecifications) ClusterMasterInstanceFleetLaunchSpecifications {
		return *v
	}).(ClusterMasterInstanceFleetLaunchSpecificationsOutput)
}

// Configuration block for on demand instances launch specifications
func (o ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput) OnDemandSpecifications() ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceFleetLaunchSpecifications) []ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecification {
		if v == nil {
			return nil
		}
		return v.OnDemandSpecifications
	}).(ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput)
}

// Configuration block for spot instances launch specifications
func (o ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput) SpotSpecifications() ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceFleetLaunchSpecifications) []ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecification {
		if v == nil {
			return nil
		}
		return v.SpotSpecifications
	}).(ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput)
}

type ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecification struct {
	// Specifies the strategy to use in launching Spot instance fleets. Currently, the only option is `capacity-optimized` (the default), which launches instances from Spot instance pools with optimal capacity for the number of instances that are launching.
	AllocationStrategy string `pulumi:"allocationStrategy"`
}

// ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationInput is an input type that accepts ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs and ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationInput` via:
//
//          ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs{...}
type ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationInput interface {
	pulumi.Input

	ToClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput() ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput
	ToClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutputWithContext(context.Context) ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput
}

type ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs struct {
	// Specifies the strategy to use in launching Spot instance fleets. Currently, the only option is `capacity-optimized` (the default), which launches instances from Spot instance pools with optimal capacity for the number of instances that are launching.
	AllocationStrategy pulumi.StringInput `pulumi:"allocationStrategy"`
}

func (ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecification)(nil)).Elem()
}

func (i ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs) ToClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput() ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput {
	return i.ToClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs) ToClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput)
}

// ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayInput is an input type that accepts ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArray and ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayInput` via:
//
//          ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArray{ ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArgs{...} }
type ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayInput interface {
	pulumi.Input

	ToClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput() ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput
	ToClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutputWithContext(context.Context) ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput
}

type ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArray []ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationInput

func (ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecification)(nil)).Elem()
}

func (i ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArray) ToClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput() ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput {
	return i.ToClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArray) ToClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput)
}

type ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecification)(nil)).Elem()
}

func (o ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput) ToClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput() ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput {
	return o
}

func (o ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput) ToClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput {
	return o
}

// Specifies the strategy to use in launching Spot instance fleets. Currently, the only option is `capacity-optimized` (the default), which launches instances from Spot instance pools with optimal capacity for the number of instances that are launching.
func (o ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput) AllocationStrategy() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecification) string {
		return v.AllocationStrategy
	}).(pulumi.StringOutput)
}

type ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecification)(nil)).Elem()
}

func (o ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput) ToClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput() ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput {
	return o
}

func (o ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput) ToClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput {
	return o
}

func (o ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput) Index(i pulumi.IntInput) ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecification {
		return vs[0].([]ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecification)[vs[1].(int)]
	}).(ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput)
}

type ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecification struct {
	// Specifies the strategy to use in launching Spot instance fleets. Currently, the only option is `capacity-optimized` (the default), which launches instances from Spot instance pools with optimal capacity for the number of instances that are launching.
	AllocationStrategy string `pulumi:"allocationStrategy"`
	// The defined duration for Spot instances (also known as Spot blocks) in minutes. When specified, the Spot instance does not terminate before the defined duration expires, and defined duration pricing for Spot instances applies. Valid values are 60, 120, 180, 240, 300, or 360. The duration period starts as soon as a Spot instance receives its instance ID. At the end of the duration, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates.
	BlockDurationMinutes *int `pulumi:"blockDurationMinutes"`
	// The action to take when TargetSpotCapacity has not been fulfilled when the TimeoutDurationMinutes has expired; that is, when all Spot instances could not be provisioned within the Spot provisioning timeout. Valid values are `TERMINATE_CLUSTER` and `SWITCH_TO_ON_DEMAND`. SWITCH_TO_ON_DEMAND specifies that if no Spot instances are available, On-Demand Instances should be provisioned to fulfill any remaining Spot capacity.
	TimeoutAction string `pulumi:"timeoutAction"`
	// The spot provisioning timeout period in minutes. If Spot instances are not provisioned within this time period, the TimeOutAction is taken. Minimum value is 5 and maximum value is 1440. The timeout applies only during initial provisioning, when the cluster is first created.
	TimeoutDurationMinutes int `pulumi:"timeoutDurationMinutes"`
}

// ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationInput is an input type that accepts ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArgs and ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationInput` via:
//
//          ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArgs{...}
type ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationInput interface {
	pulumi.Input

	ToClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput() ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput
	ToClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutputWithContext(context.Context) ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput
}

type ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArgs struct {
	// Specifies the strategy to use in launching Spot instance fleets. Currently, the only option is `capacity-optimized` (the default), which launches instances from Spot instance pools with optimal capacity for the number of instances that are launching.
	AllocationStrategy pulumi.StringInput `pulumi:"allocationStrategy"`
	// The defined duration for Spot instances (also known as Spot blocks) in minutes. When specified, the Spot instance does not terminate before the defined duration expires, and defined duration pricing for Spot instances applies. Valid values are 60, 120, 180, 240, 300, or 360. The duration period starts as soon as a Spot instance receives its instance ID. At the end of the duration, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates.
	BlockDurationMinutes pulumi.IntPtrInput `pulumi:"blockDurationMinutes"`
	// The action to take when TargetSpotCapacity has not been fulfilled when the TimeoutDurationMinutes has expired; that is, when all Spot instances could not be provisioned within the Spot provisioning timeout. Valid values are `TERMINATE_CLUSTER` and `SWITCH_TO_ON_DEMAND`. SWITCH_TO_ON_DEMAND specifies that if no Spot instances are available, On-Demand Instances should be provisioned to fulfill any remaining Spot capacity.
	TimeoutAction pulumi.StringInput `pulumi:"timeoutAction"`
	// The spot provisioning timeout period in minutes. If Spot instances are not provisioned within this time period, the TimeOutAction is taken. Minimum value is 5 and maximum value is 1440. The timeout applies only during initial provisioning, when the cluster is first created.
	TimeoutDurationMinutes pulumi.IntInput `pulumi:"timeoutDurationMinutes"`
}

func (ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecification)(nil)).Elem()
}

func (i ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArgs) ToClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput() ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput {
	return i.ToClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArgs) ToClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput)
}

// ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayInput is an input type that accepts ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArray and ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayInput` via:
//
//          ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArray{ ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArgs{...} }
type ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayInput interface {
	pulumi.Input

	ToClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput() ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput
	ToClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutputWithContext(context.Context) ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput
}

type ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArray []ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationInput

func (ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecification)(nil)).Elem()
}

func (i ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArray) ToClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput() ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput {
	return i.ToClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArray) ToClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput)
}

type ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecification)(nil)).Elem()
}

func (o ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput) ToClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput() ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput {
	return o
}

func (o ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput) ToClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput {
	return o
}

// Specifies the strategy to use in launching Spot instance fleets. Currently, the only option is `capacity-optimized` (the default), which launches instances from Spot instance pools with optimal capacity for the number of instances that are launching.
func (o ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput) AllocationStrategy() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecification) string {
		return v.AllocationStrategy
	}).(pulumi.StringOutput)
}

// The defined duration for Spot instances (also known as Spot blocks) in minutes. When specified, the Spot instance does not terminate before the defined duration expires, and defined duration pricing for Spot instances applies. Valid values are 60, 120, 180, 240, 300, or 360. The duration period starts as soon as a Spot instance receives its instance ID. At the end of the duration, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates.
func (o ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput) BlockDurationMinutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecification) *int {
		return v.BlockDurationMinutes
	}).(pulumi.IntPtrOutput)
}

// The action to take when TargetSpotCapacity has not been fulfilled when the TimeoutDurationMinutes has expired; that is, when all Spot instances could not be provisioned within the Spot provisioning timeout. Valid values are `TERMINATE_CLUSTER` and `SWITCH_TO_ON_DEMAND`. SWITCH_TO_ON_DEMAND specifies that if no Spot instances are available, On-Demand Instances should be provisioned to fulfill any remaining Spot capacity.
func (o ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput) TimeoutAction() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecification) string { return v.TimeoutAction }).(pulumi.StringOutput)
}

// The spot provisioning timeout period in minutes. If Spot instances are not provisioned within this time period, the TimeOutAction is taken. Minimum value is 5 and maximum value is 1440. The timeout applies only during initial provisioning, when the cluster is first created.
func (o ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput) TimeoutDurationMinutes() pulumi.IntOutput {
	return o.ApplyT(func(v ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecification) int {
		return v.TimeoutDurationMinutes
	}).(pulumi.IntOutput)
}

type ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecification)(nil)).Elem()
}

func (o ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput) ToClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput() ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput {
	return o
}

func (o ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput) ToClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutputWithContext(ctx context.Context) ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput {
	return o
}

func (o ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput) Index(i pulumi.IntInput) ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecification {
		return vs[0].([]ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecification)[vs[1].(int)]
	}).(ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput)
}

type ClusterMasterInstanceGroup struct {
	// The bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
	BidPrice *string `pulumi:"bidPrice"`
	// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
	EbsConfigs []ClusterMasterInstanceGroupEbsConfig `pulumi:"ebsConfigs"`
	// The ID of the EMR Cluster
	Id *string `pulumi:"id"`
	// Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have `map public IP on launch` enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
	InstanceCount *int `pulumi:"instanceCount"`
	// An EC2 instance type, such as m4.xlarge.
	InstanceType string `pulumi:"instanceType"`
	// Friendly name given to the instance fleet.
	Name *string `pulumi:"name"`
}

// ClusterMasterInstanceGroupInput is an input type that accepts ClusterMasterInstanceGroupArgs and ClusterMasterInstanceGroupOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceGroupInput` via:
//
//          ClusterMasterInstanceGroupArgs{...}
type ClusterMasterInstanceGroupInput interface {
	pulumi.Input

	ToClusterMasterInstanceGroupOutput() ClusterMasterInstanceGroupOutput
	ToClusterMasterInstanceGroupOutputWithContext(context.Context) ClusterMasterInstanceGroupOutput
}

type ClusterMasterInstanceGroupArgs struct {
	// The bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
	BidPrice pulumi.StringPtrInput `pulumi:"bidPrice"`
	// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
	EbsConfigs ClusterMasterInstanceGroupEbsConfigArrayInput `pulumi:"ebsConfigs"`
	// The ID of the EMR Cluster
	Id pulumi.StringPtrInput `pulumi:"id"`
	// Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have `map public IP on launch` enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
	InstanceCount pulumi.IntPtrInput `pulumi:"instanceCount"`
	// An EC2 instance type, such as m4.xlarge.
	InstanceType pulumi.StringInput `pulumi:"instanceType"`
	// Friendly name given to the instance fleet.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (ClusterMasterInstanceGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceGroup)(nil)).Elem()
}

func (i ClusterMasterInstanceGroupArgs) ToClusterMasterInstanceGroupOutput() ClusterMasterInstanceGroupOutput {
	return i.ToClusterMasterInstanceGroupOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceGroupArgs) ToClusterMasterInstanceGroupOutputWithContext(ctx context.Context) ClusterMasterInstanceGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceGroupOutput)
}

func (i ClusterMasterInstanceGroupArgs) ToClusterMasterInstanceGroupPtrOutput() ClusterMasterInstanceGroupPtrOutput {
	return i.ToClusterMasterInstanceGroupPtrOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceGroupArgs) ToClusterMasterInstanceGroupPtrOutputWithContext(ctx context.Context) ClusterMasterInstanceGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceGroupOutput).ToClusterMasterInstanceGroupPtrOutputWithContext(ctx)
}

// ClusterMasterInstanceGroupPtrInput is an input type that accepts ClusterMasterInstanceGroupArgs, ClusterMasterInstanceGroupPtr and ClusterMasterInstanceGroupPtrOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceGroupPtrInput` via:
//
//          ClusterMasterInstanceGroupArgs{...}
//
//  or:
//
//          nil
type ClusterMasterInstanceGroupPtrInput interface {
	pulumi.Input

	ToClusterMasterInstanceGroupPtrOutput() ClusterMasterInstanceGroupPtrOutput
	ToClusterMasterInstanceGroupPtrOutputWithContext(context.Context) ClusterMasterInstanceGroupPtrOutput
}

type clusterMasterInstanceGroupPtrType ClusterMasterInstanceGroupArgs

func ClusterMasterInstanceGroupPtr(v *ClusterMasterInstanceGroupArgs) ClusterMasterInstanceGroupPtrInput {
	return (*clusterMasterInstanceGroupPtrType)(v)
}

func (*clusterMasterInstanceGroupPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterMasterInstanceGroup)(nil)).Elem()
}

func (i *clusterMasterInstanceGroupPtrType) ToClusterMasterInstanceGroupPtrOutput() ClusterMasterInstanceGroupPtrOutput {
	return i.ToClusterMasterInstanceGroupPtrOutputWithContext(context.Background())
}

func (i *clusterMasterInstanceGroupPtrType) ToClusterMasterInstanceGroupPtrOutputWithContext(ctx context.Context) ClusterMasterInstanceGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceGroupPtrOutput)
}

type ClusterMasterInstanceGroupOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceGroup)(nil)).Elem()
}

func (o ClusterMasterInstanceGroupOutput) ToClusterMasterInstanceGroupOutput() ClusterMasterInstanceGroupOutput {
	return o
}

func (o ClusterMasterInstanceGroupOutput) ToClusterMasterInstanceGroupOutputWithContext(ctx context.Context) ClusterMasterInstanceGroupOutput {
	return o
}

func (o ClusterMasterInstanceGroupOutput) ToClusterMasterInstanceGroupPtrOutput() ClusterMasterInstanceGroupPtrOutput {
	return o.ToClusterMasterInstanceGroupPtrOutputWithContext(context.Background())
}

func (o ClusterMasterInstanceGroupOutput) ToClusterMasterInstanceGroupPtrOutputWithContext(ctx context.Context) ClusterMasterInstanceGroupPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroup) *ClusterMasterInstanceGroup {
		return &v
	}).(ClusterMasterInstanceGroupPtrOutput)
}

// The bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
func (o ClusterMasterInstanceGroupOutput) BidPrice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroup) *string { return v.BidPrice }).(pulumi.StringPtrOutput)
}

// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
func (o ClusterMasterInstanceGroupOutput) EbsConfigs() ClusterMasterInstanceGroupEbsConfigArrayOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroup) []ClusterMasterInstanceGroupEbsConfig { return v.EbsConfigs }).(ClusterMasterInstanceGroupEbsConfigArrayOutput)
}

// The ID of the EMR Cluster
func (o ClusterMasterInstanceGroupOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroup) *string { return v.Id }).(pulumi.StringPtrOutput)
}

// Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have `map public IP on launch` enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
func (o ClusterMasterInstanceGroupOutput) InstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroup) *int { return v.InstanceCount }).(pulumi.IntPtrOutput)
}

// An EC2 instance type, such as m4.xlarge.
func (o ClusterMasterInstanceGroupOutput) InstanceType() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroup) string { return v.InstanceType }).(pulumi.StringOutput)
}

// Friendly name given to the instance fleet.
func (o ClusterMasterInstanceGroupOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroup) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ClusterMasterInstanceGroupPtrOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceGroupPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterMasterInstanceGroup)(nil)).Elem()
}

func (o ClusterMasterInstanceGroupPtrOutput) ToClusterMasterInstanceGroupPtrOutput() ClusterMasterInstanceGroupPtrOutput {
	return o
}

func (o ClusterMasterInstanceGroupPtrOutput) ToClusterMasterInstanceGroupPtrOutputWithContext(ctx context.Context) ClusterMasterInstanceGroupPtrOutput {
	return o
}

func (o ClusterMasterInstanceGroupPtrOutput) Elem() ClusterMasterInstanceGroupOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceGroup) ClusterMasterInstanceGroup { return *v }).(ClusterMasterInstanceGroupOutput)
}

// The bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
func (o ClusterMasterInstanceGroupPtrOutput) BidPrice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceGroup) *string {
		if v == nil {
			return nil
		}
		return v.BidPrice
	}).(pulumi.StringPtrOutput)
}

// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
func (o ClusterMasterInstanceGroupPtrOutput) EbsConfigs() ClusterMasterInstanceGroupEbsConfigArrayOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceGroup) []ClusterMasterInstanceGroupEbsConfig {
		if v == nil {
			return nil
		}
		return v.EbsConfigs
	}).(ClusterMasterInstanceGroupEbsConfigArrayOutput)
}

// The ID of the EMR Cluster
func (o ClusterMasterInstanceGroupPtrOutput) Id() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceGroup) *string {
		if v == nil {
			return nil
		}
		return v.Id
	}).(pulumi.StringPtrOutput)
}

// Target number of instances for the instance group. Must be 1 or 3. Defaults to 1. Launching with multiple master nodes is only supported in EMR version 5.23.0+, and requires this resource's `coreInstanceGroup` to be configured. Public (Internet accessible) instances must be created in VPC subnets that have `map public IP on launch` enabled. Termination protection is automatically enabled when launched with multiple master nodes and this provider must have the `terminationProtection = false` configuration applied before destroying this resource.
func (o ClusterMasterInstanceGroupPtrOutput) InstanceCount() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceGroup) *int {
		if v == nil {
			return nil
		}
		return v.InstanceCount
	}).(pulumi.IntPtrOutput)
}

// An EC2 instance type, such as m4.xlarge.
func (o ClusterMasterInstanceGroupPtrOutput) InstanceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceGroup) *string {
		if v == nil {
			return nil
		}
		return &v.InstanceType
	}).(pulumi.StringPtrOutput)
}

// Friendly name given to the instance fleet.
func (o ClusterMasterInstanceGroupPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterMasterInstanceGroup) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

type ClusterMasterInstanceGroupEbsConfig struct {
	// The number of I/O operations per second (IOPS) that the volume supports
	Iops *int `pulumi:"iops"`
	// The volume size, in gibibytes (GiB).
	Size int `pulumi:"size"`
	// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
	Type string `pulumi:"type"`
	// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
	VolumesPerInstance *int `pulumi:"volumesPerInstance"`
}

// ClusterMasterInstanceGroupEbsConfigInput is an input type that accepts ClusterMasterInstanceGroupEbsConfigArgs and ClusterMasterInstanceGroupEbsConfigOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceGroupEbsConfigInput` via:
//
//          ClusterMasterInstanceGroupEbsConfigArgs{...}
type ClusterMasterInstanceGroupEbsConfigInput interface {
	pulumi.Input

	ToClusterMasterInstanceGroupEbsConfigOutput() ClusterMasterInstanceGroupEbsConfigOutput
	ToClusterMasterInstanceGroupEbsConfigOutputWithContext(context.Context) ClusterMasterInstanceGroupEbsConfigOutput
}

type ClusterMasterInstanceGroupEbsConfigArgs struct {
	// The number of I/O operations per second (IOPS) that the volume supports
	Iops pulumi.IntPtrInput `pulumi:"iops"`
	// The volume size, in gibibytes (GiB).
	Size pulumi.IntInput `pulumi:"size"`
	// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
	Type pulumi.StringInput `pulumi:"type"`
	// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
	VolumesPerInstance pulumi.IntPtrInput `pulumi:"volumesPerInstance"`
}

func (ClusterMasterInstanceGroupEbsConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceGroupEbsConfig)(nil)).Elem()
}

func (i ClusterMasterInstanceGroupEbsConfigArgs) ToClusterMasterInstanceGroupEbsConfigOutput() ClusterMasterInstanceGroupEbsConfigOutput {
	return i.ToClusterMasterInstanceGroupEbsConfigOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceGroupEbsConfigArgs) ToClusterMasterInstanceGroupEbsConfigOutputWithContext(ctx context.Context) ClusterMasterInstanceGroupEbsConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceGroupEbsConfigOutput)
}

// ClusterMasterInstanceGroupEbsConfigArrayInput is an input type that accepts ClusterMasterInstanceGroupEbsConfigArray and ClusterMasterInstanceGroupEbsConfigArrayOutput values.
// You can construct a concrete instance of `ClusterMasterInstanceGroupEbsConfigArrayInput` via:
//
//          ClusterMasterInstanceGroupEbsConfigArray{ ClusterMasterInstanceGroupEbsConfigArgs{...} }
type ClusterMasterInstanceGroupEbsConfigArrayInput interface {
	pulumi.Input

	ToClusterMasterInstanceGroupEbsConfigArrayOutput() ClusterMasterInstanceGroupEbsConfigArrayOutput
	ToClusterMasterInstanceGroupEbsConfigArrayOutputWithContext(context.Context) ClusterMasterInstanceGroupEbsConfigArrayOutput
}

type ClusterMasterInstanceGroupEbsConfigArray []ClusterMasterInstanceGroupEbsConfigInput

func (ClusterMasterInstanceGroupEbsConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterMasterInstanceGroupEbsConfig)(nil)).Elem()
}

func (i ClusterMasterInstanceGroupEbsConfigArray) ToClusterMasterInstanceGroupEbsConfigArrayOutput() ClusterMasterInstanceGroupEbsConfigArrayOutput {
	return i.ToClusterMasterInstanceGroupEbsConfigArrayOutputWithContext(context.Background())
}

func (i ClusterMasterInstanceGroupEbsConfigArray) ToClusterMasterInstanceGroupEbsConfigArrayOutputWithContext(ctx context.Context) ClusterMasterInstanceGroupEbsConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterMasterInstanceGroupEbsConfigArrayOutput)
}

type ClusterMasterInstanceGroupEbsConfigOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceGroupEbsConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterMasterInstanceGroupEbsConfig)(nil)).Elem()
}

func (o ClusterMasterInstanceGroupEbsConfigOutput) ToClusterMasterInstanceGroupEbsConfigOutput() ClusterMasterInstanceGroupEbsConfigOutput {
	return o
}

func (o ClusterMasterInstanceGroupEbsConfigOutput) ToClusterMasterInstanceGroupEbsConfigOutputWithContext(ctx context.Context) ClusterMasterInstanceGroupEbsConfigOutput {
	return o
}

// The number of I/O operations per second (IOPS) that the volume supports
func (o ClusterMasterInstanceGroupEbsConfigOutput) Iops() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroupEbsConfig) *int { return v.Iops }).(pulumi.IntPtrOutput)
}

// The volume size, in gibibytes (GiB).
func (o ClusterMasterInstanceGroupEbsConfigOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroupEbsConfig) int { return v.Size }).(pulumi.IntOutput)
}

// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
func (o ClusterMasterInstanceGroupEbsConfigOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroupEbsConfig) string { return v.Type }).(pulumi.StringOutput)
}

// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
func (o ClusterMasterInstanceGroupEbsConfigOutput) VolumesPerInstance() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ClusterMasterInstanceGroupEbsConfig) *int { return v.VolumesPerInstance }).(pulumi.IntPtrOutput)
}

type ClusterMasterInstanceGroupEbsConfigArrayOutput struct{ *pulumi.OutputState }

func (ClusterMasterInstanceGroupEbsConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterMasterInstanceGroupEbsConfig)(nil)).Elem()
}

func (o ClusterMasterInstanceGroupEbsConfigArrayOutput) ToClusterMasterInstanceGroupEbsConfigArrayOutput() ClusterMasterInstanceGroupEbsConfigArrayOutput {
	return o
}

func (o ClusterMasterInstanceGroupEbsConfigArrayOutput) ToClusterMasterInstanceGroupEbsConfigArrayOutputWithContext(ctx context.Context) ClusterMasterInstanceGroupEbsConfigArrayOutput {
	return o
}

func (o ClusterMasterInstanceGroupEbsConfigArrayOutput) Index(i pulumi.IntInput) ClusterMasterInstanceGroupEbsConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterMasterInstanceGroupEbsConfig {
		return vs[0].([]ClusterMasterInstanceGroupEbsConfig)[vs[1].(int)]
	}).(ClusterMasterInstanceGroupEbsConfigOutput)
}

type ClusterStep struct {
	// The action to take if the step fails. Valid values: `TERMINATE_JOB_FLOW`, `TERMINATE_CLUSTER`, `CANCEL_AND_WAIT`, and `CONTINUE`
	ActionOnFailure string `pulumi:"actionOnFailure"`
	// The JAR file used for the step. Defined below.
	HadoopJarStep ClusterStepHadoopJarStep `pulumi:"hadoopJarStep"`
	// Friendly name given to the instance fleet.
	Name string `pulumi:"name"`
}

// ClusterStepInput is an input type that accepts ClusterStepArgs and ClusterStepOutput values.
// You can construct a concrete instance of `ClusterStepInput` via:
//
//          ClusterStepArgs{...}
type ClusterStepInput interface {
	pulumi.Input

	ToClusterStepOutput() ClusterStepOutput
	ToClusterStepOutputWithContext(context.Context) ClusterStepOutput
}

type ClusterStepArgs struct {
	// The action to take if the step fails. Valid values: `TERMINATE_JOB_FLOW`, `TERMINATE_CLUSTER`, `CANCEL_AND_WAIT`, and `CONTINUE`
	ActionOnFailure pulumi.StringInput `pulumi:"actionOnFailure"`
	// The JAR file used for the step. Defined below.
	HadoopJarStep ClusterStepHadoopJarStepInput `pulumi:"hadoopJarStep"`
	// Friendly name given to the instance fleet.
	Name pulumi.StringInput `pulumi:"name"`
}

func (ClusterStepArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterStep)(nil)).Elem()
}

func (i ClusterStepArgs) ToClusterStepOutput() ClusterStepOutput {
	return i.ToClusterStepOutputWithContext(context.Background())
}

func (i ClusterStepArgs) ToClusterStepOutputWithContext(ctx context.Context) ClusterStepOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterStepOutput)
}

// ClusterStepArrayInput is an input type that accepts ClusterStepArray and ClusterStepArrayOutput values.
// You can construct a concrete instance of `ClusterStepArrayInput` via:
//
//          ClusterStepArray{ ClusterStepArgs{...} }
type ClusterStepArrayInput interface {
	pulumi.Input

	ToClusterStepArrayOutput() ClusterStepArrayOutput
	ToClusterStepArrayOutputWithContext(context.Context) ClusterStepArrayOutput
}

type ClusterStepArray []ClusterStepInput

func (ClusterStepArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterStep)(nil)).Elem()
}

func (i ClusterStepArray) ToClusterStepArrayOutput() ClusterStepArrayOutput {
	return i.ToClusterStepArrayOutputWithContext(context.Background())
}

func (i ClusterStepArray) ToClusterStepArrayOutputWithContext(ctx context.Context) ClusterStepArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterStepArrayOutput)
}

type ClusterStepOutput struct{ *pulumi.OutputState }

func (ClusterStepOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterStep)(nil)).Elem()
}

func (o ClusterStepOutput) ToClusterStepOutput() ClusterStepOutput {
	return o
}

func (o ClusterStepOutput) ToClusterStepOutputWithContext(ctx context.Context) ClusterStepOutput {
	return o
}

// The action to take if the step fails. Valid values: `TERMINATE_JOB_FLOW`, `TERMINATE_CLUSTER`, `CANCEL_AND_WAIT`, and `CONTINUE`
func (o ClusterStepOutput) ActionOnFailure() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterStep) string { return v.ActionOnFailure }).(pulumi.StringOutput)
}

// The JAR file used for the step. Defined below.
func (o ClusterStepOutput) HadoopJarStep() ClusterStepHadoopJarStepOutput {
	return o.ApplyT(func(v ClusterStep) ClusterStepHadoopJarStep { return v.HadoopJarStep }).(ClusterStepHadoopJarStepOutput)
}

// Friendly name given to the instance fleet.
func (o ClusterStepOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterStep) string { return v.Name }).(pulumi.StringOutput)
}

type ClusterStepArrayOutput struct{ *pulumi.OutputState }

func (ClusterStepArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ClusterStep)(nil)).Elem()
}

func (o ClusterStepArrayOutput) ToClusterStepArrayOutput() ClusterStepArrayOutput {
	return o
}

func (o ClusterStepArrayOutput) ToClusterStepArrayOutputWithContext(ctx context.Context) ClusterStepArrayOutput {
	return o
}

func (o ClusterStepArrayOutput) Index(i pulumi.IntInput) ClusterStepOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ClusterStep {
		return vs[0].([]ClusterStep)[vs[1].(int)]
	}).(ClusterStepOutput)
}

type ClusterStepHadoopJarStep struct {
	// List of command line arguments passed to the JAR file's main function when executed.
	Args []string `pulumi:"args"`
	// Path to a JAR file run during the step.
	Jar string `pulumi:"jar"`
	// Name of the main class in the specified Java file. If not specified, the JAR file should specify a Main-Class in its manifest file.
	MainClass *string `pulumi:"mainClass"`
	// A map of properties specified within a configuration classification
	Properties map[string]string `pulumi:"properties"`
}

// ClusterStepHadoopJarStepInput is an input type that accepts ClusterStepHadoopJarStepArgs and ClusterStepHadoopJarStepOutput values.
// You can construct a concrete instance of `ClusterStepHadoopJarStepInput` via:
//
//          ClusterStepHadoopJarStepArgs{...}
type ClusterStepHadoopJarStepInput interface {
	pulumi.Input

	ToClusterStepHadoopJarStepOutput() ClusterStepHadoopJarStepOutput
	ToClusterStepHadoopJarStepOutputWithContext(context.Context) ClusterStepHadoopJarStepOutput
}

type ClusterStepHadoopJarStepArgs struct {
	// List of command line arguments passed to the JAR file's main function when executed.
	Args pulumi.StringArrayInput `pulumi:"args"`
	// Path to a JAR file run during the step.
	Jar pulumi.StringInput `pulumi:"jar"`
	// Name of the main class in the specified Java file. If not specified, the JAR file should specify a Main-Class in its manifest file.
	MainClass pulumi.StringPtrInput `pulumi:"mainClass"`
	// A map of properties specified within a configuration classification
	Properties pulumi.StringMapInput `pulumi:"properties"`
}

func (ClusterStepHadoopJarStepArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterStepHadoopJarStep)(nil)).Elem()
}

func (i ClusterStepHadoopJarStepArgs) ToClusterStepHadoopJarStepOutput() ClusterStepHadoopJarStepOutput {
	return i.ToClusterStepHadoopJarStepOutputWithContext(context.Background())
}

func (i ClusterStepHadoopJarStepArgs) ToClusterStepHadoopJarStepOutputWithContext(ctx context.Context) ClusterStepHadoopJarStepOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterStepHadoopJarStepOutput)
}

type ClusterStepHadoopJarStepOutput struct{ *pulumi.OutputState }

func (ClusterStepHadoopJarStepOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ClusterStepHadoopJarStep)(nil)).Elem()
}

func (o ClusterStepHadoopJarStepOutput) ToClusterStepHadoopJarStepOutput() ClusterStepHadoopJarStepOutput {
	return o
}

func (o ClusterStepHadoopJarStepOutput) ToClusterStepHadoopJarStepOutputWithContext(ctx context.Context) ClusterStepHadoopJarStepOutput {
	return o
}

// List of command line arguments passed to the JAR file's main function when executed.
func (o ClusterStepHadoopJarStepOutput) Args() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ClusterStepHadoopJarStep) []string { return v.Args }).(pulumi.StringArrayOutput)
}

// Path to a JAR file run during the step.
func (o ClusterStepHadoopJarStepOutput) Jar() pulumi.StringOutput {
	return o.ApplyT(func(v ClusterStepHadoopJarStep) string { return v.Jar }).(pulumi.StringOutput)
}

// Name of the main class in the specified Java file. If not specified, the JAR file should specify a Main-Class in its manifest file.
func (o ClusterStepHadoopJarStepOutput) MainClass() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ClusterStepHadoopJarStep) *string { return v.MainClass }).(pulumi.StringPtrOutput)
}

// A map of properties specified within a configuration classification
func (o ClusterStepHadoopJarStepOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v ClusterStepHadoopJarStep) map[string]string { return v.Properties }).(pulumi.StringMapOutput)
}

type InstanceFleetInstanceTypeConfig struct {
	// The bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
	BidPrice *string `pulumi:"bidPrice"`
	// The bid price, as a percentage of On-Demand price, for each EC2 Spot instance as defined by `instanceType`. Expressed as a number (for example, 20 specifies 20%). If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
	BidPriceAsPercentageOfOnDemandPrice *float64 `pulumi:"bidPriceAsPercentageOfOnDemandPrice"`
	// A configuration classification that applies when provisioning cluster instances, which can include configurations for applications and software that run on the cluster. List of `configuration` blocks.
	Configurations []InstanceFleetInstanceTypeConfigConfiguration `pulumi:"configurations"`
	// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
	EbsConfigs []InstanceFleetInstanceTypeConfigEbsConfig `pulumi:"ebsConfigs"`
	// An EC2 instance type, such as m4.xlarge.
	InstanceType string `pulumi:"instanceType"`
	// The number of units that a provisioned instance of this type provides toward fulfilling the target capacities defined in `emr.InstanceFleet`.
	WeightedCapacity *int `pulumi:"weightedCapacity"`
}

// InstanceFleetInstanceTypeConfigInput is an input type that accepts InstanceFleetInstanceTypeConfigArgs and InstanceFleetInstanceTypeConfigOutput values.
// You can construct a concrete instance of `InstanceFleetInstanceTypeConfigInput` via:
//
//          InstanceFleetInstanceTypeConfigArgs{...}
type InstanceFleetInstanceTypeConfigInput interface {
	pulumi.Input

	ToInstanceFleetInstanceTypeConfigOutput() InstanceFleetInstanceTypeConfigOutput
	ToInstanceFleetInstanceTypeConfigOutputWithContext(context.Context) InstanceFleetInstanceTypeConfigOutput
}

type InstanceFleetInstanceTypeConfigArgs struct {
	// The bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
	BidPrice pulumi.StringPtrInput `pulumi:"bidPrice"`
	// The bid price, as a percentage of On-Demand price, for each EC2 Spot instance as defined by `instanceType`. Expressed as a number (for example, 20 specifies 20%). If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
	BidPriceAsPercentageOfOnDemandPrice pulumi.Float64PtrInput `pulumi:"bidPriceAsPercentageOfOnDemandPrice"`
	// A configuration classification that applies when provisioning cluster instances, which can include configurations for applications and software that run on the cluster. List of `configuration` blocks.
	Configurations InstanceFleetInstanceTypeConfigConfigurationArrayInput `pulumi:"configurations"`
	// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
	EbsConfigs InstanceFleetInstanceTypeConfigEbsConfigArrayInput `pulumi:"ebsConfigs"`
	// An EC2 instance type, such as m4.xlarge.
	InstanceType pulumi.StringInput `pulumi:"instanceType"`
	// The number of units that a provisioned instance of this type provides toward fulfilling the target capacities defined in `emr.InstanceFleet`.
	WeightedCapacity pulumi.IntPtrInput `pulumi:"weightedCapacity"`
}

func (InstanceFleetInstanceTypeConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceFleetInstanceTypeConfig)(nil)).Elem()
}

func (i InstanceFleetInstanceTypeConfigArgs) ToInstanceFleetInstanceTypeConfigOutput() InstanceFleetInstanceTypeConfigOutput {
	return i.ToInstanceFleetInstanceTypeConfigOutputWithContext(context.Background())
}

func (i InstanceFleetInstanceTypeConfigArgs) ToInstanceFleetInstanceTypeConfigOutputWithContext(ctx context.Context) InstanceFleetInstanceTypeConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceFleetInstanceTypeConfigOutput)
}

// InstanceFleetInstanceTypeConfigArrayInput is an input type that accepts InstanceFleetInstanceTypeConfigArray and InstanceFleetInstanceTypeConfigArrayOutput values.
// You can construct a concrete instance of `InstanceFleetInstanceTypeConfigArrayInput` via:
//
//          InstanceFleetInstanceTypeConfigArray{ InstanceFleetInstanceTypeConfigArgs{...} }
type InstanceFleetInstanceTypeConfigArrayInput interface {
	pulumi.Input

	ToInstanceFleetInstanceTypeConfigArrayOutput() InstanceFleetInstanceTypeConfigArrayOutput
	ToInstanceFleetInstanceTypeConfigArrayOutputWithContext(context.Context) InstanceFleetInstanceTypeConfigArrayOutput
}

type InstanceFleetInstanceTypeConfigArray []InstanceFleetInstanceTypeConfigInput

func (InstanceFleetInstanceTypeConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceFleetInstanceTypeConfig)(nil)).Elem()
}

func (i InstanceFleetInstanceTypeConfigArray) ToInstanceFleetInstanceTypeConfigArrayOutput() InstanceFleetInstanceTypeConfigArrayOutput {
	return i.ToInstanceFleetInstanceTypeConfigArrayOutputWithContext(context.Background())
}

func (i InstanceFleetInstanceTypeConfigArray) ToInstanceFleetInstanceTypeConfigArrayOutputWithContext(ctx context.Context) InstanceFleetInstanceTypeConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceFleetInstanceTypeConfigArrayOutput)
}

type InstanceFleetInstanceTypeConfigOutput struct{ *pulumi.OutputState }

func (InstanceFleetInstanceTypeConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceFleetInstanceTypeConfig)(nil)).Elem()
}

func (o InstanceFleetInstanceTypeConfigOutput) ToInstanceFleetInstanceTypeConfigOutput() InstanceFleetInstanceTypeConfigOutput {
	return o
}

func (o InstanceFleetInstanceTypeConfigOutput) ToInstanceFleetInstanceTypeConfigOutputWithContext(ctx context.Context) InstanceFleetInstanceTypeConfigOutput {
	return o
}

// The bid price for each EC2 Spot instance type as defined by `instanceType`. Expressed in USD. If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
func (o InstanceFleetInstanceTypeConfigOutput) BidPrice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceFleetInstanceTypeConfig) *string { return v.BidPrice }).(pulumi.StringPtrOutput)
}

// The bid price, as a percentage of On-Demand price, for each EC2 Spot instance as defined by `instanceType`. Expressed as a number (for example, 20 specifies 20%). If neither `bidPrice` nor `bidPriceAsPercentageOfOnDemandPrice` is provided, `bidPriceAsPercentageOfOnDemandPrice` defaults to 100%.
func (o InstanceFleetInstanceTypeConfigOutput) BidPriceAsPercentageOfOnDemandPrice() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v InstanceFleetInstanceTypeConfig) *float64 { return v.BidPriceAsPercentageOfOnDemandPrice }).(pulumi.Float64PtrOutput)
}

// A configuration classification that applies when provisioning cluster instances, which can include configurations for applications and software that run on the cluster. List of `configuration` blocks.
func (o InstanceFleetInstanceTypeConfigOutput) Configurations() InstanceFleetInstanceTypeConfigConfigurationArrayOutput {
	return o.ApplyT(func(v InstanceFleetInstanceTypeConfig) []InstanceFleetInstanceTypeConfigConfiguration {
		return v.Configurations
	}).(InstanceFleetInstanceTypeConfigConfigurationArrayOutput)
}

// Configuration block(s) for EBS volumes attached to each instance in the instance group. Detailed below.
func (o InstanceFleetInstanceTypeConfigOutput) EbsConfigs() InstanceFleetInstanceTypeConfigEbsConfigArrayOutput {
	return o.ApplyT(func(v InstanceFleetInstanceTypeConfig) []InstanceFleetInstanceTypeConfigEbsConfig {
		return v.EbsConfigs
	}).(InstanceFleetInstanceTypeConfigEbsConfigArrayOutput)
}

// An EC2 instance type, such as m4.xlarge.
func (o InstanceFleetInstanceTypeConfigOutput) InstanceType() pulumi.StringOutput {
	return o.ApplyT(func(v InstanceFleetInstanceTypeConfig) string { return v.InstanceType }).(pulumi.StringOutput)
}

// The number of units that a provisioned instance of this type provides toward fulfilling the target capacities defined in `emr.InstanceFleet`.
func (o InstanceFleetInstanceTypeConfigOutput) WeightedCapacity() pulumi.IntPtrOutput {
	return o.ApplyT(func(v InstanceFleetInstanceTypeConfig) *int { return v.WeightedCapacity }).(pulumi.IntPtrOutput)
}

type InstanceFleetInstanceTypeConfigArrayOutput struct{ *pulumi.OutputState }

func (InstanceFleetInstanceTypeConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceFleetInstanceTypeConfig)(nil)).Elem()
}

func (o InstanceFleetInstanceTypeConfigArrayOutput) ToInstanceFleetInstanceTypeConfigArrayOutput() InstanceFleetInstanceTypeConfigArrayOutput {
	return o
}

func (o InstanceFleetInstanceTypeConfigArrayOutput) ToInstanceFleetInstanceTypeConfigArrayOutputWithContext(ctx context.Context) InstanceFleetInstanceTypeConfigArrayOutput {
	return o
}

func (o InstanceFleetInstanceTypeConfigArrayOutput) Index(i pulumi.IntInput) InstanceFleetInstanceTypeConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InstanceFleetInstanceTypeConfig {
		return vs[0].([]InstanceFleetInstanceTypeConfig)[vs[1].(int)]
	}).(InstanceFleetInstanceTypeConfigOutput)
}

type InstanceFleetInstanceTypeConfigConfiguration struct {
	// The classification within a configuration.
	Classification *string `pulumi:"classification"`
	// A map of properties specified within a configuration classification
	Properties map[string]interface{} `pulumi:"properties"`
}

// InstanceFleetInstanceTypeConfigConfigurationInput is an input type that accepts InstanceFleetInstanceTypeConfigConfigurationArgs and InstanceFleetInstanceTypeConfigConfigurationOutput values.
// You can construct a concrete instance of `InstanceFleetInstanceTypeConfigConfigurationInput` via:
//
//          InstanceFleetInstanceTypeConfigConfigurationArgs{...}
type InstanceFleetInstanceTypeConfigConfigurationInput interface {
	pulumi.Input

	ToInstanceFleetInstanceTypeConfigConfigurationOutput() InstanceFleetInstanceTypeConfigConfigurationOutput
	ToInstanceFleetInstanceTypeConfigConfigurationOutputWithContext(context.Context) InstanceFleetInstanceTypeConfigConfigurationOutput
}

type InstanceFleetInstanceTypeConfigConfigurationArgs struct {
	// The classification within a configuration.
	Classification pulumi.StringPtrInput `pulumi:"classification"`
	// A map of properties specified within a configuration classification
	Properties pulumi.MapInput `pulumi:"properties"`
}

func (InstanceFleetInstanceTypeConfigConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceFleetInstanceTypeConfigConfiguration)(nil)).Elem()
}

func (i InstanceFleetInstanceTypeConfigConfigurationArgs) ToInstanceFleetInstanceTypeConfigConfigurationOutput() InstanceFleetInstanceTypeConfigConfigurationOutput {
	return i.ToInstanceFleetInstanceTypeConfigConfigurationOutputWithContext(context.Background())
}

func (i InstanceFleetInstanceTypeConfigConfigurationArgs) ToInstanceFleetInstanceTypeConfigConfigurationOutputWithContext(ctx context.Context) InstanceFleetInstanceTypeConfigConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceFleetInstanceTypeConfigConfigurationOutput)
}

// InstanceFleetInstanceTypeConfigConfigurationArrayInput is an input type that accepts InstanceFleetInstanceTypeConfigConfigurationArray and InstanceFleetInstanceTypeConfigConfigurationArrayOutput values.
// You can construct a concrete instance of `InstanceFleetInstanceTypeConfigConfigurationArrayInput` via:
//
//          InstanceFleetInstanceTypeConfigConfigurationArray{ InstanceFleetInstanceTypeConfigConfigurationArgs{...} }
type InstanceFleetInstanceTypeConfigConfigurationArrayInput interface {
	pulumi.Input

	ToInstanceFleetInstanceTypeConfigConfigurationArrayOutput() InstanceFleetInstanceTypeConfigConfigurationArrayOutput
	ToInstanceFleetInstanceTypeConfigConfigurationArrayOutputWithContext(context.Context) InstanceFleetInstanceTypeConfigConfigurationArrayOutput
}

type InstanceFleetInstanceTypeConfigConfigurationArray []InstanceFleetInstanceTypeConfigConfigurationInput

func (InstanceFleetInstanceTypeConfigConfigurationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceFleetInstanceTypeConfigConfiguration)(nil)).Elem()
}

func (i InstanceFleetInstanceTypeConfigConfigurationArray) ToInstanceFleetInstanceTypeConfigConfigurationArrayOutput() InstanceFleetInstanceTypeConfigConfigurationArrayOutput {
	return i.ToInstanceFleetInstanceTypeConfigConfigurationArrayOutputWithContext(context.Background())
}

func (i InstanceFleetInstanceTypeConfigConfigurationArray) ToInstanceFleetInstanceTypeConfigConfigurationArrayOutputWithContext(ctx context.Context) InstanceFleetInstanceTypeConfigConfigurationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceFleetInstanceTypeConfigConfigurationArrayOutput)
}

type InstanceFleetInstanceTypeConfigConfigurationOutput struct{ *pulumi.OutputState }

func (InstanceFleetInstanceTypeConfigConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceFleetInstanceTypeConfigConfiguration)(nil)).Elem()
}

func (o InstanceFleetInstanceTypeConfigConfigurationOutput) ToInstanceFleetInstanceTypeConfigConfigurationOutput() InstanceFleetInstanceTypeConfigConfigurationOutput {
	return o
}

func (o InstanceFleetInstanceTypeConfigConfigurationOutput) ToInstanceFleetInstanceTypeConfigConfigurationOutputWithContext(ctx context.Context) InstanceFleetInstanceTypeConfigConfigurationOutput {
	return o
}

// The classification within a configuration.
func (o InstanceFleetInstanceTypeConfigConfigurationOutput) Classification() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InstanceFleetInstanceTypeConfigConfiguration) *string { return v.Classification }).(pulumi.StringPtrOutput)
}

// A map of properties specified within a configuration classification
func (o InstanceFleetInstanceTypeConfigConfigurationOutput) Properties() pulumi.MapOutput {
	return o.ApplyT(func(v InstanceFleetInstanceTypeConfigConfiguration) map[string]interface{} { return v.Properties }).(pulumi.MapOutput)
}

type InstanceFleetInstanceTypeConfigConfigurationArrayOutput struct{ *pulumi.OutputState }

func (InstanceFleetInstanceTypeConfigConfigurationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceFleetInstanceTypeConfigConfiguration)(nil)).Elem()
}

func (o InstanceFleetInstanceTypeConfigConfigurationArrayOutput) ToInstanceFleetInstanceTypeConfigConfigurationArrayOutput() InstanceFleetInstanceTypeConfigConfigurationArrayOutput {
	return o
}

func (o InstanceFleetInstanceTypeConfigConfigurationArrayOutput) ToInstanceFleetInstanceTypeConfigConfigurationArrayOutputWithContext(ctx context.Context) InstanceFleetInstanceTypeConfigConfigurationArrayOutput {
	return o
}

func (o InstanceFleetInstanceTypeConfigConfigurationArrayOutput) Index(i pulumi.IntInput) InstanceFleetInstanceTypeConfigConfigurationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InstanceFleetInstanceTypeConfigConfiguration {
		return vs[0].([]InstanceFleetInstanceTypeConfigConfiguration)[vs[1].(int)]
	}).(InstanceFleetInstanceTypeConfigConfigurationOutput)
}

type InstanceFleetInstanceTypeConfigEbsConfig struct {
	// The number of I/O operations per second (IOPS) that the volume supports
	Iops *int `pulumi:"iops"`
	// The volume size, in gibibytes (GiB).
	Size int `pulumi:"size"`
	// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
	Type string `pulumi:"type"`
	// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
	VolumesPerInstance *int `pulumi:"volumesPerInstance"`
}

// InstanceFleetInstanceTypeConfigEbsConfigInput is an input type that accepts InstanceFleetInstanceTypeConfigEbsConfigArgs and InstanceFleetInstanceTypeConfigEbsConfigOutput values.
// You can construct a concrete instance of `InstanceFleetInstanceTypeConfigEbsConfigInput` via:
//
//          InstanceFleetInstanceTypeConfigEbsConfigArgs{...}
type InstanceFleetInstanceTypeConfigEbsConfigInput interface {
	pulumi.Input

	ToInstanceFleetInstanceTypeConfigEbsConfigOutput() InstanceFleetInstanceTypeConfigEbsConfigOutput
	ToInstanceFleetInstanceTypeConfigEbsConfigOutputWithContext(context.Context) InstanceFleetInstanceTypeConfigEbsConfigOutput
}

type InstanceFleetInstanceTypeConfigEbsConfigArgs struct {
	// The number of I/O operations per second (IOPS) that the volume supports
	Iops pulumi.IntPtrInput `pulumi:"iops"`
	// The volume size, in gibibytes (GiB).
	Size pulumi.IntInput `pulumi:"size"`
	// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
	Type pulumi.StringInput `pulumi:"type"`
	// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
	VolumesPerInstance pulumi.IntPtrInput `pulumi:"volumesPerInstance"`
}

func (InstanceFleetInstanceTypeConfigEbsConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceFleetInstanceTypeConfigEbsConfig)(nil)).Elem()
}

func (i InstanceFleetInstanceTypeConfigEbsConfigArgs) ToInstanceFleetInstanceTypeConfigEbsConfigOutput() InstanceFleetInstanceTypeConfigEbsConfigOutput {
	return i.ToInstanceFleetInstanceTypeConfigEbsConfigOutputWithContext(context.Background())
}

func (i InstanceFleetInstanceTypeConfigEbsConfigArgs) ToInstanceFleetInstanceTypeConfigEbsConfigOutputWithContext(ctx context.Context) InstanceFleetInstanceTypeConfigEbsConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceFleetInstanceTypeConfigEbsConfigOutput)
}

// InstanceFleetInstanceTypeConfigEbsConfigArrayInput is an input type that accepts InstanceFleetInstanceTypeConfigEbsConfigArray and InstanceFleetInstanceTypeConfigEbsConfigArrayOutput values.
// You can construct a concrete instance of `InstanceFleetInstanceTypeConfigEbsConfigArrayInput` via:
//
//          InstanceFleetInstanceTypeConfigEbsConfigArray{ InstanceFleetInstanceTypeConfigEbsConfigArgs{...} }
type InstanceFleetInstanceTypeConfigEbsConfigArrayInput interface {
	pulumi.Input

	ToInstanceFleetInstanceTypeConfigEbsConfigArrayOutput() InstanceFleetInstanceTypeConfigEbsConfigArrayOutput
	ToInstanceFleetInstanceTypeConfigEbsConfigArrayOutputWithContext(context.Context) InstanceFleetInstanceTypeConfigEbsConfigArrayOutput
}

type InstanceFleetInstanceTypeConfigEbsConfigArray []InstanceFleetInstanceTypeConfigEbsConfigInput

func (InstanceFleetInstanceTypeConfigEbsConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceFleetInstanceTypeConfigEbsConfig)(nil)).Elem()
}

func (i InstanceFleetInstanceTypeConfigEbsConfigArray) ToInstanceFleetInstanceTypeConfigEbsConfigArrayOutput() InstanceFleetInstanceTypeConfigEbsConfigArrayOutput {
	return i.ToInstanceFleetInstanceTypeConfigEbsConfigArrayOutputWithContext(context.Background())
}

func (i InstanceFleetInstanceTypeConfigEbsConfigArray) ToInstanceFleetInstanceTypeConfigEbsConfigArrayOutputWithContext(ctx context.Context) InstanceFleetInstanceTypeConfigEbsConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceFleetInstanceTypeConfigEbsConfigArrayOutput)
}

type InstanceFleetInstanceTypeConfigEbsConfigOutput struct{ *pulumi.OutputState }

func (InstanceFleetInstanceTypeConfigEbsConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceFleetInstanceTypeConfigEbsConfig)(nil)).Elem()
}

func (o InstanceFleetInstanceTypeConfigEbsConfigOutput) ToInstanceFleetInstanceTypeConfigEbsConfigOutput() InstanceFleetInstanceTypeConfigEbsConfigOutput {
	return o
}

func (o InstanceFleetInstanceTypeConfigEbsConfigOutput) ToInstanceFleetInstanceTypeConfigEbsConfigOutputWithContext(ctx context.Context) InstanceFleetInstanceTypeConfigEbsConfigOutput {
	return o
}

// The number of I/O operations per second (IOPS) that the volume supports
func (o InstanceFleetInstanceTypeConfigEbsConfigOutput) Iops() pulumi.IntPtrOutput {
	return o.ApplyT(func(v InstanceFleetInstanceTypeConfigEbsConfig) *int { return v.Iops }).(pulumi.IntPtrOutput)
}

// The volume size, in gibibytes (GiB).
func (o InstanceFleetInstanceTypeConfigEbsConfigOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v InstanceFleetInstanceTypeConfigEbsConfig) int { return v.Size }).(pulumi.IntOutput)
}

// The volume type. Valid options are `gp2`, `io1`, `standard` and `st1`. See [EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
func (o InstanceFleetInstanceTypeConfigEbsConfigOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v InstanceFleetInstanceTypeConfigEbsConfig) string { return v.Type }).(pulumi.StringOutput)
}

// The number of EBS volumes with this configuration to attach to each EC2 instance in the instance group (default is 1)
func (o InstanceFleetInstanceTypeConfigEbsConfigOutput) VolumesPerInstance() pulumi.IntPtrOutput {
	return o.ApplyT(func(v InstanceFleetInstanceTypeConfigEbsConfig) *int { return v.VolumesPerInstance }).(pulumi.IntPtrOutput)
}

type InstanceFleetInstanceTypeConfigEbsConfigArrayOutput struct{ *pulumi.OutputState }

func (InstanceFleetInstanceTypeConfigEbsConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceFleetInstanceTypeConfigEbsConfig)(nil)).Elem()
}

func (o InstanceFleetInstanceTypeConfigEbsConfigArrayOutput) ToInstanceFleetInstanceTypeConfigEbsConfigArrayOutput() InstanceFleetInstanceTypeConfigEbsConfigArrayOutput {
	return o
}

func (o InstanceFleetInstanceTypeConfigEbsConfigArrayOutput) ToInstanceFleetInstanceTypeConfigEbsConfigArrayOutputWithContext(ctx context.Context) InstanceFleetInstanceTypeConfigEbsConfigArrayOutput {
	return o
}

func (o InstanceFleetInstanceTypeConfigEbsConfigArrayOutput) Index(i pulumi.IntInput) InstanceFleetInstanceTypeConfigEbsConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InstanceFleetInstanceTypeConfigEbsConfig {
		return vs[0].([]InstanceFleetInstanceTypeConfigEbsConfig)[vs[1].(int)]
	}).(InstanceFleetInstanceTypeConfigEbsConfigOutput)
}

type InstanceFleetLaunchSpecifications struct {
	// Configuration block for on demand instances launch specifications
	OnDemandSpecifications []InstanceFleetLaunchSpecificationsOnDemandSpecification `pulumi:"onDemandSpecifications"`
	// Configuration block for spot instances launch specifications
	SpotSpecifications []InstanceFleetLaunchSpecificationsSpotSpecification `pulumi:"spotSpecifications"`
}

// InstanceFleetLaunchSpecificationsInput is an input type that accepts InstanceFleetLaunchSpecificationsArgs and InstanceFleetLaunchSpecificationsOutput values.
// You can construct a concrete instance of `InstanceFleetLaunchSpecificationsInput` via:
//
//          InstanceFleetLaunchSpecificationsArgs{...}
type InstanceFleetLaunchSpecificationsInput interface {
	pulumi.Input

	ToInstanceFleetLaunchSpecificationsOutput() InstanceFleetLaunchSpecificationsOutput
	ToInstanceFleetLaunchSpecificationsOutputWithContext(context.Context) InstanceFleetLaunchSpecificationsOutput
}

type InstanceFleetLaunchSpecificationsArgs struct {
	// Configuration block for on demand instances launch specifications
	OnDemandSpecifications InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayInput `pulumi:"onDemandSpecifications"`
	// Configuration block for spot instances launch specifications
	SpotSpecifications InstanceFleetLaunchSpecificationsSpotSpecificationArrayInput `pulumi:"spotSpecifications"`
}

func (InstanceFleetLaunchSpecificationsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceFleetLaunchSpecifications)(nil)).Elem()
}

func (i InstanceFleetLaunchSpecificationsArgs) ToInstanceFleetLaunchSpecificationsOutput() InstanceFleetLaunchSpecificationsOutput {
	return i.ToInstanceFleetLaunchSpecificationsOutputWithContext(context.Background())
}

func (i InstanceFleetLaunchSpecificationsArgs) ToInstanceFleetLaunchSpecificationsOutputWithContext(ctx context.Context) InstanceFleetLaunchSpecificationsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceFleetLaunchSpecificationsOutput)
}

func (i InstanceFleetLaunchSpecificationsArgs) ToInstanceFleetLaunchSpecificationsPtrOutput() InstanceFleetLaunchSpecificationsPtrOutput {
	return i.ToInstanceFleetLaunchSpecificationsPtrOutputWithContext(context.Background())
}

func (i InstanceFleetLaunchSpecificationsArgs) ToInstanceFleetLaunchSpecificationsPtrOutputWithContext(ctx context.Context) InstanceFleetLaunchSpecificationsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceFleetLaunchSpecificationsOutput).ToInstanceFleetLaunchSpecificationsPtrOutputWithContext(ctx)
}

// InstanceFleetLaunchSpecificationsPtrInput is an input type that accepts InstanceFleetLaunchSpecificationsArgs, InstanceFleetLaunchSpecificationsPtr and InstanceFleetLaunchSpecificationsPtrOutput values.
// You can construct a concrete instance of `InstanceFleetLaunchSpecificationsPtrInput` via:
//
//          InstanceFleetLaunchSpecificationsArgs{...}
//
//  or:
//
//          nil
type InstanceFleetLaunchSpecificationsPtrInput interface {
	pulumi.Input

	ToInstanceFleetLaunchSpecificationsPtrOutput() InstanceFleetLaunchSpecificationsPtrOutput
	ToInstanceFleetLaunchSpecificationsPtrOutputWithContext(context.Context) InstanceFleetLaunchSpecificationsPtrOutput
}

type instanceFleetLaunchSpecificationsPtrType InstanceFleetLaunchSpecificationsArgs

func InstanceFleetLaunchSpecificationsPtr(v *InstanceFleetLaunchSpecificationsArgs) InstanceFleetLaunchSpecificationsPtrInput {
	return (*instanceFleetLaunchSpecificationsPtrType)(v)
}

func (*instanceFleetLaunchSpecificationsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**InstanceFleetLaunchSpecifications)(nil)).Elem()
}

func (i *instanceFleetLaunchSpecificationsPtrType) ToInstanceFleetLaunchSpecificationsPtrOutput() InstanceFleetLaunchSpecificationsPtrOutput {
	return i.ToInstanceFleetLaunchSpecificationsPtrOutputWithContext(context.Background())
}

func (i *instanceFleetLaunchSpecificationsPtrType) ToInstanceFleetLaunchSpecificationsPtrOutputWithContext(ctx context.Context) InstanceFleetLaunchSpecificationsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceFleetLaunchSpecificationsPtrOutput)
}

type InstanceFleetLaunchSpecificationsOutput struct{ *pulumi.OutputState }

func (InstanceFleetLaunchSpecificationsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceFleetLaunchSpecifications)(nil)).Elem()
}

func (o InstanceFleetLaunchSpecificationsOutput) ToInstanceFleetLaunchSpecificationsOutput() InstanceFleetLaunchSpecificationsOutput {
	return o
}

func (o InstanceFleetLaunchSpecificationsOutput) ToInstanceFleetLaunchSpecificationsOutputWithContext(ctx context.Context) InstanceFleetLaunchSpecificationsOutput {
	return o
}

func (o InstanceFleetLaunchSpecificationsOutput) ToInstanceFleetLaunchSpecificationsPtrOutput() InstanceFleetLaunchSpecificationsPtrOutput {
	return o.ToInstanceFleetLaunchSpecificationsPtrOutputWithContext(context.Background())
}

func (o InstanceFleetLaunchSpecificationsOutput) ToInstanceFleetLaunchSpecificationsPtrOutputWithContext(ctx context.Context) InstanceFleetLaunchSpecificationsPtrOutput {
	return o.ApplyT(func(v InstanceFleetLaunchSpecifications) *InstanceFleetLaunchSpecifications {
		return &v
	}).(InstanceFleetLaunchSpecificationsPtrOutput)
}

// Configuration block for on demand instances launch specifications
func (o InstanceFleetLaunchSpecificationsOutput) OnDemandSpecifications() InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput {
	return o.ApplyT(func(v InstanceFleetLaunchSpecifications) []InstanceFleetLaunchSpecificationsOnDemandSpecification {
		return v.OnDemandSpecifications
	}).(InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput)
}

// Configuration block for spot instances launch specifications
func (o InstanceFleetLaunchSpecificationsOutput) SpotSpecifications() InstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput {
	return o.ApplyT(func(v InstanceFleetLaunchSpecifications) []InstanceFleetLaunchSpecificationsSpotSpecification {
		return v.SpotSpecifications
	}).(InstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput)
}

type InstanceFleetLaunchSpecificationsPtrOutput struct{ *pulumi.OutputState }

func (InstanceFleetLaunchSpecificationsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InstanceFleetLaunchSpecifications)(nil)).Elem()
}

func (o InstanceFleetLaunchSpecificationsPtrOutput) ToInstanceFleetLaunchSpecificationsPtrOutput() InstanceFleetLaunchSpecificationsPtrOutput {
	return o
}

func (o InstanceFleetLaunchSpecificationsPtrOutput) ToInstanceFleetLaunchSpecificationsPtrOutputWithContext(ctx context.Context) InstanceFleetLaunchSpecificationsPtrOutput {
	return o
}

func (o InstanceFleetLaunchSpecificationsPtrOutput) Elem() InstanceFleetLaunchSpecificationsOutput {
	return o.ApplyT(func(v *InstanceFleetLaunchSpecifications) InstanceFleetLaunchSpecifications { return *v }).(InstanceFleetLaunchSpecificationsOutput)
}

// Configuration block for on demand instances launch specifications
func (o InstanceFleetLaunchSpecificationsPtrOutput) OnDemandSpecifications() InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput {
	return o.ApplyT(func(v *InstanceFleetLaunchSpecifications) []InstanceFleetLaunchSpecificationsOnDemandSpecification {
		if v == nil {
			return nil
		}
		return v.OnDemandSpecifications
	}).(InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput)
}

// Configuration block for spot instances launch specifications
func (o InstanceFleetLaunchSpecificationsPtrOutput) SpotSpecifications() InstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput {
	return o.ApplyT(func(v *InstanceFleetLaunchSpecifications) []InstanceFleetLaunchSpecificationsSpotSpecification {
		if v == nil {
			return nil
		}
		return v.SpotSpecifications
	}).(InstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput)
}

type InstanceFleetLaunchSpecificationsOnDemandSpecification struct {
	// Specifies the strategy to use in launching Spot instance fleets. Currently, the only option is `capacity-optimized` (the default), which launches instances from Spot instance pools with optimal capacity for the number of instances that are launching.
	AllocationStrategy string `pulumi:"allocationStrategy"`
}

// InstanceFleetLaunchSpecificationsOnDemandSpecificationInput is an input type that accepts InstanceFleetLaunchSpecificationsOnDemandSpecificationArgs and InstanceFleetLaunchSpecificationsOnDemandSpecificationOutput values.
// You can construct a concrete instance of `InstanceFleetLaunchSpecificationsOnDemandSpecificationInput` via:
//
//          InstanceFleetLaunchSpecificationsOnDemandSpecificationArgs{...}
type InstanceFleetLaunchSpecificationsOnDemandSpecificationInput interface {
	pulumi.Input

	ToInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput() InstanceFleetLaunchSpecificationsOnDemandSpecificationOutput
	ToInstanceFleetLaunchSpecificationsOnDemandSpecificationOutputWithContext(context.Context) InstanceFleetLaunchSpecificationsOnDemandSpecificationOutput
}

type InstanceFleetLaunchSpecificationsOnDemandSpecificationArgs struct {
	// Specifies the strategy to use in launching Spot instance fleets. Currently, the only option is `capacity-optimized` (the default), which launches instances from Spot instance pools with optimal capacity for the number of instances that are launching.
	AllocationStrategy pulumi.StringInput `pulumi:"allocationStrategy"`
}

func (InstanceFleetLaunchSpecificationsOnDemandSpecificationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceFleetLaunchSpecificationsOnDemandSpecification)(nil)).Elem()
}

func (i InstanceFleetLaunchSpecificationsOnDemandSpecificationArgs) ToInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput() InstanceFleetLaunchSpecificationsOnDemandSpecificationOutput {
	return i.ToInstanceFleetLaunchSpecificationsOnDemandSpecificationOutputWithContext(context.Background())
}

func (i InstanceFleetLaunchSpecificationsOnDemandSpecificationArgs) ToInstanceFleetLaunchSpecificationsOnDemandSpecificationOutputWithContext(ctx context.Context) InstanceFleetLaunchSpecificationsOnDemandSpecificationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceFleetLaunchSpecificationsOnDemandSpecificationOutput)
}

// InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayInput is an input type that accepts InstanceFleetLaunchSpecificationsOnDemandSpecificationArray and InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput values.
// You can construct a concrete instance of `InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayInput` via:
//
//          InstanceFleetLaunchSpecificationsOnDemandSpecificationArray{ InstanceFleetLaunchSpecificationsOnDemandSpecificationArgs{...} }
type InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayInput interface {
	pulumi.Input

	ToInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput() InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput
	ToInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutputWithContext(context.Context) InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput
}

type InstanceFleetLaunchSpecificationsOnDemandSpecificationArray []InstanceFleetLaunchSpecificationsOnDemandSpecificationInput

func (InstanceFleetLaunchSpecificationsOnDemandSpecificationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceFleetLaunchSpecificationsOnDemandSpecification)(nil)).Elem()
}

func (i InstanceFleetLaunchSpecificationsOnDemandSpecificationArray) ToInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput() InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput {
	return i.ToInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutputWithContext(context.Background())
}

func (i InstanceFleetLaunchSpecificationsOnDemandSpecificationArray) ToInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutputWithContext(ctx context.Context) InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput)
}

type InstanceFleetLaunchSpecificationsOnDemandSpecificationOutput struct{ *pulumi.OutputState }

func (InstanceFleetLaunchSpecificationsOnDemandSpecificationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceFleetLaunchSpecificationsOnDemandSpecification)(nil)).Elem()
}

func (o InstanceFleetLaunchSpecificationsOnDemandSpecificationOutput) ToInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput() InstanceFleetLaunchSpecificationsOnDemandSpecificationOutput {
	return o
}

func (o InstanceFleetLaunchSpecificationsOnDemandSpecificationOutput) ToInstanceFleetLaunchSpecificationsOnDemandSpecificationOutputWithContext(ctx context.Context) InstanceFleetLaunchSpecificationsOnDemandSpecificationOutput {
	return o
}

// Specifies the strategy to use in launching Spot instance fleets. Currently, the only option is `capacity-optimized` (the default), which launches instances from Spot instance pools with optimal capacity for the number of instances that are launching.
func (o InstanceFleetLaunchSpecificationsOnDemandSpecificationOutput) AllocationStrategy() pulumi.StringOutput {
	return o.ApplyT(func(v InstanceFleetLaunchSpecificationsOnDemandSpecification) string { return v.AllocationStrategy }).(pulumi.StringOutput)
}

type InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput struct{ *pulumi.OutputState }

func (InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceFleetLaunchSpecificationsOnDemandSpecification)(nil)).Elem()
}

func (o InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput) ToInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput() InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput {
	return o
}

func (o InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput) ToInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutputWithContext(ctx context.Context) InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput {
	return o
}

func (o InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput) Index(i pulumi.IntInput) InstanceFleetLaunchSpecificationsOnDemandSpecificationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InstanceFleetLaunchSpecificationsOnDemandSpecification {
		return vs[0].([]InstanceFleetLaunchSpecificationsOnDemandSpecification)[vs[1].(int)]
	}).(InstanceFleetLaunchSpecificationsOnDemandSpecificationOutput)
}

type InstanceFleetLaunchSpecificationsSpotSpecification struct {
	// Specifies the strategy to use in launching Spot instance fleets. Currently, the only option is `capacity-optimized` (the default), which launches instances from Spot instance pools with optimal capacity for the number of instances that are launching.
	AllocationStrategy string `pulumi:"allocationStrategy"`
	// The defined duration for Spot instances (also known as Spot blocks) in minutes. When specified, the Spot instance does not terminate before the defined duration expires, and defined duration pricing for Spot instances applies. Valid values are 60, 120, 180, 240, 300, or 360. The duration period starts as soon as a Spot instance receives its instance ID. At the end of the duration, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates.
	BlockDurationMinutes *int `pulumi:"blockDurationMinutes"`
	// The action to take when TargetSpotCapacity has not been fulfilled when the TimeoutDurationMinutes has expired; that is, when all Spot instances could not be provisioned within the Spot provisioning timeout. Valid values are `TERMINATE_CLUSTER` and `SWITCH_TO_ON_DEMAND`. SWITCH_TO_ON_DEMAND specifies that if no Spot instances are available, On-Demand Instances should be provisioned to fulfill any remaining Spot capacity.
	TimeoutAction string `pulumi:"timeoutAction"`
	// The spot provisioning timeout period in minutes. If Spot instances are not provisioned within this time period, the TimeOutAction is taken. Minimum value is 5 and maximum value is 1440. The timeout applies only during initial provisioning, when the cluster is first created.
	TimeoutDurationMinutes int `pulumi:"timeoutDurationMinutes"`
}

// InstanceFleetLaunchSpecificationsSpotSpecificationInput is an input type that accepts InstanceFleetLaunchSpecificationsSpotSpecificationArgs and InstanceFleetLaunchSpecificationsSpotSpecificationOutput values.
// You can construct a concrete instance of `InstanceFleetLaunchSpecificationsSpotSpecificationInput` via:
//
//          InstanceFleetLaunchSpecificationsSpotSpecificationArgs{...}
type InstanceFleetLaunchSpecificationsSpotSpecificationInput interface {
	pulumi.Input

	ToInstanceFleetLaunchSpecificationsSpotSpecificationOutput() InstanceFleetLaunchSpecificationsSpotSpecificationOutput
	ToInstanceFleetLaunchSpecificationsSpotSpecificationOutputWithContext(context.Context) InstanceFleetLaunchSpecificationsSpotSpecificationOutput
}

type InstanceFleetLaunchSpecificationsSpotSpecificationArgs struct {
	// Specifies the strategy to use in launching Spot instance fleets. Currently, the only option is `capacity-optimized` (the default), which launches instances from Spot instance pools with optimal capacity for the number of instances that are launching.
	AllocationStrategy pulumi.StringInput `pulumi:"allocationStrategy"`
	// The defined duration for Spot instances (also known as Spot blocks) in minutes. When specified, the Spot instance does not terminate before the defined duration expires, and defined duration pricing for Spot instances applies. Valid values are 60, 120, 180, 240, 300, or 360. The duration period starts as soon as a Spot instance receives its instance ID. At the end of the duration, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates.
	BlockDurationMinutes pulumi.IntPtrInput `pulumi:"blockDurationMinutes"`
	// The action to take when TargetSpotCapacity has not been fulfilled when the TimeoutDurationMinutes has expired; that is, when all Spot instances could not be provisioned within the Spot provisioning timeout. Valid values are `TERMINATE_CLUSTER` and `SWITCH_TO_ON_DEMAND`. SWITCH_TO_ON_DEMAND specifies that if no Spot instances are available, On-Demand Instances should be provisioned to fulfill any remaining Spot capacity.
	TimeoutAction pulumi.StringInput `pulumi:"timeoutAction"`
	// The spot provisioning timeout period in minutes. If Spot instances are not provisioned within this time period, the TimeOutAction is taken. Minimum value is 5 and maximum value is 1440. The timeout applies only during initial provisioning, when the cluster is first created.
	TimeoutDurationMinutes pulumi.IntInput `pulumi:"timeoutDurationMinutes"`
}

func (InstanceFleetLaunchSpecificationsSpotSpecificationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceFleetLaunchSpecificationsSpotSpecification)(nil)).Elem()
}

func (i InstanceFleetLaunchSpecificationsSpotSpecificationArgs) ToInstanceFleetLaunchSpecificationsSpotSpecificationOutput() InstanceFleetLaunchSpecificationsSpotSpecificationOutput {
	return i.ToInstanceFleetLaunchSpecificationsSpotSpecificationOutputWithContext(context.Background())
}

func (i InstanceFleetLaunchSpecificationsSpotSpecificationArgs) ToInstanceFleetLaunchSpecificationsSpotSpecificationOutputWithContext(ctx context.Context) InstanceFleetLaunchSpecificationsSpotSpecificationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceFleetLaunchSpecificationsSpotSpecificationOutput)
}

// InstanceFleetLaunchSpecificationsSpotSpecificationArrayInput is an input type that accepts InstanceFleetLaunchSpecificationsSpotSpecificationArray and InstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput values.
// You can construct a concrete instance of `InstanceFleetLaunchSpecificationsSpotSpecificationArrayInput` via:
//
//          InstanceFleetLaunchSpecificationsSpotSpecificationArray{ InstanceFleetLaunchSpecificationsSpotSpecificationArgs{...} }
type InstanceFleetLaunchSpecificationsSpotSpecificationArrayInput interface {
	pulumi.Input

	ToInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput() InstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput
	ToInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutputWithContext(context.Context) InstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput
}

type InstanceFleetLaunchSpecificationsSpotSpecificationArray []InstanceFleetLaunchSpecificationsSpotSpecificationInput

func (InstanceFleetLaunchSpecificationsSpotSpecificationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceFleetLaunchSpecificationsSpotSpecification)(nil)).Elem()
}

func (i InstanceFleetLaunchSpecificationsSpotSpecificationArray) ToInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput() InstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput {
	return i.ToInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutputWithContext(context.Background())
}

func (i InstanceFleetLaunchSpecificationsSpotSpecificationArray) ToInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutputWithContext(ctx context.Context) InstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput)
}

type InstanceFleetLaunchSpecificationsSpotSpecificationOutput struct{ *pulumi.OutputState }

func (InstanceFleetLaunchSpecificationsSpotSpecificationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceFleetLaunchSpecificationsSpotSpecification)(nil)).Elem()
}

func (o InstanceFleetLaunchSpecificationsSpotSpecificationOutput) ToInstanceFleetLaunchSpecificationsSpotSpecificationOutput() InstanceFleetLaunchSpecificationsSpotSpecificationOutput {
	return o
}

func (o InstanceFleetLaunchSpecificationsSpotSpecificationOutput) ToInstanceFleetLaunchSpecificationsSpotSpecificationOutputWithContext(ctx context.Context) InstanceFleetLaunchSpecificationsSpotSpecificationOutput {
	return o
}

// Specifies the strategy to use in launching Spot instance fleets. Currently, the only option is `capacity-optimized` (the default), which launches instances from Spot instance pools with optimal capacity for the number of instances that are launching.
func (o InstanceFleetLaunchSpecificationsSpotSpecificationOutput) AllocationStrategy() pulumi.StringOutput {
	return o.ApplyT(func(v InstanceFleetLaunchSpecificationsSpotSpecification) string { return v.AllocationStrategy }).(pulumi.StringOutput)
}

// The defined duration for Spot instances (also known as Spot blocks) in minutes. When specified, the Spot instance does not terminate before the defined duration expires, and defined duration pricing for Spot instances applies. Valid values are 60, 120, 180, 240, 300, or 360. The duration period starts as soon as a Spot instance receives its instance ID. At the end of the duration, Amazon EC2 marks the Spot instance for termination and provides a Spot instance termination notice, which gives the instance a two-minute warning before it terminates.
func (o InstanceFleetLaunchSpecificationsSpotSpecificationOutput) BlockDurationMinutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v InstanceFleetLaunchSpecificationsSpotSpecification) *int { return v.BlockDurationMinutes }).(pulumi.IntPtrOutput)
}

// The action to take when TargetSpotCapacity has not been fulfilled when the TimeoutDurationMinutes has expired; that is, when all Spot instances could not be provisioned within the Spot provisioning timeout. Valid values are `TERMINATE_CLUSTER` and `SWITCH_TO_ON_DEMAND`. SWITCH_TO_ON_DEMAND specifies that if no Spot instances are available, On-Demand Instances should be provisioned to fulfill any remaining Spot capacity.
func (o InstanceFleetLaunchSpecificationsSpotSpecificationOutput) TimeoutAction() pulumi.StringOutput {
	return o.ApplyT(func(v InstanceFleetLaunchSpecificationsSpotSpecification) string { return v.TimeoutAction }).(pulumi.StringOutput)
}

// The spot provisioning timeout period in minutes. If Spot instances are not provisioned within this time period, the TimeOutAction is taken. Minimum value is 5 and maximum value is 1440. The timeout applies only during initial provisioning, when the cluster is first created.
func (o InstanceFleetLaunchSpecificationsSpotSpecificationOutput) TimeoutDurationMinutes() pulumi.IntOutput {
	return o.ApplyT(func(v InstanceFleetLaunchSpecificationsSpotSpecification) int { return v.TimeoutDurationMinutes }).(pulumi.IntOutput)
}

type InstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput struct{ *pulumi.OutputState }

func (InstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceFleetLaunchSpecificationsSpotSpecification)(nil)).Elem()
}

func (o InstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput) ToInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput() InstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput {
	return o
}

func (o InstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput) ToInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutputWithContext(ctx context.Context) InstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput {
	return o
}

func (o InstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput) Index(i pulumi.IntInput) InstanceFleetLaunchSpecificationsSpotSpecificationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InstanceFleetLaunchSpecificationsSpotSpecification {
		return vs[0].([]InstanceFleetLaunchSpecificationsSpotSpecification)[vs[1].(int)]
	}).(InstanceFleetLaunchSpecificationsSpotSpecificationOutput)
}

type InstanceGroupEbsConfig struct {
	// The number of I/O operations per second (IOPS) that the volume supports.
	Iops *int `pulumi:"iops"`
	// The volume size, in gibibytes (GiB). This can be a number from 1 - 1024. If the volume type is EBS-optimized, the minimum value is 10.
	Size int `pulumi:"size"`
	// The volume type. Valid options are 'gp2', 'io1' and 'standard'.
	Type string `pulumi:"type"`
	// The number of EBS Volumes to attach per instance.
	VolumesPerInstance *int `pulumi:"volumesPerInstance"`
}

// InstanceGroupEbsConfigInput is an input type that accepts InstanceGroupEbsConfigArgs and InstanceGroupEbsConfigOutput values.
// You can construct a concrete instance of `InstanceGroupEbsConfigInput` via:
//
//          InstanceGroupEbsConfigArgs{...}
type InstanceGroupEbsConfigInput interface {
	pulumi.Input

	ToInstanceGroupEbsConfigOutput() InstanceGroupEbsConfigOutput
	ToInstanceGroupEbsConfigOutputWithContext(context.Context) InstanceGroupEbsConfigOutput
}

type InstanceGroupEbsConfigArgs struct {
	// The number of I/O operations per second (IOPS) that the volume supports.
	Iops pulumi.IntPtrInput `pulumi:"iops"`
	// The volume size, in gibibytes (GiB). This can be a number from 1 - 1024. If the volume type is EBS-optimized, the minimum value is 10.
	Size pulumi.IntInput `pulumi:"size"`
	// The volume type. Valid options are 'gp2', 'io1' and 'standard'.
	Type pulumi.StringInput `pulumi:"type"`
	// The number of EBS Volumes to attach per instance.
	VolumesPerInstance pulumi.IntPtrInput `pulumi:"volumesPerInstance"`
}

func (InstanceGroupEbsConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceGroupEbsConfig)(nil)).Elem()
}

func (i InstanceGroupEbsConfigArgs) ToInstanceGroupEbsConfigOutput() InstanceGroupEbsConfigOutput {
	return i.ToInstanceGroupEbsConfigOutputWithContext(context.Background())
}

func (i InstanceGroupEbsConfigArgs) ToInstanceGroupEbsConfigOutputWithContext(ctx context.Context) InstanceGroupEbsConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceGroupEbsConfigOutput)
}

// InstanceGroupEbsConfigArrayInput is an input type that accepts InstanceGroupEbsConfigArray and InstanceGroupEbsConfigArrayOutput values.
// You can construct a concrete instance of `InstanceGroupEbsConfigArrayInput` via:
//
//          InstanceGroupEbsConfigArray{ InstanceGroupEbsConfigArgs{...} }
type InstanceGroupEbsConfigArrayInput interface {
	pulumi.Input

	ToInstanceGroupEbsConfigArrayOutput() InstanceGroupEbsConfigArrayOutput
	ToInstanceGroupEbsConfigArrayOutputWithContext(context.Context) InstanceGroupEbsConfigArrayOutput
}

type InstanceGroupEbsConfigArray []InstanceGroupEbsConfigInput

func (InstanceGroupEbsConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceGroupEbsConfig)(nil)).Elem()
}

func (i InstanceGroupEbsConfigArray) ToInstanceGroupEbsConfigArrayOutput() InstanceGroupEbsConfigArrayOutput {
	return i.ToInstanceGroupEbsConfigArrayOutputWithContext(context.Background())
}

func (i InstanceGroupEbsConfigArray) ToInstanceGroupEbsConfigArrayOutputWithContext(ctx context.Context) InstanceGroupEbsConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceGroupEbsConfigArrayOutput)
}

type InstanceGroupEbsConfigOutput struct{ *pulumi.OutputState }

func (InstanceGroupEbsConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InstanceGroupEbsConfig)(nil)).Elem()
}

func (o InstanceGroupEbsConfigOutput) ToInstanceGroupEbsConfigOutput() InstanceGroupEbsConfigOutput {
	return o
}

func (o InstanceGroupEbsConfigOutput) ToInstanceGroupEbsConfigOutputWithContext(ctx context.Context) InstanceGroupEbsConfigOutput {
	return o
}

// The number of I/O operations per second (IOPS) that the volume supports.
func (o InstanceGroupEbsConfigOutput) Iops() pulumi.IntPtrOutput {
	return o.ApplyT(func(v InstanceGroupEbsConfig) *int { return v.Iops }).(pulumi.IntPtrOutput)
}

// The volume size, in gibibytes (GiB). This can be a number from 1 - 1024. If the volume type is EBS-optimized, the minimum value is 10.
func (o InstanceGroupEbsConfigOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v InstanceGroupEbsConfig) int { return v.Size }).(pulumi.IntOutput)
}

// The volume type. Valid options are 'gp2', 'io1' and 'standard'.
func (o InstanceGroupEbsConfigOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v InstanceGroupEbsConfig) string { return v.Type }).(pulumi.StringOutput)
}

// The number of EBS Volumes to attach per instance.
func (o InstanceGroupEbsConfigOutput) VolumesPerInstance() pulumi.IntPtrOutput {
	return o.ApplyT(func(v InstanceGroupEbsConfig) *int { return v.VolumesPerInstance }).(pulumi.IntPtrOutput)
}

type InstanceGroupEbsConfigArrayOutput struct{ *pulumi.OutputState }

func (InstanceGroupEbsConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]InstanceGroupEbsConfig)(nil)).Elem()
}

func (o InstanceGroupEbsConfigArrayOutput) ToInstanceGroupEbsConfigArrayOutput() InstanceGroupEbsConfigArrayOutput {
	return o
}

func (o InstanceGroupEbsConfigArrayOutput) ToInstanceGroupEbsConfigArrayOutputWithContext(ctx context.Context) InstanceGroupEbsConfigArrayOutput {
	return o
}

func (o InstanceGroupEbsConfigArrayOutput) Index(i pulumi.IntInput) InstanceGroupEbsConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) InstanceGroupEbsConfig {
		return vs[0].([]InstanceGroupEbsConfig)[vs[1].(int)]
	}).(InstanceGroupEbsConfigOutput)
}

type ManagedScalingPolicyComputeLimit struct {
	// The upper boundary of EC2 units. It is measured through VCPU cores or instances for instance groups and measured through units for instance fleets. Managed scaling activities are not allowed beyond this boundary. The limit only applies to the core and task nodes. The master node cannot be scaled after initial configuration.
	MaximumCapacityUnits int `pulumi:"maximumCapacityUnits"`
	// The upper boundary of EC2 units for core node type in a cluster. It is measured through VCPU cores or instances for instance groups and measured through units for instance fleets. The core units are not allowed to scale beyond this boundary. The parameter is used to split capacity allocation between core and task nodes.
	MaximumCoreCapacityUnits *int `pulumi:"maximumCoreCapacityUnits"`
	// The upper boundary of On-Demand EC2 units. It is measured through VCPU cores or instances for instance groups and measured through units for instance fleets. The On-Demand units are not allowed to scale beyond this boundary. The parameter is used to split capacity allocation between On-Demand and Spot instances.
	MaximumOndemandCapacityUnits *int `pulumi:"maximumOndemandCapacityUnits"`
	// The lower boundary of EC2 units. It is measured through VCPU cores or instances for instance groups and measured through units for instance fleets. Managed scaling activities are not allowed beyond this boundary. The limit only applies to the core and task nodes. The master node cannot be scaled after initial configuration.
	MinimumCapacityUnits int `pulumi:"minimumCapacityUnits"`
	// The unit type used for specifying a managed scaling policy. Valid Values: `InstanceFleetUnits` | `Instances` | `VCPU`
	UnitType string `pulumi:"unitType"`
}

// ManagedScalingPolicyComputeLimitInput is an input type that accepts ManagedScalingPolicyComputeLimitArgs and ManagedScalingPolicyComputeLimitOutput values.
// You can construct a concrete instance of `ManagedScalingPolicyComputeLimitInput` via:
//
//          ManagedScalingPolicyComputeLimitArgs{...}
type ManagedScalingPolicyComputeLimitInput interface {
	pulumi.Input

	ToManagedScalingPolicyComputeLimitOutput() ManagedScalingPolicyComputeLimitOutput
	ToManagedScalingPolicyComputeLimitOutputWithContext(context.Context) ManagedScalingPolicyComputeLimitOutput
}

type ManagedScalingPolicyComputeLimitArgs struct {
	// The upper boundary of EC2 units. It is measured through VCPU cores or instances for instance groups and measured through units for instance fleets. Managed scaling activities are not allowed beyond this boundary. The limit only applies to the core and task nodes. The master node cannot be scaled after initial configuration.
	MaximumCapacityUnits pulumi.IntInput `pulumi:"maximumCapacityUnits"`
	// The upper boundary of EC2 units for core node type in a cluster. It is measured through VCPU cores or instances for instance groups and measured through units for instance fleets. The core units are not allowed to scale beyond this boundary. The parameter is used to split capacity allocation between core and task nodes.
	MaximumCoreCapacityUnits pulumi.IntPtrInput `pulumi:"maximumCoreCapacityUnits"`
	// The upper boundary of On-Demand EC2 units. It is measured through VCPU cores or instances for instance groups and measured through units for instance fleets. The On-Demand units are not allowed to scale beyond this boundary. The parameter is used to split capacity allocation between On-Demand and Spot instances.
	MaximumOndemandCapacityUnits pulumi.IntPtrInput `pulumi:"maximumOndemandCapacityUnits"`
	// The lower boundary of EC2 units. It is measured through VCPU cores or instances for instance groups and measured through units for instance fleets. Managed scaling activities are not allowed beyond this boundary. The limit only applies to the core and task nodes. The master node cannot be scaled after initial configuration.
	MinimumCapacityUnits pulumi.IntInput `pulumi:"minimumCapacityUnits"`
	// The unit type used for specifying a managed scaling policy. Valid Values: `InstanceFleetUnits` | `Instances` | `VCPU`
	UnitType pulumi.StringInput `pulumi:"unitType"`
}

func (ManagedScalingPolicyComputeLimitArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedScalingPolicyComputeLimit)(nil)).Elem()
}

func (i ManagedScalingPolicyComputeLimitArgs) ToManagedScalingPolicyComputeLimitOutput() ManagedScalingPolicyComputeLimitOutput {
	return i.ToManagedScalingPolicyComputeLimitOutputWithContext(context.Background())
}

func (i ManagedScalingPolicyComputeLimitArgs) ToManagedScalingPolicyComputeLimitOutputWithContext(ctx context.Context) ManagedScalingPolicyComputeLimitOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedScalingPolicyComputeLimitOutput)
}

// ManagedScalingPolicyComputeLimitArrayInput is an input type that accepts ManagedScalingPolicyComputeLimitArray and ManagedScalingPolicyComputeLimitArrayOutput values.
// You can construct a concrete instance of `ManagedScalingPolicyComputeLimitArrayInput` via:
//
//          ManagedScalingPolicyComputeLimitArray{ ManagedScalingPolicyComputeLimitArgs{...} }
type ManagedScalingPolicyComputeLimitArrayInput interface {
	pulumi.Input

	ToManagedScalingPolicyComputeLimitArrayOutput() ManagedScalingPolicyComputeLimitArrayOutput
	ToManagedScalingPolicyComputeLimitArrayOutputWithContext(context.Context) ManagedScalingPolicyComputeLimitArrayOutput
}

type ManagedScalingPolicyComputeLimitArray []ManagedScalingPolicyComputeLimitInput

func (ManagedScalingPolicyComputeLimitArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ManagedScalingPolicyComputeLimit)(nil)).Elem()
}

func (i ManagedScalingPolicyComputeLimitArray) ToManagedScalingPolicyComputeLimitArrayOutput() ManagedScalingPolicyComputeLimitArrayOutput {
	return i.ToManagedScalingPolicyComputeLimitArrayOutputWithContext(context.Background())
}

func (i ManagedScalingPolicyComputeLimitArray) ToManagedScalingPolicyComputeLimitArrayOutputWithContext(ctx context.Context) ManagedScalingPolicyComputeLimitArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedScalingPolicyComputeLimitArrayOutput)
}

type ManagedScalingPolicyComputeLimitOutput struct{ *pulumi.OutputState }

func (ManagedScalingPolicyComputeLimitOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedScalingPolicyComputeLimit)(nil)).Elem()
}

func (o ManagedScalingPolicyComputeLimitOutput) ToManagedScalingPolicyComputeLimitOutput() ManagedScalingPolicyComputeLimitOutput {
	return o
}

func (o ManagedScalingPolicyComputeLimitOutput) ToManagedScalingPolicyComputeLimitOutputWithContext(ctx context.Context) ManagedScalingPolicyComputeLimitOutput {
	return o
}

// The upper boundary of EC2 units. It is measured through VCPU cores or instances for instance groups and measured through units for instance fleets. Managed scaling activities are not allowed beyond this boundary. The limit only applies to the core and task nodes. The master node cannot be scaled after initial configuration.
func (o ManagedScalingPolicyComputeLimitOutput) MaximumCapacityUnits() pulumi.IntOutput {
	return o.ApplyT(func(v ManagedScalingPolicyComputeLimit) int { return v.MaximumCapacityUnits }).(pulumi.IntOutput)
}

// The upper boundary of EC2 units for core node type in a cluster. It is measured through VCPU cores or instances for instance groups and measured through units for instance fleets. The core units are not allowed to scale beyond this boundary. The parameter is used to split capacity allocation between core and task nodes.
func (o ManagedScalingPolicyComputeLimitOutput) MaximumCoreCapacityUnits() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ManagedScalingPolicyComputeLimit) *int { return v.MaximumCoreCapacityUnits }).(pulumi.IntPtrOutput)
}

// The upper boundary of On-Demand EC2 units. It is measured through VCPU cores or instances for instance groups and measured through units for instance fleets. The On-Demand units are not allowed to scale beyond this boundary. The parameter is used to split capacity allocation between On-Demand and Spot instances.
func (o ManagedScalingPolicyComputeLimitOutput) MaximumOndemandCapacityUnits() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ManagedScalingPolicyComputeLimit) *int { return v.MaximumOndemandCapacityUnits }).(pulumi.IntPtrOutput)
}

// The lower boundary of EC2 units. It is measured through VCPU cores or instances for instance groups and measured through units for instance fleets. Managed scaling activities are not allowed beyond this boundary. The limit only applies to the core and task nodes. The master node cannot be scaled after initial configuration.
func (o ManagedScalingPolicyComputeLimitOutput) MinimumCapacityUnits() pulumi.IntOutput {
	return o.ApplyT(func(v ManagedScalingPolicyComputeLimit) int { return v.MinimumCapacityUnits }).(pulumi.IntOutput)
}

// The unit type used for specifying a managed scaling policy. Valid Values: `InstanceFleetUnits` | `Instances` | `VCPU`
func (o ManagedScalingPolicyComputeLimitOutput) UnitType() pulumi.StringOutput {
	return o.ApplyT(func(v ManagedScalingPolicyComputeLimit) string { return v.UnitType }).(pulumi.StringOutput)
}

type ManagedScalingPolicyComputeLimitArrayOutput struct{ *pulumi.OutputState }

func (ManagedScalingPolicyComputeLimitArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ManagedScalingPolicyComputeLimit)(nil)).Elem()
}

func (o ManagedScalingPolicyComputeLimitArrayOutput) ToManagedScalingPolicyComputeLimitArrayOutput() ManagedScalingPolicyComputeLimitArrayOutput {
	return o
}

func (o ManagedScalingPolicyComputeLimitArrayOutput) ToManagedScalingPolicyComputeLimitArrayOutputWithContext(ctx context.Context) ManagedScalingPolicyComputeLimitArrayOutput {
	return o
}

func (o ManagedScalingPolicyComputeLimitArrayOutput) Index(i pulumi.IntInput) ManagedScalingPolicyComputeLimitOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ManagedScalingPolicyComputeLimit {
		return vs[0].([]ManagedScalingPolicyComputeLimit)[vs[1].(int)]
	}).(ManagedScalingPolicyComputeLimitOutput)
}

func init() {
	pulumi.RegisterOutputType(ClusterBootstrapActionOutput{})
	pulumi.RegisterOutputType(ClusterBootstrapActionArrayOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceFleetOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceFleetPtrOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceFleetInstanceTypeConfigOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceFleetInstanceTypeConfigArrayOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceFleetInstanceTypeConfigConfigurationOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceFleetInstanceTypeConfigConfigurationArrayOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArrayOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceFleetLaunchSpecificationsOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceFleetLaunchSpecificationsPtrOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceGroupOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceGroupPtrOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceGroupEbsConfigOutput{})
	pulumi.RegisterOutputType(ClusterCoreInstanceGroupEbsConfigArrayOutput{})
	pulumi.RegisterOutputType(ClusterEc2AttributesOutput{})
	pulumi.RegisterOutputType(ClusterEc2AttributesPtrOutput{})
	pulumi.RegisterOutputType(ClusterKerberosAttributesOutput{})
	pulumi.RegisterOutputType(ClusterKerberosAttributesPtrOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceFleetOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceFleetPtrOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceFleetInstanceTypeConfigOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceFleetInstanceTypeConfigArrayOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceFleetInstanceTypeConfigConfigurationOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceFleetInstanceTypeConfigConfigurationArrayOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceFleetInstanceTypeConfigEbsConfigArrayOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceFleetLaunchSpecificationsOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceFleetLaunchSpecificationsPtrOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceGroupOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceGroupPtrOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceGroupEbsConfigOutput{})
	pulumi.RegisterOutputType(ClusterMasterInstanceGroupEbsConfigArrayOutput{})
	pulumi.RegisterOutputType(ClusterStepOutput{})
	pulumi.RegisterOutputType(ClusterStepArrayOutput{})
	pulumi.RegisterOutputType(ClusterStepHadoopJarStepOutput{})
	pulumi.RegisterOutputType(InstanceFleetInstanceTypeConfigOutput{})
	pulumi.RegisterOutputType(InstanceFleetInstanceTypeConfigArrayOutput{})
	pulumi.RegisterOutputType(InstanceFleetInstanceTypeConfigConfigurationOutput{})
	pulumi.RegisterOutputType(InstanceFleetInstanceTypeConfigConfigurationArrayOutput{})
	pulumi.RegisterOutputType(InstanceFleetInstanceTypeConfigEbsConfigOutput{})
	pulumi.RegisterOutputType(InstanceFleetInstanceTypeConfigEbsConfigArrayOutput{})
	pulumi.RegisterOutputType(InstanceFleetLaunchSpecificationsOutput{})
	pulumi.RegisterOutputType(InstanceFleetLaunchSpecificationsPtrOutput{})
	pulumi.RegisterOutputType(InstanceFleetLaunchSpecificationsOnDemandSpecificationOutput{})
	pulumi.RegisterOutputType(InstanceFleetLaunchSpecificationsOnDemandSpecificationArrayOutput{})
	pulumi.RegisterOutputType(InstanceFleetLaunchSpecificationsSpotSpecificationOutput{})
	pulumi.RegisterOutputType(InstanceFleetLaunchSpecificationsSpotSpecificationArrayOutput{})
	pulumi.RegisterOutputType(InstanceGroupEbsConfigOutput{})
	pulumi.RegisterOutputType(InstanceGroupEbsConfigArrayOutput{})
	pulumi.RegisterOutputType(ManagedScalingPolicyComputeLimitOutput{})
	pulumi.RegisterOutputType(ManagedScalingPolicyComputeLimitArrayOutput{})
}
