// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package finspace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v7/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type KxVolume struct {
	pulumi.CustomResourceState

	Arn                   pulumi.StringOutput                  `pulumi:"arn"`
	AttachedClusters      KxVolumeAttachedClusterArrayOutput   `pulumi:"attachedClusters"`
	AvailabilityZones     pulumi.StringArrayOutput             `pulumi:"availabilityZones"`
	AzMode                pulumi.StringOutput                  `pulumi:"azMode"`
	CreatedTimestamp      pulumi.StringOutput                  `pulumi:"createdTimestamp"`
	Description           pulumi.StringPtrOutput               `pulumi:"description"`
	EnvironmentId         pulumi.StringOutput                  `pulumi:"environmentId"`
	LastModifiedTimestamp pulumi.StringOutput                  `pulumi:"lastModifiedTimestamp"`
	Name                  pulumi.StringOutput                  `pulumi:"name"`
	Nas1Configurations    KxVolumeNas1ConfigurationArrayOutput `pulumi:"nas1Configurations"`
	Region                pulumi.StringOutput                  `pulumi:"region"`
	Status                pulumi.StringOutput                  `pulumi:"status"`
	StatusReason          pulumi.StringOutput                  `pulumi:"statusReason"`
	Tags                  pulumi.StringMapOutput               `pulumi:"tags"`
	TagsAll               pulumi.StringMapOutput               `pulumi:"tagsAll"`
	Type                  pulumi.StringOutput                  `pulumi:"type"`
}

// NewKxVolume registers a new resource with the given unique name, arguments, and options.
func NewKxVolume(ctx *pulumi.Context,
	name string, args *KxVolumeArgs, opts ...pulumi.ResourceOption) (*KxVolume, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AvailabilityZones == nil {
		return nil, errors.New("invalid value for required argument 'AvailabilityZones'")
	}
	if args.AzMode == nil {
		return nil, errors.New("invalid value for required argument 'AzMode'")
	}
	if args.EnvironmentId == nil {
		return nil, errors.New("invalid value for required argument 'EnvironmentId'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource KxVolume
	err := ctx.RegisterResource("aws:finspace/kxVolume:KxVolume", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetKxVolume gets an existing KxVolume resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetKxVolume(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *KxVolumeState, opts ...pulumi.ResourceOption) (*KxVolume, error) {
	var resource KxVolume
	err := ctx.ReadResource("aws:finspace/kxVolume:KxVolume", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering KxVolume resources.
type kxVolumeState struct {
	Arn                   *string                     `pulumi:"arn"`
	AttachedClusters      []KxVolumeAttachedCluster   `pulumi:"attachedClusters"`
	AvailabilityZones     []string                    `pulumi:"availabilityZones"`
	AzMode                *string                     `pulumi:"azMode"`
	CreatedTimestamp      *string                     `pulumi:"createdTimestamp"`
	Description           *string                     `pulumi:"description"`
	EnvironmentId         *string                     `pulumi:"environmentId"`
	LastModifiedTimestamp *string                     `pulumi:"lastModifiedTimestamp"`
	Name                  *string                     `pulumi:"name"`
	Nas1Configurations    []KxVolumeNas1Configuration `pulumi:"nas1Configurations"`
	Region                *string                     `pulumi:"region"`
	Status                *string                     `pulumi:"status"`
	StatusReason          *string                     `pulumi:"statusReason"`
	Tags                  map[string]string           `pulumi:"tags"`
	TagsAll               map[string]string           `pulumi:"tagsAll"`
	Type                  *string                     `pulumi:"type"`
}

type KxVolumeState struct {
	Arn                   pulumi.StringPtrInput
	AttachedClusters      KxVolumeAttachedClusterArrayInput
	AvailabilityZones     pulumi.StringArrayInput
	AzMode                pulumi.StringPtrInput
	CreatedTimestamp      pulumi.StringPtrInput
	Description           pulumi.StringPtrInput
	EnvironmentId         pulumi.StringPtrInput
	LastModifiedTimestamp pulumi.StringPtrInput
	Name                  pulumi.StringPtrInput
	Nas1Configurations    KxVolumeNas1ConfigurationArrayInput
	Region                pulumi.StringPtrInput
	Status                pulumi.StringPtrInput
	StatusReason          pulumi.StringPtrInput
	Tags                  pulumi.StringMapInput
	TagsAll               pulumi.StringMapInput
	Type                  pulumi.StringPtrInput
}

func (KxVolumeState) ElementType() reflect.Type {
	return reflect.TypeOf((*kxVolumeState)(nil)).Elem()
}

type kxVolumeArgs struct {
	AvailabilityZones  []string                    `pulumi:"availabilityZones"`
	AzMode             string                      `pulumi:"azMode"`
	Description        *string                     `pulumi:"description"`
	EnvironmentId      string                      `pulumi:"environmentId"`
	Name               *string                     `pulumi:"name"`
	Nas1Configurations []KxVolumeNas1Configuration `pulumi:"nas1Configurations"`
	Region             *string                     `pulumi:"region"`
	Tags               map[string]string           `pulumi:"tags"`
	Type               string                      `pulumi:"type"`
}

// The set of arguments for constructing a KxVolume resource.
type KxVolumeArgs struct {
	AvailabilityZones  pulumi.StringArrayInput
	AzMode             pulumi.StringInput
	Description        pulumi.StringPtrInput
	EnvironmentId      pulumi.StringInput
	Name               pulumi.StringPtrInput
	Nas1Configurations KxVolumeNas1ConfigurationArrayInput
	Region             pulumi.StringPtrInput
	Tags               pulumi.StringMapInput
	Type               pulumi.StringInput
}

func (KxVolumeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*kxVolumeArgs)(nil)).Elem()
}

type KxVolumeInput interface {
	pulumi.Input

	ToKxVolumeOutput() KxVolumeOutput
	ToKxVolumeOutputWithContext(ctx context.Context) KxVolumeOutput
}

func (*KxVolume) ElementType() reflect.Type {
	return reflect.TypeOf((**KxVolume)(nil)).Elem()
}

func (i *KxVolume) ToKxVolumeOutput() KxVolumeOutput {
	return i.ToKxVolumeOutputWithContext(context.Background())
}

func (i *KxVolume) ToKxVolumeOutputWithContext(ctx context.Context) KxVolumeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KxVolumeOutput)
}

// KxVolumeArrayInput is an input type that accepts KxVolumeArray and KxVolumeArrayOutput values.
// You can construct a concrete instance of `KxVolumeArrayInput` via:
//
//	KxVolumeArray{ KxVolumeArgs{...} }
type KxVolumeArrayInput interface {
	pulumi.Input

	ToKxVolumeArrayOutput() KxVolumeArrayOutput
	ToKxVolumeArrayOutputWithContext(context.Context) KxVolumeArrayOutput
}

type KxVolumeArray []KxVolumeInput

func (KxVolumeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KxVolume)(nil)).Elem()
}

func (i KxVolumeArray) ToKxVolumeArrayOutput() KxVolumeArrayOutput {
	return i.ToKxVolumeArrayOutputWithContext(context.Background())
}

func (i KxVolumeArray) ToKxVolumeArrayOutputWithContext(ctx context.Context) KxVolumeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KxVolumeArrayOutput)
}

// KxVolumeMapInput is an input type that accepts KxVolumeMap and KxVolumeMapOutput values.
// You can construct a concrete instance of `KxVolumeMapInput` via:
//
//	KxVolumeMap{ "key": KxVolumeArgs{...} }
type KxVolumeMapInput interface {
	pulumi.Input

	ToKxVolumeMapOutput() KxVolumeMapOutput
	ToKxVolumeMapOutputWithContext(context.Context) KxVolumeMapOutput
}

type KxVolumeMap map[string]KxVolumeInput

func (KxVolumeMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KxVolume)(nil)).Elem()
}

func (i KxVolumeMap) ToKxVolumeMapOutput() KxVolumeMapOutput {
	return i.ToKxVolumeMapOutputWithContext(context.Background())
}

func (i KxVolumeMap) ToKxVolumeMapOutputWithContext(ctx context.Context) KxVolumeMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KxVolumeMapOutput)
}

type KxVolumeOutput struct{ *pulumi.OutputState }

func (KxVolumeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KxVolume)(nil)).Elem()
}

func (o KxVolumeOutput) ToKxVolumeOutput() KxVolumeOutput {
	return o
}

func (o KxVolumeOutput) ToKxVolumeOutputWithContext(ctx context.Context) KxVolumeOutput {
	return o
}

func (o KxVolumeOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v *KxVolume) pulumi.StringOutput { return v.Arn }).(pulumi.StringOutput)
}

func (o KxVolumeOutput) AttachedClusters() KxVolumeAttachedClusterArrayOutput {
	return o.ApplyT(func(v *KxVolume) KxVolumeAttachedClusterArrayOutput { return v.AttachedClusters }).(KxVolumeAttachedClusterArrayOutput)
}

func (o KxVolumeOutput) AvailabilityZones() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *KxVolume) pulumi.StringArrayOutput { return v.AvailabilityZones }).(pulumi.StringArrayOutput)
}

func (o KxVolumeOutput) AzMode() pulumi.StringOutput {
	return o.ApplyT(func(v *KxVolume) pulumi.StringOutput { return v.AzMode }).(pulumi.StringOutput)
}

func (o KxVolumeOutput) CreatedTimestamp() pulumi.StringOutput {
	return o.ApplyT(func(v *KxVolume) pulumi.StringOutput { return v.CreatedTimestamp }).(pulumi.StringOutput)
}

func (o KxVolumeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KxVolume) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

func (o KxVolumeOutput) EnvironmentId() pulumi.StringOutput {
	return o.ApplyT(func(v *KxVolume) pulumi.StringOutput { return v.EnvironmentId }).(pulumi.StringOutput)
}

func (o KxVolumeOutput) LastModifiedTimestamp() pulumi.StringOutput {
	return o.ApplyT(func(v *KxVolume) pulumi.StringOutput { return v.LastModifiedTimestamp }).(pulumi.StringOutput)
}

func (o KxVolumeOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *KxVolume) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o KxVolumeOutput) Nas1Configurations() KxVolumeNas1ConfigurationArrayOutput {
	return o.ApplyT(func(v *KxVolume) KxVolumeNas1ConfigurationArrayOutput { return v.Nas1Configurations }).(KxVolumeNas1ConfigurationArrayOutput)
}

func (o KxVolumeOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *KxVolume) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

func (o KxVolumeOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *KxVolume) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

func (o KxVolumeOutput) StatusReason() pulumi.StringOutput {
	return o.ApplyT(func(v *KxVolume) pulumi.StringOutput { return v.StatusReason }).(pulumi.StringOutput)
}

func (o KxVolumeOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *KxVolume) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

func (o KxVolumeOutput) TagsAll() pulumi.StringMapOutput {
	return o.ApplyT(func(v *KxVolume) pulumi.StringMapOutput { return v.TagsAll }).(pulumi.StringMapOutput)
}

func (o KxVolumeOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *KxVolume) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

type KxVolumeArrayOutput struct{ *pulumi.OutputState }

func (KxVolumeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KxVolume)(nil)).Elem()
}

func (o KxVolumeArrayOutput) ToKxVolumeArrayOutput() KxVolumeArrayOutput {
	return o
}

func (o KxVolumeArrayOutput) ToKxVolumeArrayOutputWithContext(ctx context.Context) KxVolumeArrayOutput {
	return o
}

func (o KxVolumeArrayOutput) Index(i pulumi.IntInput) KxVolumeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *KxVolume {
		return vs[0].([]*KxVolume)[vs[1].(int)]
	}).(KxVolumeOutput)
}

type KxVolumeMapOutput struct{ *pulumi.OutputState }

func (KxVolumeMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KxVolume)(nil)).Elem()
}

func (o KxVolumeMapOutput) ToKxVolumeMapOutput() KxVolumeMapOutput {
	return o
}

func (o KxVolumeMapOutput) ToKxVolumeMapOutputWithContext(ctx context.Context) KxVolumeMapOutput {
	return o
}

func (o KxVolumeMapOutput) MapIndex(k pulumi.StringInput) KxVolumeOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *KxVolume {
		return vs[0].(map[string]*KxVolume)[vs[1].(string)]
	}).(KxVolumeOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*KxVolumeInput)(nil)).Elem(), &KxVolume{})
	pulumi.RegisterInputType(reflect.TypeOf((*KxVolumeArrayInput)(nil)).Elem(), KxVolumeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KxVolumeMapInput)(nil)).Elem(), KxVolumeMap{})
	pulumi.RegisterOutputType(KxVolumeOutput{})
	pulumi.RegisterOutputType(KxVolumeArrayOutput{})
	pulumi.RegisterOutputType(KxVolumeMapOutput{})
}
