// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package finspace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Resource for managing an AWS FinSpace Kx Dataview.
//
// ## Example Usage
// ### Basic Usage
//
// ```go
// package main
//
// import (
//
//	finspace/kxDataview "github.com/pulumi/pulumi-aws/sdk/v1/go/aws/finspace/kxDataview"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
// func main() {
// pulumi.Run(func(ctx *pulumi.Context) error {
// _, err := finspace/kxDataview.NewKxDataview(ctx, "example", &finspace/kxDataview.KxDataviewArgs{
// EnvironmentId: aws_finspace_kx_environment.Example.Id,
// DatabaseName: aws_finspace_kx_database.Example.Name,
// AvailabilityZoneId: "use1-az2",
// Description: "Terraform managed Kx Dataview",
// AzMode: "SINGLE",
// AutoUpdate: true,
// SegmentConfigurations: []map[string]interface{}{
// map[string]interface{}{
// "volumeName": aws_finspace_kx_volume.Example.Name,
// "dbPaths": []string{
// "/*",
// },
// },
// },
// Timeouts: []map[string]interface{}{
// map[string]interface{}{
// "create": "24h",
// "update": "24h",
// "delete": "12h",
// },
// },
// })
// if err != nil {
// return err
// }
// return nil
// })
// }
// ```
//
// ## Import
//
// Using `pulumi import`, import an AWS FinSpace Kx Cluster using the `id` (environment ID and cluster name, comma-delimited). For example:
//
// ```sh
//
//	$ pulumi import aws:finspace/kxDataview:KxDataview example n3ceo7wqxoxcti5tujqwzs,my-tf-kx-database,my-tf-kx-dataview
//
// ```
type KxDataview struct {
	pulumi.CustomResourceState

	// Amazon Resource Name (ARN) identifier of the KX dataview.
	Arn pulumi.StringOutput `pulumi:"arn"`
	// The option to specify whether you want to apply all the future additions and corrections automatically to the dataview, when you ingest new changesets. The default value is false.
	AutoUpdate pulumi.BoolOutput `pulumi:"autoUpdate"`
	// The identifier of the availability zones. If attaching a volume, the volume must be in the same availability zone as the dataview that you are attaching to.
	AvailabilityZoneId pulumi.StringPtrOutput `pulumi:"availabilityZoneId"`
	// The number of availability zones you want to assign per cluster. This can be one of the following:
	AzMode pulumi.StringOutput `pulumi:"azMode"`
	// A unique identifier of the changeset of the database that you want to use to ingest data.
	ChangesetId pulumi.StringPtrOutput `pulumi:"changesetId"`
	// Timestamp at which the dataview was created in FinSpace. Value determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
	CreatedTimestamp pulumi.StringOutput `pulumi:"createdTimestamp"`
	// The name of the database where you want to create a dataview.
	DatabaseName pulumi.StringOutput `pulumi:"databaseName"`
	// A description for the dataview.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Unique identifier for the KX environment.
	EnvironmentId pulumi.StringOutput `pulumi:"environmentId"`
	// The last time that the dataview was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
	LastModifiedTimestamp pulumi.StringOutput `pulumi:"lastModifiedTimestamp"`
	// A unique identifier for the dataview.
	//
	// The following arguments are optional:
	Name pulumi.StringOutput `pulumi:"name"`
	// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment. See segmentConfigurations below.
	SegmentConfigurations KxDataviewSegmentConfigurationArrayOutput `pulumi:"segmentConfigurations"`
	Status                pulumi.StringOutput                       `pulumi:"status"`
	// Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags pulumi.StringMapOutput `pulumi:"tags"`
	// Map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
	//
	// Deprecated: Please use `tags` instead.
	TagsAll pulumi.StringMapOutput `pulumi:"tagsAll"`
}

// NewKxDataview registers a new resource with the given unique name, arguments, and options.
func NewKxDataview(ctx *pulumi.Context,
	name string, args *KxDataviewArgs, opts ...pulumi.ResourceOption) (*KxDataview, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AutoUpdate == nil {
		return nil, errors.New("invalid value for required argument 'AutoUpdate'")
	}
	if args.AzMode == nil {
		return nil, errors.New("invalid value for required argument 'AzMode'")
	}
	if args.DatabaseName == nil {
		return nil, errors.New("invalid value for required argument 'DatabaseName'")
	}
	if args.EnvironmentId == nil {
		return nil, errors.New("invalid value for required argument 'EnvironmentId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource KxDataview
	err := ctx.RegisterResource("aws:finspace/kxDataview:KxDataview", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetKxDataview gets an existing KxDataview resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetKxDataview(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *KxDataviewState, opts ...pulumi.ResourceOption) (*KxDataview, error) {
	var resource KxDataview
	err := ctx.ReadResource("aws:finspace/kxDataview:KxDataview", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering KxDataview resources.
type kxDataviewState struct {
	// Amazon Resource Name (ARN) identifier of the KX dataview.
	Arn *string `pulumi:"arn"`
	// The option to specify whether you want to apply all the future additions and corrections automatically to the dataview, when you ingest new changesets. The default value is false.
	AutoUpdate *bool `pulumi:"autoUpdate"`
	// The identifier of the availability zones. If attaching a volume, the volume must be in the same availability zone as the dataview that you are attaching to.
	AvailabilityZoneId *string `pulumi:"availabilityZoneId"`
	// The number of availability zones you want to assign per cluster. This can be one of the following:
	AzMode *string `pulumi:"azMode"`
	// A unique identifier of the changeset of the database that you want to use to ingest data.
	ChangesetId *string `pulumi:"changesetId"`
	// Timestamp at which the dataview was created in FinSpace. Value determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
	CreatedTimestamp *string `pulumi:"createdTimestamp"`
	// The name of the database where you want to create a dataview.
	DatabaseName *string `pulumi:"databaseName"`
	// A description for the dataview.
	Description *string `pulumi:"description"`
	// Unique identifier for the KX environment.
	EnvironmentId *string `pulumi:"environmentId"`
	// The last time that the dataview was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
	LastModifiedTimestamp *string `pulumi:"lastModifiedTimestamp"`
	// A unique identifier for the dataview.
	//
	// The following arguments are optional:
	Name *string `pulumi:"name"`
	// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment. See segmentConfigurations below.
	SegmentConfigurations []KxDataviewSegmentConfiguration `pulumi:"segmentConfigurations"`
	Status                *string                          `pulumi:"status"`
	// Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags map[string]string `pulumi:"tags"`
	// Map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
	//
	// Deprecated: Please use `tags` instead.
	TagsAll map[string]string `pulumi:"tagsAll"`
}

type KxDataviewState struct {
	// Amazon Resource Name (ARN) identifier of the KX dataview.
	Arn pulumi.StringPtrInput
	// The option to specify whether you want to apply all the future additions and corrections automatically to the dataview, when you ingest new changesets. The default value is false.
	AutoUpdate pulumi.BoolPtrInput
	// The identifier of the availability zones. If attaching a volume, the volume must be in the same availability zone as the dataview that you are attaching to.
	AvailabilityZoneId pulumi.StringPtrInput
	// The number of availability zones you want to assign per cluster. This can be one of the following:
	AzMode pulumi.StringPtrInput
	// A unique identifier of the changeset of the database that you want to use to ingest data.
	ChangesetId pulumi.StringPtrInput
	// Timestamp at which the dataview was created in FinSpace. Value determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
	CreatedTimestamp pulumi.StringPtrInput
	// The name of the database where you want to create a dataview.
	DatabaseName pulumi.StringPtrInput
	// A description for the dataview.
	Description pulumi.StringPtrInput
	// Unique identifier for the KX environment.
	EnvironmentId pulumi.StringPtrInput
	// The last time that the dataview was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
	LastModifiedTimestamp pulumi.StringPtrInput
	// A unique identifier for the dataview.
	//
	// The following arguments are optional:
	Name pulumi.StringPtrInput
	// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment. See segmentConfigurations below.
	SegmentConfigurations KxDataviewSegmentConfigurationArrayInput
	Status                pulumi.StringPtrInput
	// Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags pulumi.StringMapInput
	// Map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
	//
	// Deprecated: Please use `tags` instead.
	TagsAll pulumi.StringMapInput
}

func (KxDataviewState) ElementType() reflect.Type {
	return reflect.TypeOf((*kxDataviewState)(nil)).Elem()
}

type kxDataviewArgs struct {
	// The option to specify whether you want to apply all the future additions and corrections automatically to the dataview, when you ingest new changesets. The default value is false.
	AutoUpdate bool `pulumi:"autoUpdate"`
	// The identifier of the availability zones. If attaching a volume, the volume must be in the same availability zone as the dataview that you are attaching to.
	AvailabilityZoneId *string `pulumi:"availabilityZoneId"`
	// The number of availability zones you want to assign per cluster. This can be one of the following:
	AzMode string `pulumi:"azMode"`
	// A unique identifier of the changeset of the database that you want to use to ingest data.
	ChangesetId *string `pulumi:"changesetId"`
	// The name of the database where you want to create a dataview.
	DatabaseName string `pulumi:"databaseName"`
	// A description for the dataview.
	Description *string `pulumi:"description"`
	// Unique identifier for the KX environment.
	EnvironmentId string `pulumi:"environmentId"`
	// A unique identifier for the dataview.
	//
	// The following arguments are optional:
	Name *string `pulumi:"name"`
	// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment. See segmentConfigurations below.
	SegmentConfigurations []KxDataviewSegmentConfiguration `pulumi:"segmentConfigurations"`
	// Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags map[string]string `pulumi:"tags"`
}

// The set of arguments for constructing a KxDataview resource.
type KxDataviewArgs struct {
	// The option to specify whether you want to apply all the future additions and corrections automatically to the dataview, when you ingest new changesets. The default value is false.
	AutoUpdate pulumi.BoolInput
	// The identifier of the availability zones. If attaching a volume, the volume must be in the same availability zone as the dataview that you are attaching to.
	AvailabilityZoneId pulumi.StringPtrInput
	// The number of availability zones you want to assign per cluster. This can be one of the following:
	AzMode pulumi.StringInput
	// A unique identifier of the changeset of the database that you want to use to ingest data.
	ChangesetId pulumi.StringPtrInput
	// The name of the database where you want to create a dataview.
	DatabaseName pulumi.StringInput
	// A description for the dataview.
	Description pulumi.StringPtrInput
	// Unique identifier for the KX environment.
	EnvironmentId pulumi.StringInput
	// A unique identifier for the dataview.
	//
	// The following arguments are optional:
	Name pulumi.StringPtrInput
	// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment. See segmentConfigurations below.
	SegmentConfigurations KxDataviewSegmentConfigurationArrayInput
	// Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags pulumi.StringMapInput
}

func (KxDataviewArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*kxDataviewArgs)(nil)).Elem()
}

type KxDataviewInput interface {
	pulumi.Input

	ToKxDataviewOutput() KxDataviewOutput
	ToKxDataviewOutputWithContext(ctx context.Context) KxDataviewOutput
}

func (*KxDataview) ElementType() reflect.Type {
	return reflect.TypeOf((**KxDataview)(nil)).Elem()
}

func (i *KxDataview) ToKxDataviewOutput() KxDataviewOutput {
	return i.ToKxDataviewOutputWithContext(context.Background())
}

func (i *KxDataview) ToKxDataviewOutputWithContext(ctx context.Context) KxDataviewOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KxDataviewOutput)
}

// KxDataviewArrayInput is an input type that accepts KxDataviewArray and KxDataviewArrayOutput values.
// You can construct a concrete instance of `KxDataviewArrayInput` via:
//
//	KxDataviewArray{ KxDataviewArgs{...} }
type KxDataviewArrayInput interface {
	pulumi.Input

	ToKxDataviewArrayOutput() KxDataviewArrayOutput
	ToKxDataviewArrayOutputWithContext(context.Context) KxDataviewArrayOutput
}

type KxDataviewArray []KxDataviewInput

func (KxDataviewArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KxDataview)(nil)).Elem()
}

func (i KxDataviewArray) ToKxDataviewArrayOutput() KxDataviewArrayOutput {
	return i.ToKxDataviewArrayOutputWithContext(context.Background())
}

func (i KxDataviewArray) ToKxDataviewArrayOutputWithContext(ctx context.Context) KxDataviewArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KxDataviewArrayOutput)
}

// KxDataviewMapInput is an input type that accepts KxDataviewMap and KxDataviewMapOutput values.
// You can construct a concrete instance of `KxDataviewMapInput` via:
//
//	KxDataviewMap{ "key": KxDataviewArgs{...} }
type KxDataviewMapInput interface {
	pulumi.Input

	ToKxDataviewMapOutput() KxDataviewMapOutput
	ToKxDataviewMapOutputWithContext(context.Context) KxDataviewMapOutput
}

type KxDataviewMap map[string]KxDataviewInput

func (KxDataviewMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KxDataview)(nil)).Elem()
}

func (i KxDataviewMap) ToKxDataviewMapOutput() KxDataviewMapOutput {
	return i.ToKxDataviewMapOutputWithContext(context.Background())
}

func (i KxDataviewMap) ToKxDataviewMapOutputWithContext(ctx context.Context) KxDataviewMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KxDataviewMapOutput)
}

type KxDataviewOutput struct{ *pulumi.OutputState }

func (KxDataviewOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KxDataview)(nil)).Elem()
}

func (o KxDataviewOutput) ToKxDataviewOutput() KxDataviewOutput {
	return o
}

func (o KxDataviewOutput) ToKxDataviewOutputWithContext(ctx context.Context) KxDataviewOutput {
	return o
}

// Amazon Resource Name (ARN) identifier of the KX dataview.
func (o KxDataviewOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v *KxDataview) pulumi.StringOutput { return v.Arn }).(pulumi.StringOutput)
}

// The option to specify whether you want to apply all the future additions and corrections automatically to the dataview, when you ingest new changesets. The default value is false.
func (o KxDataviewOutput) AutoUpdate() pulumi.BoolOutput {
	return o.ApplyT(func(v *KxDataview) pulumi.BoolOutput { return v.AutoUpdate }).(pulumi.BoolOutput)
}

// The identifier of the availability zones. If attaching a volume, the volume must be in the same availability zone as the dataview that you are attaching to.
func (o KxDataviewOutput) AvailabilityZoneId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KxDataview) pulumi.StringPtrOutput { return v.AvailabilityZoneId }).(pulumi.StringPtrOutput)
}

// The number of availability zones you want to assign per cluster. This can be one of the following:
func (o KxDataviewOutput) AzMode() pulumi.StringOutput {
	return o.ApplyT(func(v *KxDataview) pulumi.StringOutput { return v.AzMode }).(pulumi.StringOutput)
}

// A unique identifier of the changeset of the database that you want to use to ingest data.
func (o KxDataviewOutput) ChangesetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KxDataview) pulumi.StringPtrOutput { return v.ChangesetId }).(pulumi.StringPtrOutput)
}

// Timestamp at which the dataview was created in FinSpace. Value determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
func (o KxDataviewOutput) CreatedTimestamp() pulumi.StringOutput {
	return o.ApplyT(func(v *KxDataview) pulumi.StringOutput { return v.CreatedTimestamp }).(pulumi.StringOutput)
}

// The name of the database where you want to create a dataview.
func (o KxDataviewOutput) DatabaseName() pulumi.StringOutput {
	return o.ApplyT(func(v *KxDataview) pulumi.StringOutput { return v.DatabaseName }).(pulumi.StringOutput)
}

// A description for the dataview.
func (o KxDataviewOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KxDataview) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Unique identifier for the KX environment.
func (o KxDataviewOutput) EnvironmentId() pulumi.StringOutput {
	return o.ApplyT(func(v *KxDataview) pulumi.StringOutput { return v.EnvironmentId }).(pulumi.StringOutput)
}

// The last time that the dataview was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
func (o KxDataviewOutput) LastModifiedTimestamp() pulumi.StringOutput {
	return o.ApplyT(func(v *KxDataview) pulumi.StringOutput { return v.LastModifiedTimestamp }).(pulumi.StringOutput)
}

// A unique identifier for the dataview.
//
// The following arguments are optional:
func (o KxDataviewOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *KxDataview) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment. See segmentConfigurations below.
func (o KxDataviewOutput) SegmentConfigurations() KxDataviewSegmentConfigurationArrayOutput {
	return o.ApplyT(func(v *KxDataview) KxDataviewSegmentConfigurationArrayOutput { return v.SegmentConfigurations }).(KxDataviewSegmentConfigurationArrayOutput)
}

func (o KxDataviewOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *KxDataview) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

// Key-value mapping of resource tags. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
func (o KxDataviewOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *KxDataview) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

// Map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
//
// Deprecated: Please use `tags` instead.
func (o KxDataviewOutput) TagsAll() pulumi.StringMapOutput {
	return o.ApplyT(func(v *KxDataview) pulumi.StringMapOutput { return v.TagsAll }).(pulumi.StringMapOutput)
}

type KxDataviewArrayOutput struct{ *pulumi.OutputState }

func (KxDataviewArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KxDataview)(nil)).Elem()
}

func (o KxDataviewArrayOutput) ToKxDataviewArrayOutput() KxDataviewArrayOutput {
	return o
}

func (o KxDataviewArrayOutput) ToKxDataviewArrayOutputWithContext(ctx context.Context) KxDataviewArrayOutput {
	return o
}

func (o KxDataviewArrayOutput) Index(i pulumi.IntInput) KxDataviewOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *KxDataview {
		return vs[0].([]*KxDataview)[vs[1].(int)]
	}).(KxDataviewOutput)
}

type KxDataviewMapOutput struct{ *pulumi.OutputState }

func (KxDataviewMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KxDataview)(nil)).Elem()
}

func (o KxDataviewMapOutput) ToKxDataviewMapOutput() KxDataviewMapOutput {
	return o
}

func (o KxDataviewMapOutput) ToKxDataviewMapOutputWithContext(ctx context.Context) KxDataviewMapOutput {
	return o
}

func (o KxDataviewMapOutput) MapIndex(k pulumi.StringInput) KxDataviewOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *KxDataview {
		return vs[0].(map[string]*KxDataview)[vs[1].(string)]
	}).(KxDataviewOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*KxDataviewInput)(nil)).Elem(), &KxDataview{})
	pulumi.RegisterInputType(reflect.TypeOf((*KxDataviewArrayInput)(nil)).Elem(), KxDataviewArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KxDataviewMapInput)(nil)).Elem(), KxDataviewMap{})
	pulumi.RegisterOutputType(KxDataviewOutput{})
	pulumi.RegisterOutputType(KxDataviewArrayOutput{})
	pulumi.RegisterOutputType(KxDataviewMapOutput{})
}
