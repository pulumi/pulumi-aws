// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package opensearch

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// Manages an AWS Opensearch Package Association.
//
// ## Example Usage
// ### Basic Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/opensearch"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			myDomain, err := opensearch.NewDomain(ctx, "myDomain", &opensearch.DomainArgs{
//				EngineVersion: pulumi.String("Elasticsearch_7.10"),
//				ClusterConfig: &opensearch.DomainClusterConfigArgs{
//					InstanceType: pulumi.String("r4.large.search"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			examplePackage, err := opensearch.NewPackage(ctx, "examplePackage", &opensearch.PackageArgs{
//				PackageName: pulumi.String("example-txt"),
//				PackageSource: &opensearch.PackagePackageSourceArgs{
//					S3BucketName: pulumi.Any(aws_s3_bucket.My_opensearch_packages.Bucket),
//					S3Key:        pulumi.Any(aws_s3_object.Example.Key),
//				},
//				PackageType: pulumi.String("TXT-DICTIONARY"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = opensearch.NewPackageAssociation(ctx, "examplePackageAssociation", &opensearch.PackageAssociationArgs{
//				PackageId:  examplePackage.ID(),
//				DomainName: myDomain.DomainName,
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type PackageAssociation struct {
	pulumi.CustomResourceState

	// Name of the domain to associate the package with.
	DomainName pulumi.StringOutput `pulumi:"domainName"`
	// Internal ID of the package to associate with a domain.
	PackageId     pulumi.StringOutput `pulumi:"packageId"`
	ReferencePath pulumi.StringOutput `pulumi:"referencePath"`
}

// NewPackageAssociation registers a new resource with the given unique name, arguments, and options.
func NewPackageAssociation(ctx *pulumi.Context,
	name string, args *PackageAssociationArgs, opts ...pulumi.ResourceOption) (*PackageAssociation, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DomainName == nil {
		return nil, errors.New("invalid value for required argument 'DomainName'")
	}
	if args.PackageId == nil {
		return nil, errors.New("invalid value for required argument 'PackageId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource PackageAssociation
	err := ctx.RegisterResource("aws:opensearch/packageAssociation:PackageAssociation", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPackageAssociation gets an existing PackageAssociation resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPackageAssociation(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PackageAssociationState, opts ...pulumi.ResourceOption) (*PackageAssociation, error) {
	var resource PackageAssociation
	err := ctx.ReadResource("aws:opensearch/packageAssociation:PackageAssociation", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering PackageAssociation resources.
type packageAssociationState struct {
	// Name of the domain to associate the package with.
	DomainName *string `pulumi:"domainName"`
	// Internal ID of the package to associate with a domain.
	PackageId     *string `pulumi:"packageId"`
	ReferencePath *string `pulumi:"referencePath"`
}

type PackageAssociationState struct {
	// Name of the domain to associate the package with.
	DomainName pulumi.StringPtrInput
	// Internal ID of the package to associate with a domain.
	PackageId     pulumi.StringPtrInput
	ReferencePath pulumi.StringPtrInput
}

func (PackageAssociationState) ElementType() reflect.Type {
	return reflect.TypeOf((*packageAssociationState)(nil)).Elem()
}

type packageAssociationArgs struct {
	// Name of the domain to associate the package with.
	DomainName string `pulumi:"domainName"`
	// Internal ID of the package to associate with a domain.
	PackageId string `pulumi:"packageId"`
}

// The set of arguments for constructing a PackageAssociation resource.
type PackageAssociationArgs struct {
	// Name of the domain to associate the package with.
	DomainName pulumi.StringInput
	// Internal ID of the package to associate with a domain.
	PackageId pulumi.StringInput
}

func (PackageAssociationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*packageAssociationArgs)(nil)).Elem()
}

type PackageAssociationInput interface {
	pulumi.Input

	ToPackageAssociationOutput() PackageAssociationOutput
	ToPackageAssociationOutputWithContext(ctx context.Context) PackageAssociationOutput
}

func (*PackageAssociation) ElementType() reflect.Type {
	return reflect.TypeOf((**PackageAssociation)(nil)).Elem()
}

func (i *PackageAssociation) ToPackageAssociationOutput() PackageAssociationOutput {
	return i.ToPackageAssociationOutputWithContext(context.Background())
}

func (i *PackageAssociation) ToPackageAssociationOutputWithContext(ctx context.Context) PackageAssociationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageAssociationOutput)
}

func (i *PackageAssociation) ToOutput(ctx context.Context) pulumix.Output[*PackageAssociation] {
	return pulumix.Output[*PackageAssociation]{
		OutputState: i.ToPackageAssociationOutputWithContext(ctx).OutputState,
	}
}

// PackageAssociationArrayInput is an input type that accepts PackageAssociationArray and PackageAssociationArrayOutput values.
// You can construct a concrete instance of `PackageAssociationArrayInput` via:
//
//	PackageAssociationArray{ PackageAssociationArgs{...} }
type PackageAssociationArrayInput interface {
	pulumi.Input

	ToPackageAssociationArrayOutput() PackageAssociationArrayOutput
	ToPackageAssociationArrayOutputWithContext(context.Context) PackageAssociationArrayOutput
}

type PackageAssociationArray []PackageAssociationInput

func (PackageAssociationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PackageAssociation)(nil)).Elem()
}

func (i PackageAssociationArray) ToPackageAssociationArrayOutput() PackageAssociationArrayOutput {
	return i.ToPackageAssociationArrayOutputWithContext(context.Background())
}

func (i PackageAssociationArray) ToPackageAssociationArrayOutputWithContext(ctx context.Context) PackageAssociationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageAssociationArrayOutput)
}

func (i PackageAssociationArray) ToOutput(ctx context.Context) pulumix.Output[[]*PackageAssociation] {
	return pulumix.Output[[]*PackageAssociation]{
		OutputState: i.ToPackageAssociationArrayOutputWithContext(ctx).OutputState,
	}
}

// PackageAssociationMapInput is an input type that accepts PackageAssociationMap and PackageAssociationMapOutput values.
// You can construct a concrete instance of `PackageAssociationMapInput` via:
//
//	PackageAssociationMap{ "key": PackageAssociationArgs{...} }
type PackageAssociationMapInput interface {
	pulumi.Input

	ToPackageAssociationMapOutput() PackageAssociationMapOutput
	ToPackageAssociationMapOutputWithContext(context.Context) PackageAssociationMapOutput
}

type PackageAssociationMap map[string]PackageAssociationInput

func (PackageAssociationMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PackageAssociation)(nil)).Elem()
}

func (i PackageAssociationMap) ToPackageAssociationMapOutput() PackageAssociationMapOutput {
	return i.ToPackageAssociationMapOutputWithContext(context.Background())
}

func (i PackageAssociationMap) ToPackageAssociationMapOutputWithContext(ctx context.Context) PackageAssociationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageAssociationMapOutput)
}

func (i PackageAssociationMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*PackageAssociation] {
	return pulumix.Output[map[string]*PackageAssociation]{
		OutputState: i.ToPackageAssociationMapOutputWithContext(ctx).OutputState,
	}
}

type PackageAssociationOutput struct{ *pulumi.OutputState }

func (PackageAssociationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PackageAssociation)(nil)).Elem()
}

func (o PackageAssociationOutput) ToPackageAssociationOutput() PackageAssociationOutput {
	return o
}

func (o PackageAssociationOutput) ToPackageAssociationOutputWithContext(ctx context.Context) PackageAssociationOutput {
	return o
}

func (o PackageAssociationOutput) ToOutput(ctx context.Context) pulumix.Output[*PackageAssociation] {
	return pulumix.Output[*PackageAssociation]{
		OutputState: o.OutputState,
	}
}

// Name of the domain to associate the package with.
func (o PackageAssociationOutput) DomainName() pulumi.StringOutput {
	return o.ApplyT(func(v *PackageAssociation) pulumi.StringOutput { return v.DomainName }).(pulumi.StringOutput)
}

// Internal ID of the package to associate with a domain.
func (o PackageAssociationOutput) PackageId() pulumi.StringOutput {
	return o.ApplyT(func(v *PackageAssociation) pulumi.StringOutput { return v.PackageId }).(pulumi.StringOutput)
}

func (o PackageAssociationOutput) ReferencePath() pulumi.StringOutput {
	return o.ApplyT(func(v *PackageAssociation) pulumi.StringOutput { return v.ReferencePath }).(pulumi.StringOutput)
}

type PackageAssociationArrayOutput struct{ *pulumi.OutputState }

func (PackageAssociationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PackageAssociation)(nil)).Elem()
}

func (o PackageAssociationArrayOutput) ToPackageAssociationArrayOutput() PackageAssociationArrayOutput {
	return o
}

func (o PackageAssociationArrayOutput) ToPackageAssociationArrayOutputWithContext(ctx context.Context) PackageAssociationArrayOutput {
	return o
}

func (o PackageAssociationArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*PackageAssociation] {
	return pulumix.Output[[]*PackageAssociation]{
		OutputState: o.OutputState,
	}
}

func (o PackageAssociationArrayOutput) Index(i pulumi.IntInput) PackageAssociationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *PackageAssociation {
		return vs[0].([]*PackageAssociation)[vs[1].(int)]
	}).(PackageAssociationOutput)
}

type PackageAssociationMapOutput struct{ *pulumi.OutputState }

func (PackageAssociationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PackageAssociation)(nil)).Elem()
}

func (o PackageAssociationMapOutput) ToPackageAssociationMapOutput() PackageAssociationMapOutput {
	return o
}

func (o PackageAssociationMapOutput) ToPackageAssociationMapOutputWithContext(ctx context.Context) PackageAssociationMapOutput {
	return o
}

func (o PackageAssociationMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*PackageAssociation] {
	return pulumix.Output[map[string]*PackageAssociation]{
		OutputState: o.OutputState,
	}
}

func (o PackageAssociationMapOutput) MapIndex(k pulumi.StringInput) PackageAssociationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *PackageAssociation {
		return vs[0].(map[string]*PackageAssociation)[vs[1].(string)]
	}).(PackageAssociationOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PackageAssociationInput)(nil)).Elem(), &PackageAssociation{})
	pulumi.RegisterInputType(reflect.TypeOf((*PackageAssociationArrayInput)(nil)).Elem(), PackageAssociationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PackageAssociationMapInput)(nil)).Elem(), PackageAssociationMap{})
	pulumi.RegisterOutputType(PackageAssociationOutput{})
	pulumi.RegisterOutputType(PackageAssociationArrayOutput{})
	pulumi.RegisterOutputType(PackageAssociationMapOutput{})
}
