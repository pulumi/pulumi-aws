// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package iam

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Import
//
// Using `pulumi import`, import exclusive management of inline policy assignments using the `user_name`. For example:
//
// ```sh
// $ pulumi import aws:iam/userPoliciesExclusive:UserPoliciesExclusive example MyUser
// ```
type UserPoliciesExclusive struct {
	pulumi.CustomResourceState

	// A list of inline policy names to be assigned to the user. Policies attached to this user but not configured in this argument will be removed.
	PolicyNames pulumi.StringArrayOutput `pulumi:"policyNames"`
	// IAM user name.
	UserName pulumi.StringOutput `pulumi:"userName"`
}

// NewUserPoliciesExclusive registers a new resource with the given unique name, arguments, and options.
func NewUserPoliciesExclusive(ctx *pulumi.Context,
	name string, args *UserPoliciesExclusiveArgs, opts ...pulumi.ResourceOption) (*UserPoliciesExclusive, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.PolicyNames == nil {
		return nil, errors.New("invalid value for required argument 'PolicyNames'")
	}
	if args.UserName == nil {
		return nil, errors.New("invalid value for required argument 'UserName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource UserPoliciesExclusive
	err := ctx.RegisterResource("aws:iam/userPoliciesExclusive:UserPoliciesExclusive", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetUserPoliciesExclusive gets an existing UserPoliciesExclusive resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetUserPoliciesExclusive(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *UserPoliciesExclusiveState, opts ...pulumi.ResourceOption) (*UserPoliciesExclusive, error) {
	var resource UserPoliciesExclusive
	err := ctx.ReadResource("aws:iam/userPoliciesExclusive:UserPoliciesExclusive", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering UserPoliciesExclusive resources.
type userPoliciesExclusiveState struct {
	// A list of inline policy names to be assigned to the user. Policies attached to this user but not configured in this argument will be removed.
	PolicyNames []string `pulumi:"policyNames"`
	// IAM user name.
	UserName *string `pulumi:"userName"`
}

type UserPoliciesExclusiveState struct {
	// A list of inline policy names to be assigned to the user. Policies attached to this user but not configured in this argument will be removed.
	PolicyNames pulumi.StringArrayInput
	// IAM user name.
	UserName pulumi.StringPtrInput
}

func (UserPoliciesExclusiveState) ElementType() reflect.Type {
	return reflect.TypeOf((*userPoliciesExclusiveState)(nil)).Elem()
}

type userPoliciesExclusiveArgs struct {
	// A list of inline policy names to be assigned to the user. Policies attached to this user but not configured in this argument will be removed.
	PolicyNames []string `pulumi:"policyNames"`
	// IAM user name.
	UserName string `pulumi:"userName"`
}

// The set of arguments for constructing a UserPoliciesExclusive resource.
type UserPoliciesExclusiveArgs struct {
	// A list of inline policy names to be assigned to the user. Policies attached to this user but not configured in this argument will be removed.
	PolicyNames pulumi.StringArrayInput
	// IAM user name.
	UserName pulumi.StringInput
}

func (UserPoliciesExclusiveArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*userPoliciesExclusiveArgs)(nil)).Elem()
}

type UserPoliciesExclusiveInput interface {
	pulumi.Input

	ToUserPoliciesExclusiveOutput() UserPoliciesExclusiveOutput
	ToUserPoliciesExclusiveOutputWithContext(ctx context.Context) UserPoliciesExclusiveOutput
}

func (*UserPoliciesExclusive) ElementType() reflect.Type {
	return reflect.TypeOf((**UserPoliciesExclusive)(nil)).Elem()
}

func (i *UserPoliciesExclusive) ToUserPoliciesExclusiveOutput() UserPoliciesExclusiveOutput {
	return i.ToUserPoliciesExclusiveOutputWithContext(context.Background())
}

func (i *UserPoliciesExclusive) ToUserPoliciesExclusiveOutputWithContext(ctx context.Context) UserPoliciesExclusiveOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserPoliciesExclusiveOutput)
}

// UserPoliciesExclusiveArrayInput is an input type that accepts UserPoliciesExclusiveArray and UserPoliciesExclusiveArrayOutput values.
// You can construct a concrete instance of `UserPoliciesExclusiveArrayInput` via:
//
//	UserPoliciesExclusiveArray{ UserPoliciesExclusiveArgs{...} }
type UserPoliciesExclusiveArrayInput interface {
	pulumi.Input

	ToUserPoliciesExclusiveArrayOutput() UserPoliciesExclusiveArrayOutput
	ToUserPoliciesExclusiveArrayOutputWithContext(context.Context) UserPoliciesExclusiveArrayOutput
}

type UserPoliciesExclusiveArray []UserPoliciesExclusiveInput

func (UserPoliciesExclusiveArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*UserPoliciesExclusive)(nil)).Elem()
}

func (i UserPoliciesExclusiveArray) ToUserPoliciesExclusiveArrayOutput() UserPoliciesExclusiveArrayOutput {
	return i.ToUserPoliciesExclusiveArrayOutputWithContext(context.Background())
}

func (i UserPoliciesExclusiveArray) ToUserPoliciesExclusiveArrayOutputWithContext(ctx context.Context) UserPoliciesExclusiveArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserPoliciesExclusiveArrayOutput)
}

// UserPoliciesExclusiveMapInput is an input type that accepts UserPoliciesExclusiveMap and UserPoliciesExclusiveMapOutput values.
// You can construct a concrete instance of `UserPoliciesExclusiveMapInput` via:
//
//	UserPoliciesExclusiveMap{ "key": UserPoliciesExclusiveArgs{...} }
type UserPoliciesExclusiveMapInput interface {
	pulumi.Input

	ToUserPoliciesExclusiveMapOutput() UserPoliciesExclusiveMapOutput
	ToUserPoliciesExclusiveMapOutputWithContext(context.Context) UserPoliciesExclusiveMapOutput
}

type UserPoliciesExclusiveMap map[string]UserPoliciesExclusiveInput

func (UserPoliciesExclusiveMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*UserPoliciesExclusive)(nil)).Elem()
}

func (i UserPoliciesExclusiveMap) ToUserPoliciesExclusiveMapOutput() UserPoliciesExclusiveMapOutput {
	return i.ToUserPoliciesExclusiveMapOutputWithContext(context.Background())
}

func (i UserPoliciesExclusiveMap) ToUserPoliciesExclusiveMapOutputWithContext(ctx context.Context) UserPoliciesExclusiveMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserPoliciesExclusiveMapOutput)
}

type UserPoliciesExclusiveOutput struct{ *pulumi.OutputState }

func (UserPoliciesExclusiveOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UserPoliciesExclusive)(nil)).Elem()
}

func (o UserPoliciesExclusiveOutput) ToUserPoliciesExclusiveOutput() UserPoliciesExclusiveOutput {
	return o
}

func (o UserPoliciesExclusiveOutput) ToUserPoliciesExclusiveOutputWithContext(ctx context.Context) UserPoliciesExclusiveOutput {
	return o
}

// A list of inline policy names to be assigned to the user. Policies attached to this user but not configured in this argument will be removed.
func (o UserPoliciesExclusiveOutput) PolicyNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *UserPoliciesExclusive) pulumi.StringArrayOutput { return v.PolicyNames }).(pulumi.StringArrayOutput)
}

// IAM user name.
func (o UserPoliciesExclusiveOutput) UserName() pulumi.StringOutput {
	return o.ApplyT(func(v *UserPoliciesExclusive) pulumi.StringOutput { return v.UserName }).(pulumi.StringOutput)
}

type UserPoliciesExclusiveArrayOutput struct{ *pulumi.OutputState }

func (UserPoliciesExclusiveArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*UserPoliciesExclusive)(nil)).Elem()
}

func (o UserPoliciesExclusiveArrayOutput) ToUserPoliciesExclusiveArrayOutput() UserPoliciesExclusiveArrayOutput {
	return o
}

func (o UserPoliciesExclusiveArrayOutput) ToUserPoliciesExclusiveArrayOutputWithContext(ctx context.Context) UserPoliciesExclusiveArrayOutput {
	return o
}

func (o UserPoliciesExclusiveArrayOutput) Index(i pulumi.IntInput) UserPoliciesExclusiveOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *UserPoliciesExclusive {
		return vs[0].([]*UserPoliciesExclusive)[vs[1].(int)]
	}).(UserPoliciesExclusiveOutput)
}

type UserPoliciesExclusiveMapOutput struct{ *pulumi.OutputState }

func (UserPoliciesExclusiveMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*UserPoliciesExclusive)(nil)).Elem()
}

func (o UserPoliciesExclusiveMapOutput) ToUserPoliciesExclusiveMapOutput() UserPoliciesExclusiveMapOutput {
	return o
}

func (o UserPoliciesExclusiveMapOutput) ToUserPoliciesExclusiveMapOutputWithContext(ctx context.Context) UserPoliciesExclusiveMapOutput {
	return o
}

func (o UserPoliciesExclusiveMapOutput) MapIndex(k pulumi.StringInput) UserPoliciesExclusiveOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *UserPoliciesExclusive {
		return vs[0].(map[string]*UserPoliciesExclusive)[vs[1].(string)]
	}).(UserPoliciesExclusiveOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*UserPoliciesExclusiveInput)(nil)).Elem(), &UserPoliciesExclusive{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserPoliciesExclusiveArrayInput)(nil)).Elem(), UserPoliciesExclusiveArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserPoliciesExclusiveMapInput)(nil)).Elem(), UserPoliciesExclusiveMap{})
	pulumi.RegisterOutputType(UserPoliciesExclusiveOutput{})
	pulumi.RegisterOutputType(UserPoliciesExclusiveArrayOutput{})
	pulumi.RegisterOutputType(UserPoliciesExclusiveMapOutput{})
}
