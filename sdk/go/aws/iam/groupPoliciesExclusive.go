// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package iam

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Import
//
// Using `pulumi import`, import exclusive management of inline policy assignments using the `group_name`. For example:
//
// ```sh
// $ pulumi import aws:iam/groupPoliciesExclusive:GroupPoliciesExclusive example MyGroup
// ```
type GroupPoliciesExclusive struct {
	pulumi.CustomResourceState

	// IAM group name.
	GroupName pulumi.StringOutput `pulumi:"groupName"`
	// A list of inline policy names to be assigned to the group. Policies attached to this group but not configured in this argument will be removed.
	PolicyNames pulumi.StringArrayOutput `pulumi:"policyNames"`
}

// NewGroupPoliciesExclusive registers a new resource with the given unique name, arguments, and options.
func NewGroupPoliciesExclusive(ctx *pulumi.Context,
	name string, args *GroupPoliciesExclusiveArgs, opts ...pulumi.ResourceOption) (*GroupPoliciesExclusive, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.GroupName == nil {
		return nil, errors.New("invalid value for required argument 'GroupName'")
	}
	if args.PolicyNames == nil {
		return nil, errors.New("invalid value for required argument 'PolicyNames'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource GroupPoliciesExclusive
	err := ctx.RegisterResource("aws:iam/groupPoliciesExclusive:GroupPoliciesExclusive", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetGroupPoliciesExclusive gets an existing GroupPoliciesExclusive resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetGroupPoliciesExclusive(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *GroupPoliciesExclusiveState, opts ...pulumi.ResourceOption) (*GroupPoliciesExclusive, error) {
	var resource GroupPoliciesExclusive
	err := ctx.ReadResource("aws:iam/groupPoliciesExclusive:GroupPoliciesExclusive", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering GroupPoliciesExclusive resources.
type groupPoliciesExclusiveState struct {
	// IAM group name.
	GroupName *string `pulumi:"groupName"`
	// A list of inline policy names to be assigned to the group. Policies attached to this group but not configured in this argument will be removed.
	PolicyNames []string `pulumi:"policyNames"`
}

type GroupPoliciesExclusiveState struct {
	// IAM group name.
	GroupName pulumi.StringPtrInput
	// A list of inline policy names to be assigned to the group. Policies attached to this group but not configured in this argument will be removed.
	PolicyNames pulumi.StringArrayInput
}

func (GroupPoliciesExclusiveState) ElementType() reflect.Type {
	return reflect.TypeOf((*groupPoliciesExclusiveState)(nil)).Elem()
}

type groupPoliciesExclusiveArgs struct {
	// IAM group name.
	GroupName string `pulumi:"groupName"`
	// A list of inline policy names to be assigned to the group. Policies attached to this group but not configured in this argument will be removed.
	PolicyNames []string `pulumi:"policyNames"`
}

// The set of arguments for constructing a GroupPoliciesExclusive resource.
type GroupPoliciesExclusiveArgs struct {
	// IAM group name.
	GroupName pulumi.StringInput
	// A list of inline policy names to be assigned to the group. Policies attached to this group but not configured in this argument will be removed.
	PolicyNames pulumi.StringArrayInput
}

func (GroupPoliciesExclusiveArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*groupPoliciesExclusiveArgs)(nil)).Elem()
}

type GroupPoliciesExclusiveInput interface {
	pulumi.Input

	ToGroupPoliciesExclusiveOutput() GroupPoliciesExclusiveOutput
	ToGroupPoliciesExclusiveOutputWithContext(ctx context.Context) GroupPoliciesExclusiveOutput
}

func (*GroupPoliciesExclusive) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupPoliciesExclusive)(nil)).Elem()
}

func (i *GroupPoliciesExclusive) ToGroupPoliciesExclusiveOutput() GroupPoliciesExclusiveOutput {
	return i.ToGroupPoliciesExclusiveOutputWithContext(context.Background())
}

func (i *GroupPoliciesExclusive) ToGroupPoliciesExclusiveOutputWithContext(ctx context.Context) GroupPoliciesExclusiveOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupPoliciesExclusiveOutput)
}

// GroupPoliciesExclusiveArrayInput is an input type that accepts GroupPoliciesExclusiveArray and GroupPoliciesExclusiveArrayOutput values.
// You can construct a concrete instance of `GroupPoliciesExclusiveArrayInput` via:
//
//	GroupPoliciesExclusiveArray{ GroupPoliciesExclusiveArgs{...} }
type GroupPoliciesExclusiveArrayInput interface {
	pulumi.Input

	ToGroupPoliciesExclusiveArrayOutput() GroupPoliciesExclusiveArrayOutput
	ToGroupPoliciesExclusiveArrayOutputWithContext(context.Context) GroupPoliciesExclusiveArrayOutput
}

type GroupPoliciesExclusiveArray []GroupPoliciesExclusiveInput

func (GroupPoliciesExclusiveArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GroupPoliciesExclusive)(nil)).Elem()
}

func (i GroupPoliciesExclusiveArray) ToGroupPoliciesExclusiveArrayOutput() GroupPoliciesExclusiveArrayOutput {
	return i.ToGroupPoliciesExclusiveArrayOutputWithContext(context.Background())
}

func (i GroupPoliciesExclusiveArray) ToGroupPoliciesExclusiveArrayOutputWithContext(ctx context.Context) GroupPoliciesExclusiveArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupPoliciesExclusiveArrayOutput)
}

// GroupPoliciesExclusiveMapInput is an input type that accepts GroupPoliciesExclusiveMap and GroupPoliciesExclusiveMapOutput values.
// You can construct a concrete instance of `GroupPoliciesExclusiveMapInput` via:
//
//	GroupPoliciesExclusiveMap{ "key": GroupPoliciesExclusiveArgs{...} }
type GroupPoliciesExclusiveMapInput interface {
	pulumi.Input

	ToGroupPoliciesExclusiveMapOutput() GroupPoliciesExclusiveMapOutput
	ToGroupPoliciesExclusiveMapOutputWithContext(context.Context) GroupPoliciesExclusiveMapOutput
}

type GroupPoliciesExclusiveMap map[string]GroupPoliciesExclusiveInput

func (GroupPoliciesExclusiveMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GroupPoliciesExclusive)(nil)).Elem()
}

func (i GroupPoliciesExclusiveMap) ToGroupPoliciesExclusiveMapOutput() GroupPoliciesExclusiveMapOutput {
	return i.ToGroupPoliciesExclusiveMapOutputWithContext(context.Background())
}

func (i GroupPoliciesExclusiveMap) ToGroupPoliciesExclusiveMapOutputWithContext(ctx context.Context) GroupPoliciesExclusiveMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupPoliciesExclusiveMapOutput)
}

type GroupPoliciesExclusiveOutput struct{ *pulumi.OutputState }

func (GroupPoliciesExclusiveOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupPoliciesExclusive)(nil)).Elem()
}

func (o GroupPoliciesExclusiveOutput) ToGroupPoliciesExclusiveOutput() GroupPoliciesExclusiveOutput {
	return o
}

func (o GroupPoliciesExclusiveOutput) ToGroupPoliciesExclusiveOutputWithContext(ctx context.Context) GroupPoliciesExclusiveOutput {
	return o
}

// IAM group name.
func (o GroupPoliciesExclusiveOutput) GroupName() pulumi.StringOutput {
	return o.ApplyT(func(v *GroupPoliciesExclusive) pulumi.StringOutput { return v.GroupName }).(pulumi.StringOutput)
}

// A list of inline policy names to be assigned to the group. Policies attached to this group but not configured in this argument will be removed.
func (o GroupPoliciesExclusiveOutput) PolicyNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GroupPoliciesExclusive) pulumi.StringArrayOutput { return v.PolicyNames }).(pulumi.StringArrayOutput)
}

type GroupPoliciesExclusiveArrayOutput struct{ *pulumi.OutputState }

func (GroupPoliciesExclusiveArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GroupPoliciesExclusive)(nil)).Elem()
}

func (o GroupPoliciesExclusiveArrayOutput) ToGroupPoliciesExclusiveArrayOutput() GroupPoliciesExclusiveArrayOutput {
	return o
}

func (o GroupPoliciesExclusiveArrayOutput) ToGroupPoliciesExclusiveArrayOutputWithContext(ctx context.Context) GroupPoliciesExclusiveArrayOutput {
	return o
}

func (o GroupPoliciesExclusiveArrayOutput) Index(i pulumi.IntInput) GroupPoliciesExclusiveOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *GroupPoliciesExclusive {
		return vs[0].([]*GroupPoliciesExclusive)[vs[1].(int)]
	}).(GroupPoliciesExclusiveOutput)
}

type GroupPoliciesExclusiveMapOutput struct{ *pulumi.OutputState }

func (GroupPoliciesExclusiveMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GroupPoliciesExclusive)(nil)).Elem()
}

func (o GroupPoliciesExclusiveMapOutput) ToGroupPoliciesExclusiveMapOutput() GroupPoliciesExclusiveMapOutput {
	return o
}

func (o GroupPoliciesExclusiveMapOutput) ToGroupPoliciesExclusiveMapOutputWithContext(ctx context.Context) GroupPoliciesExclusiveMapOutput {
	return o
}

func (o GroupPoliciesExclusiveMapOutput) MapIndex(k pulumi.StringInput) GroupPoliciesExclusiveOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *GroupPoliciesExclusive {
		return vs[0].(map[string]*GroupPoliciesExclusive)[vs[1].(string)]
	}).(GroupPoliciesExclusiveOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*GroupPoliciesExclusiveInput)(nil)).Elem(), &GroupPoliciesExclusive{})
	pulumi.RegisterInputType(reflect.TypeOf((*GroupPoliciesExclusiveArrayInput)(nil)).Elem(), GroupPoliciesExclusiveArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GroupPoliciesExclusiveMapInput)(nil)).Elem(), GroupPoliciesExclusiveMap{})
	pulumi.RegisterOutputType(GroupPoliciesExclusiveOutput{})
	pulumi.RegisterOutputType(GroupPoliciesExclusiveArrayOutput{})
	pulumi.RegisterOutputType(GroupPoliciesExclusiveMapOutput{})
}
