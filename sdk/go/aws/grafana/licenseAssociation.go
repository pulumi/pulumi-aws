// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package grafana

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v7/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type LicenseAssociation struct {
	pulumi.CustomResourceState

	FreeTrialExpiration pulumi.StringOutput    `pulumi:"freeTrialExpiration"`
	GrafanaToken        pulumi.StringPtrOutput `pulumi:"grafanaToken"`
	LicenseExpiration   pulumi.StringOutput    `pulumi:"licenseExpiration"`
	LicenseType         pulumi.StringOutput    `pulumi:"licenseType"`
	Region              pulumi.StringOutput    `pulumi:"region"`
	WorkspaceId         pulumi.StringOutput    `pulumi:"workspaceId"`
}

// NewLicenseAssociation registers a new resource with the given unique name, arguments, and options.
func NewLicenseAssociation(ctx *pulumi.Context,
	name string, args *LicenseAssociationArgs, opts ...pulumi.ResourceOption) (*LicenseAssociation, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.LicenseType == nil {
		return nil, errors.New("invalid value for required argument 'LicenseType'")
	}
	if args.WorkspaceId == nil {
		return nil, errors.New("invalid value for required argument 'WorkspaceId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource LicenseAssociation
	err := ctx.RegisterResource("aws:grafana/licenseAssociation:LicenseAssociation", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLicenseAssociation gets an existing LicenseAssociation resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLicenseAssociation(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LicenseAssociationState, opts ...pulumi.ResourceOption) (*LicenseAssociation, error) {
	var resource LicenseAssociation
	err := ctx.ReadResource("aws:grafana/licenseAssociation:LicenseAssociation", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LicenseAssociation resources.
type licenseAssociationState struct {
	FreeTrialExpiration *string `pulumi:"freeTrialExpiration"`
	GrafanaToken        *string `pulumi:"grafanaToken"`
	LicenseExpiration   *string `pulumi:"licenseExpiration"`
	LicenseType         *string `pulumi:"licenseType"`
	Region              *string `pulumi:"region"`
	WorkspaceId         *string `pulumi:"workspaceId"`
}

type LicenseAssociationState struct {
	FreeTrialExpiration pulumi.StringPtrInput
	GrafanaToken        pulumi.StringPtrInput
	LicenseExpiration   pulumi.StringPtrInput
	LicenseType         pulumi.StringPtrInput
	Region              pulumi.StringPtrInput
	WorkspaceId         pulumi.StringPtrInput
}

func (LicenseAssociationState) ElementType() reflect.Type {
	return reflect.TypeOf((*licenseAssociationState)(nil)).Elem()
}

type licenseAssociationArgs struct {
	GrafanaToken *string `pulumi:"grafanaToken"`
	LicenseType  string  `pulumi:"licenseType"`
	Region       *string `pulumi:"region"`
	WorkspaceId  string  `pulumi:"workspaceId"`
}

// The set of arguments for constructing a LicenseAssociation resource.
type LicenseAssociationArgs struct {
	GrafanaToken pulumi.StringPtrInput
	LicenseType  pulumi.StringInput
	Region       pulumi.StringPtrInput
	WorkspaceId  pulumi.StringInput
}

func (LicenseAssociationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*licenseAssociationArgs)(nil)).Elem()
}

type LicenseAssociationInput interface {
	pulumi.Input

	ToLicenseAssociationOutput() LicenseAssociationOutput
	ToLicenseAssociationOutputWithContext(ctx context.Context) LicenseAssociationOutput
}

func (*LicenseAssociation) ElementType() reflect.Type {
	return reflect.TypeOf((**LicenseAssociation)(nil)).Elem()
}

func (i *LicenseAssociation) ToLicenseAssociationOutput() LicenseAssociationOutput {
	return i.ToLicenseAssociationOutputWithContext(context.Background())
}

func (i *LicenseAssociation) ToLicenseAssociationOutputWithContext(ctx context.Context) LicenseAssociationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LicenseAssociationOutput)
}

// LicenseAssociationArrayInput is an input type that accepts LicenseAssociationArray and LicenseAssociationArrayOutput values.
// You can construct a concrete instance of `LicenseAssociationArrayInput` via:
//
//	LicenseAssociationArray{ LicenseAssociationArgs{...} }
type LicenseAssociationArrayInput interface {
	pulumi.Input

	ToLicenseAssociationArrayOutput() LicenseAssociationArrayOutput
	ToLicenseAssociationArrayOutputWithContext(context.Context) LicenseAssociationArrayOutput
}

type LicenseAssociationArray []LicenseAssociationInput

func (LicenseAssociationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LicenseAssociation)(nil)).Elem()
}

func (i LicenseAssociationArray) ToLicenseAssociationArrayOutput() LicenseAssociationArrayOutput {
	return i.ToLicenseAssociationArrayOutputWithContext(context.Background())
}

func (i LicenseAssociationArray) ToLicenseAssociationArrayOutputWithContext(ctx context.Context) LicenseAssociationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LicenseAssociationArrayOutput)
}

// LicenseAssociationMapInput is an input type that accepts LicenseAssociationMap and LicenseAssociationMapOutput values.
// You can construct a concrete instance of `LicenseAssociationMapInput` via:
//
//	LicenseAssociationMap{ "key": LicenseAssociationArgs{...} }
type LicenseAssociationMapInput interface {
	pulumi.Input

	ToLicenseAssociationMapOutput() LicenseAssociationMapOutput
	ToLicenseAssociationMapOutputWithContext(context.Context) LicenseAssociationMapOutput
}

type LicenseAssociationMap map[string]LicenseAssociationInput

func (LicenseAssociationMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LicenseAssociation)(nil)).Elem()
}

func (i LicenseAssociationMap) ToLicenseAssociationMapOutput() LicenseAssociationMapOutput {
	return i.ToLicenseAssociationMapOutputWithContext(context.Background())
}

func (i LicenseAssociationMap) ToLicenseAssociationMapOutputWithContext(ctx context.Context) LicenseAssociationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LicenseAssociationMapOutput)
}

type LicenseAssociationOutput struct{ *pulumi.OutputState }

func (LicenseAssociationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LicenseAssociation)(nil)).Elem()
}

func (o LicenseAssociationOutput) ToLicenseAssociationOutput() LicenseAssociationOutput {
	return o
}

func (o LicenseAssociationOutput) ToLicenseAssociationOutputWithContext(ctx context.Context) LicenseAssociationOutput {
	return o
}

func (o LicenseAssociationOutput) FreeTrialExpiration() pulumi.StringOutput {
	return o.ApplyT(func(v *LicenseAssociation) pulumi.StringOutput { return v.FreeTrialExpiration }).(pulumi.StringOutput)
}

func (o LicenseAssociationOutput) GrafanaToken() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LicenseAssociation) pulumi.StringPtrOutput { return v.GrafanaToken }).(pulumi.StringPtrOutput)
}

func (o LicenseAssociationOutput) LicenseExpiration() pulumi.StringOutput {
	return o.ApplyT(func(v *LicenseAssociation) pulumi.StringOutput { return v.LicenseExpiration }).(pulumi.StringOutput)
}

func (o LicenseAssociationOutput) LicenseType() pulumi.StringOutput {
	return o.ApplyT(func(v *LicenseAssociation) pulumi.StringOutput { return v.LicenseType }).(pulumi.StringOutput)
}

func (o LicenseAssociationOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *LicenseAssociation) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

func (o LicenseAssociationOutput) WorkspaceId() pulumi.StringOutput {
	return o.ApplyT(func(v *LicenseAssociation) pulumi.StringOutput { return v.WorkspaceId }).(pulumi.StringOutput)
}

type LicenseAssociationArrayOutput struct{ *pulumi.OutputState }

func (LicenseAssociationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LicenseAssociation)(nil)).Elem()
}

func (o LicenseAssociationArrayOutput) ToLicenseAssociationArrayOutput() LicenseAssociationArrayOutput {
	return o
}

func (o LicenseAssociationArrayOutput) ToLicenseAssociationArrayOutputWithContext(ctx context.Context) LicenseAssociationArrayOutput {
	return o
}

func (o LicenseAssociationArrayOutput) Index(i pulumi.IntInput) LicenseAssociationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *LicenseAssociation {
		return vs[0].([]*LicenseAssociation)[vs[1].(int)]
	}).(LicenseAssociationOutput)
}

type LicenseAssociationMapOutput struct{ *pulumi.OutputState }

func (LicenseAssociationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LicenseAssociation)(nil)).Elem()
}

func (o LicenseAssociationMapOutput) ToLicenseAssociationMapOutput() LicenseAssociationMapOutput {
	return o
}

func (o LicenseAssociationMapOutput) ToLicenseAssociationMapOutputWithContext(ctx context.Context) LicenseAssociationMapOutput {
	return o
}

func (o LicenseAssociationMapOutput) MapIndex(k pulumi.StringInput) LicenseAssociationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *LicenseAssociation {
		return vs[0].(map[string]*LicenseAssociation)[vs[1].(string)]
	}).(LicenseAssociationOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LicenseAssociationInput)(nil)).Elem(), &LicenseAssociation{})
	pulumi.RegisterInputType(reflect.TypeOf((*LicenseAssociationArrayInput)(nil)).Elem(), LicenseAssociationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LicenseAssociationMapInput)(nil)).Elem(), LicenseAssociationMap{})
	pulumi.RegisterOutputType(LicenseAssociationOutput{})
	pulumi.RegisterOutputType(LicenseAssociationArrayOutput{})
	pulumi.RegisterOutputType(LicenseAssociationMapOutput{})
}
