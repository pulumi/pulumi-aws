// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package redshiftdata

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Executes a Redshift Data Statement.
//
// ## Example Usage
// ### clusterIdentifier
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-aws/sdk/v5/go/aws/redshiftdata"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := redshiftdata.NewStatement(ctx, "example", &redshiftdata.StatementArgs{
//				ClusterIdentifier: pulumi.Any(aws_redshift_cluster.Example.Cluster_identifier),
//				Database:          pulumi.Any(aws_redshift_cluster.Example.Database_name),
//				DbUser:            pulumi.Any(aws_redshift_cluster.Example.Master_username),
//				Sql:               pulumi.String("CREATE GROUP group_name;"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### workgroupName
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-aws/sdk/v5/go/aws/redshiftdata"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := redshiftdata.NewStatement(ctx, "example", &redshiftdata.StatementArgs{
//				WorkgroupName: pulumi.Any(aws_redshiftserverless_workgroup.Example.Workgroup_name),
//				Database:      pulumi.String("dev"),
//				Sql:           pulumi.String("CREATE GROUP group_name;"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Redshift Data Statements can be imported using the `id`, e.g.,
//
// ```sh
//
//	$ pulumi import aws:redshiftdata/statement:Statement example example
//
// ```
type Statement struct {
	pulumi.CustomResourceState

	// The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.
	ClusterIdentifier pulumi.StringPtrOutput `pulumi:"clusterIdentifier"`
	// The name of the database.
	Database pulumi.StringOutput `pulumi:"database"`
	// The database user name.
	DbUser     pulumi.StringPtrOutput        `pulumi:"dbUser"`
	Parameters StatementParameterArrayOutput `pulumi:"parameters"`
	// The name or ARN of the secret that enables access to the database.
	SecretArn pulumi.StringPtrOutput `pulumi:"secretArn"`
	// The SQL statement text to run.
	Sql pulumi.StringOutput `pulumi:"sql"`
	// The name of the SQL statement. You can name the SQL statement when you create it to identify the query.
	StatementName pulumi.StringPtrOutput `pulumi:"statementName"`
	// A value that indicates whether to send an event to the Amazon EventBridge event bus after the SQL statement runs.
	WithEvent pulumi.BoolPtrOutput `pulumi:"withEvent"`
	// The serverless workgroup name. This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.
	WorkgroupName pulumi.StringPtrOutput `pulumi:"workgroupName"`
}

// NewStatement registers a new resource with the given unique name, arguments, and options.
func NewStatement(ctx *pulumi.Context,
	name string, args *StatementArgs, opts ...pulumi.ResourceOption) (*Statement, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Database == nil {
		return nil, errors.New("invalid value for required argument 'Database'")
	}
	if args.Sql == nil {
		return nil, errors.New("invalid value for required argument 'Sql'")
	}
	var resource Statement
	err := ctx.RegisterResource("aws:redshiftdata/statement:Statement", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetStatement gets an existing Statement resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetStatement(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *StatementState, opts ...pulumi.ResourceOption) (*Statement, error) {
	var resource Statement
	err := ctx.ReadResource("aws:redshiftdata/statement:Statement", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Statement resources.
type statementState struct {
	// The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.
	ClusterIdentifier *string `pulumi:"clusterIdentifier"`
	// The name of the database.
	Database *string `pulumi:"database"`
	// The database user name.
	DbUser     *string              `pulumi:"dbUser"`
	Parameters []StatementParameter `pulumi:"parameters"`
	// The name or ARN of the secret that enables access to the database.
	SecretArn *string `pulumi:"secretArn"`
	// The SQL statement text to run.
	Sql *string `pulumi:"sql"`
	// The name of the SQL statement. You can name the SQL statement when you create it to identify the query.
	StatementName *string `pulumi:"statementName"`
	// A value that indicates whether to send an event to the Amazon EventBridge event bus after the SQL statement runs.
	WithEvent *bool `pulumi:"withEvent"`
	// The serverless workgroup name. This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.
	WorkgroupName *string `pulumi:"workgroupName"`
}

type StatementState struct {
	// The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.
	ClusterIdentifier pulumi.StringPtrInput
	// The name of the database.
	Database pulumi.StringPtrInput
	// The database user name.
	DbUser     pulumi.StringPtrInput
	Parameters StatementParameterArrayInput
	// The name or ARN of the secret that enables access to the database.
	SecretArn pulumi.StringPtrInput
	// The SQL statement text to run.
	Sql pulumi.StringPtrInput
	// The name of the SQL statement. You can name the SQL statement when you create it to identify the query.
	StatementName pulumi.StringPtrInput
	// A value that indicates whether to send an event to the Amazon EventBridge event bus after the SQL statement runs.
	WithEvent pulumi.BoolPtrInput
	// The serverless workgroup name. This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.
	WorkgroupName pulumi.StringPtrInput
}

func (StatementState) ElementType() reflect.Type {
	return reflect.TypeOf((*statementState)(nil)).Elem()
}

type statementArgs struct {
	// The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.
	ClusterIdentifier *string `pulumi:"clusterIdentifier"`
	// The name of the database.
	Database string `pulumi:"database"`
	// The database user name.
	DbUser     *string              `pulumi:"dbUser"`
	Parameters []StatementParameter `pulumi:"parameters"`
	// The name or ARN of the secret that enables access to the database.
	SecretArn *string `pulumi:"secretArn"`
	// The SQL statement text to run.
	Sql string `pulumi:"sql"`
	// The name of the SQL statement. You can name the SQL statement when you create it to identify the query.
	StatementName *string `pulumi:"statementName"`
	// A value that indicates whether to send an event to the Amazon EventBridge event bus after the SQL statement runs.
	WithEvent *bool `pulumi:"withEvent"`
	// The serverless workgroup name. This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.
	WorkgroupName *string `pulumi:"workgroupName"`
}

// The set of arguments for constructing a Statement resource.
type StatementArgs struct {
	// The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.
	ClusterIdentifier pulumi.StringPtrInput
	// The name of the database.
	Database pulumi.StringInput
	// The database user name.
	DbUser     pulumi.StringPtrInput
	Parameters StatementParameterArrayInput
	// The name or ARN of the secret that enables access to the database.
	SecretArn pulumi.StringPtrInput
	// The SQL statement text to run.
	Sql pulumi.StringInput
	// The name of the SQL statement. You can name the SQL statement when you create it to identify the query.
	StatementName pulumi.StringPtrInput
	// A value that indicates whether to send an event to the Amazon EventBridge event bus after the SQL statement runs.
	WithEvent pulumi.BoolPtrInput
	// The serverless workgroup name. This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.
	WorkgroupName pulumi.StringPtrInput
}

func (StatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*statementArgs)(nil)).Elem()
}

type StatementInput interface {
	pulumi.Input

	ToStatementOutput() StatementOutput
	ToStatementOutputWithContext(ctx context.Context) StatementOutput
}

func (*Statement) ElementType() reflect.Type {
	return reflect.TypeOf((**Statement)(nil)).Elem()
}

func (i *Statement) ToStatementOutput() StatementOutput {
	return i.ToStatementOutputWithContext(context.Background())
}

func (i *Statement) ToStatementOutputWithContext(ctx context.Context) StatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatementOutput)
}

// StatementArrayInput is an input type that accepts StatementArray and StatementArrayOutput values.
// You can construct a concrete instance of `StatementArrayInput` via:
//
//	StatementArray{ StatementArgs{...} }
type StatementArrayInput interface {
	pulumi.Input

	ToStatementArrayOutput() StatementArrayOutput
	ToStatementArrayOutputWithContext(context.Context) StatementArrayOutput
}

type StatementArray []StatementInput

func (StatementArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Statement)(nil)).Elem()
}

func (i StatementArray) ToStatementArrayOutput() StatementArrayOutput {
	return i.ToStatementArrayOutputWithContext(context.Background())
}

func (i StatementArray) ToStatementArrayOutputWithContext(ctx context.Context) StatementArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatementArrayOutput)
}

// StatementMapInput is an input type that accepts StatementMap and StatementMapOutput values.
// You can construct a concrete instance of `StatementMapInput` via:
//
//	StatementMap{ "key": StatementArgs{...} }
type StatementMapInput interface {
	pulumi.Input

	ToStatementMapOutput() StatementMapOutput
	ToStatementMapOutputWithContext(context.Context) StatementMapOutput
}

type StatementMap map[string]StatementInput

func (StatementMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Statement)(nil)).Elem()
}

func (i StatementMap) ToStatementMapOutput() StatementMapOutput {
	return i.ToStatementMapOutputWithContext(context.Background())
}

func (i StatementMap) ToStatementMapOutputWithContext(ctx context.Context) StatementMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StatementMapOutput)
}

type StatementOutput struct{ *pulumi.OutputState }

func (StatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Statement)(nil)).Elem()
}

func (o StatementOutput) ToStatementOutput() StatementOutput {
	return o
}

func (o StatementOutput) ToStatementOutputWithContext(ctx context.Context) StatementOutput {
	return o
}

// The cluster identifier. This parameter is required when connecting to a cluster and authenticating using either Secrets Manager or temporary credentials.
func (o StatementOutput) ClusterIdentifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Statement) pulumi.StringPtrOutput { return v.ClusterIdentifier }).(pulumi.StringPtrOutput)
}

// The name of the database.
func (o StatementOutput) Database() pulumi.StringOutput {
	return o.ApplyT(func(v *Statement) pulumi.StringOutput { return v.Database }).(pulumi.StringOutput)
}

// The database user name.
func (o StatementOutput) DbUser() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Statement) pulumi.StringPtrOutput { return v.DbUser }).(pulumi.StringPtrOutput)
}

func (o StatementOutput) Parameters() StatementParameterArrayOutput {
	return o.ApplyT(func(v *Statement) StatementParameterArrayOutput { return v.Parameters }).(StatementParameterArrayOutput)
}

// The name or ARN of the secret that enables access to the database.
func (o StatementOutput) SecretArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Statement) pulumi.StringPtrOutput { return v.SecretArn }).(pulumi.StringPtrOutput)
}

// The SQL statement text to run.
func (o StatementOutput) Sql() pulumi.StringOutput {
	return o.ApplyT(func(v *Statement) pulumi.StringOutput { return v.Sql }).(pulumi.StringOutput)
}

// The name of the SQL statement. You can name the SQL statement when you create it to identify the query.
func (o StatementOutput) StatementName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Statement) pulumi.StringPtrOutput { return v.StatementName }).(pulumi.StringPtrOutput)
}

// A value that indicates whether to send an event to the Amazon EventBridge event bus after the SQL statement runs.
func (o StatementOutput) WithEvent() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Statement) pulumi.BoolPtrOutput { return v.WithEvent }).(pulumi.BoolPtrOutput)
}

// The serverless workgroup name. This parameter is required when connecting to a serverless workgroup and authenticating using either Secrets Manager or temporary credentials.
func (o StatementOutput) WorkgroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Statement) pulumi.StringPtrOutput { return v.WorkgroupName }).(pulumi.StringPtrOutput)
}

type StatementArrayOutput struct{ *pulumi.OutputState }

func (StatementArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Statement)(nil)).Elem()
}

func (o StatementArrayOutput) ToStatementArrayOutput() StatementArrayOutput {
	return o
}

func (o StatementArrayOutput) ToStatementArrayOutputWithContext(ctx context.Context) StatementArrayOutput {
	return o
}

func (o StatementArrayOutput) Index(i pulumi.IntInput) StatementOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Statement {
		return vs[0].([]*Statement)[vs[1].(int)]
	}).(StatementOutput)
}

type StatementMapOutput struct{ *pulumi.OutputState }

func (StatementMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Statement)(nil)).Elem()
}

func (o StatementMapOutput) ToStatementMapOutput() StatementMapOutput {
	return o
}

func (o StatementMapOutput) ToStatementMapOutputWithContext(ctx context.Context) StatementMapOutput {
	return o
}

func (o StatementMapOutput) MapIndex(k pulumi.StringInput) StatementOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Statement {
		return vs[0].(map[string]*Statement)[vs[1].(string)]
	}).(StatementOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*StatementInput)(nil)).Elem(), &Statement{})
	pulumi.RegisterInputType(reflect.TypeOf((*StatementArrayInput)(nil)).Elem(), StatementArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*StatementMapInput)(nil)).Elem(), StatementMap{})
	pulumi.RegisterOutputType(StatementOutput{})
	pulumi.RegisterOutputType(StatementArrayOutput{})
	pulumi.RegisterOutputType(StatementMapOutput{})
}
