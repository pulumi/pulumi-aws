// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package datazone

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Resource for managing an AWS DataZone Glossary.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"encoding/json"
//
//	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/datazone"
//	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/ec2"
//	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/iam"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			tmpJSON0, err := json.Marshal(map[string]interface{}{
//				"Version": "2012-10-17",
//				"Statement": []map[string]interface{}{
//					map[string]interface{}{
//						"Action": []string{
//							"sts:AssumeRole",
//							"sts:TagSession",
//						},
//						"Effect": "Allow",
//						"Principal": map[string]interface{}{
//							"Service": "datazone.amazonaws.com",
//						},
//					},
//					map[string]interface{}{
//						"Action": []string{
//							"sts:AssumeRole",
//							"sts:TagSession",
//						},
//						"Effect": "Allow",
//						"Principal": map[string]interface{}{
//							"Service": "cloudformation.amazonaws.com",
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			json0 := string(tmpJSON0)
//			tmpJSON1, err := json.Marshal(map[string]interface{}{
//				"Version": "2012-10-17",
//				"Statement": []map[string]interface{}{
//					map[string]interface{}{
//						"Action": []string{
//							"datazone:*",
//							"ram:*",
//							"sso:*",
//							"kms:*",
//						},
//						"Effect":   "Allow",
//						"Resource": "*",
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			json1 := string(tmpJSON1)
//			domainExecutionRole, err := iam.NewRole(ctx, "domain_execution_role", &iam.RoleArgs{
//				Name:             pulumi.String("example_name"),
//				AssumeRolePolicy: pulumi.String(json0),
//				InlinePolicies: iam.RoleInlinePolicyArray{
//					&iam.RoleInlinePolicyArgs{
//						Name:   pulumi.String("example_name"),
//						Policy: pulumi.String(json1),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			test, err := datazone.NewDomain(ctx, "test", &datazone.DomainArgs{
//				Name:                pulumi.String("example_name"),
//				DomainExecutionRole: domainExecutionRole.Arn,
//			})
//			if err != nil {
//				return err
//			}
//			_, err = ec2.NewSecurityGroup(ctx, "test", &ec2.SecurityGroupArgs{
//				Name: pulumi.String("example_name"),
//			})
//			if err != nil {
//				return err
//			}
//			testProject, err := datazone.NewProject(ctx, "test", &datazone.ProjectArgs{
//				DomainIdentifier: test.ID(),
//				GlossaryTerms: pulumi.StringArray{
//					pulumi.String("2N8w6XJCwZf"),
//				},
//				Name:              pulumi.String("example_name"),
//				Description:       pulumi.String("desc"),
//				SkipDeletionCheck: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = datazone.NewGlossary(ctx, "test", &datazone.GlossaryArgs{
//				Description:             pulumi.String("description"),
//				Name:                    pulumi.String("example_name"),
//				OwningProjectIdentifier: testProject.ID(),
//				Status:                  pulumi.String("DISABLED"),
//				DomainIdentifier:        testProject.DomainIdentifier,
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Basic Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/datazone"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := datazone.NewGlossary(ctx, "test", &datazone.GlossaryArgs{
//				Description:             pulumi.String("description"),
//				Name:                    pulumi.String("example_name"),
//				OwningProjectIdentifier: pulumi.Any(testAwsDatazoneProject.Id),
//				Status:                  pulumi.String("DISABLED"),
//				DomainIdentifier:        pulumi.Any(testAwsDatazoneProject.DomainIdentifier),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Using `pulumi import`, import DataZone Glossary using the import Datazone Glossary using a comma-delimited string combining the domain id, glossary id, and the id of the project it's under. For example:
//
// ```sh
// $ pulumi import aws:datazone/glossary:Glossary example domain-id,glossary-id,owning-project-identifier
// ```
type Glossary struct {
	pulumi.CustomResourceState

	// Description of the glossary. Must have a length between 0 and 4096.
	Description      pulumi.StringPtrOutput `pulumi:"description"`
	DomainIdentifier pulumi.StringOutput    `pulumi:"domainIdentifier"`
	// Name of the glossary. Must have length between 1 and 256.
	Name pulumi.StringOutput `pulumi:"name"`
	// ID of the project that owns business glossary. Must follow regex of ^[a-zA-Z0-9_-]{1,36}$.
	//
	// The following arguments are optional:
	OwningProjectIdentifier pulumi.StringOutput `pulumi:"owningProjectIdentifier"`
	// Status of business glossary. Valid values are DISABLED and ENABLED.
	Status pulumi.StringPtrOutput `pulumi:"status"`
}

// NewGlossary registers a new resource with the given unique name, arguments, and options.
func NewGlossary(ctx *pulumi.Context,
	name string, args *GlossaryArgs, opts ...pulumi.ResourceOption) (*Glossary, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DomainIdentifier == nil {
		return nil, errors.New("invalid value for required argument 'DomainIdentifier'")
	}
	if args.OwningProjectIdentifier == nil {
		return nil, errors.New("invalid value for required argument 'OwningProjectIdentifier'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Glossary
	err := ctx.RegisterResource("aws:datazone/glossary:Glossary", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetGlossary gets an existing Glossary resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetGlossary(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *GlossaryState, opts ...pulumi.ResourceOption) (*Glossary, error) {
	var resource Glossary
	err := ctx.ReadResource("aws:datazone/glossary:Glossary", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Glossary resources.
type glossaryState struct {
	// Description of the glossary. Must have a length between 0 and 4096.
	Description      *string `pulumi:"description"`
	DomainIdentifier *string `pulumi:"domainIdentifier"`
	// Name of the glossary. Must have length between 1 and 256.
	Name *string `pulumi:"name"`
	// ID of the project that owns business glossary. Must follow regex of ^[a-zA-Z0-9_-]{1,36}$.
	//
	// The following arguments are optional:
	OwningProjectIdentifier *string `pulumi:"owningProjectIdentifier"`
	// Status of business glossary. Valid values are DISABLED and ENABLED.
	Status *string `pulumi:"status"`
}

type GlossaryState struct {
	// Description of the glossary. Must have a length between 0 and 4096.
	Description      pulumi.StringPtrInput
	DomainIdentifier pulumi.StringPtrInput
	// Name of the glossary. Must have length between 1 and 256.
	Name pulumi.StringPtrInput
	// ID of the project that owns business glossary. Must follow regex of ^[a-zA-Z0-9_-]{1,36}$.
	//
	// The following arguments are optional:
	OwningProjectIdentifier pulumi.StringPtrInput
	// Status of business glossary. Valid values are DISABLED and ENABLED.
	Status pulumi.StringPtrInput
}

func (GlossaryState) ElementType() reflect.Type {
	return reflect.TypeOf((*glossaryState)(nil)).Elem()
}

type glossaryArgs struct {
	// Description of the glossary. Must have a length between 0 and 4096.
	Description      *string `pulumi:"description"`
	DomainIdentifier string  `pulumi:"domainIdentifier"`
	// Name of the glossary. Must have length between 1 and 256.
	Name *string `pulumi:"name"`
	// ID of the project that owns business glossary. Must follow regex of ^[a-zA-Z0-9_-]{1,36}$.
	//
	// The following arguments are optional:
	OwningProjectIdentifier string `pulumi:"owningProjectIdentifier"`
	// Status of business glossary. Valid values are DISABLED and ENABLED.
	Status *string `pulumi:"status"`
}

// The set of arguments for constructing a Glossary resource.
type GlossaryArgs struct {
	// Description of the glossary. Must have a length between 0 and 4096.
	Description      pulumi.StringPtrInput
	DomainIdentifier pulumi.StringInput
	// Name of the glossary. Must have length between 1 and 256.
	Name pulumi.StringPtrInput
	// ID of the project that owns business glossary. Must follow regex of ^[a-zA-Z0-9_-]{1,36}$.
	//
	// The following arguments are optional:
	OwningProjectIdentifier pulumi.StringInput
	// Status of business glossary. Valid values are DISABLED and ENABLED.
	Status pulumi.StringPtrInput
}

func (GlossaryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*glossaryArgs)(nil)).Elem()
}

type GlossaryInput interface {
	pulumi.Input

	ToGlossaryOutput() GlossaryOutput
	ToGlossaryOutputWithContext(ctx context.Context) GlossaryOutput
}

func (*Glossary) ElementType() reflect.Type {
	return reflect.TypeOf((**Glossary)(nil)).Elem()
}

func (i *Glossary) ToGlossaryOutput() GlossaryOutput {
	return i.ToGlossaryOutputWithContext(context.Background())
}

func (i *Glossary) ToGlossaryOutputWithContext(ctx context.Context) GlossaryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GlossaryOutput)
}

// GlossaryArrayInput is an input type that accepts GlossaryArray and GlossaryArrayOutput values.
// You can construct a concrete instance of `GlossaryArrayInput` via:
//
//	GlossaryArray{ GlossaryArgs{...} }
type GlossaryArrayInput interface {
	pulumi.Input

	ToGlossaryArrayOutput() GlossaryArrayOutput
	ToGlossaryArrayOutputWithContext(context.Context) GlossaryArrayOutput
}

type GlossaryArray []GlossaryInput

func (GlossaryArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Glossary)(nil)).Elem()
}

func (i GlossaryArray) ToGlossaryArrayOutput() GlossaryArrayOutput {
	return i.ToGlossaryArrayOutputWithContext(context.Background())
}

func (i GlossaryArray) ToGlossaryArrayOutputWithContext(ctx context.Context) GlossaryArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GlossaryArrayOutput)
}

// GlossaryMapInput is an input type that accepts GlossaryMap and GlossaryMapOutput values.
// You can construct a concrete instance of `GlossaryMapInput` via:
//
//	GlossaryMap{ "key": GlossaryArgs{...} }
type GlossaryMapInput interface {
	pulumi.Input

	ToGlossaryMapOutput() GlossaryMapOutput
	ToGlossaryMapOutputWithContext(context.Context) GlossaryMapOutput
}

type GlossaryMap map[string]GlossaryInput

func (GlossaryMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Glossary)(nil)).Elem()
}

func (i GlossaryMap) ToGlossaryMapOutput() GlossaryMapOutput {
	return i.ToGlossaryMapOutputWithContext(context.Background())
}

func (i GlossaryMap) ToGlossaryMapOutputWithContext(ctx context.Context) GlossaryMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GlossaryMapOutput)
}

type GlossaryOutput struct{ *pulumi.OutputState }

func (GlossaryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Glossary)(nil)).Elem()
}

func (o GlossaryOutput) ToGlossaryOutput() GlossaryOutput {
	return o
}

func (o GlossaryOutput) ToGlossaryOutputWithContext(ctx context.Context) GlossaryOutput {
	return o
}

// Description of the glossary. Must have a length between 0 and 4096.
func (o GlossaryOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Glossary) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

func (o GlossaryOutput) DomainIdentifier() pulumi.StringOutput {
	return o.ApplyT(func(v *Glossary) pulumi.StringOutput { return v.DomainIdentifier }).(pulumi.StringOutput)
}

// Name of the glossary. Must have length between 1 and 256.
func (o GlossaryOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Glossary) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// ID of the project that owns business glossary. Must follow regex of ^[a-zA-Z0-9_-]{1,36}$.
//
// The following arguments are optional:
func (o GlossaryOutput) OwningProjectIdentifier() pulumi.StringOutput {
	return o.ApplyT(func(v *Glossary) pulumi.StringOutput { return v.OwningProjectIdentifier }).(pulumi.StringOutput)
}

// Status of business glossary. Valid values are DISABLED and ENABLED.
func (o GlossaryOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Glossary) pulumi.StringPtrOutput { return v.Status }).(pulumi.StringPtrOutput)
}

type GlossaryArrayOutput struct{ *pulumi.OutputState }

func (GlossaryArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Glossary)(nil)).Elem()
}

func (o GlossaryArrayOutput) ToGlossaryArrayOutput() GlossaryArrayOutput {
	return o
}

func (o GlossaryArrayOutput) ToGlossaryArrayOutputWithContext(ctx context.Context) GlossaryArrayOutput {
	return o
}

func (o GlossaryArrayOutput) Index(i pulumi.IntInput) GlossaryOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Glossary {
		return vs[0].([]*Glossary)[vs[1].(int)]
	}).(GlossaryOutput)
}

type GlossaryMapOutput struct{ *pulumi.OutputState }

func (GlossaryMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Glossary)(nil)).Elem()
}

func (o GlossaryMapOutput) ToGlossaryMapOutput() GlossaryMapOutput {
	return o
}

func (o GlossaryMapOutput) ToGlossaryMapOutputWithContext(ctx context.Context) GlossaryMapOutput {
	return o
}

func (o GlossaryMapOutput) MapIndex(k pulumi.StringInput) GlossaryOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Glossary {
		return vs[0].(map[string]*Glossary)[vs[1].(string)]
	}).(GlossaryOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*GlossaryInput)(nil)).Elem(), &Glossary{})
	pulumi.RegisterInputType(reflect.TypeOf((*GlossaryArrayInput)(nil)).Elem(), GlossaryArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GlossaryMapInput)(nil)).Elem(), GlossaryMap{})
	pulumi.RegisterOutputType(GlossaryOutput{})
	pulumi.RegisterOutputType(GlossaryArrayOutput{})
	pulumi.RegisterOutputType(GlossaryMapOutput{})
}
