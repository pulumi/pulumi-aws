// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ec2

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v7/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type Fleet struct {
	pulumi.CustomResourceState

	Arn                              pulumi.StringOutput                    `pulumi:"arn"`
	Context                          pulumi.StringPtrOutput                 `pulumi:"context"`
	ExcessCapacityTerminationPolicy  pulumi.StringPtrOutput                 `pulumi:"excessCapacityTerminationPolicy"`
	FleetInstanceSets                FleetFleetInstanceSetArrayOutput       `pulumi:"fleetInstanceSets"`
	FleetState                       pulumi.StringOutput                    `pulumi:"fleetState"`
	FulfilledCapacity                pulumi.Float64Output                   `pulumi:"fulfilledCapacity"`
	FulfilledOnDemandCapacity        pulumi.Float64Output                   `pulumi:"fulfilledOnDemandCapacity"`
	LaunchTemplateConfigs            FleetLaunchTemplateConfigArrayOutput   `pulumi:"launchTemplateConfigs"`
	OnDemandOptions                  FleetOnDemandOptionsPtrOutput          `pulumi:"onDemandOptions"`
	Region                           pulumi.StringOutput                    `pulumi:"region"`
	ReplaceUnhealthyInstances        pulumi.BoolPtrOutput                   `pulumi:"replaceUnhealthyInstances"`
	SpotOptions                      FleetSpotOptionsPtrOutput              `pulumi:"spotOptions"`
	Tags                             pulumi.StringMapOutput                 `pulumi:"tags"`
	TagsAll                          pulumi.StringMapOutput                 `pulumi:"tagsAll"`
	TargetCapacitySpecification      FleetTargetCapacitySpecificationOutput `pulumi:"targetCapacitySpecification"`
	TerminateInstances               pulumi.BoolPtrOutput                   `pulumi:"terminateInstances"`
	TerminateInstancesWithExpiration pulumi.BoolPtrOutput                   `pulumi:"terminateInstancesWithExpiration"`
	Type                             pulumi.StringPtrOutput                 `pulumi:"type"`
	ValidFrom                        pulumi.StringPtrOutput                 `pulumi:"validFrom"`
	ValidUntil                       pulumi.StringPtrOutput                 `pulumi:"validUntil"`
}

// NewFleet registers a new resource with the given unique name, arguments, and options.
func NewFleet(ctx *pulumi.Context,
	name string, args *FleetArgs, opts ...pulumi.ResourceOption) (*Fleet, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.LaunchTemplateConfigs == nil {
		return nil, errors.New("invalid value for required argument 'LaunchTemplateConfigs'")
	}
	if args.TargetCapacitySpecification == nil {
		return nil, errors.New("invalid value for required argument 'TargetCapacitySpecification'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Fleet
	err := ctx.RegisterResource("aws:ec2/fleet:Fleet", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFleet gets an existing Fleet resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFleet(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FleetState, opts ...pulumi.ResourceOption) (*Fleet, error) {
	var resource Fleet
	err := ctx.ReadResource("aws:ec2/fleet:Fleet", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Fleet resources.
type fleetState struct {
	Arn                              *string                           `pulumi:"arn"`
	Context                          *string                           `pulumi:"context"`
	ExcessCapacityTerminationPolicy  *string                           `pulumi:"excessCapacityTerminationPolicy"`
	FleetInstanceSets                []FleetFleetInstanceSet           `pulumi:"fleetInstanceSets"`
	FleetState                       *string                           `pulumi:"fleetState"`
	FulfilledCapacity                *float64                          `pulumi:"fulfilledCapacity"`
	FulfilledOnDemandCapacity        *float64                          `pulumi:"fulfilledOnDemandCapacity"`
	LaunchTemplateConfigs            []FleetLaunchTemplateConfig       `pulumi:"launchTemplateConfigs"`
	OnDemandOptions                  *FleetOnDemandOptions             `pulumi:"onDemandOptions"`
	Region                           *string                           `pulumi:"region"`
	ReplaceUnhealthyInstances        *bool                             `pulumi:"replaceUnhealthyInstances"`
	SpotOptions                      *FleetSpotOptions                 `pulumi:"spotOptions"`
	Tags                             map[string]string                 `pulumi:"tags"`
	TagsAll                          map[string]string                 `pulumi:"tagsAll"`
	TargetCapacitySpecification      *FleetTargetCapacitySpecification `pulumi:"targetCapacitySpecification"`
	TerminateInstances               *bool                             `pulumi:"terminateInstances"`
	TerminateInstancesWithExpiration *bool                             `pulumi:"terminateInstancesWithExpiration"`
	Type                             *string                           `pulumi:"type"`
	ValidFrom                        *string                           `pulumi:"validFrom"`
	ValidUntil                       *string                           `pulumi:"validUntil"`
}

type FleetState struct {
	Arn                              pulumi.StringPtrInput
	Context                          pulumi.StringPtrInput
	ExcessCapacityTerminationPolicy  pulumi.StringPtrInput
	FleetInstanceSets                FleetFleetInstanceSetArrayInput
	FleetState                       pulumi.StringPtrInput
	FulfilledCapacity                pulumi.Float64PtrInput
	FulfilledOnDemandCapacity        pulumi.Float64PtrInput
	LaunchTemplateConfigs            FleetLaunchTemplateConfigArrayInput
	OnDemandOptions                  FleetOnDemandOptionsPtrInput
	Region                           pulumi.StringPtrInput
	ReplaceUnhealthyInstances        pulumi.BoolPtrInput
	SpotOptions                      FleetSpotOptionsPtrInput
	Tags                             pulumi.StringMapInput
	TagsAll                          pulumi.StringMapInput
	TargetCapacitySpecification      FleetTargetCapacitySpecificationPtrInput
	TerminateInstances               pulumi.BoolPtrInput
	TerminateInstancesWithExpiration pulumi.BoolPtrInput
	Type                             pulumi.StringPtrInput
	ValidFrom                        pulumi.StringPtrInput
	ValidUntil                       pulumi.StringPtrInput
}

func (FleetState) ElementType() reflect.Type {
	return reflect.TypeOf((*fleetState)(nil)).Elem()
}

type fleetArgs struct {
	Context                          *string                          `pulumi:"context"`
	ExcessCapacityTerminationPolicy  *string                          `pulumi:"excessCapacityTerminationPolicy"`
	FleetInstanceSets                []FleetFleetInstanceSet          `pulumi:"fleetInstanceSets"`
	FleetState                       *string                          `pulumi:"fleetState"`
	FulfilledCapacity                *float64                         `pulumi:"fulfilledCapacity"`
	FulfilledOnDemandCapacity        *float64                         `pulumi:"fulfilledOnDemandCapacity"`
	LaunchTemplateConfigs            []FleetLaunchTemplateConfig      `pulumi:"launchTemplateConfigs"`
	OnDemandOptions                  *FleetOnDemandOptions            `pulumi:"onDemandOptions"`
	Region                           *string                          `pulumi:"region"`
	ReplaceUnhealthyInstances        *bool                            `pulumi:"replaceUnhealthyInstances"`
	SpotOptions                      *FleetSpotOptions                `pulumi:"spotOptions"`
	Tags                             map[string]string                `pulumi:"tags"`
	TargetCapacitySpecification      FleetTargetCapacitySpecification `pulumi:"targetCapacitySpecification"`
	TerminateInstances               *bool                            `pulumi:"terminateInstances"`
	TerminateInstancesWithExpiration *bool                            `pulumi:"terminateInstancesWithExpiration"`
	Type                             *string                          `pulumi:"type"`
	ValidFrom                        *string                          `pulumi:"validFrom"`
	ValidUntil                       *string                          `pulumi:"validUntil"`
}

// The set of arguments for constructing a Fleet resource.
type FleetArgs struct {
	Context                          pulumi.StringPtrInput
	ExcessCapacityTerminationPolicy  pulumi.StringPtrInput
	FleetInstanceSets                FleetFleetInstanceSetArrayInput
	FleetState                       pulumi.StringPtrInput
	FulfilledCapacity                pulumi.Float64PtrInput
	FulfilledOnDemandCapacity        pulumi.Float64PtrInput
	LaunchTemplateConfigs            FleetLaunchTemplateConfigArrayInput
	OnDemandOptions                  FleetOnDemandOptionsPtrInput
	Region                           pulumi.StringPtrInput
	ReplaceUnhealthyInstances        pulumi.BoolPtrInput
	SpotOptions                      FleetSpotOptionsPtrInput
	Tags                             pulumi.StringMapInput
	TargetCapacitySpecification      FleetTargetCapacitySpecificationInput
	TerminateInstances               pulumi.BoolPtrInput
	TerminateInstancesWithExpiration pulumi.BoolPtrInput
	Type                             pulumi.StringPtrInput
	ValidFrom                        pulumi.StringPtrInput
	ValidUntil                       pulumi.StringPtrInput
}

func (FleetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*fleetArgs)(nil)).Elem()
}

type FleetInput interface {
	pulumi.Input

	ToFleetOutput() FleetOutput
	ToFleetOutputWithContext(ctx context.Context) FleetOutput
}

func (*Fleet) ElementType() reflect.Type {
	return reflect.TypeOf((**Fleet)(nil)).Elem()
}

func (i *Fleet) ToFleetOutput() FleetOutput {
	return i.ToFleetOutputWithContext(context.Background())
}

func (i *Fleet) ToFleetOutputWithContext(ctx context.Context) FleetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetOutput)
}

// FleetArrayInput is an input type that accepts FleetArray and FleetArrayOutput values.
// You can construct a concrete instance of `FleetArrayInput` via:
//
//	FleetArray{ FleetArgs{...} }
type FleetArrayInput interface {
	pulumi.Input

	ToFleetArrayOutput() FleetArrayOutput
	ToFleetArrayOutputWithContext(context.Context) FleetArrayOutput
}

type FleetArray []FleetInput

func (FleetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Fleet)(nil)).Elem()
}

func (i FleetArray) ToFleetArrayOutput() FleetArrayOutput {
	return i.ToFleetArrayOutputWithContext(context.Background())
}

func (i FleetArray) ToFleetArrayOutputWithContext(ctx context.Context) FleetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetArrayOutput)
}

// FleetMapInput is an input type that accepts FleetMap and FleetMapOutput values.
// You can construct a concrete instance of `FleetMapInput` via:
//
//	FleetMap{ "key": FleetArgs{...} }
type FleetMapInput interface {
	pulumi.Input

	ToFleetMapOutput() FleetMapOutput
	ToFleetMapOutputWithContext(context.Context) FleetMapOutput
}

type FleetMap map[string]FleetInput

func (FleetMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Fleet)(nil)).Elem()
}

func (i FleetMap) ToFleetMapOutput() FleetMapOutput {
	return i.ToFleetMapOutputWithContext(context.Background())
}

func (i FleetMap) ToFleetMapOutputWithContext(ctx context.Context) FleetMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetMapOutput)
}

type FleetOutput struct{ *pulumi.OutputState }

func (FleetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Fleet)(nil)).Elem()
}

func (o FleetOutput) ToFleetOutput() FleetOutput {
	return o
}

func (o FleetOutput) ToFleetOutputWithContext(ctx context.Context) FleetOutput {
	return o
}

func (o FleetOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringOutput { return v.Arn }).(pulumi.StringOutput)
}

func (o FleetOutput) Context() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringPtrOutput { return v.Context }).(pulumi.StringPtrOutput)
}

func (o FleetOutput) ExcessCapacityTerminationPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringPtrOutput { return v.ExcessCapacityTerminationPolicy }).(pulumi.StringPtrOutput)
}

func (o FleetOutput) FleetInstanceSets() FleetFleetInstanceSetArrayOutput {
	return o.ApplyT(func(v *Fleet) FleetFleetInstanceSetArrayOutput { return v.FleetInstanceSets }).(FleetFleetInstanceSetArrayOutput)
}

func (o FleetOutput) FleetState() pulumi.StringOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringOutput { return v.FleetState }).(pulumi.StringOutput)
}

func (o FleetOutput) FulfilledCapacity() pulumi.Float64Output {
	return o.ApplyT(func(v *Fleet) pulumi.Float64Output { return v.FulfilledCapacity }).(pulumi.Float64Output)
}

func (o FleetOutput) FulfilledOnDemandCapacity() pulumi.Float64Output {
	return o.ApplyT(func(v *Fleet) pulumi.Float64Output { return v.FulfilledOnDemandCapacity }).(pulumi.Float64Output)
}

func (o FleetOutput) LaunchTemplateConfigs() FleetLaunchTemplateConfigArrayOutput {
	return o.ApplyT(func(v *Fleet) FleetLaunchTemplateConfigArrayOutput { return v.LaunchTemplateConfigs }).(FleetLaunchTemplateConfigArrayOutput)
}

func (o FleetOutput) OnDemandOptions() FleetOnDemandOptionsPtrOutput {
	return o.ApplyT(func(v *Fleet) FleetOnDemandOptionsPtrOutput { return v.OnDemandOptions }).(FleetOnDemandOptionsPtrOutput)
}

func (o FleetOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

func (o FleetOutput) ReplaceUnhealthyInstances() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Fleet) pulumi.BoolPtrOutput { return v.ReplaceUnhealthyInstances }).(pulumi.BoolPtrOutput)
}

func (o FleetOutput) SpotOptions() FleetSpotOptionsPtrOutput {
	return o.ApplyT(func(v *Fleet) FleetSpotOptionsPtrOutput { return v.SpotOptions }).(FleetSpotOptionsPtrOutput)
}

func (o FleetOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

func (o FleetOutput) TagsAll() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringMapOutput { return v.TagsAll }).(pulumi.StringMapOutput)
}

func (o FleetOutput) TargetCapacitySpecification() FleetTargetCapacitySpecificationOutput {
	return o.ApplyT(func(v *Fleet) FleetTargetCapacitySpecificationOutput { return v.TargetCapacitySpecification }).(FleetTargetCapacitySpecificationOutput)
}

func (o FleetOutput) TerminateInstances() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Fleet) pulumi.BoolPtrOutput { return v.TerminateInstances }).(pulumi.BoolPtrOutput)
}

func (o FleetOutput) TerminateInstancesWithExpiration() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Fleet) pulumi.BoolPtrOutput { return v.TerminateInstancesWithExpiration }).(pulumi.BoolPtrOutput)
}

func (o FleetOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringPtrOutput { return v.Type }).(pulumi.StringPtrOutput)
}

func (o FleetOutput) ValidFrom() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringPtrOutput { return v.ValidFrom }).(pulumi.StringPtrOutput)
}

func (o FleetOutput) ValidUntil() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Fleet) pulumi.StringPtrOutput { return v.ValidUntil }).(pulumi.StringPtrOutput)
}

type FleetArrayOutput struct{ *pulumi.OutputState }

func (FleetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Fleet)(nil)).Elem()
}

func (o FleetArrayOutput) ToFleetArrayOutput() FleetArrayOutput {
	return o
}

func (o FleetArrayOutput) ToFleetArrayOutputWithContext(ctx context.Context) FleetArrayOutput {
	return o
}

func (o FleetArrayOutput) Index(i pulumi.IntInput) FleetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Fleet {
		return vs[0].([]*Fleet)[vs[1].(int)]
	}).(FleetOutput)
}

type FleetMapOutput struct{ *pulumi.OutputState }

func (FleetMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Fleet)(nil)).Elem()
}

func (o FleetMapOutput) ToFleetMapOutput() FleetMapOutput {
	return o
}

func (o FleetMapOutput) ToFleetMapOutputWithContext(ctx context.Context) FleetMapOutput {
	return o
}

func (o FleetMapOutput) MapIndex(k pulumi.StringInput) FleetOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Fleet {
		return vs[0].(map[string]*Fleet)[vs[1].(string)]
	}).(FleetOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FleetInput)(nil)).Elem(), &Fleet{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetArrayInput)(nil)).Elem(), FleetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetMapInput)(nil)).Elem(), FleetMap{})
	pulumi.RegisterOutputType(FleetOutput{})
	pulumi.RegisterOutputType(FleetArrayOutput{})
	pulumi.RegisterOutputType(FleetMapOutput{})
}
