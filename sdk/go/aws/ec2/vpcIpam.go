// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package ec2

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a IPAM resource.
//
// ## Import
//
// IPAMs can be imported using the `ipam id`, e.g.
//
// ```sh
//  $ pulumi import aws:ec2/vpcIpam:VpcIpam example ipam-0178368ad2146a492
// ```
type VpcIpam struct {
	pulumi.CustomResourceState

	// Amazon Resource Name (ARN) of IPAM
	Arn pulumi.StringOutput `pulumi:"arn"`
	// A description for the IPAM.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Determines which locales can be chosen when you create pools. Locale is the Region where you want to make an IPAM pool available for allocations. You can only create pools with locales that match the operating Regions of the IPAM. You can only create VPCs from a pool whose locale matches the VPC's Region. You specify a region using the regionName parameter. You **must** set your provider block region as an operating_region.
	OperatingRegions VpcIpamOperatingRegionArrayOutput `pulumi:"operatingRegions"`
	// The ID of the IPAM's private scope. A scope is a top-level container in IPAM. Each scope represents an IP-independent network. Scopes enable you to represent networks where you have overlapping IP space. When you create an IPAM, IPAM automatically creates two scopes: public and private. The private scope is intended for private IP space. The public scope is intended for all internet-routable IP space.
	PrivateDefaultScopeId pulumi.StringOutput `pulumi:"privateDefaultScopeId"`
	// The ID of the IPAM's public scope. A scope is a top-level container in IPAM. Each scope represents an IP-independent network. Scopes enable you to represent networks where you have overlapping IP space. When you create an IPAM, IPAM automatically creates two scopes: public and private. The private scope is intended for private
	// IP space. The public scope is intended for all internet-routable IP space.
	PublicDefaultScopeId pulumi.StringOutput `pulumi:"publicDefaultScopeId"`
	// The number of scopes in the IPAM.
	ScopeCount pulumi.IntOutput `pulumi:"scopeCount"`
	// A map of tags to assign to the resource. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags pulumi.StringMapOutput `pulumi:"tags"`
	// A map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
	TagsAll pulumi.StringMapOutput `pulumi:"tagsAll"`
}

// NewVpcIpam registers a new resource with the given unique name, arguments, and options.
func NewVpcIpam(ctx *pulumi.Context,
	name string, args *VpcIpamArgs, opts ...pulumi.ResourceOption) (*VpcIpam, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.OperatingRegions == nil {
		return nil, errors.New("invalid value for required argument 'OperatingRegions'")
	}
	var resource VpcIpam
	err := ctx.RegisterResource("aws:ec2/vpcIpam:VpcIpam", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetVpcIpam gets an existing VpcIpam resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetVpcIpam(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *VpcIpamState, opts ...pulumi.ResourceOption) (*VpcIpam, error) {
	var resource VpcIpam
	err := ctx.ReadResource("aws:ec2/vpcIpam:VpcIpam", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering VpcIpam resources.
type vpcIpamState struct {
	// Amazon Resource Name (ARN) of IPAM
	Arn *string `pulumi:"arn"`
	// A description for the IPAM.
	Description *string `pulumi:"description"`
	// Determines which locales can be chosen when you create pools. Locale is the Region where you want to make an IPAM pool available for allocations. You can only create pools with locales that match the operating Regions of the IPAM. You can only create VPCs from a pool whose locale matches the VPC's Region. You specify a region using the regionName parameter. You **must** set your provider block region as an operating_region.
	OperatingRegions []VpcIpamOperatingRegion `pulumi:"operatingRegions"`
	// The ID of the IPAM's private scope. A scope is a top-level container in IPAM. Each scope represents an IP-independent network. Scopes enable you to represent networks where you have overlapping IP space. When you create an IPAM, IPAM automatically creates two scopes: public and private. The private scope is intended for private IP space. The public scope is intended for all internet-routable IP space.
	PrivateDefaultScopeId *string `pulumi:"privateDefaultScopeId"`
	// The ID of the IPAM's public scope. A scope is a top-level container in IPAM. Each scope represents an IP-independent network. Scopes enable you to represent networks where you have overlapping IP space. When you create an IPAM, IPAM automatically creates two scopes: public and private. The private scope is intended for private
	// IP space. The public scope is intended for all internet-routable IP space.
	PublicDefaultScopeId *string `pulumi:"publicDefaultScopeId"`
	// The number of scopes in the IPAM.
	ScopeCount *int `pulumi:"scopeCount"`
	// A map of tags to assign to the resource. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags map[string]string `pulumi:"tags"`
	// A map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
	TagsAll map[string]string `pulumi:"tagsAll"`
}

type VpcIpamState struct {
	// Amazon Resource Name (ARN) of IPAM
	Arn pulumi.StringPtrInput
	// A description for the IPAM.
	Description pulumi.StringPtrInput
	// Determines which locales can be chosen when you create pools. Locale is the Region where you want to make an IPAM pool available for allocations. You can only create pools with locales that match the operating Regions of the IPAM. You can only create VPCs from a pool whose locale matches the VPC's Region. You specify a region using the regionName parameter. You **must** set your provider block region as an operating_region.
	OperatingRegions VpcIpamOperatingRegionArrayInput
	// The ID of the IPAM's private scope. A scope is a top-level container in IPAM. Each scope represents an IP-independent network. Scopes enable you to represent networks where you have overlapping IP space. When you create an IPAM, IPAM automatically creates two scopes: public and private. The private scope is intended for private IP space. The public scope is intended for all internet-routable IP space.
	PrivateDefaultScopeId pulumi.StringPtrInput
	// The ID of the IPAM's public scope. A scope is a top-level container in IPAM. Each scope represents an IP-independent network. Scopes enable you to represent networks where you have overlapping IP space. When you create an IPAM, IPAM automatically creates two scopes: public and private. The private scope is intended for private
	// IP space. The public scope is intended for all internet-routable IP space.
	PublicDefaultScopeId pulumi.StringPtrInput
	// The number of scopes in the IPAM.
	ScopeCount pulumi.IntPtrInput
	// A map of tags to assign to the resource. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags pulumi.StringMapInput
	// A map of tags assigned to the resource, including those inherited from the provider `defaultTags` configuration block.
	TagsAll pulumi.StringMapInput
}

func (VpcIpamState) ElementType() reflect.Type {
	return reflect.TypeOf((*vpcIpamState)(nil)).Elem()
}

type vpcIpamArgs struct {
	// A description for the IPAM.
	Description *string `pulumi:"description"`
	// Determines which locales can be chosen when you create pools. Locale is the Region where you want to make an IPAM pool available for allocations. You can only create pools with locales that match the operating Regions of the IPAM. You can only create VPCs from a pool whose locale matches the VPC's Region. You specify a region using the regionName parameter. You **must** set your provider block region as an operating_region.
	OperatingRegions []VpcIpamOperatingRegion `pulumi:"operatingRegions"`
	// A map of tags to assign to the resource. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags map[string]string `pulumi:"tags"`
}

// The set of arguments for constructing a VpcIpam resource.
type VpcIpamArgs struct {
	// A description for the IPAM.
	Description pulumi.StringPtrInput
	// Determines which locales can be chosen when you create pools. Locale is the Region where you want to make an IPAM pool available for allocations. You can only create pools with locales that match the operating Regions of the IPAM. You can only create VPCs from a pool whose locale matches the VPC's Region. You specify a region using the regionName parameter. You **must** set your provider block region as an operating_region.
	OperatingRegions VpcIpamOperatingRegionArrayInput
	// A map of tags to assign to the resource. If configured with a provider `defaultTags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags pulumi.StringMapInput
}

func (VpcIpamArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*vpcIpamArgs)(nil)).Elem()
}

type VpcIpamInput interface {
	pulumi.Input

	ToVpcIpamOutput() VpcIpamOutput
	ToVpcIpamOutputWithContext(ctx context.Context) VpcIpamOutput
}

func (*VpcIpam) ElementType() reflect.Type {
	return reflect.TypeOf((*VpcIpam)(nil))
}

func (i *VpcIpam) ToVpcIpamOutput() VpcIpamOutput {
	return i.ToVpcIpamOutputWithContext(context.Background())
}

func (i *VpcIpam) ToVpcIpamOutputWithContext(ctx context.Context) VpcIpamOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcIpamOutput)
}

func (i *VpcIpam) ToVpcIpamPtrOutput() VpcIpamPtrOutput {
	return i.ToVpcIpamPtrOutputWithContext(context.Background())
}

func (i *VpcIpam) ToVpcIpamPtrOutputWithContext(ctx context.Context) VpcIpamPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcIpamPtrOutput)
}

type VpcIpamPtrInput interface {
	pulumi.Input

	ToVpcIpamPtrOutput() VpcIpamPtrOutput
	ToVpcIpamPtrOutputWithContext(ctx context.Context) VpcIpamPtrOutput
}

type vpcIpamPtrType VpcIpamArgs

func (*vpcIpamPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VpcIpam)(nil))
}

func (i *vpcIpamPtrType) ToVpcIpamPtrOutput() VpcIpamPtrOutput {
	return i.ToVpcIpamPtrOutputWithContext(context.Background())
}

func (i *vpcIpamPtrType) ToVpcIpamPtrOutputWithContext(ctx context.Context) VpcIpamPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcIpamPtrOutput)
}

// VpcIpamArrayInput is an input type that accepts VpcIpamArray and VpcIpamArrayOutput values.
// You can construct a concrete instance of `VpcIpamArrayInput` via:
//
//          VpcIpamArray{ VpcIpamArgs{...} }
type VpcIpamArrayInput interface {
	pulumi.Input

	ToVpcIpamArrayOutput() VpcIpamArrayOutput
	ToVpcIpamArrayOutputWithContext(context.Context) VpcIpamArrayOutput
}

type VpcIpamArray []VpcIpamInput

func (VpcIpamArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VpcIpam)(nil)).Elem()
}

func (i VpcIpamArray) ToVpcIpamArrayOutput() VpcIpamArrayOutput {
	return i.ToVpcIpamArrayOutputWithContext(context.Background())
}

func (i VpcIpamArray) ToVpcIpamArrayOutputWithContext(ctx context.Context) VpcIpamArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcIpamArrayOutput)
}

// VpcIpamMapInput is an input type that accepts VpcIpamMap and VpcIpamMapOutput values.
// You can construct a concrete instance of `VpcIpamMapInput` via:
//
//          VpcIpamMap{ "key": VpcIpamArgs{...} }
type VpcIpamMapInput interface {
	pulumi.Input

	ToVpcIpamMapOutput() VpcIpamMapOutput
	ToVpcIpamMapOutputWithContext(context.Context) VpcIpamMapOutput
}

type VpcIpamMap map[string]VpcIpamInput

func (VpcIpamMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VpcIpam)(nil)).Elem()
}

func (i VpcIpamMap) ToVpcIpamMapOutput() VpcIpamMapOutput {
	return i.ToVpcIpamMapOutputWithContext(context.Background())
}

func (i VpcIpamMap) ToVpcIpamMapOutputWithContext(ctx context.Context) VpcIpamMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcIpamMapOutput)
}

type VpcIpamOutput struct{ *pulumi.OutputState }

func (VpcIpamOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VpcIpam)(nil))
}

func (o VpcIpamOutput) ToVpcIpamOutput() VpcIpamOutput {
	return o
}

func (o VpcIpamOutput) ToVpcIpamOutputWithContext(ctx context.Context) VpcIpamOutput {
	return o
}

func (o VpcIpamOutput) ToVpcIpamPtrOutput() VpcIpamPtrOutput {
	return o.ToVpcIpamPtrOutputWithContext(context.Background())
}

func (o VpcIpamOutput) ToVpcIpamPtrOutputWithContext(ctx context.Context) VpcIpamPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v VpcIpam) *VpcIpam {
		return &v
	}).(VpcIpamPtrOutput)
}

type VpcIpamPtrOutput struct{ *pulumi.OutputState }

func (VpcIpamPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VpcIpam)(nil))
}

func (o VpcIpamPtrOutput) ToVpcIpamPtrOutput() VpcIpamPtrOutput {
	return o
}

func (o VpcIpamPtrOutput) ToVpcIpamPtrOutputWithContext(ctx context.Context) VpcIpamPtrOutput {
	return o
}

func (o VpcIpamPtrOutput) Elem() VpcIpamOutput {
	return o.ApplyT(func(v *VpcIpam) VpcIpam {
		if v != nil {
			return *v
		}
		var ret VpcIpam
		return ret
	}).(VpcIpamOutput)
}

type VpcIpamArrayOutput struct{ *pulumi.OutputState }

func (VpcIpamArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VpcIpam)(nil))
}

func (o VpcIpamArrayOutput) ToVpcIpamArrayOutput() VpcIpamArrayOutput {
	return o
}

func (o VpcIpamArrayOutput) ToVpcIpamArrayOutputWithContext(ctx context.Context) VpcIpamArrayOutput {
	return o
}

func (o VpcIpamArrayOutput) Index(i pulumi.IntInput) VpcIpamOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VpcIpam {
		return vs[0].([]VpcIpam)[vs[1].(int)]
	}).(VpcIpamOutput)
}

type VpcIpamMapOutput struct{ *pulumi.OutputState }

func (VpcIpamMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]VpcIpam)(nil))
}

func (o VpcIpamMapOutput) ToVpcIpamMapOutput() VpcIpamMapOutput {
	return o
}

func (o VpcIpamMapOutput) ToVpcIpamMapOutputWithContext(ctx context.Context) VpcIpamMapOutput {
	return o
}

func (o VpcIpamMapOutput) MapIndex(k pulumi.StringInput) VpcIpamOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) VpcIpam {
		return vs[0].(map[string]VpcIpam)[vs[1].(string)]
	}).(VpcIpamOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*VpcIpamInput)(nil)).Elem(), &VpcIpam{})
	pulumi.RegisterInputType(reflect.TypeOf((*VpcIpamPtrInput)(nil)).Elem(), &VpcIpam{})
	pulumi.RegisterInputType(reflect.TypeOf((*VpcIpamArrayInput)(nil)).Elem(), VpcIpamArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VpcIpamMapInput)(nil)).Elem(), VpcIpamMap{})
	pulumi.RegisterOutputType(VpcIpamOutput{})
	pulumi.RegisterOutputType(VpcIpamPtrOutput{})
	pulumi.RegisterOutputType(VpcIpamArrayOutput{})
	pulumi.RegisterOutputType(VpcIpamMapOutput{})
}
