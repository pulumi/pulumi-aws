// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package securityhub

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws/sdk/v7/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type Insight struct {
	pulumi.CustomResourceState

	Arn              pulumi.StringOutput  `pulumi:"arn"`
	Filters          InsightFiltersOutput `pulumi:"filters"`
	GroupByAttribute pulumi.StringOutput  `pulumi:"groupByAttribute"`
	Name             pulumi.StringOutput  `pulumi:"name"`
	Region           pulumi.StringOutput  `pulumi:"region"`
}

// NewInsight registers a new resource with the given unique name, arguments, and options.
func NewInsight(ctx *pulumi.Context,
	name string, args *InsightArgs, opts ...pulumi.ResourceOption) (*Insight, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Filters == nil {
		return nil, errors.New("invalid value for required argument 'Filters'")
	}
	if args.GroupByAttribute == nil {
		return nil, errors.New("invalid value for required argument 'GroupByAttribute'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Insight
	err := ctx.RegisterResource("aws:securityhub/insight:Insight", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetInsight gets an existing Insight resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetInsight(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *InsightState, opts ...pulumi.ResourceOption) (*Insight, error) {
	var resource Insight
	err := ctx.ReadResource("aws:securityhub/insight:Insight", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Insight resources.
type insightState struct {
	Arn              *string         `pulumi:"arn"`
	Filters          *InsightFilters `pulumi:"filters"`
	GroupByAttribute *string         `pulumi:"groupByAttribute"`
	Name             *string         `pulumi:"name"`
	Region           *string         `pulumi:"region"`
}

type InsightState struct {
	Arn              pulumi.StringPtrInput
	Filters          InsightFiltersPtrInput
	GroupByAttribute pulumi.StringPtrInput
	Name             pulumi.StringPtrInput
	Region           pulumi.StringPtrInput
}

func (InsightState) ElementType() reflect.Type {
	return reflect.TypeOf((*insightState)(nil)).Elem()
}

type insightArgs struct {
	Filters          InsightFilters `pulumi:"filters"`
	GroupByAttribute string         `pulumi:"groupByAttribute"`
	Name             *string        `pulumi:"name"`
	Region           *string        `pulumi:"region"`
}

// The set of arguments for constructing a Insight resource.
type InsightArgs struct {
	Filters          InsightFiltersInput
	GroupByAttribute pulumi.StringInput
	Name             pulumi.StringPtrInput
	Region           pulumi.StringPtrInput
}

func (InsightArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*insightArgs)(nil)).Elem()
}

type InsightInput interface {
	pulumi.Input

	ToInsightOutput() InsightOutput
	ToInsightOutputWithContext(ctx context.Context) InsightOutput
}

func (*Insight) ElementType() reflect.Type {
	return reflect.TypeOf((**Insight)(nil)).Elem()
}

func (i *Insight) ToInsightOutput() InsightOutput {
	return i.ToInsightOutputWithContext(context.Background())
}

func (i *Insight) ToInsightOutputWithContext(ctx context.Context) InsightOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InsightOutput)
}

// InsightArrayInput is an input type that accepts InsightArray and InsightArrayOutput values.
// You can construct a concrete instance of `InsightArrayInput` via:
//
//	InsightArray{ InsightArgs{...} }
type InsightArrayInput interface {
	pulumi.Input

	ToInsightArrayOutput() InsightArrayOutput
	ToInsightArrayOutputWithContext(context.Context) InsightArrayOutput
}

type InsightArray []InsightInput

func (InsightArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Insight)(nil)).Elem()
}

func (i InsightArray) ToInsightArrayOutput() InsightArrayOutput {
	return i.ToInsightArrayOutputWithContext(context.Background())
}

func (i InsightArray) ToInsightArrayOutputWithContext(ctx context.Context) InsightArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InsightArrayOutput)
}

// InsightMapInput is an input type that accepts InsightMap and InsightMapOutput values.
// You can construct a concrete instance of `InsightMapInput` via:
//
//	InsightMap{ "key": InsightArgs{...} }
type InsightMapInput interface {
	pulumi.Input

	ToInsightMapOutput() InsightMapOutput
	ToInsightMapOutputWithContext(context.Context) InsightMapOutput
}

type InsightMap map[string]InsightInput

func (InsightMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Insight)(nil)).Elem()
}

func (i InsightMap) ToInsightMapOutput() InsightMapOutput {
	return i.ToInsightMapOutputWithContext(context.Background())
}

func (i InsightMap) ToInsightMapOutputWithContext(ctx context.Context) InsightMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InsightMapOutput)
}

type InsightOutput struct{ *pulumi.OutputState }

func (InsightOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Insight)(nil)).Elem()
}

func (o InsightOutput) ToInsightOutput() InsightOutput {
	return o
}

func (o InsightOutput) ToInsightOutputWithContext(ctx context.Context) InsightOutput {
	return o
}

func (o InsightOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v *Insight) pulumi.StringOutput { return v.Arn }).(pulumi.StringOutput)
}

func (o InsightOutput) Filters() InsightFiltersOutput {
	return o.ApplyT(func(v *Insight) InsightFiltersOutput { return v.Filters }).(InsightFiltersOutput)
}

func (o InsightOutput) GroupByAttribute() pulumi.StringOutput {
	return o.ApplyT(func(v *Insight) pulumi.StringOutput { return v.GroupByAttribute }).(pulumi.StringOutput)
}

func (o InsightOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Insight) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o InsightOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *Insight) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

type InsightArrayOutput struct{ *pulumi.OutputState }

func (InsightArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Insight)(nil)).Elem()
}

func (o InsightArrayOutput) ToInsightArrayOutput() InsightArrayOutput {
	return o
}

func (o InsightArrayOutput) ToInsightArrayOutputWithContext(ctx context.Context) InsightArrayOutput {
	return o
}

func (o InsightArrayOutput) Index(i pulumi.IntInput) InsightOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Insight {
		return vs[0].([]*Insight)[vs[1].(int)]
	}).(InsightOutput)
}

type InsightMapOutput struct{ *pulumi.OutputState }

func (InsightMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Insight)(nil)).Elem()
}

func (o InsightMapOutput) ToInsightMapOutput() InsightMapOutput {
	return o
}

func (o InsightMapOutput) ToInsightMapOutputWithContext(ctx context.Context) InsightMapOutput {
	return o
}

func (o InsightMapOutput) MapIndex(k pulumi.StringInput) InsightOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Insight {
		return vs[0].(map[string]*Insight)[vs[1].(string)]
	}).(InsightOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*InsightInput)(nil)).Elem(), &Insight{})
	pulumi.RegisterInputType(reflect.TypeOf((*InsightArrayInput)(nil)).Elem(), InsightArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*InsightMapInput)(nil)).Elem(), InsightMap{})
	pulumi.RegisterOutputType(InsightOutput{})
	pulumi.RegisterOutputType(InsightArrayOutput{})
	pulumi.RegisterOutputType(InsightMapOutput{})
}
