// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Aws.Alb
{
    /// <summary>
    /// Provides a Load Balancer Listener Rule resource.
    /// 
    /// &gt; **Note:** `aws.alb.ListenerRule` is known as `aws.lb.ListenerRule`. The functionality is identical.
    /// 
    /// &gt; This content is derived from https://github.com/terraform-providers/terraform-provider-aws/blob/master/website/docs/r/lb_listener_rule.html.markdown.
    /// </summary>
    public partial class ListenerRule : Pulumi.CustomResource
    {
        /// <summary>
        /// An Action block. Action blocks are documented below.
        /// </summary>
        [Output("actions")]
        public Output<ImmutableArray<Outputs.ListenerRuleActions>> Actions { get; private set; } = null!;

        /// <summary>
        /// The ARN of the rule (matches `id`)
        /// </summary>
        [Output("arn")]
        public Output<string> Arn { get; private set; } = null!;

        /// <summary>
        /// A Condition block. Multiple condition blocks of different types can be set and all must be satisfied for the rule to match. Condition blocks are documented below.
        /// </summary>
        [Output("conditions")]
        public Output<ImmutableArray<Outputs.ListenerRuleConditions>> Conditions { get; private set; } = null!;

        /// <summary>
        /// The ARN of the listener to which to attach the rule.
        /// </summary>
        [Output("listenerArn")]
        public Output<string> ListenerArn { get; private set; } = null!;

        /// <summary>
        /// The priority for the rule between `1` and `50000`. Leaving it unset will automatically set the rule with next available priority after currently existing highest rule. A listener can't have multiple rules with the same priority.
        /// </summary>
        [Output("priority")]
        public Output<int> Priority { get; private set; } = null!;


        /// <summary>
        /// Create a ListenerRule resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public ListenerRule(string name, ListenerRuleArgs args, CustomResourceOptions? options = null)
            : base("aws:alb/listenerRule:ListenerRule", name, args ?? ResourceArgs.Empty, MakeResourceOptions(options, ""))
        {
        }

        private ListenerRule(string name, Input<string> id, ListenerRuleState? state = null, CustomResourceOptions? options = null)
            : base("aws:alb/listenerRule:ListenerRule", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,                Aliases = { new Alias { Type = "aws:applicationloadbalancing/listenerRule:ListenerRule" } },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing ListenerRule resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static ListenerRule Get(string name, Input<string> id, ListenerRuleState? state = null, CustomResourceOptions? options = null)
        {
            return new ListenerRule(name, id, state, options);
        }
    }

    public sealed class ListenerRuleArgs : Pulumi.ResourceArgs
    {
        [Input("actions", required: true)]
        private InputList<Inputs.ListenerRuleActionsArgs>? _actions;

        /// <summary>
        /// An Action block. Action blocks are documented below.
        /// </summary>
        public InputList<Inputs.ListenerRuleActionsArgs> Actions
        {
            get => _actions ?? (_actions = new InputList<Inputs.ListenerRuleActionsArgs>());
            set => _actions = value;
        }

        [Input("conditions", required: true)]
        private InputList<Inputs.ListenerRuleConditionsArgs>? _conditions;

        /// <summary>
        /// A Condition block. Multiple condition blocks of different types can be set and all must be satisfied for the rule to match. Condition blocks are documented below.
        /// </summary>
        public InputList<Inputs.ListenerRuleConditionsArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Inputs.ListenerRuleConditionsArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// The ARN of the listener to which to attach the rule.
        /// </summary>
        [Input("listenerArn", required: true)]
        public Input<string> ListenerArn { get; set; } = null!;

        /// <summary>
        /// The priority for the rule between `1` and `50000`. Leaving it unset will automatically set the rule with next available priority after currently existing highest rule. A listener can't have multiple rules with the same priority.
        /// </summary>
        [Input("priority")]
        public Input<int>? Priority { get; set; }

        public ListenerRuleArgs()
        {
        }
    }

    public sealed class ListenerRuleState : Pulumi.ResourceArgs
    {
        [Input("actions")]
        private InputList<Inputs.ListenerRuleActionsGetArgs>? _actions;

        /// <summary>
        /// An Action block. Action blocks are documented below.
        /// </summary>
        public InputList<Inputs.ListenerRuleActionsGetArgs> Actions
        {
            get => _actions ?? (_actions = new InputList<Inputs.ListenerRuleActionsGetArgs>());
            set => _actions = value;
        }

        /// <summary>
        /// The ARN of the rule (matches `id`)
        /// </summary>
        [Input("arn")]
        public Input<string>? Arn { get; set; }

        [Input("conditions")]
        private InputList<Inputs.ListenerRuleConditionsGetArgs>? _conditions;

        /// <summary>
        /// A Condition block. Multiple condition blocks of different types can be set and all must be satisfied for the rule to match. Condition blocks are documented below.
        /// </summary>
        public InputList<Inputs.ListenerRuleConditionsGetArgs> Conditions
        {
            get => _conditions ?? (_conditions = new InputList<Inputs.ListenerRuleConditionsGetArgs>());
            set => _conditions = value;
        }

        /// <summary>
        /// The ARN of the listener to which to attach the rule.
        /// </summary>
        [Input("listenerArn")]
        public Input<string>? ListenerArn { get; set; }

        /// <summary>
        /// The priority for the rule between `1` and `50000`. Leaving it unset will automatically set the rule with next available priority after currently existing highest rule. A listener can't have multiple rules with the same priority.
        /// </summary>
        [Input("priority")]
        public Input<int>? Priority { get; set; }

        public ListenerRuleState()
        {
        }
    }

    namespace Inputs
    {

    public sealed class ListenerRuleActionsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Information for creating an authenticate action using Cognito. Required if `type` is `authenticate-cognito`.
        /// </summary>
        [Input("authenticateCognito")]
        public Input<ListenerRuleActionsAuthenticateCognitoArgs>? AuthenticateCognito { get; set; }

        /// <summary>
        /// Information for creating an authenticate action using OIDC. Required if `type` is `authenticate-oidc`.
        /// </summary>
        [Input("authenticateOidc")]
        public Input<ListenerRuleActionsAuthenticateOidcArgs>? AuthenticateOidc { get; set; }

        /// <summary>
        /// Information for creating an action that returns a custom HTTP response. Required if `type` is `fixed-response`.
        /// </summary>
        [Input("fixedResponse")]
        public Input<ListenerRuleActionsFixedResponseArgs>? FixedResponse { get; set; }

        [Input("order")]
        public Input<int>? Order { get; set; }

        /// <summary>
        /// Information for creating a redirect action. Required if `type` is `redirect`.
        /// </summary>
        [Input("redirect")]
        public Input<ListenerRuleActionsRedirectArgs>? Redirect { get; set; }

        /// <summary>
        /// The ARN of the Target Group to which to route traffic. Required if `type` is `forward`.
        /// </summary>
        [Input("targetGroupArn")]
        public Input<string>? TargetGroupArn { get; set; }

        /// <summary>
        /// The type of routing action. Valid values are `forward`, `redirect`, `fixed-response`, `authenticate-cognito` and `authenticate-oidc`.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        public ListenerRuleActionsArgs()
        {
        }
    }

    public sealed class ListenerRuleActionsAuthenticateCognitoArgs : Pulumi.ResourceArgs
    {
        [Input("authenticationRequestExtraParams")]
        private InputMap<object>? _authenticationRequestExtraParams;

        /// <summary>
        /// The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
        /// </summary>
        public InputMap<object> AuthenticationRequestExtraParams
        {
            get => _authenticationRequestExtraParams ?? (_authenticationRequestExtraParams = new InputMap<object>());
            set => _authenticationRequestExtraParams = value;
        }

        /// <summary>
        /// The behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`
        /// </summary>
        [Input("onUnauthenticatedRequest")]
        public Input<string>? OnUnauthenticatedRequest { get; set; }

        /// <summary>
        /// The set of user claims to be requested from the IdP.
        /// </summary>
        [Input("scope")]
        public Input<string>? Scope { get; set; }

        /// <summary>
        /// The name of the cookie used to maintain session information.
        /// </summary>
        [Input("sessionCookieName")]
        public Input<string>? SessionCookieName { get; set; }

        /// <summary>
        /// The maximum duration of the authentication session, in seconds.
        /// </summary>
        [Input("sessionTimeout")]
        public Input<int>? SessionTimeout { get; set; }

        /// <summary>
        /// The ARN of the Cognito user pool.
        /// </summary>
        [Input("userPoolArn", required: true)]
        public Input<string> UserPoolArn { get; set; } = null!;

        /// <summary>
        /// The ID of the Cognito user pool client.
        /// </summary>
        [Input("userPoolClientId", required: true)]
        public Input<string> UserPoolClientId { get; set; } = null!;

        /// <summary>
        /// The domain prefix or fully-qualified domain name of the Cognito user pool.
        /// </summary>
        [Input("userPoolDomain", required: true)]
        public Input<string> UserPoolDomain { get; set; } = null!;

        public ListenerRuleActionsAuthenticateCognitoArgs()
        {
        }
    }

    public sealed class ListenerRuleActionsAuthenticateCognitoGetArgs : Pulumi.ResourceArgs
    {
        [Input("authenticationRequestExtraParams")]
        private InputMap<object>? _authenticationRequestExtraParams;

        /// <summary>
        /// The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
        /// </summary>
        public InputMap<object> AuthenticationRequestExtraParams
        {
            get => _authenticationRequestExtraParams ?? (_authenticationRequestExtraParams = new InputMap<object>());
            set => _authenticationRequestExtraParams = value;
        }

        /// <summary>
        /// The behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`
        /// </summary>
        [Input("onUnauthenticatedRequest")]
        public Input<string>? OnUnauthenticatedRequest { get; set; }

        /// <summary>
        /// The set of user claims to be requested from the IdP.
        /// </summary>
        [Input("scope")]
        public Input<string>? Scope { get; set; }

        /// <summary>
        /// The name of the cookie used to maintain session information.
        /// </summary>
        [Input("sessionCookieName")]
        public Input<string>? SessionCookieName { get; set; }

        /// <summary>
        /// The maximum duration of the authentication session, in seconds.
        /// </summary>
        [Input("sessionTimeout")]
        public Input<int>? SessionTimeout { get; set; }

        /// <summary>
        /// The ARN of the Cognito user pool.
        /// </summary>
        [Input("userPoolArn", required: true)]
        public Input<string> UserPoolArn { get; set; } = null!;

        /// <summary>
        /// The ID of the Cognito user pool client.
        /// </summary>
        [Input("userPoolClientId", required: true)]
        public Input<string> UserPoolClientId { get; set; } = null!;

        /// <summary>
        /// The domain prefix or fully-qualified domain name of the Cognito user pool.
        /// </summary>
        [Input("userPoolDomain", required: true)]
        public Input<string> UserPoolDomain { get; set; } = null!;

        public ListenerRuleActionsAuthenticateCognitoGetArgs()
        {
        }
    }

    public sealed class ListenerRuleActionsAuthenticateOidcArgs : Pulumi.ResourceArgs
    {
        [Input("authenticationRequestExtraParams")]
        private InputMap<object>? _authenticationRequestExtraParams;

        /// <summary>
        /// The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
        /// </summary>
        public InputMap<object> AuthenticationRequestExtraParams
        {
            get => _authenticationRequestExtraParams ?? (_authenticationRequestExtraParams = new InputMap<object>());
            set => _authenticationRequestExtraParams = value;
        }

        /// <summary>
        /// The authorization endpoint of the IdP.
        /// </summary>
        [Input("authorizationEndpoint", required: true)]
        public Input<string> AuthorizationEndpoint { get; set; } = null!;

        /// <summary>
        /// The OAuth 2.0 client identifier.
        /// </summary>
        [Input("clientId", required: true)]
        public Input<string> ClientId { get; set; } = null!;

        /// <summary>
        /// The OAuth 2.0 client secret.
        /// </summary>
        [Input("clientSecret", required: true)]
        public Input<string> ClientSecret { get; set; } = null!;

        /// <summary>
        /// The OIDC issuer identifier of the IdP.
        /// </summary>
        [Input("issuer", required: true)]
        public Input<string> Issuer { get; set; } = null!;

        /// <summary>
        /// The behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`
        /// </summary>
        [Input("onUnauthenticatedRequest")]
        public Input<string>? OnUnauthenticatedRequest { get; set; }

        /// <summary>
        /// The set of user claims to be requested from the IdP.
        /// </summary>
        [Input("scope")]
        public Input<string>? Scope { get; set; }

        /// <summary>
        /// The name of the cookie used to maintain session information.
        /// </summary>
        [Input("sessionCookieName")]
        public Input<string>? SessionCookieName { get; set; }

        /// <summary>
        /// The maximum duration of the authentication session, in seconds.
        /// </summary>
        [Input("sessionTimeout")]
        public Input<int>? SessionTimeout { get; set; }

        /// <summary>
        /// The token endpoint of the IdP.
        /// </summary>
        [Input("tokenEndpoint", required: true)]
        public Input<string> TokenEndpoint { get; set; } = null!;

        /// <summary>
        /// The user info endpoint of the IdP.
        /// </summary>
        [Input("userInfoEndpoint", required: true)]
        public Input<string> UserInfoEndpoint { get; set; } = null!;

        public ListenerRuleActionsAuthenticateOidcArgs()
        {
        }
    }

    public sealed class ListenerRuleActionsAuthenticateOidcGetArgs : Pulumi.ResourceArgs
    {
        [Input("authenticationRequestExtraParams")]
        private InputMap<object>? _authenticationRequestExtraParams;

        /// <summary>
        /// The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
        /// </summary>
        public InputMap<object> AuthenticationRequestExtraParams
        {
            get => _authenticationRequestExtraParams ?? (_authenticationRequestExtraParams = new InputMap<object>());
            set => _authenticationRequestExtraParams = value;
        }

        /// <summary>
        /// The authorization endpoint of the IdP.
        /// </summary>
        [Input("authorizationEndpoint", required: true)]
        public Input<string> AuthorizationEndpoint { get; set; } = null!;

        /// <summary>
        /// The OAuth 2.0 client identifier.
        /// </summary>
        [Input("clientId", required: true)]
        public Input<string> ClientId { get; set; } = null!;

        /// <summary>
        /// The OAuth 2.0 client secret.
        /// </summary>
        [Input("clientSecret", required: true)]
        public Input<string> ClientSecret { get; set; } = null!;

        /// <summary>
        /// The OIDC issuer identifier of the IdP.
        /// </summary>
        [Input("issuer", required: true)]
        public Input<string> Issuer { get; set; } = null!;

        /// <summary>
        /// The behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`
        /// </summary>
        [Input("onUnauthenticatedRequest")]
        public Input<string>? OnUnauthenticatedRequest { get; set; }

        /// <summary>
        /// The set of user claims to be requested from the IdP.
        /// </summary>
        [Input("scope")]
        public Input<string>? Scope { get; set; }

        /// <summary>
        /// The name of the cookie used to maintain session information.
        /// </summary>
        [Input("sessionCookieName")]
        public Input<string>? SessionCookieName { get; set; }

        /// <summary>
        /// The maximum duration of the authentication session, in seconds.
        /// </summary>
        [Input("sessionTimeout")]
        public Input<int>? SessionTimeout { get; set; }

        /// <summary>
        /// The token endpoint of the IdP.
        /// </summary>
        [Input("tokenEndpoint", required: true)]
        public Input<string> TokenEndpoint { get; set; } = null!;

        /// <summary>
        /// The user info endpoint of the IdP.
        /// </summary>
        [Input("userInfoEndpoint", required: true)]
        public Input<string> UserInfoEndpoint { get; set; } = null!;

        public ListenerRuleActionsAuthenticateOidcGetArgs()
        {
        }
    }

    public sealed class ListenerRuleActionsFixedResponseArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The content type. Valid values are `text/plain`, `text/css`, `text/html`, `application/javascript` and `application/json`.
        /// </summary>
        [Input("contentType", required: true)]
        public Input<string> ContentType { get; set; } = null!;

        /// <summary>
        /// The message body.
        /// </summary>
        [Input("messageBody")]
        public Input<string>? MessageBody { get; set; }

        /// <summary>
        /// The HTTP response code. Valid values are `2XX`, `4XX`, or `5XX`.
        /// </summary>
        [Input("statusCode")]
        public Input<string>? StatusCode { get; set; }

        public ListenerRuleActionsFixedResponseArgs()
        {
        }
    }

    public sealed class ListenerRuleActionsFixedResponseGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The content type. Valid values are `text/plain`, `text/css`, `text/html`, `application/javascript` and `application/json`.
        /// </summary>
        [Input("contentType", required: true)]
        public Input<string> ContentType { get; set; } = null!;

        /// <summary>
        /// The message body.
        /// </summary>
        [Input("messageBody")]
        public Input<string>? MessageBody { get; set; }

        /// <summary>
        /// The HTTP response code. Valid values are `2XX`, `4XX`, or `5XX`.
        /// </summary>
        [Input("statusCode")]
        public Input<string>? StatusCode { get; set; }

        public ListenerRuleActionsFixedResponseGetArgs()
        {
        }
    }

    public sealed class ListenerRuleActionsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Information for creating an authenticate action using Cognito. Required if `type` is `authenticate-cognito`.
        /// </summary>
        [Input("authenticateCognito")]
        public Input<ListenerRuleActionsAuthenticateCognitoGetArgs>? AuthenticateCognito { get; set; }

        /// <summary>
        /// Information for creating an authenticate action using OIDC. Required if `type` is `authenticate-oidc`.
        /// </summary>
        [Input("authenticateOidc")]
        public Input<ListenerRuleActionsAuthenticateOidcGetArgs>? AuthenticateOidc { get; set; }

        /// <summary>
        /// Information for creating an action that returns a custom HTTP response. Required if `type` is `fixed-response`.
        /// </summary>
        [Input("fixedResponse")]
        public Input<ListenerRuleActionsFixedResponseGetArgs>? FixedResponse { get; set; }

        [Input("order")]
        public Input<int>? Order { get; set; }

        /// <summary>
        /// Information for creating a redirect action. Required if `type` is `redirect`.
        /// </summary>
        [Input("redirect")]
        public Input<ListenerRuleActionsRedirectGetArgs>? Redirect { get; set; }

        /// <summary>
        /// The ARN of the Target Group to which to route traffic. Required if `type` is `forward`.
        /// </summary>
        [Input("targetGroupArn")]
        public Input<string>? TargetGroupArn { get; set; }

        /// <summary>
        /// The type of routing action. Valid values are `forward`, `redirect`, `fixed-response`, `authenticate-cognito` and `authenticate-oidc`.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        public ListenerRuleActionsGetArgs()
        {
        }
    }

    public sealed class ListenerRuleActionsRedirectArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The hostname. This component is not percent-encoded. The hostname can contain `#{host}`. Defaults to `#{host}`.
        /// </summary>
        [Input("host")]
        public Input<string>? Host { get; set; }

        /// <summary>
        /// The absolute path, starting with the leading "/". This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}. Defaults to `/#{path}`.
        /// </summary>
        [Input("path")]
        public Input<string>? Path { get; set; }

        /// <summary>
        /// The port. Specify a value from `1` to `65535` or `#{port}`. Defaults to `#{port}`.
        /// </summary>
        [Input("port")]
        public Input<string>? Port { get; set; }

        /// <summary>
        /// The protocol. Valid values are `HTTP`, `HTTPS`, or `#{protocol}`. Defaults to `#{protocol}`.
        /// </summary>
        [Input("protocol")]
        public Input<string>? Protocol { get; set; }

        /// <summary>
        /// The query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading "?". Defaults to `#{query}`.
        /// </summary>
        [Input("query")]
        public Input<string>? Query { get; set; }

        /// <summary>
        /// The HTTP redirect code. The redirect is either permanent (`HTTP_301`) or temporary (`HTTP_302`).
        /// </summary>
        [Input("statusCode", required: true)]
        public Input<string> StatusCode { get; set; } = null!;

        public ListenerRuleActionsRedirectArgs()
        {
        }
    }

    public sealed class ListenerRuleActionsRedirectGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The hostname. This component is not percent-encoded. The hostname can contain `#{host}`. Defaults to `#{host}`.
        /// </summary>
        [Input("host")]
        public Input<string>? Host { get; set; }

        /// <summary>
        /// The absolute path, starting with the leading "/". This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}. Defaults to `/#{path}`.
        /// </summary>
        [Input("path")]
        public Input<string>? Path { get; set; }

        /// <summary>
        /// The port. Specify a value from `1` to `65535` or `#{port}`. Defaults to `#{port}`.
        /// </summary>
        [Input("port")]
        public Input<string>? Port { get; set; }

        /// <summary>
        /// The protocol. Valid values are `HTTP`, `HTTPS`, or `#{protocol}`. Defaults to `#{protocol}`.
        /// </summary>
        [Input("protocol")]
        public Input<string>? Protocol { get; set; }

        /// <summary>
        /// The query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading "?". Defaults to `#{query}`.
        /// </summary>
        [Input("query")]
        public Input<string>? Query { get; set; }

        /// <summary>
        /// The HTTP redirect code. The redirect is either permanent (`HTTP_301`) or temporary (`HTTP_302`).
        /// </summary>
        [Input("statusCode", required: true)]
        public Input<string> StatusCode { get; set; } = null!;

        public ListenerRuleActionsRedirectGetArgs()
        {
        }
    }

    public sealed class ListenerRuleConditionsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The type of condition. Valid values are `host-header` or `path-pattern`. Must also set `values`.
        /// </summary>
        [Input("field")]
        public Input<string>? Field { get; set; }

        /// <summary>
        /// Contains a single `values` item which is a list of host header patterns to match. The maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied.
        /// </summary>
        [Input("hostHeader")]
        public Input<ListenerRuleConditionsHostHeaderArgs>? HostHeader { get; set; }

        /// <summary>
        /// HTTP headers to match. HTTP Header block fields documented below.
        /// </summary>
        [Input("httpHeader")]
        public Input<ListenerRuleConditionsHttpHeaderArgs>? HttpHeader { get; set; }

        /// <summary>
        /// Contains a single `values` item which is a list of HTTP request methods or verbs to match. Maximum size is 40 characters. Only allowed characters are A-Z, hyphen (-) and underscore (\_). Comparison is case sensitive. Wildcards are not supported. Only one needs to match for the condition to be satisfied. AWS recommends that GET and HEAD requests are routed in the same way because the response to a HEAD request may be cached.
        /// </summary>
        [Input("httpRequestMethod")]
        public Input<ListenerRuleConditionsHttpRequestMethodArgs>? HttpRequestMethod { get; set; }

        /// <summary>
        /// Contains a single `values` item which is a list of path patterns to match against the request URL. Maximum size of each pattern is 128 characters. Comparison is case sensitive. Wildcard charaters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied. Path pattern is compared only to the path of the URL, not to its query string. To compare against the query string, use a `query-string` condition.
        /// </summary>
        [Input("pathPattern")]
        public Input<ListenerRuleConditionsPathPatternArgs>? PathPattern { get; set; }

        [Input("queryStrings")]
        private InputList<ListenerRuleConditionsQueryStringsArgs>? _queryStrings;

        /// <summary>
        /// Query strings to match. Query String block fields documented below.
        /// </summary>
        public InputList<ListenerRuleConditionsQueryStringsArgs> QueryStrings
        {
            get => _queryStrings ?? (_queryStrings = new InputList<ListenerRuleConditionsQueryStringsArgs>());
            set => _queryStrings = value;
        }

        /// <summary>
        /// Contains a single `values` item which is a list of source IP CIDR notations to match. You can use both IPv4 and IPv6 addresses. Wildcards are not supported. Condition is satisfied if the source IP address of the request matches one of the CIDR blocks. Condition is not satisfied by the addresses in the `X-Forwarded-For` header, use `http-header` condition instead.
        /// </summary>
        [Input("sourceIp")]
        public Input<ListenerRuleConditionsSourceIpArgs>? SourceIp { get; set; }

        /// <summary>
        /// List of exactly one pattern to match. Required when `field` is set.
        /// </summary>
        [Input("values")]
        public Input<string>? Values { get; set; }

        public ListenerRuleConditionsArgs()
        {
        }
    }

    public sealed class ListenerRuleConditionsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The type of condition. Valid values are `host-header` or `path-pattern`. Must also set `values`.
        /// </summary>
        [Input("field")]
        public Input<string>? Field { get; set; }

        /// <summary>
        /// Contains a single `values` item which is a list of host header patterns to match. The maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied.
        /// </summary>
        [Input("hostHeader")]
        public Input<ListenerRuleConditionsHostHeaderGetArgs>? HostHeader { get; set; }

        /// <summary>
        /// HTTP headers to match. HTTP Header block fields documented below.
        /// </summary>
        [Input("httpHeader")]
        public Input<ListenerRuleConditionsHttpHeaderGetArgs>? HttpHeader { get; set; }

        /// <summary>
        /// Contains a single `values` item which is a list of HTTP request methods or verbs to match. Maximum size is 40 characters. Only allowed characters are A-Z, hyphen (-) and underscore (\_). Comparison is case sensitive. Wildcards are not supported. Only one needs to match for the condition to be satisfied. AWS recommends that GET and HEAD requests are routed in the same way because the response to a HEAD request may be cached.
        /// </summary>
        [Input("httpRequestMethod")]
        public Input<ListenerRuleConditionsHttpRequestMethodGetArgs>? HttpRequestMethod { get; set; }

        /// <summary>
        /// Contains a single `values` item which is a list of path patterns to match against the request URL. Maximum size of each pattern is 128 characters. Comparison is case sensitive. Wildcard charaters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied. Path pattern is compared only to the path of the URL, not to its query string. To compare against the query string, use a `query-string` condition.
        /// </summary>
        [Input("pathPattern")]
        public Input<ListenerRuleConditionsPathPatternGetArgs>? PathPattern { get; set; }

        [Input("queryStrings")]
        private InputList<ListenerRuleConditionsQueryStringsGetArgs>? _queryStrings;

        /// <summary>
        /// Query strings to match. Query String block fields documented below.
        /// </summary>
        public InputList<ListenerRuleConditionsQueryStringsGetArgs> QueryStrings
        {
            get => _queryStrings ?? (_queryStrings = new InputList<ListenerRuleConditionsQueryStringsGetArgs>());
            set => _queryStrings = value;
        }

        /// <summary>
        /// Contains a single `values` item which is a list of source IP CIDR notations to match. You can use both IPv4 and IPv6 addresses. Wildcards are not supported. Condition is satisfied if the source IP address of the request matches one of the CIDR blocks. Condition is not satisfied by the addresses in the `X-Forwarded-For` header, use `http-header` condition instead.
        /// </summary>
        [Input("sourceIp")]
        public Input<ListenerRuleConditionsSourceIpGetArgs>? SourceIp { get; set; }

        /// <summary>
        /// List of exactly one pattern to match. Required when `field` is set.
        /// </summary>
        [Input("values")]
        public Input<string>? Values { get; set; }

        public ListenerRuleConditionsGetArgs()
        {
        }
    }

    public sealed class ListenerRuleConditionsHostHeaderArgs : Pulumi.ResourceArgs
    {
        [Input("values")]
        private InputList<string>? _values;

        /// <summary>
        /// List of exactly one pattern to match. Required when `field` is set.
        /// </summary>
        public InputList<string> Values
        {
            get => _values ?? (_values = new InputList<string>());
            set => _values = value;
        }

        public ListenerRuleConditionsHostHeaderArgs()
        {
        }
    }

    public sealed class ListenerRuleConditionsHostHeaderGetArgs : Pulumi.ResourceArgs
    {
        [Input("values")]
        private InputList<string>? _values;

        /// <summary>
        /// List of exactly one pattern to match. Required when `field` is set.
        /// </summary>
        public InputList<string> Values
        {
            get => _values ?? (_values = new InputList<string>());
            set => _values = value;
        }

        public ListenerRuleConditionsHostHeaderGetArgs()
        {
        }
    }

    public sealed class ListenerRuleConditionsHttpHeaderArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name of HTTP header to search. The maximum size is 40 characters. Comparison is case insensitive. Only RFC7240 characters are supported. Wildcards are not supported. You cannot use HTTP header condition to specify the host header, use a `host-header` condition instead.
        /// </summary>
        [Input("httpHeaderName", required: true)]
        public Input<string> HttpHeaderName { get; set; } = null!;

        [Input("values", required: true)]
        private InputList<string>? _values;

        /// <summary>
        /// List of header value patterns to match. Maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). If the same header appears multiple times in the request they will be searched in order until a match is found. Only one pattern needs to match for the condition to be satisfied. To require that all of the strings are a match, create one condition block per string.
        /// </summary>
        public InputList<string> Values
        {
            get => _values ?? (_values = new InputList<string>());
            set => _values = value;
        }

        public ListenerRuleConditionsHttpHeaderArgs()
        {
        }
    }

    public sealed class ListenerRuleConditionsHttpHeaderGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name of HTTP header to search. The maximum size is 40 characters. Comparison is case insensitive. Only RFC7240 characters are supported. Wildcards are not supported. You cannot use HTTP header condition to specify the host header, use a `host-header` condition instead.
        /// </summary>
        [Input("httpHeaderName", required: true)]
        public Input<string> HttpHeaderName { get; set; } = null!;

        [Input("values", required: true)]
        private InputList<string>? _values;

        /// <summary>
        /// List of header value patterns to match. Maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). If the same header appears multiple times in the request they will be searched in order until a match is found. Only one pattern needs to match for the condition to be satisfied. To require that all of the strings are a match, create one condition block per string.
        /// </summary>
        public InputList<string> Values
        {
            get => _values ?? (_values = new InputList<string>());
            set => _values = value;
        }

        public ListenerRuleConditionsHttpHeaderGetArgs()
        {
        }
    }

    public sealed class ListenerRuleConditionsHttpRequestMethodArgs : Pulumi.ResourceArgs
    {
        [Input("values", required: true)]
        private InputList<string>? _values;

        /// <summary>
        /// List of exactly one pattern to match. Required when `field` is set.
        /// </summary>
        public InputList<string> Values
        {
            get => _values ?? (_values = new InputList<string>());
            set => _values = value;
        }

        public ListenerRuleConditionsHttpRequestMethodArgs()
        {
        }
    }

    public sealed class ListenerRuleConditionsHttpRequestMethodGetArgs : Pulumi.ResourceArgs
    {
        [Input("values", required: true)]
        private InputList<string>? _values;

        /// <summary>
        /// List of exactly one pattern to match. Required when `field` is set.
        /// </summary>
        public InputList<string> Values
        {
            get => _values ?? (_values = new InputList<string>());
            set => _values = value;
        }

        public ListenerRuleConditionsHttpRequestMethodGetArgs()
        {
        }
    }

    public sealed class ListenerRuleConditionsPathPatternArgs : Pulumi.ResourceArgs
    {
        [Input("values")]
        private InputList<string>? _values;

        /// <summary>
        /// List of exactly one pattern to match. Required when `field` is set.
        /// </summary>
        public InputList<string> Values
        {
            get => _values ?? (_values = new InputList<string>());
            set => _values = value;
        }

        public ListenerRuleConditionsPathPatternArgs()
        {
        }
    }

    public sealed class ListenerRuleConditionsPathPatternGetArgs : Pulumi.ResourceArgs
    {
        [Input("values")]
        private InputList<string>? _values;

        /// <summary>
        /// List of exactly one pattern to match. Required when `field` is set.
        /// </summary>
        public InputList<string> Values
        {
            get => _values ?? (_values = new InputList<string>());
            set => _values = value;
        }

        public ListenerRuleConditionsPathPatternGetArgs()
        {
        }
    }

    public sealed class ListenerRuleConditionsQueryStringsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Query string key pattern to match.
        /// </summary>
        [Input("key")]
        public Input<string>? Key { get; set; }

        /// <summary>
        /// Query string value pattern to match.
        /// </summary>
        [Input("value", required: true)]
        public Input<string> Value { get; set; } = null!;

        public ListenerRuleConditionsQueryStringsArgs()
        {
        }
    }

    public sealed class ListenerRuleConditionsQueryStringsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Query string key pattern to match.
        /// </summary>
        [Input("key")]
        public Input<string>? Key { get; set; }

        /// <summary>
        /// Query string value pattern to match.
        /// </summary>
        [Input("value", required: true)]
        public Input<string> Value { get; set; } = null!;

        public ListenerRuleConditionsQueryStringsGetArgs()
        {
        }
    }

    public sealed class ListenerRuleConditionsSourceIpArgs : Pulumi.ResourceArgs
    {
        [Input("values", required: true)]
        private InputList<string>? _values;

        /// <summary>
        /// List of exactly one pattern to match. Required when `field` is set.
        /// </summary>
        public InputList<string> Values
        {
            get => _values ?? (_values = new InputList<string>());
            set => _values = value;
        }

        public ListenerRuleConditionsSourceIpArgs()
        {
        }
    }

    public sealed class ListenerRuleConditionsSourceIpGetArgs : Pulumi.ResourceArgs
    {
        [Input("values", required: true)]
        private InputList<string>? _values;

        /// <summary>
        /// List of exactly one pattern to match. Required when `field` is set.
        /// </summary>
        public InputList<string> Values
        {
            get => _values ?? (_values = new InputList<string>());
            set => _values = value;
        }

        public ListenerRuleConditionsSourceIpGetArgs()
        {
        }
    }
    }

    namespace Outputs
    {

    [OutputType]
    public sealed class ListenerRuleActions
    {
        /// <summary>
        /// Information for creating an authenticate action using Cognito. Required if `type` is `authenticate-cognito`.
        /// </summary>
        public readonly ListenerRuleActionsAuthenticateCognito? AuthenticateCognito;
        /// <summary>
        /// Information for creating an authenticate action using OIDC. Required if `type` is `authenticate-oidc`.
        /// </summary>
        public readonly ListenerRuleActionsAuthenticateOidc? AuthenticateOidc;
        /// <summary>
        /// Information for creating an action that returns a custom HTTP response. Required if `type` is `fixed-response`.
        /// </summary>
        public readonly ListenerRuleActionsFixedResponse? FixedResponse;
        public readonly int Order;
        /// <summary>
        /// Information for creating a redirect action. Required if `type` is `redirect`.
        /// </summary>
        public readonly ListenerRuleActionsRedirect? Redirect;
        /// <summary>
        /// The ARN of the Target Group to which to route traffic. Required if `type` is `forward`.
        /// </summary>
        public readonly string? TargetGroupArn;
        /// <summary>
        /// The type of routing action. Valid values are `forward`, `redirect`, `fixed-response`, `authenticate-cognito` and `authenticate-oidc`.
        /// </summary>
        public readonly string Type;

        [OutputConstructor]
        private ListenerRuleActions(
            ListenerRuleActionsAuthenticateCognito? authenticateCognito,
            ListenerRuleActionsAuthenticateOidc? authenticateOidc,
            ListenerRuleActionsFixedResponse? fixedResponse,
            int order,
            ListenerRuleActionsRedirect? redirect,
            string? targetGroupArn,
            string type)
        {
            AuthenticateCognito = authenticateCognito;
            AuthenticateOidc = authenticateOidc;
            FixedResponse = fixedResponse;
            Order = order;
            Redirect = redirect;
            TargetGroupArn = targetGroupArn;
            Type = type;
        }
    }

    [OutputType]
    public sealed class ListenerRuleActionsAuthenticateCognito
    {
        /// <summary>
        /// The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
        /// </summary>
        public readonly ImmutableDictionary<string, object>? AuthenticationRequestExtraParams;
        /// <summary>
        /// The behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`
        /// </summary>
        public readonly string OnUnauthenticatedRequest;
        /// <summary>
        /// The set of user claims to be requested from the IdP.
        /// </summary>
        public readonly string Scope;
        /// <summary>
        /// The name of the cookie used to maintain session information.
        /// </summary>
        public readonly string SessionCookieName;
        /// <summary>
        /// The maximum duration of the authentication session, in seconds.
        /// </summary>
        public readonly int SessionTimeout;
        /// <summary>
        /// The ARN of the Cognito user pool.
        /// </summary>
        public readonly string UserPoolArn;
        /// <summary>
        /// The ID of the Cognito user pool client.
        /// </summary>
        public readonly string UserPoolClientId;
        /// <summary>
        /// The domain prefix or fully-qualified domain name of the Cognito user pool.
        /// </summary>
        public readonly string UserPoolDomain;

        [OutputConstructor]
        private ListenerRuleActionsAuthenticateCognito(
            ImmutableDictionary<string, object>? authenticationRequestExtraParams,
            string onUnauthenticatedRequest,
            string scope,
            string sessionCookieName,
            int sessionTimeout,
            string userPoolArn,
            string userPoolClientId,
            string userPoolDomain)
        {
            AuthenticationRequestExtraParams = authenticationRequestExtraParams;
            OnUnauthenticatedRequest = onUnauthenticatedRequest;
            Scope = scope;
            SessionCookieName = sessionCookieName;
            SessionTimeout = sessionTimeout;
            UserPoolArn = userPoolArn;
            UserPoolClientId = userPoolClientId;
            UserPoolDomain = userPoolDomain;
        }
    }

    [OutputType]
    public sealed class ListenerRuleActionsAuthenticateOidc
    {
        /// <summary>
        /// The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
        /// </summary>
        public readonly ImmutableDictionary<string, object>? AuthenticationRequestExtraParams;
        /// <summary>
        /// The authorization endpoint of the IdP.
        /// </summary>
        public readonly string AuthorizationEndpoint;
        /// <summary>
        /// The OAuth 2.0 client identifier.
        /// </summary>
        public readonly string ClientId;
        /// <summary>
        /// The OAuth 2.0 client secret.
        /// </summary>
        public readonly string ClientSecret;
        /// <summary>
        /// The OIDC issuer identifier of the IdP.
        /// </summary>
        public readonly string Issuer;
        /// <summary>
        /// The behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`
        /// </summary>
        public readonly string OnUnauthenticatedRequest;
        /// <summary>
        /// The set of user claims to be requested from the IdP.
        /// </summary>
        public readonly string Scope;
        /// <summary>
        /// The name of the cookie used to maintain session information.
        /// </summary>
        public readonly string SessionCookieName;
        /// <summary>
        /// The maximum duration of the authentication session, in seconds.
        /// </summary>
        public readonly int SessionTimeout;
        /// <summary>
        /// The token endpoint of the IdP.
        /// </summary>
        public readonly string TokenEndpoint;
        /// <summary>
        /// The user info endpoint of the IdP.
        /// </summary>
        public readonly string UserInfoEndpoint;

        [OutputConstructor]
        private ListenerRuleActionsAuthenticateOidc(
            ImmutableDictionary<string, object>? authenticationRequestExtraParams,
            string authorizationEndpoint,
            string clientId,
            string clientSecret,
            string issuer,
            string onUnauthenticatedRequest,
            string scope,
            string sessionCookieName,
            int sessionTimeout,
            string tokenEndpoint,
            string userInfoEndpoint)
        {
            AuthenticationRequestExtraParams = authenticationRequestExtraParams;
            AuthorizationEndpoint = authorizationEndpoint;
            ClientId = clientId;
            ClientSecret = clientSecret;
            Issuer = issuer;
            OnUnauthenticatedRequest = onUnauthenticatedRequest;
            Scope = scope;
            SessionCookieName = sessionCookieName;
            SessionTimeout = sessionTimeout;
            TokenEndpoint = tokenEndpoint;
            UserInfoEndpoint = userInfoEndpoint;
        }
    }

    [OutputType]
    public sealed class ListenerRuleActionsFixedResponse
    {
        /// <summary>
        /// The content type. Valid values are `text/plain`, `text/css`, `text/html`, `application/javascript` and `application/json`.
        /// </summary>
        public readonly string ContentType;
        /// <summary>
        /// The message body.
        /// </summary>
        public readonly string? MessageBody;
        /// <summary>
        /// The HTTP response code. Valid values are `2XX`, `4XX`, or `5XX`.
        /// </summary>
        public readonly string StatusCode;

        [OutputConstructor]
        private ListenerRuleActionsFixedResponse(
            string contentType,
            string? messageBody,
            string statusCode)
        {
            ContentType = contentType;
            MessageBody = messageBody;
            StatusCode = statusCode;
        }
    }

    [OutputType]
    public sealed class ListenerRuleActionsRedirect
    {
        /// <summary>
        /// The hostname. This component is not percent-encoded. The hostname can contain `#{host}`. Defaults to `#{host}`.
        /// </summary>
        public readonly string? Host;
        /// <summary>
        /// The absolute path, starting with the leading "/". This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}. Defaults to `/#{path}`.
        /// </summary>
        public readonly string? Path;
        /// <summary>
        /// The port. Specify a value from `1` to `65535` or `#{port}`. Defaults to `#{port}`.
        /// </summary>
        public readonly string? Port;
        /// <summary>
        /// The protocol. Valid values are `HTTP`, `HTTPS`, or `#{protocol}`. Defaults to `#{protocol}`.
        /// </summary>
        public readonly string? Protocol;
        /// <summary>
        /// The query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading "?". Defaults to `#{query}`.
        /// </summary>
        public readonly string? Query;
        /// <summary>
        /// The HTTP redirect code. The redirect is either permanent (`HTTP_301`) or temporary (`HTTP_302`).
        /// </summary>
        public readonly string StatusCode;

        [OutputConstructor]
        private ListenerRuleActionsRedirect(
            string? host,
            string? path,
            string? port,
            string? protocol,
            string? query,
            string statusCode)
        {
            Host = host;
            Path = path;
            Port = port;
            Protocol = protocol;
            Query = query;
            StatusCode = statusCode;
        }
    }

    [OutputType]
    public sealed class ListenerRuleConditions
    {
        /// <summary>
        /// The type of condition. Valid values are `host-header` or `path-pattern`. Must also set `values`.
        /// </summary>
        public readonly string Field;
        /// <summary>
        /// Contains a single `values` item which is a list of host header patterns to match. The maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied.
        /// </summary>
        public readonly ListenerRuleConditionsHostHeader HostHeader;
        /// <summary>
        /// HTTP headers to match. HTTP Header block fields documented below.
        /// </summary>
        public readonly ListenerRuleConditionsHttpHeader? HttpHeader;
        /// <summary>
        /// Contains a single `values` item which is a list of HTTP request methods or verbs to match. Maximum size is 40 characters. Only allowed characters are A-Z, hyphen (-) and underscore (\_). Comparison is case sensitive. Wildcards are not supported. Only one needs to match for the condition to be satisfied. AWS recommends that GET and HEAD requests are routed in the same way because the response to a HEAD request may be cached.
        /// </summary>
        public readonly ListenerRuleConditionsHttpRequestMethod? HttpRequestMethod;
        /// <summary>
        /// Contains a single `values` item which is a list of path patterns to match against the request URL. Maximum size of each pattern is 128 characters. Comparison is case sensitive. Wildcard charaters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied. Path pattern is compared only to the path of the URL, not to its query string. To compare against the query string, use a `query-string` condition.
        /// </summary>
        public readonly ListenerRuleConditionsPathPattern PathPattern;
        /// <summary>
        /// Query strings to match. Query String block fields documented below.
        /// </summary>
        public readonly ImmutableArray<ListenerRuleConditionsQueryStrings> QueryStrings;
        /// <summary>
        /// Contains a single `values` item which is a list of source IP CIDR notations to match. You can use both IPv4 and IPv6 addresses. Wildcards are not supported. Condition is satisfied if the source IP address of the request matches one of the CIDR blocks. Condition is not satisfied by the addresses in the `X-Forwarded-For` header, use `http-header` condition instead.
        /// </summary>
        public readonly ListenerRuleConditionsSourceIp? SourceIp;
        /// <summary>
        /// List of exactly one pattern to match. Required when `field` is set.
        /// </summary>
        public readonly string Values;

        [OutputConstructor]
        private ListenerRuleConditions(
            string field,
            ListenerRuleConditionsHostHeader hostHeader,
            ListenerRuleConditionsHttpHeader? httpHeader,
            ListenerRuleConditionsHttpRequestMethod? httpRequestMethod,
            ListenerRuleConditionsPathPattern pathPattern,
            ImmutableArray<ListenerRuleConditionsQueryStrings> queryStrings,
            ListenerRuleConditionsSourceIp? sourceIp,
            string values)
        {
            Field = field;
            HostHeader = hostHeader;
            HttpHeader = httpHeader;
            HttpRequestMethod = httpRequestMethod;
            PathPattern = pathPattern;
            QueryStrings = queryStrings;
            SourceIp = sourceIp;
            Values = values;
        }
    }

    [OutputType]
    public sealed class ListenerRuleConditionsHostHeader
    {
        /// <summary>
        /// List of exactly one pattern to match. Required when `field` is set.
        /// </summary>
        public readonly ImmutableArray<string> Values;

        [OutputConstructor]
        private ListenerRuleConditionsHostHeader(ImmutableArray<string> values)
        {
            Values = values;
        }
    }

    [OutputType]
    public sealed class ListenerRuleConditionsHttpHeader
    {
        /// <summary>
        /// Name of HTTP header to search. The maximum size is 40 characters. Comparison is case insensitive. Only RFC7240 characters are supported. Wildcards are not supported. You cannot use HTTP header condition to specify the host header, use a `host-header` condition instead.
        /// </summary>
        public readonly string HttpHeaderName;
        /// <summary>
        /// List of header value patterns to match. Maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). If the same header appears multiple times in the request they will be searched in order until a match is found. Only one pattern needs to match for the condition to be satisfied. To require that all of the strings are a match, create one condition block per string.
        /// </summary>
        public readonly ImmutableArray<string> Values;

        [OutputConstructor]
        private ListenerRuleConditionsHttpHeader(
            string httpHeaderName,
            ImmutableArray<string> values)
        {
            HttpHeaderName = httpHeaderName;
            Values = values;
        }
    }

    [OutputType]
    public sealed class ListenerRuleConditionsHttpRequestMethod
    {
        /// <summary>
        /// List of exactly one pattern to match. Required when `field` is set.
        /// </summary>
        public readonly ImmutableArray<string> Values;

        [OutputConstructor]
        private ListenerRuleConditionsHttpRequestMethod(ImmutableArray<string> values)
        {
            Values = values;
        }
    }

    [OutputType]
    public sealed class ListenerRuleConditionsPathPattern
    {
        /// <summary>
        /// List of exactly one pattern to match. Required when `field` is set.
        /// </summary>
        public readonly ImmutableArray<string> Values;

        [OutputConstructor]
        private ListenerRuleConditionsPathPattern(ImmutableArray<string> values)
        {
            Values = values;
        }
    }

    [OutputType]
    public sealed class ListenerRuleConditionsQueryStrings
    {
        /// <summary>
        /// Query string key pattern to match.
        /// </summary>
        public readonly string? Key;
        /// <summary>
        /// Query string value pattern to match.
        /// </summary>
        public readonly string Value;

        [OutputConstructor]
        private ListenerRuleConditionsQueryStrings(
            string? key,
            string value)
        {
            Key = key;
            Value = value;
        }
    }

    [OutputType]
    public sealed class ListenerRuleConditionsSourceIp
    {
        /// <summary>
        /// List of exactly one pattern to match. Required when `field` is set.
        /// </summary>
        public readonly ImmutableArray<string> Values;

        [OutputConstructor]
        private ListenerRuleConditionsSourceIp(ImmutableArray<string> values)
        {
            Values = values;
        }
    }
    }
}
