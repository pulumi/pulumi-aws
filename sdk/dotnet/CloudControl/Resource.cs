// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Aws.CloudControl
{
    /// <summary>
    /// Manages a Cloud Control API Resource. The configuration and lifecycle handling of these resources is proxied through Cloud Control API handlers to the backend service.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using System.Text.Json;
    /// using Pulumi;
    /// using Aws = Pulumi.Aws;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var example = new Aws.CloudControl.Resource("example", new()
    ///     {
    ///         TypeName = "AWS::ECS::Cluster",
    ///         DesiredState = JsonSerializer.Serialize(new Dictionary&lt;string, object?&gt;
    ///         {
    ///             ["clusterName"] = "example",
    ///             ["tags"] = new[]
    ///             {
    ///                 new Dictionary&lt;string, object?&gt;
    ///                 {
    ///                     ["key"] = "CostCenter",
    ///                     ["value"] = "IT",
    ///                 },
    ///             },
    ///         }),
    ///     });
    /// 
    /// });
    /// ```
    /// </summary>
    [AwsResourceType("aws:cloudcontrol/resource:Resource")]
    public partial class Resource : global::Pulumi.CustomResource
    {
        /// <summary>
        /// JSON string matching the CloudFormation resource type schema with desired configuration.
        /// </summary>
        [Output("desiredState")]
        public Output<string> DesiredState { get; private set; } = null!;

        /// <summary>
        /// JSON string matching the CloudFormation resource type schema with current configuration. Underlying attributes can be referenced via the `jsondecode()` function, for example, `jsondecode(data.aws_cloudcontrolapi_resource.example.properties)["example"]`.
        /// </summary>
        [Output("properties")]
        public Output<string> Properties { get; private set; } = null!;

        /// <summary>
        /// Amazon Resource Name (ARN) of the IAM Role to assume for operations.
        /// </summary>
        [Output("roleArn")]
        public Output<string?> RoleArn { get; private set; } = null!;

        /// <summary>
        /// JSON string of the CloudFormation resource type schema which is used for plan time validation where possible. Automatically fetched if not provided. In large scale environments with multiple resources using the same `type_name`, it is recommended to fetch the schema once via the `aws.cloudformation.CloudFormationType` data source and use this argument to reduce `DescribeType` API operation throttling. This value is marked sensitive only to prevent large plan differences from showing.
        /// </summary>
        [Output("schema")]
        public Output<string> Schema { get; private set; } = null!;

        /// <summary>
        /// CloudFormation resource type name. For example, `AWS::EC2::VPC`.
        /// 
        /// The following arguments are optional:
        /// </summary>
        [Output("typeName")]
        public Output<string> TypeName { get; private set; } = null!;

        /// <summary>
        /// Identifier of the CloudFormation resource type version.
        /// </summary>
        [Output("typeVersionId")]
        public Output<string?> TypeVersionId { get; private set; } = null!;


        /// <summary>
        /// Create a Resource resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Resource(string name, ResourceArgs args, CustomResourceOptions? options = null)
            : base("aws:cloudcontrol/resource:Resource", name, args ?? new ResourceArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Resource(string name, Input<string> id, ResourceState? state = null, CustomResourceOptions? options = null)
            : base("aws:cloudcontrol/resource:Resource", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                AdditionalSecretOutputs =
                {
                    "schema",
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Resource resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Resource Get(string name, Input<string> id, ResourceState? state = null, CustomResourceOptions? options = null)
        {
            return new Resource(name, id, state, options);
        }
    }

    public sealed class ResourceArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// JSON string matching the CloudFormation resource type schema with desired configuration.
        /// </summary>
        [Input("desiredState", required: true)]
        public Input<string> DesiredState { get; set; } = null!;

        /// <summary>
        /// Amazon Resource Name (ARN) of the IAM Role to assume for operations.
        /// </summary>
        [Input("roleArn")]
        public Input<string>? RoleArn { get; set; }

        [Input("schema")]
        private Input<string>? _schema;

        /// <summary>
        /// JSON string of the CloudFormation resource type schema which is used for plan time validation where possible. Automatically fetched if not provided. In large scale environments with multiple resources using the same `type_name`, it is recommended to fetch the schema once via the `aws.cloudformation.CloudFormationType` data source and use this argument to reduce `DescribeType` API operation throttling. This value is marked sensitive only to prevent large plan differences from showing.
        /// </summary>
        public Input<string>? Schema
        {
            get => _schema;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _schema = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// CloudFormation resource type name. For example, `AWS::EC2::VPC`.
        /// 
        /// The following arguments are optional:
        /// </summary>
        [Input("typeName", required: true)]
        public Input<string> TypeName { get; set; } = null!;

        /// <summary>
        /// Identifier of the CloudFormation resource type version.
        /// </summary>
        [Input("typeVersionId")]
        public Input<string>? TypeVersionId { get; set; }

        public ResourceArgs()
        {
        }
        public static new ResourceArgs Empty => new ResourceArgs();
    }

    public sealed class ResourceState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// JSON string matching the CloudFormation resource type schema with desired configuration.
        /// </summary>
        [Input("desiredState")]
        public Input<string>? DesiredState { get; set; }

        /// <summary>
        /// JSON string matching the CloudFormation resource type schema with current configuration. Underlying attributes can be referenced via the `jsondecode()` function, for example, `jsondecode(data.aws_cloudcontrolapi_resource.example.properties)["example"]`.
        /// </summary>
        [Input("properties")]
        public Input<string>? Properties { get; set; }

        /// <summary>
        /// Amazon Resource Name (ARN) of the IAM Role to assume for operations.
        /// </summary>
        [Input("roleArn")]
        public Input<string>? RoleArn { get; set; }

        [Input("schema")]
        private Input<string>? _schema;

        /// <summary>
        /// JSON string of the CloudFormation resource type schema which is used for plan time validation where possible. Automatically fetched if not provided. In large scale environments with multiple resources using the same `type_name`, it is recommended to fetch the schema once via the `aws.cloudformation.CloudFormationType` data source and use this argument to reduce `DescribeType` API operation throttling. This value is marked sensitive only to prevent large plan differences from showing.
        /// </summary>
        public Input<string>? Schema
        {
            get => _schema;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _schema = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// CloudFormation resource type name. For example, `AWS::EC2::VPC`.
        /// 
        /// The following arguments are optional:
        /// </summary>
        [Input("typeName")]
        public Input<string>? TypeName { get; set; }

        /// <summary>
        /// Identifier of the CloudFormation resource type version.
        /// </summary>
        [Input("typeVersionId")]
        public Input<string>? TypeVersionId { get; set; }

        public ResourceState()
        {
        }
        public static new ResourceState Empty => new ResourceState();
    }
}
