// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Aws.AutoScaling
{
    /// <summary>
    /// Provides an AutoScaling Group resource.
    /// 
    /// &gt; **Note:** You must specify either `launch_configuration`, `launch_template`, or `mixed_instances_policy`.
    /// 
    /// ## Waiting for Capacity
    /// 
    /// A newly-created ASG is initially empty and begins to scale to `min_size` (or
    /// `desired_capacity`, if specified) by launching instances using the provided
    /// Launch Configuration. These instances take time to launch and boot.
    /// 
    /// On ASG Update, changes to these values also take time to result in the target
    /// number of instances providing service.
    /// 
    /// This provider provides two mechanisms to help consistently manage ASG scale up
    /// time across dependent resources.
    /// 
    /// #### Waiting for ASG Capacity
    /// 
    /// The first is default behavior. This provider waits after ASG creation for
    /// `min_size` (or `desired_capacity`, if specified) healthy instances to show up
    /// in the ASG before continuing.
    /// 
    /// If `min_size` or `desired_capacity` are changed in a subsequent update,
    /// this provider will also wait for the correct number of healthy instances before
    /// continuing.
    /// 
    /// This provider considers an instance "healthy" when the ASG reports `HealthStatus:
    /// "Healthy"` and `LifecycleState: "InService"`. See the [AWS AutoScaling
    /// Docs](https://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/AutoScalingGroupLifecycle.html)
    /// for more information on an ASG's lifecycle.
    /// 
    /// This provider will wait for healthy instances for up to
    /// `wait_for_capacity_timeout`. If ASG creation is taking more than a few minutes,
    /// it's worth investigating for scaling activity errors, which can be caused by
    /// problems with the selected Launch Configuration.
    /// 
    /// Setting `wait_for_capacity_timeout` to `"0"` disables ASG Capacity waiting.
    /// 
    /// #### Waiting for ELB Capacity
    /// 
    /// The second mechanism is optional, and affects ASGs with attached ELBs specified
    /// via the `load_balancers` attribute or with ALBs specified with `target_group_arns`.
    /// 
    /// The `min_elb_capacity` parameter causes this provider to wait for at least the
    /// requested number of instances to show up `"InService"` in all attached ELBs
    /// during ASG creation.  It has no effect on ASG updates.
    /// 
    /// If `wait_for_elb_capacity` is set, this provider will wait for exactly that number
    /// of Instances to be `"InService"` in all attached ELBs on both creation and
    /// updates.
    /// 
    /// These parameters can be used to ensure that service is being provided before
    /// this provider moves on. If new instances don't pass the ELB's health checks for any
    /// reason, the deployment will time out, and the ASG will be marked as
    /// tainted (i.e. marked to be destroyed in a follow up run).
    /// 
    /// As with ASG Capacity, this provider will wait for up to `wait_for_capacity_timeout`
    /// for the proper number of instances to be healthy.
    /// 
    /// #### Troubleshooting Capacity Waiting Timeouts
    /// 
    /// If ASG creation takes more than a few minutes, this could indicate one of a
    /// number of configuration problems. See the [AWS Docs on Load Balancer
    /// Troubleshooting](https://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/elb-troubleshooting.html)
    /// for more information.
    /// 
    /// &gt; This content is derived from https://github.com/terraform-providers/terraform-provider-aws/blob/master/website/docs/r/autoscaling_group.html.markdown.
    /// </summary>
    public partial class Group : Pulumi.CustomResource
    {
        /// <summary>
        /// The ARN for this AutoScaling Group
        /// </summary>
        [Output("arn")]
        public Output<string> Arn { get; private set; } = null!;

        /// <summary>
        /// A list of one or more availability zones for the group. This parameter should not be specified when using `vpc_zone_identifier`.
        /// </summary>
        [Output("availabilityZones")]
        public Output<ImmutableArray<string>> AvailabilityZones { get; private set; } = null!;

        /// <summary>
        /// The amount of time, in seconds, after a scaling activity completes before another scaling activity can start.
        /// </summary>
        [Output("defaultCooldown")]
        public Output<int> DefaultCooldown { get; private set; } = null!;

        /// <summary>
        /// The number of Amazon EC2 instances that
        /// should be running in the group. (See also Waiting for
        /// Capacity below.)
        /// </summary>
        [Output("desiredCapacity")]
        public Output<int> DesiredCapacity { get; private set; } = null!;

        /// <summary>
        /// A list of metrics to collect. The allowed values are `GroupDesiredCapacity`, `GroupInServiceCapacity`, `GroupPendingCapacity`, `GroupMinSize`, `GroupMaxSize`, `GroupInServiceInstances`, `GroupPendingInstances`, `GroupStandbyInstances`, `GroupStandbyCapacity`, `GroupTerminatingCapacity`, `GroupTerminatingInstances`, `GroupTotalCapacity`, `GroupTotalInstances`.
        /// * `wait_for_capacity_timeout` (Default: "10m") A maximum
        /// [duration](https://golang.org/pkg/time/#ParseDuration) that this provider should
        /// wait for ASG instances to be healthy before timing out.  (See also Waiting
        /// for Capacity below.) Setting this to "0" causes
        /// this provider to skip all Capacity Waiting behavior.
        /// </summary>
        [Output("enabledMetrics")]
        public Output<ImmutableArray<string>> EnabledMetrics { get; private set; } = null!;

        /// <summary>
        /// Allows deleting the autoscaling group without waiting
        /// for all instances in the pool to terminate.  You can force an autoscaling group to delete
        /// even if it's in the process of scaling a resource. Normally, this provider
        /// drains all the instances before deleting the group.  This bypasses that
        /// behavior and potentially leaves resources dangling.
        /// </summary>
        [Output("forceDelete")]
        public Output<bool?> ForceDelete { get; private set; } = null!;

        /// <summary>
        /// Time (in seconds) after instance comes into service before checking health.
        /// </summary>
        [Output("healthCheckGracePeriod")]
        public Output<int?> HealthCheckGracePeriod { get; private set; } = null!;

        /// <summary>
        /// "EC2" or "ELB". Controls how health checking is done.
        /// </summary>
        [Output("healthCheckType")]
        public Output<string> HealthCheckType { get; private set; } = null!;

        /// <summary>
        /// One or more
        /// [Lifecycle Hooks](http://docs.aws.amazon.com/autoscaling/latest/userguide/lifecycle-hooks.html)
        /// to attach to the autoscaling group **before** instances are launched. The
        /// syntax is exactly the same as the separate
        /// [`aws.autoscaling.LifecycleHook`](https://www.terraform.io/docs/providers/aws/r/autoscaling_lifecycle_hook.html)
        /// resource, without the `autoscaling_group_name` attribute. Please note that this will only work when creating
        /// a new autoscaling group. For all other use-cases, please use `aws.autoscaling.LifecycleHook` resource.
        /// </summary>
        [Output("initialLifecycleHooks")]
        public Output<ImmutableArray<Outputs.GroupInitialLifecycleHooks>> InitialLifecycleHooks { get; private set; } = null!;

        /// <summary>
        /// The name of the launch configuration to use.
        /// </summary>
        [Output("launchConfiguration")]
        public Output<string?> LaunchConfiguration { get; private set; } = null!;

        /// <summary>
        /// Nested argument containing launch template settings along with the overrides to specify multiple instance types and weights. Defined below.
        /// </summary>
        [Output("launchTemplate")]
        public Output<Outputs.GroupLaunchTemplate?> LaunchTemplate { get; private set; } = null!;

        /// <summary>
        /// A list of elastic load balancer names to add to the autoscaling
        /// group names. Only valid for classic load balancers. For ALBs, use `target_group_arns` instead.
        /// </summary>
        [Output("loadBalancers")]
        public Output<ImmutableArray<string>> LoadBalancers { get; private set; } = null!;

        /// <summary>
        /// The maximum amount of time, in seconds, that an instance can be in service, values must be either equal to 0 or between 604800 and 31536000 seconds.
        /// </summary>
        [Output("maxInstanceLifetime")]
        public Output<int?> MaxInstanceLifetime { get; private set; } = null!;

        /// <summary>
        /// The maximum size of the auto scale group.
        /// </summary>
        [Output("maxSize")]
        public Output<int> MaxSize { get; private set; } = null!;

        /// <summary>
        /// The granularity to associate with the metrics to collect. The only valid value is `1Minute`. Default is `1Minute`.
        /// </summary>
        [Output("metricsGranularity")]
        public Output<string?> MetricsGranularity { get; private set; } = null!;

        /// <summary>
        /// Setting this causes this provider to wait for
        /// this number of instances from this autoscaling group to show up healthy in the
        /// ELB only on creation. Updates will not wait on ELB instance number changes.
        /// (See also Waiting for Capacity below.)
        /// </summary>
        [Output("minElbCapacity")]
        public Output<int?> MinElbCapacity { get; private set; } = null!;

        /// <summary>
        /// The minimum size of the auto scale group.
        /// (See also Waiting for Capacity below.)
        /// </summary>
        [Output("minSize")]
        public Output<int> MinSize { get; private set; } = null!;

        /// <summary>
        /// Configuration block containing settings to define launch targets for Auto Scaling groups. Defined below.
        /// </summary>
        [Output("mixedInstancesPolicy")]
        public Output<Outputs.GroupMixedInstancesPolicy?> MixedInstancesPolicy { get; private set; } = null!;

        /// <summary>
        /// The name of the auto scaling group. By default generated by this provider.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Creates a unique name beginning with the specified
        /// prefix. Conflicts with `name`.
        /// </summary>
        [Output("namePrefix")]
        public Output<string?> NamePrefix { get; private set; } = null!;

        /// <summary>
        /// The name of the placement group into which you'll launch your instances, if any.
        /// </summary>
        [Output("placementGroup")]
        public Output<string?> PlacementGroup { get; private set; } = null!;

        /// <summary>
        /// Allows setting instance protection. The
        /// autoscaling group will not select instances with this setting for terminination
        /// during scale in events.
        /// </summary>
        [Output("protectFromScaleIn")]
        public Output<bool?> ProtectFromScaleIn { get; private set; } = null!;

        /// <summary>
        /// The ARN of the service-linked role that the ASG will use to call other AWS services
        /// </summary>
        [Output("serviceLinkedRoleArn")]
        public Output<string> ServiceLinkedRoleArn { get; private set; } = null!;

        /// <summary>
        /// A list of processes to suspend for the AutoScaling Group. The allowed values are `Launch`, `Terminate`, `HealthCheck`, `ReplaceUnhealthy`, `AZRebalance`, `AlarmNotification`, `ScheduledActions`, `AddToLoadBalancer`.
        /// Note that if you suspend either the `Launch` or `Terminate` process types, it can prevent your autoscaling group from functioning properly.
        /// </summary>
        [Output("suspendedProcesses")]
        public Output<ImmutableArray<string>> SuspendedProcesses { get; private set; } = null!;

        /// <summary>
        /// A list of tag blocks. Tags documented below.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableArray<Outputs.GroupTags>> Tags { get; private set; } = null!;

        /// <summary>
        /// A list of tag blocks (maps). Tags documented below.
        /// </summary>
        [Output("tagsCollection")]
        public Output<ImmutableArray<ImmutableDictionary<string, object>>> TagsCollection { get; private set; } = null!;

        /// <summary>
        /// A list of `aws.alb.TargetGroup` ARNs, for use with Application or Network Load Balancing.
        /// </summary>
        [Output("targetGroupArns")]
        public Output<ImmutableArray<string>> TargetGroupArns { get; private set; } = null!;

        /// <summary>
        /// A list of policies to decide how the instances in the auto scale group should be terminated. The allowed values are `OldestInstance`, `NewestInstance`, `OldestLaunchConfiguration`, `ClosestToNextInstanceHour`, `OldestLaunchTemplate`, `AllocationStrategy`, `Default`.
        /// </summary>
        [Output("terminationPolicies")]
        public Output<ImmutableArray<string>> TerminationPolicies { get; private set; } = null!;

        /// <summary>
        /// A list of subnet IDs to launch resources in.
        /// </summary>
        [Output("vpcZoneIdentifiers")]
        public Output<ImmutableArray<string>> VpcZoneIdentifiers { get; private set; } = null!;

        [Output("waitForCapacityTimeout")]
        public Output<string?> WaitForCapacityTimeout { get; private set; } = null!;

        /// <summary>
        /// Setting this will cause this provider to wait
        /// for exactly this number of healthy instances from this autoscaling group in
        /// all attached load balancers on both create and update operations. (Takes
        /// precedence over `min_elb_capacity` behavior.)
        /// (See also Waiting for Capacity below.)
        /// </summary>
        [Output("waitForElbCapacity")]
        public Output<int?> WaitForElbCapacity { get; private set; } = null!;


        /// <summary>
        /// Create a Group resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Group(string name, GroupArgs args, CustomResourceOptions? options = null)
            : base("aws:autoscaling/group:Group", name, args ?? ResourceArgs.Empty, MakeResourceOptions(options, ""))
        {
        }

        private Group(string name, Input<string> id, GroupState? state = null, CustomResourceOptions? options = null)
            : base("aws:autoscaling/group:Group", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Group resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Group Get(string name, Input<string> id, GroupState? state = null, CustomResourceOptions? options = null)
        {
            return new Group(name, id, state, options);
        }
    }

    public sealed class GroupArgs : Pulumi.ResourceArgs
    {
        [Input("availabilityZones")]
        private InputList<string>? _availabilityZones;

        /// <summary>
        /// A list of one or more availability zones for the group. This parameter should not be specified when using `vpc_zone_identifier`.
        /// </summary>
        public InputList<string> AvailabilityZones
        {
            get => _availabilityZones ?? (_availabilityZones = new InputList<string>());
            set => _availabilityZones = value;
        }

        /// <summary>
        /// The amount of time, in seconds, after a scaling activity completes before another scaling activity can start.
        /// </summary>
        [Input("defaultCooldown")]
        public Input<int>? DefaultCooldown { get; set; }

        /// <summary>
        /// The number of Amazon EC2 instances that
        /// should be running in the group. (See also Waiting for
        /// Capacity below.)
        /// </summary>
        [Input("desiredCapacity")]
        public Input<int>? DesiredCapacity { get; set; }

        [Input("enabledMetrics")]
        private InputList<string>? _enabledMetrics;

        /// <summary>
        /// A list of metrics to collect. The allowed values are `GroupDesiredCapacity`, `GroupInServiceCapacity`, `GroupPendingCapacity`, `GroupMinSize`, `GroupMaxSize`, `GroupInServiceInstances`, `GroupPendingInstances`, `GroupStandbyInstances`, `GroupStandbyCapacity`, `GroupTerminatingCapacity`, `GroupTerminatingInstances`, `GroupTotalCapacity`, `GroupTotalInstances`.
        /// * `wait_for_capacity_timeout` (Default: "10m") A maximum
        /// [duration](https://golang.org/pkg/time/#ParseDuration) that this provider should
        /// wait for ASG instances to be healthy before timing out.  (See also Waiting
        /// for Capacity below.) Setting this to "0" causes
        /// this provider to skip all Capacity Waiting behavior.
        /// </summary>
        public InputList<string> EnabledMetrics
        {
            get => _enabledMetrics ?? (_enabledMetrics = new InputList<string>());
            set => _enabledMetrics = value;
        }

        /// <summary>
        /// Allows deleting the autoscaling group without waiting
        /// for all instances in the pool to terminate.  You can force an autoscaling group to delete
        /// even if it's in the process of scaling a resource. Normally, this provider
        /// drains all the instances before deleting the group.  This bypasses that
        /// behavior and potentially leaves resources dangling.
        /// </summary>
        [Input("forceDelete")]
        public Input<bool>? ForceDelete { get; set; }

        /// <summary>
        /// Time (in seconds) after instance comes into service before checking health.
        /// </summary>
        [Input("healthCheckGracePeriod")]
        public Input<int>? HealthCheckGracePeriod { get; set; }

        /// <summary>
        /// "EC2" or "ELB". Controls how health checking is done.
        /// </summary>
        [Input("healthCheckType")]
        public Input<string>? HealthCheckType { get; set; }

        [Input("initialLifecycleHooks")]
        private InputList<Inputs.GroupInitialLifecycleHooksArgs>? _initialLifecycleHooks;

        /// <summary>
        /// One or more
        /// [Lifecycle Hooks](http://docs.aws.amazon.com/autoscaling/latest/userguide/lifecycle-hooks.html)
        /// to attach to the autoscaling group **before** instances are launched. The
        /// syntax is exactly the same as the separate
        /// [`aws.autoscaling.LifecycleHook`](https://www.terraform.io/docs/providers/aws/r/autoscaling_lifecycle_hook.html)
        /// resource, without the `autoscaling_group_name` attribute. Please note that this will only work when creating
        /// a new autoscaling group. For all other use-cases, please use `aws.autoscaling.LifecycleHook` resource.
        /// </summary>
        public InputList<Inputs.GroupInitialLifecycleHooksArgs> InitialLifecycleHooks
        {
            get => _initialLifecycleHooks ?? (_initialLifecycleHooks = new InputList<Inputs.GroupInitialLifecycleHooksArgs>());
            set => _initialLifecycleHooks = value;
        }

        /// <summary>
        /// The name of the launch configuration to use.
        /// </summary>
        [Input("launchConfiguration")]
        public Input<string>? LaunchConfiguration { get; set; }

        /// <summary>
        /// Nested argument containing launch template settings along with the overrides to specify multiple instance types and weights. Defined below.
        /// </summary>
        [Input("launchTemplate")]
        public Input<Inputs.GroupLaunchTemplateArgs>? LaunchTemplate { get; set; }

        [Input("loadBalancers")]
        private InputList<string>? _loadBalancers;

        /// <summary>
        /// A list of elastic load balancer names to add to the autoscaling
        /// group names. Only valid for classic load balancers. For ALBs, use `target_group_arns` instead.
        /// </summary>
        public InputList<string> LoadBalancers
        {
            get => _loadBalancers ?? (_loadBalancers = new InputList<string>());
            set => _loadBalancers = value;
        }

        /// <summary>
        /// The maximum amount of time, in seconds, that an instance can be in service, values must be either equal to 0 or between 604800 and 31536000 seconds.
        /// </summary>
        [Input("maxInstanceLifetime")]
        public Input<int>? MaxInstanceLifetime { get; set; }

        /// <summary>
        /// The maximum size of the auto scale group.
        /// </summary>
        [Input("maxSize", required: true)]
        public Input<int> MaxSize { get; set; } = null!;

        /// <summary>
        /// The granularity to associate with the metrics to collect. The only valid value is `1Minute`. Default is `1Minute`.
        /// </summary>
        [Input("metricsGranularity")]
        public Input<string>? MetricsGranularity { get; set; }

        /// <summary>
        /// Setting this causes this provider to wait for
        /// this number of instances from this autoscaling group to show up healthy in the
        /// ELB only on creation. Updates will not wait on ELB instance number changes.
        /// (See also Waiting for Capacity below.)
        /// </summary>
        [Input("minElbCapacity")]
        public Input<int>? MinElbCapacity { get; set; }

        /// <summary>
        /// The minimum size of the auto scale group.
        /// (See also Waiting for Capacity below.)
        /// </summary>
        [Input("minSize", required: true)]
        public Input<int> MinSize { get; set; } = null!;

        /// <summary>
        /// Configuration block containing settings to define launch targets for Auto Scaling groups. Defined below.
        /// </summary>
        [Input("mixedInstancesPolicy")]
        public Input<Inputs.GroupMixedInstancesPolicyArgs>? MixedInstancesPolicy { get; set; }

        /// <summary>
        /// The name of the auto scaling group. By default generated by this provider.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Creates a unique name beginning with the specified
        /// prefix. Conflicts with `name`.
        /// </summary>
        [Input("namePrefix")]
        public Input<string>? NamePrefix { get; set; }

        /// <summary>
        /// The name of the placement group into which you'll launch your instances, if any.
        /// </summary>
        [Input("placementGroup")]
        public Input<string>? PlacementGroup { get; set; }

        /// <summary>
        /// Allows setting instance protection. The
        /// autoscaling group will not select instances with this setting for terminination
        /// during scale in events.
        /// </summary>
        [Input("protectFromScaleIn")]
        public Input<bool>? ProtectFromScaleIn { get; set; }

        /// <summary>
        /// The ARN of the service-linked role that the ASG will use to call other AWS services
        /// </summary>
        [Input("serviceLinkedRoleArn")]
        public Input<string>? ServiceLinkedRoleArn { get; set; }

        [Input("suspendedProcesses")]
        private InputList<string>? _suspendedProcesses;

        /// <summary>
        /// A list of processes to suspend for the AutoScaling Group. The allowed values are `Launch`, `Terminate`, `HealthCheck`, `ReplaceUnhealthy`, `AZRebalance`, `AlarmNotification`, `ScheduledActions`, `AddToLoadBalancer`.
        /// Note that if you suspend either the `Launch` or `Terminate` process types, it can prevent your autoscaling group from functioning properly.
        /// </summary>
        public InputList<string> SuspendedProcesses
        {
            get => _suspendedProcesses ?? (_suspendedProcesses = new InputList<string>());
            set => _suspendedProcesses = value;
        }

        [Input("tags")]
        private InputList<Inputs.GroupTagsArgs>? _tags;

        /// <summary>
        /// A list of tag blocks. Tags documented below.
        /// </summary>
        public InputList<Inputs.GroupTagsArgs> Tags
        {
            get => _tags ?? (_tags = new InputList<Inputs.GroupTagsArgs>());
            set => _tags = value;
        }

        [Input("tagsCollection")]
        private InputList<ImmutableDictionary<string, object>>? _tagsCollection;

        /// <summary>
        /// A list of tag blocks (maps). Tags documented below.
        /// </summary>
        public InputList<ImmutableDictionary<string, object>> TagsCollection
        {
            get => _tagsCollection ?? (_tagsCollection = new InputList<ImmutableDictionary<string, object>>());
            set => _tagsCollection = value;
        }

        [Input("targetGroupArns")]
        private InputList<string>? _targetGroupArns;

        /// <summary>
        /// A list of `aws.alb.TargetGroup` ARNs, for use with Application or Network Load Balancing.
        /// </summary>
        public InputList<string> TargetGroupArns
        {
            get => _targetGroupArns ?? (_targetGroupArns = new InputList<string>());
            set => _targetGroupArns = value;
        }

        [Input("terminationPolicies")]
        private InputList<string>? _terminationPolicies;

        /// <summary>
        /// A list of policies to decide how the instances in the auto scale group should be terminated. The allowed values are `OldestInstance`, `NewestInstance`, `OldestLaunchConfiguration`, `ClosestToNextInstanceHour`, `OldestLaunchTemplate`, `AllocationStrategy`, `Default`.
        /// </summary>
        public InputList<string> TerminationPolicies
        {
            get => _terminationPolicies ?? (_terminationPolicies = new InputList<string>());
            set => _terminationPolicies = value;
        }

        [Input("vpcZoneIdentifiers")]
        private InputList<string>? _vpcZoneIdentifiers;

        /// <summary>
        /// A list of subnet IDs to launch resources in.
        /// </summary>
        public InputList<string> VpcZoneIdentifiers
        {
            get => _vpcZoneIdentifiers ?? (_vpcZoneIdentifiers = new InputList<string>());
            set => _vpcZoneIdentifiers = value;
        }

        [Input("waitForCapacityTimeout")]
        public Input<string>? WaitForCapacityTimeout { get; set; }

        /// <summary>
        /// Setting this will cause this provider to wait
        /// for exactly this number of healthy instances from this autoscaling group in
        /// all attached load balancers on both create and update operations. (Takes
        /// precedence over `min_elb_capacity` behavior.)
        /// (See also Waiting for Capacity below.)
        /// </summary>
        [Input("waitForElbCapacity")]
        public Input<int>? WaitForElbCapacity { get; set; }

        public GroupArgs()
        {
        }
    }

    public sealed class GroupState : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The ARN for this AutoScaling Group
        /// </summary>
        [Input("arn")]
        public Input<string>? Arn { get; set; }

        [Input("availabilityZones")]
        private InputList<string>? _availabilityZones;

        /// <summary>
        /// A list of one or more availability zones for the group. This parameter should not be specified when using `vpc_zone_identifier`.
        /// </summary>
        public InputList<string> AvailabilityZones
        {
            get => _availabilityZones ?? (_availabilityZones = new InputList<string>());
            set => _availabilityZones = value;
        }

        /// <summary>
        /// The amount of time, in seconds, after a scaling activity completes before another scaling activity can start.
        /// </summary>
        [Input("defaultCooldown")]
        public Input<int>? DefaultCooldown { get; set; }

        /// <summary>
        /// The number of Amazon EC2 instances that
        /// should be running in the group. (See also Waiting for
        /// Capacity below.)
        /// </summary>
        [Input("desiredCapacity")]
        public Input<int>? DesiredCapacity { get; set; }

        [Input("enabledMetrics")]
        private InputList<string>? _enabledMetrics;

        /// <summary>
        /// A list of metrics to collect. The allowed values are `GroupDesiredCapacity`, `GroupInServiceCapacity`, `GroupPendingCapacity`, `GroupMinSize`, `GroupMaxSize`, `GroupInServiceInstances`, `GroupPendingInstances`, `GroupStandbyInstances`, `GroupStandbyCapacity`, `GroupTerminatingCapacity`, `GroupTerminatingInstances`, `GroupTotalCapacity`, `GroupTotalInstances`.
        /// * `wait_for_capacity_timeout` (Default: "10m") A maximum
        /// [duration](https://golang.org/pkg/time/#ParseDuration) that this provider should
        /// wait for ASG instances to be healthy before timing out.  (See also Waiting
        /// for Capacity below.) Setting this to "0" causes
        /// this provider to skip all Capacity Waiting behavior.
        /// </summary>
        public InputList<string> EnabledMetrics
        {
            get => _enabledMetrics ?? (_enabledMetrics = new InputList<string>());
            set => _enabledMetrics = value;
        }

        /// <summary>
        /// Allows deleting the autoscaling group without waiting
        /// for all instances in the pool to terminate.  You can force an autoscaling group to delete
        /// even if it's in the process of scaling a resource. Normally, this provider
        /// drains all the instances before deleting the group.  This bypasses that
        /// behavior and potentially leaves resources dangling.
        /// </summary>
        [Input("forceDelete")]
        public Input<bool>? ForceDelete { get; set; }

        /// <summary>
        /// Time (in seconds) after instance comes into service before checking health.
        /// </summary>
        [Input("healthCheckGracePeriod")]
        public Input<int>? HealthCheckGracePeriod { get; set; }

        /// <summary>
        /// "EC2" or "ELB". Controls how health checking is done.
        /// </summary>
        [Input("healthCheckType")]
        public Input<string>? HealthCheckType { get; set; }

        [Input("initialLifecycleHooks")]
        private InputList<Inputs.GroupInitialLifecycleHooksGetArgs>? _initialLifecycleHooks;

        /// <summary>
        /// One or more
        /// [Lifecycle Hooks](http://docs.aws.amazon.com/autoscaling/latest/userguide/lifecycle-hooks.html)
        /// to attach to the autoscaling group **before** instances are launched. The
        /// syntax is exactly the same as the separate
        /// [`aws.autoscaling.LifecycleHook`](https://www.terraform.io/docs/providers/aws/r/autoscaling_lifecycle_hook.html)
        /// resource, without the `autoscaling_group_name` attribute. Please note that this will only work when creating
        /// a new autoscaling group. For all other use-cases, please use `aws.autoscaling.LifecycleHook` resource.
        /// </summary>
        public InputList<Inputs.GroupInitialLifecycleHooksGetArgs> InitialLifecycleHooks
        {
            get => _initialLifecycleHooks ?? (_initialLifecycleHooks = new InputList<Inputs.GroupInitialLifecycleHooksGetArgs>());
            set => _initialLifecycleHooks = value;
        }

        /// <summary>
        /// The name of the launch configuration to use.
        /// </summary>
        [Input("launchConfiguration")]
        public Input<string>? LaunchConfiguration { get; set; }

        /// <summary>
        /// Nested argument containing launch template settings along with the overrides to specify multiple instance types and weights. Defined below.
        /// </summary>
        [Input("launchTemplate")]
        public Input<Inputs.GroupLaunchTemplateGetArgs>? LaunchTemplate { get; set; }

        [Input("loadBalancers")]
        private InputList<string>? _loadBalancers;

        /// <summary>
        /// A list of elastic load balancer names to add to the autoscaling
        /// group names. Only valid for classic load balancers. For ALBs, use `target_group_arns` instead.
        /// </summary>
        public InputList<string> LoadBalancers
        {
            get => _loadBalancers ?? (_loadBalancers = new InputList<string>());
            set => _loadBalancers = value;
        }

        /// <summary>
        /// The maximum amount of time, in seconds, that an instance can be in service, values must be either equal to 0 or between 604800 and 31536000 seconds.
        /// </summary>
        [Input("maxInstanceLifetime")]
        public Input<int>? MaxInstanceLifetime { get; set; }

        /// <summary>
        /// The maximum size of the auto scale group.
        /// </summary>
        [Input("maxSize")]
        public Input<int>? MaxSize { get; set; }

        /// <summary>
        /// The granularity to associate with the metrics to collect. The only valid value is `1Minute`. Default is `1Minute`.
        /// </summary>
        [Input("metricsGranularity")]
        public Input<string>? MetricsGranularity { get; set; }

        /// <summary>
        /// Setting this causes this provider to wait for
        /// this number of instances from this autoscaling group to show up healthy in the
        /// ELB only on creation. Updates will not wait on ELB instance number changes.
        /// (See also Waiting for Capacity below.)
        /// </summary>
        [Input("minElbCapacity")]
        public Input<int>? MinElbCapacity { get; set; }

        /// <summary>
        /// The minimum size of the auto scale group.
        /// (See also Waiting for Capacity below.)
        /// </summary>
        [Input("minSize")]
        public Input<int>? MinSize { get; set; }

        /// <summary>
        /// Configuration block containing settings to define launch targets for Auto Scaling groups. Defined below.
        /// </summary>
        [Input("mixedInstancesPolicy")]
        public Input<Inputs.GroupMixedInstancesPolicyGetArgs>? MixedInstancesPolicy { get; set; }

        /// <summary>
        /// The name of the auto scaling group. By default generated by this provider.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Creates a unique name beginning with the specified
        /// prefix. Conflicts with `name`.
        /// </summary>
        [Input("namePrefix")]
        public Input<string>? NamePrefix { get; set; }

        /// <summary>
        /// The name of the placement group into which you'll launch your instances, if any.
        /// </summary>
        [Input("placementGroup")]
        public Input<string>? PlacementGroup { get; set; }

        /// <summary>
        /// Allows setting instance protection. The
        /// autoscaling group will not select instances with this setting for terminination
        /// during scale in events.
        /// </summary>
        [Input("protectFromScaleIn")]
        public Input<bool>? ProtectFromScaleIn { get; set; }

        /// <summary>
        /// The ARN of the service-linked role that the ASG will use to call other AWS services
        /// </summary>
        [Input("serviceLinkedRoleArn")]
        public Input<string>? ServiceLinkedRoleArn { get; set; }

        [Input("suspendedProcesses")]
        private InputList<string>? _suspendedProcesses;

        /// <summary>
        /// A list of processes to suspend for the AutoScaling Group. The allowed values are `Launch`, `Terminate`, `HealthCheck`, `ReplaceUnhealthy`, `AZRebalance`, `AlarmNotification`, `ScheduledActions`, `AddToLoadBalancer`.
        /// Note that if you suspend either the `Launch` or `Terminate` process types, it can prevent your autoscaling group from functioning properly.
        /// </summary>
        public InputList<string> SuspendedProcesses
        {
            get => _suspendedProcesses ?? (_suspendedProcesses = new InputList<string>());
            set => _suspendedProcesses = value;
        }

        [Input("tags")]
        private InputList<Inputs.GroupTagsGetArgs>? _tags;

        /// <summary>
        /// A list of tag blocks. Tags documented below.
        /// </summary>
        public InputList<Inputs.GroupTagsGetArgs> Tags
        {
            get => _tags ?? (_tags = new InputList<Inputs.GroupTagsGetArgs>());
            set => _tags = value;
        }

        [Input("tagsCollection")]
        private InputList<ImmutableDictionary<string, object>>? _tagsCollection;

        /// <summary>
        /// A list of tag blocks (maps). Tags documented below.
        /// </summary>
        public InputList<ImmutableDictionary<string, object>> TagsCollection
        {
            get => _tagsCollection ?? (_tagsCollection = new InputList<ImmutableDictionary<string, object>>());
            set => _tagsCollection = value;
        }

        [Input("targetGroupArns")]
        private InputList<string>? _targetGroupArns;

        /// <summary>
        /// A list of `aws.alb.TargetGroup` ARNs, for use with Application or Network Load Balancing.
        /// </summary>
        public InputList<string> TargetGroupArns
        {
            get => _targetGroupArns ?? (_targetGroupArns = new InputList<string>());
            set => _targetGroupArns = value;
        }

        [Input("terminationPolicies")]
        private InputList<string>? _terminationPolicies;

        /// <summary>
        /// A list of policies to decide how the instances in the auto scale group should be terminated. The allowed values are `OldestInstance`, `NewestInstance`, `OldestLaunchConfiguration`, `ClosestToNextInstanceHour`, `OldestLaunchTemplate`, `AllocationStrategy`, `Default`.
        /// </summary>
        public InputList<string> TerminationPolicies
        {
            get => _terminationPolicies ?? (_terminationPolicies = new InputList<string>());
            set => _terminationPolicies = value;
        }

        [Input("vpcZoneIdentifiers")]
        private InputList<string>? _vpcZoneIdentifiers;

        /// <summary>
        /// A list of subnet IDs to launch resources in.
        /// </summary>
        public InputList<string> VpcZoneIdentifiers
        {
            get => _vpcZoneIdentifiers ?? (_vpcZoneIdentifiers = new InputList<string>());
            set => _vpcZoneIdentifiers = value;
        }

        [Input("waitForCapacityTimeout")]
        public Input<string>? WaitForCapacityTimeout { get; set; }

        /// <summary>
        /// Setting this will cause this provider to wait
        /// for exactly this number of healthy instances from this autoscaling group in
        /// all attached load balancers on both create and update operations. (Takes
        /// precedence over `min_elb_capacity` behavior.)
        /// (See also Waiting for Capacity below.)
        /// </summary>
        [Input("waitForElbCapacity")]
        public Input<int>? WaitForElbCapacity { get; set; }

        public GroupState()
        {
        }
    }

    namespace Inputs
    {

    public sealed class GroupInitialLifecycleHooksArgs : Pulumi.ResourceArgs
    {
        [Input("defaultResult")]
        public Input<string>? DefaultResult { get; set; }

        [Input("heartbeatTimeout")]
        public Input<int>? HeartbeatTimeout { get; set; }

        [Input("lifecycleTransition", required: true)]
        public Input<string> LifecycleTransition { get; set; } = null!;

        /// <summary>
        /// The name of the auto scaling group. By default generated by this provider.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("notificationMetadata")]
        public Input<string>? NotificationMetadata { get; set; }

        [Input("notificationTargetArn")]
        public Input<string>? NotificationTargetArn { get; set; }

        [Input("roleArn")]
        public Input<string>? RoleArn { get; set; }

        public GroupInitialLifecycleHooksArgs()
        {
        }
    }

    public sealed class GroupInitialLifecycleHooksGetArgs : Pulumi.ResourceArgs
    {
        [Input("defaultResult")]
        public Input<string>? DefaultResult { get; set; }

        [Input("heartbeatTimeout")]
        public Input<int>? HeartbeatTimeout { get; set; }

        [Input("lifecycleTransition", required: true)]
        public Input<string> LifecycleTransition { get; set; } = null!;

        /// <summary>
        /// The name of the auto scaling group. By default generated by this provider.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("notificationMetadata")]
        public Input<string>? NotificationMetadata { get; set; }

        [Input("notificationTargetArn")]
        public Input<string>? NotificationTargetArn { get; set; }

        [Input("roleArn")]
        public Input<string>? RoleArn { get; set; }

        public GroupInitialLifecycleHooksGetArgs()
        {
        }
    }

    public sealed class GroupLaunchTemplateArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The autoscaling group id.
        /// </summary>
        [Input("id")]
        public Input<string>? Id { get; set; }

        /// <summary>
        /// The name of the auto scaling group. By default generated by this provider.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

        public GroupLaunchTemplateArgs()
        {
        }
    }

    public sealed class GroupLaunchTemplateGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The autoscaling group id.
        /// </summary>
        [Input("id")]
        public Input<string>? Id { get; set; }

        /// <summary>
        /// The name of the auto scaling group. By default generated by this provider.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

        public GroupLaunchTemplateGetArgs()
        {
        }
    }

    public sealed class GroupMixedInstancesPolicyArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Nested argument containing settings on how to mix on-demand and Spot instances in the Auto Scaling group. Defined below.
        /// </summary>
        [Input("instancesDistribution")]
        public Input<GroupMixedInstancesPolicyInstancesDistributionArgs>? InstancesDistribution { get; set; }

        /// <summary>
        /// Nested argument containing launch template settings along with the overrides to specify multiple instance types and weights. Defined below.
        /// </summary>
        [Input("launchTemplate", required: true)]
        public Input<GroupMixedInstancesPolicyLaunchTemplateArgs> LaunchTemplate { get; set; } = null!;

        public GroupMixedInstancesPolicyArgs()
        {
        }
    }

    public sealed class GroupMixedInstancesPolicyGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Nested argument containing settings on how to mix on-demand and Spot instances in the Auto Scaling group. Defined below.
        /// </summary>
        [Input("instancesDistribution")]
        public Input<GroupMixedInstancesPolicyInstancesDistributionGetArgs>? InstancesDistribution { get; set; }

        /// <summary>
        /// Nested argument containing launch template settings along with the overrides to specify multiple instance types and weights. Defined below.
        /// </summary>
        [Input("launchTemplate", required: true)]
        public Input<GroupMixedInstancesPolicyLaunchTemplateGetArgs> LaunchTemplate { get; set; } = null!;

        public GroupMixedInstancesPolicyGetArgs()
        {
        }
    }

    public sealed class GroupMixedInstancesPolicyInstancesDistributionArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Strategy to use when launching on-demand instances. Valid values: `prioritized`. Default: `prioritized`.
        /// </summary>
        [Input("onDemandAllocationStrategy")]
        public Input<string>? OnDemandAllocationStrategy { get; set; }

        /// <summary>
        /// Absolute minimum amount of desired capacity that must be fulfilled by on-demand instances. Default: `0`.
        /// </summary>
        [Input("onDemandBaseCapacity")]
        public Input<int>? OnDemandBaseCapacity { get; set; }

        /// <summary>
        /// Percentage split between on-demand and Spot instances above the base on-demand capacity. Default: `100`.
        /// </summary>
        [Input("onDemandPercentageAboveBaseCapacity")]
        public Input<int>? OnDemandPercentageAboveBaseCapacity { get; set; }

        /// <summary>
        /// How to allocate capacity across the Spot pools. Valid values: `lowest-price`, `capacity-optimized`. Default: `lowest-price`.
        /// </summary>
        [Input("spotAllocationStrategy")]
        public Input<string>? SpotAllocationStrategy { get; set; }

        /// <summary>
        /// Number of Spot pools per availability zone to allocate capacity. EC2 Auto Scaling selects the cheapest Spot pools and evenly allocates Spot capacity across the number of Spot pools that you specify. Default: `2`.
        /// </summary>
        [Input("spotInstancePools")]
        public Input<int>? SpotInstancePools { get; set; }

        /// <summary>
        /// Maximum price per unit hour that the user is willing to pay for the Spot instances. Default: an empty string which means the on-demand price.
        /// </summary>
        [Input("spotMaxPrice")]
        public Input<string>? SpotMaxPrice { get; set; }

        public GroupMixedInstancesPolicyInstancesDistributionArgs()
        {
        }
    }

    public sealed class GroupMixedInstancesPolicyInstancesDistributionGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Strategy to use when launching on-demand instances. Valid values: `prioritized`. Default: `prioritized`.
        /// </summary>
        [Input("onDemandAllocationStrategy")]
        public Input<string>? OnDemandAllocationStrategy { get; set; }

        /// <summary>
        /// Absolute minimum amount of desired capacity that must be fulfilled by on-demand instances. Default: `0`.
        /// </summary>
        [Input("onDemandBaseCapacity")]
        public Input<int>? OnDemandBaseCapacity { get; set; }

        /// <summary>
        /// Percentage split between on-demand and Spot instances above the base on-demand capacity. Default: `100`.
        /// </summary>
        [Input("onDemandPercentageAboveBaseCapacity")]
        public Input<int>? OnDemandPercentageAboveBaseCapacity { get; set; }

        /// <summary>
        /// How to allocate capacity across the Spot pools. Valid values: `lowest-price`, `capacity-optimized`. Default: `lowest-price`.
        /// </summary>
        [Input("spotAllocationStrategy")]
        public Input<string>? SpotAllocationStrategy { get; set; }

        /// <summary>
        /// Number of Spot pools per availability zone to allocate capacity. EC2 Auto Scaling selects the cheapest Spot pools and evenly allocates Spot capacity across the number of Spot pools that you specify. Default: `2`.
        /// </summary>
        [Input("spotInstancePools")]
        public Input<int>? SpotInstancePools { get; set; }

        /// <summary>
        /// Maximum price per unit hour that the user is willing to pay for the Spot instances. Default: an empty string which means the on-demand price.
        /// </summary>
        [Input("spotMaxPrice")]
        public Input<string>? SpotMaxPrice { get; set; }

        public GroupMixedInstancesPolicyInstancesDistributionGetArgs()
        {
        }
    }

    public sealed class GroupMixedInstancesPolicyLaunchTemplateArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Nested argument defines the Launch Template. Defined below.
        /// </summary>
        [Input("launchTemplateSpecification", required: true)]
        public Input<GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationArgs> LaunchTemplateSpecification { get; set; } = null!;

        [Input("overrides")]
        private InputList<GroupMixedInstancesPolicyLaunchTemplateOverridesArgs>? _overrides;

        /// <summary>
        /// List of nested arguments provides the ability to specify multiple instance types. This will override the same parameter in the launch template. For on-demand instances, Auto Scaling considers the order of preference of instance types to launch based on the order specified in the overrides list. Defined below.
        /// </summary>
        public InputList<GroupMixedInstancesPolicyLaunchTemplateOverridesArgs> Overrides
        {
            get => _overrides ?? (_overrides = new InputList<GroupMixedInstancesPolicyLaunchTemplateOverridesArgs>());
            set => _overrides = value;
        }

        public GroupMixedInstancesPolicyLaunchTemplateArgs()
        {
        }
    }

    public sealed class GroupMixedInstancesPolicyLaunchTemplateGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Nested argument defines the Launch Template. Defined below.
        /// </summary>
        [Input("launchTemplateSpecification", required: true)]
        public Input<GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationGetArgs> LaunchTemplateSpecification { get; set; } = null!;

        [Input("overrides")]
        private InputList<GroupMixedInstancesPolicyLaunchTemplateOverridesGetArgs>? _overrides;

        /// <summary>
        /// List of nested arguments provides the ability to specify multiple instance types. This will override the same parameter in the launch template. For on-demand instances, Auto Scaling considers the order of preference of instance types to launch based on the order specified in the overrides list. Defined below.
        /// </summary>
        public InputList<GroupMixedInstancesPolicyLaunchTemplateOverridesGetArgs> Overrides
        {
            get => _overrides ?? (_overrides = new InputList<GroupMixedInstancesPolicyLaunchTemplateOverridesGetArgs>());
            set => _overrides = value;
        }

        public GroupMixedInstancesPolicyLaunchTemplateGetArgs()
        {
        }
    }

    public sealed class GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The ID of the launch template. Conflicts with `launch_template_name`.
        /// </summary>
        [Input("launchTemplateId")]
        public Input<string>? LaunchTemplateId { get; set; }

        /// <summary>
        /// The name of the launch template. Conflicts with `launch_template_id`.
        /// </summary>
        [Input("launchTemplateName")]
        public Input<string>? LaunchTemplateName { get; set; }

        /// <summary>
        /// Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

        public GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationArgs()
        {
        }
    }

    public sealed class GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The ID of the launch template. Conflicts with `launch_template_name`.
        /// </summary>
        [Input("launchTemplateId")]
        public Input<string>? LaunchTemplateId { get; set; }

        /// <summary>
        /// The name of the launch template. Conflicts with `launch_template_id`.
        /// </summary>
        [Input("launchTemplateName")]
        public Input<string>? LaunchTemplateName { get; set; }

        /// <summary>
        /// Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

        public GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationGetArgs()
        {
        }
    }

    public sealed class GroupMixedInstancesPolicyLaunchTemplateOverridesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Override the instance type in the Launch Template.
        /// </summary>
        [Input("instanceType")]
        public Input<string>? InstanceType { get; set; }

        /// <summary>
        /// The number of capacity units, which gives the instance type a proportional weight to other instance types.
        /// </summary>
        [Input("weightedCapacity")]
        public Input<string>? WeightedCapacity { get; set; }

        public GroupMixedInstancesPolicyLaunchTemplateOverridesArgs()
        {
        }
    }

    public sealed class GroupMixedInstancesPolicyLaunchTemplateOverridesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Override the instance type in the Launch Template.
        /// </summary>
        [Input("instanceType")]
        public Input<string>? InstanceType { get; set; }

        /// <summary>
        /// The number of capacity units, which gives the instance type a proportional weight to other instance types.
        /// </summary>
        [Input("weightedCapacity")]
        public Input<string>? WeightedCapacity { get; set; }

        public GroupMixedInstancesPolicyLaunchTemplateOverridesGetArgs()
        {
        }
    }

    public sealed class GroupTagsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Key
        /// </summary>
        [Input("key", required: true)]
        public Input<string> Key { get; set; } = null!;

        /// <summary>
        /// Enables propagation of the tag to
        /// Amazon EC2 instances launched via this ASG
        /// </summary>
        [Input("propagateAtLaunch", required: true)]
        public Input<bool> PropagateAtLaunch { get; set; } = null!;

        /// <summary>
        /// Value
        /// </summary>
        [Input("value", required: true)]
        public Input<string> Value { get; set; } = null!;

        public GroupTagsArgs()
        {
        }
    }

    public sealed class GroupTagsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Key
        /// </summary>
        [Input("key", required: true)]
        public Input<string> Key { get; set; } = null!;

        /// <summary>
        /// Enables propagation of the tag to
        /// Amazon EC2 instances launched via this ASG
        /// </summary>
        [Input("propagateAtLaunch", required: true)]
        public Input<bool> PropagateAtLaunch { get; set; } = null!;

        /// <summary>
        /// Value
        /// </summary>
        [Input("value", required: true)]
        public Input<string> Value { get; set; } = null!;

        public GroupTagsGetArgs()
        {
        }
    }
    }

    namespace Outputs
    {

    [OutputType]
    public sealed class GroupInitialLifecycleHooks
    {
        public readonly string DefaultResult;
        public readonly int? HeartbeatTimeout;
        public readonly string LifecycleTransition;
        /// <summary>
        /// The name of the auto scaling group. By default generated by this provider.
        /// </summary>
        public readonly string Name;
        public readonly string? NotificationMetadata;
        public readonly string? NotificationTargetArn;
        public readonly string? RoleArn;

        [OutputConstructor]
        private GroupInitialLifecycleHooks(
            string defaultResult,
            int? heartbeatTimeout,
            string lifecycleTransition,
            string name,
            string? notificationMetadata,
            string? notificationTargetArn,
            string? roleArn)
        {
            DefaultResult = defaultResult;
            HeartbeatTimeout = heartbeatTimeout;
            LifecycleTransition = lifecycleTransition;
            Name = name;
            NotificationMetadata = notificationMetadata;
            NotificationTargetArn = notificationTargetArn;
            RoleArn = roleArn;
        }
    }

    [OutputType]
    public sealed class GroupLaunchTemplate
    {
        /// <summary>
        /// The autoscaling group id.
        /// </summary>
        public readonly string Id;
        /// <summary>
        /// The name of the auto scaling group. By default generated by this provider.
        /// </summary>
        public readonly string Name;
        /// <summary>
        /// Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
        /// </summary>
        public readonly string? Version;

        [OutputConstructor]
        private GroupLaunchTemplate(
            string id,
            string name,
            string? version)
        {
            Id = id;
            Name = name;
            Version = version;
        }
    }

    [OutputType]
    public sealed class GroupMixedInstancesPolicy
    {
        /// <summary>
        /// Nested argument containing settings on how to mix on-demand and Spot instances in the Auto Scaling group. Defined below.
        /// </summary>
        public readonly GroupMixedInstancesPolicyInstancesDistribution? InstancesDistribution;
        /// <summary>
        /// Nested argument containing launch template settings along with the overrides to specify multiple instance types and weights. Defined below.
        /// </summary>
        public readonly GroupMixedInstancesPolicyLaunchTemplate LaunchTemplate;

        [OutputConstructor]
        private GroupMixedInstancesPolicy(
            GroupMixedInstancesPolicyInstancesDistribution? instancesDistribution,
            GroupMixedInstancesPolicyLaunchTemplate launchTemplate)
        {
            InstancesDistribution = instancesDistribution;
            LaunchTemplate = launchTemplate;
        }
    }

    [OutputType]
    public sealed class GroupMixedInstancesPolicyInstancesDistribution
    {
        /// <summary>
        /// Strategy to use when launching on-demand instances. Valid values: `prioritized`. Default: `prioritized`.
        /// </summary>
        public readonly string? OnDemandAllocationStrategy;
        /// <summary>
        /// Absolute minimum amount of desired capacity that must be fulfilled by on-demand instances. Default: `0`.
        /// </summary>
        public readonly int? OnDemandBaseCapacity;
        /// <summary>
        /// Percentage split between on-demand and Spot instances above the base on-demand capacity. Default: `100`.
        /// </summary>
        public readonly int? OnDemandPercentageAboveBaseCapacity;
        /// <summary>
        /// How to allocate capacity across the Spot pools. Valid values: `lowest-price`, `capacity-optimized`. Default: `lowest-price`.
        /// </summary>
        public readonly string? SpotAllocationStrategy;
        /// <summary>
        /// Number of Spot pools per availability zone to allocate capacity. EC2 Auto Scaling selects the cheapest Spot pools and evenly allocates Spot capacity across the number of Spot pools that you specify. Default: `2`.
        /// </summary>
        public readonly int SpotInstancePools;
        /// <summary>
        /// Maximum price per unit hour that the user is willing to pay for the Spot instances. Default: an empty string which means the on-demand price.
        /// </summary>
        public readonly string? SpotMaxPrice;

        [OutputConstructor]
        private GroupMixedInstancesPolicyInstancesDistribution(
            string? onDemandAllocationStrategy,
            int? onDemandBaseCapacity,
            int? onDemandPercentageAboveBaseCapacity,
            string? spotAllocationStrategy,
            int spotInstancePools,
            string? spotMaxPrice)
        {
            OnDemandAllocationStrategy = onDemandAllocationStrategy;
            OnDemandBaseCapacity = onDemandBaseCapacity;
            OnDemandPercentageAboveBaseCapacity = onDemandPercentageAboveBaseCapacity;
            SpotAllocationStrategy = spotAllocationStrategy;
            SpotInstancePools = spotInstancePools;
            SpotMaxPrice = spotMaxPrice;
        }
    }

    [OutputType]
    public sealed class GroupMixedInstancesPolicyLaunchTemplate
    {
        /// <summary>
        /// Nested argument defines the Launch Template. Defined below.
        /// </summary>
        public readonly GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification LaunchTemplateSpecification;
        /// <summary>
        /// List of nested arguments provides the ability to specify multiple instance types. This will override the same parameter in the launch template. For on-demand instances, Auto Scaling considers the order of preference of instance types to launch based on the order specified in the overrides list. Defined below.
        /// </summary>
        public readonly ImmutableArray<GroupMixedInstancesPolicyLaunchTemplateOverrides> Overrides;

        [OutputConstructor]
        private GroupMixedInstancesPolicyLaunchTemplate(
            GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification launchTemplateSpecification,
            ImmutableArray<GroupMixedInstancesPolicyLaunchTemplateOverrides> overrides)
        {
            LaunchTemplateSpecification = launchTemplateSpecification;
            Overrides = overrides;
        }
    }

    [OutputType]
    public sealed class GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification
    {
        /// <summary>
        /// The ID of the launch template. Conflicts with `launch_template_name`.
        /// </summary>
        public readonly string LaunchTemplateId;
        /// <summary>
        /// The name of the launch template. Conflicts with `launch_template_id`.
        /// </summary>
        public readonly string LaunchTemplateName;
        /// <summary>
        /// Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
        /// </summary>
        public readonly string? Version;

        [OutputConstructor]
        private GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification(
            string launchTemplateId,
            string launchTemplateName,
            string? version)
        {
            LaunchTemplateId = launchTemplateId;
            LaunchTemplateName = launchTemplateName;
            Version = version;
        }
    }

    [OutputType]
    public sealed class GroupMixedInstancesPolicyLaunchTemplateOverrides
    {
        /// <summary>
        /// Override the instance type in the Launch Template.
        /// </summary>
        public readonly string? InstanceType;
        /// <summary>
        /// The number of capacity units, which gives the instance type a proportional weight to other instance types.
        /// </summary>
        public readonly string? WeightedCapacity;

        [OutputConstructor]
        private GroupMixedInstancesPolicyLaunchTemplateOverrides(
            string? instanceType,
            string? weightedCapacity)
        {
            InstanceType = instanceType;
            WeightedCapacity = weightedCapacity;
        }
    }

    [OutputType]
    public sealed class GroupTags
    {
        /// <summary>
        /// Key
        /// </summary>
        public readonly string Key;
        /// <summary>
        /// Enables propagation of the tag to
        /// Amazon EC2 instances launched via this ASG
        /// </summary>
        public readonly bool PropagateAtLaunch;
        /// <summary>
        /// Value
        /// </summary>
        public readonly string Value;

        [OutputConstructor]
        private GroupTags(
            string key,
            bool propagateAtLaunch,
            string value)
        {
            Key = key;
            PropagateAtLaunch = propagateAtLaunch;
            Value = value;
        }
    }
    }
}
