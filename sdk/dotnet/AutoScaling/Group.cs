// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Aws.AutoScaling
{
    /// <summary>
    /// Provides an Auto Scaling Group resource.
    /// 
    /// &gt; **Note:** You must specify either `launch_configuration`, `launch_template`, or `mixed_instances_policy`.
    /// 
    /// &gt; **NOTE on Auto Scaling Groups and ASG Attachments:** This provider currently provides
    /// both a standalone `aws.autoscaling.Attachment` resource
    /// (describing an ASG attached to an ELB or ALB), and an `aws.autoscaling.Group`
    /// with `load_balancers` and `target_group_arns` defined in-line. These two methods are not
    /// mutually-exclusive. If `aws.autoscaling.Attachment` resources are used, either alone or with inline
    /// `load_balancers` or `target_group_arns`, the `aws.autoscaling.Group` resource must be configured
    /// to ignore changes to the `load_balancers` and `target_group_arns` arguments.
    /// 
    /// ## Example Usage
    /// ### With Latest Version Of Launch Template
    /// 
    /// ```csharp
    /// using Pulumi;
    /// using Aws = Pulumi.Aws;
    /// 
    /// class MyStack : Stack
    /// {
    ///     public MyStack()
    ///     {
    ///         var foobar = new Aws.Ec2.LaunchTemplate("foobar", new Aws.Ec2.LaunchTemplateArgs
    ///         {
    ///             NamePrefix = "foobar",
    ///             ImageId = "ami-1a2b3c",
    ///             InstanceType = "t2.micro",
    ///         });
    ///         var bar = new Aws.AutoScaling.Group("bar", new Aws.AutoScaling.GroupArgs
    ///         {
    ///             AvailabilityZones = 
    ///             {
    ///                 "us-east-1a",
    ///             },
    ///             DesiredCapacity = 1,
    ///             MaxSize = 1,
    ///             MinSize = 1,
    ///             LaunchTemplate = new Aws.AutoScaling.Inputs.GroupLaunchTemplateArgs
    ///             {
    ///                 Id = foobar.Id,
    ///                 Version = "$Latest",
    ///             },
    ///         });
    ///     }
    /// 
    /// }
    /// ```
    /// ### Mixed Instances Policy
    /// 
    /// ```csharp
    /// using Pulumi;
    /// using Aws = Pulumi.Aws;
    /// 
    /// class MyStack : Stack
    /// {
    ///     public MyStack()
    ///     {
    ///         var exampleLaunchTemplate = new Aws.Ec2.LaunchTemplate("exampleLaunchTemplate", new Aws.Ec2.LaunchTemplateArgs
    ///         {
    ///             NamePrefix = "example",
    ///             ImageId = data.Aws_ami.Example.Id,
    ///             InstanceType = "c5.large",
    ///         });
    ///         var exampleGroup = new Aws.AutoScaling.Group("exampleGroup", new Aws.AutoScaling.GroupArgs
    ///         {
    ///             AvailabilityZones = 
    ///             {
    ///                 "us-east-1a",
    ///             },
    ///             DesiredCapacity = 1,
    ///             MaxSize = 1,
    ///             MinSize = 1,
    ///             MixedInstancesPolicy = new Aws.AutoScaling.Inputs.GroupMixedInstancesPolicyArgs
    ///             {
    ///                 LaunchTemplate = new Aws.AutoScaling.Inputs.GroupMixedInstancesPolicyLaunchTemplateArgs
    ///                 {
    ///                     LaunchTemplateSpecification = new Aws.AutoScaling.Inputs.GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationArgs
    ///                     {
    ///                         LaunchTemplateId = exampleLaunchTemplate.Id,
    ///                     },
    ///                     Overrides = 
    ///                     {
    ///                         new Aws.AutoScaling.Inputs.GroupMixedInstancesPolicyLaunchTemplateOverrideArgs
    ///                         {
    ///                             InstanceType = "c4.large",
    ///                             WeightedCapacity = "3",
    ///                         },
    ///                         new Aws.AutoScaling.Inputs.GroupMixedInstancesPolicyLaunchTemplateOverrideArgs
    ///                         {
    ///                             InstanceType = "c3.large",
    ///                             WeightedCapacity = "2",
    ///                         },
    ///                     },
    ///                 },
    ///             },
    ///         });
    ///     }
    /// 
    /// }
    /// ```
    /// ### Mixed Instances Policy with Spot Instances and Capacity Rebalance
    /// 
    /// ```csharp
    /// using Pulumi;
    /// using Aws = Pulumi.Aws;
    /// 
    /// class MyStack : Stack
    /// {
    ///     public MyStack()
    ///     {
    ///         var exampleLaunchTemplate = new Aws.Ec2.LaunchTemplate("exampleLaunchTemplate", new Aws.Ec2.LaunchTemplateArgs
    ///         {
    ///             NamePrefix = "example",
    ///             ImageId = data.Aws_ami.Example.Id,
    ///             InstanceType = "c5.large",
    ///         });
    ///         var exampleGroup = new Aws.AutoScaling.Group("exampleGroup", new Aws.AutoScaling.GroupArgs
    ///         {
    ///             CapacityRebalance = true,
    ///             DesiredCapacity = 12,
    ///             MaxSize = 15,
    ///             MinSize = 12,
    ///             VpcZoneIdentifiers = 
    ///             {
    ///                 aws_subnet.Example1.Id,
    ///                 aws_subnet.Example2.Id,
    ///             },
    ///             MixedInstancesPolicy = new Aws.AutoScaling.Inputs.GroupMixedInstancesPolicyArgs
    ///             {
    ///                 InstancesDistribution = new Aws.AutoScaling.Inputs.GroupMixedInstancesPolicyInstancesDistributionArgs
    ///                 {
    ///                     OnDemandBaseCapacity = 0,
    ///                     OnDemandPercentageAboveBaseCapacity = 25,
    ///                     SpotAllocationStrategy = "capacity-optimized",
    ///                 },
    ///                 LaunchTemplate = new Aws.AutoScaling.Inputs.GroupMixedInstancesPolicyLaunchTemplateArgs
    ///                 {
    ///                     LaunchTemplateSpecification = new Aws.AutoScaling.Inputs.GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationArgs
    ///                     {
    ///                         LaunchTemplateId = exampleLaunchTemplate.Id,
    ///                     },
    ///                     Overrides = 
    ///                     {
    ///                         new Aws.AutoScaling.Inputs.GroupMixedInstancesPolicyLaunchTemplateOverrideArgs
    ///                         {
    ///                             InstanceType = "c4.large",
    ///                             WeightedCapacity = "3",
    ///                         },
    ///                         new Aws.AutoScaling.Inputs.GroupMixedInstancesPolicyLaunchTemplateOverrideArgs
    ///                         {
    ///                             InstanceType = "c3.large",
    ///                             WeightedCapacity = "2",
    ///                         },
    ///                     },
    ///                 },
    ///             },
    ///         });
    ///     }
    /// 
    /// }
    /// ```
    /// ### Mixed Instances Policy with Instance level LaunchTemplateSpecification Overrides
    /// 
    /// When using a diverse instance set, some instance types might require a launch template with configuration values unique to that instance type such as a different AMI (Graviton2), architecture specific user data script, different EBS configuration, or different networking configuration.
    /// 
    /// ```csharp
    /// using Pulumi;
    /// using Aws = Pulumi.Aws;
    /// 
    /// class MyStack : Stack
    /// {
    ///     public MyStack()
    ///     {
    ///         var exampleLaunchTemplate = new Aws.Ec2.LaunchTemplate("exampleLaunchTemplate", new Aws.Ec2.LaunchTemplateArgs
    ///         {
    ///             NamePrefix = "example",
    ///             ImageId = data.Aws_ami.Example.Id,
    ///             InstanceType = "c5.large",
    ///         });
    ///         var example2 = new Aws.Ec2.LaunchTemplate("example2", new Aws.Ec2.LaunchTemplateArgs
    ///         {
    ///             NamePrefix = "example2",
    ///             ImageId = data.Aws_ami.Example2.Id,
    ///         });
    ///         var exampleGroup = new Aws.AutoScaling.Group("exampleGroup", new Aws.AutoScaling.GroupArgs
    ///         {
    ///             AvailabilityZones = 
    ///             {
    ///                 "us-east-1a",
    ///             },
    ///             DesiredCapacity = 1,
    ///             MaxSize = 1,
    ///             MinSize = 1,
    ///             MixedInstancesPolicy = new Aws.AutoScaling.Inputs.GroupMixedInstancesPolicyArgs
    ///             {
    ///                 LaunchTemplate = new Aws.AutoScaling.Inputs.GroupMixedInstancesPolicyLaunchTemplateArgs
    ///                 {
    ///                     LaunchTemplateSpecification = new Aws.AutoScaling.Inputs.GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationArgs
    ///                     {
    ///                         LaunchTemplateId = exampleLaunchTemplate.Id,
    ///                     },
    ///                     Overrides = 
    ///                     {
    ///                         new Aws.AutoScaling.Inputs.GroupMixedInstancesPolicyLaunchTemplateOverrideArgs
    ///                         {
    ///                             InstanceType = "c4.large",
    ///                             WeightedCapacity = "3",
    ///                         },
    ///                         new Aws.AutoScaling.Inputs.GroupMixedInstancesPolicyLaunchTemplateOverrideArgs
    ///                         {
    ///                             InstanceType = "c6g.large",
    ///                             LaunchTemplateSpecification = new Aws.AutoScaling.Inputs.GroupMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationArgs
    ///                             {
    ///                                 LaunchTemplateId = example2.Id,
    ///                             },
    ///                             WeightedCapacity = "2",
    ///                         },
    ///                     },
    ///                 },
    ///             },
    ///         });
    ///     }
    /// 
    /// }
    /// ```
    /// ### Automatically refresh all instances after the group is updated
    /// 
    /// ```csharp
    /// using Pulumi;
    /// using Aws = Pulumi.Aws;
    /// 
    /// class MyStack : Stack
    /// {
    ///     public MyStack()
    ///     {
    ///         var exampleAmi = Output.Create(Aws.Ec2.GetAmi.InvokeAsync(new Aws.Ec2.GetAmiArgs
    ///         {
    ///             MostRecent = true,
    ///             Owners = 
    ///             {
    ///                 "amazon",
    ///             },
    ///             Filters = 
    ///             {
    ///                 new Aws.Ec2.Inputs.GetAmiFilterArgs
    ///                 {
    ///                     Name = "name",
    ///                     Values = 
    ///                     {
    ///                         "amzn-ami-hvm-*-x86_64-gp2",
    ///                     },
    ///                 },
    ///             },
    ///         }));
    ///         var exampleLaunchTemplate = new Aws.Ec2.LaunchTemplate("exampleLaunchTemplate", new Aws.Ec2.LaunchTemplateArgs
    ///         {
    ///             ImageId = exampleAmi.Apply(exampleAmi =&gt; exampleAmi.Id),
    ///             InstanceType = "t3.nano",
    ///         });
    ///         var exampleGroup = new Aws.AutoScaling.Group("exampleGroup", new Aws.AutoScaling.GroupArgs
    ///         {
    ///             AvailabilityZones = 
    ///             {
    ///                 "us-east-1a",
    ///             },
    ///             DesiredCapacity = 1,
    ///             MaxSize = 2,
    ///             MinSize = 1,
    ///             LaunchTemplate = new Aws.AutoScaling.Inputs.GroupLaunchTemplateArgs
    ///             {
    ///                 Id = exampleLaunchTemplate.Id,
    ///                 Version = exampleLaunchTemplate.LatestVersion,
    ///             },
    ///             Tags = 
    ///             {
    ///                 new Aws.AutoScaling.Inputs.GroupTagArgs
    ///                 {
    ///                     Key = "Key",
    ///                     Value = "Value",
    ///                     PropagateAtLaunch = true,
    ///                 },
    ///             },
    ///             InstanceRefresh = new Aws.AutoScaling.Inputs.GroupInstanceRefreshArgs
    ///             {
    ///                 Strategy = "Rolling",
    ///                 Preferences = new Aws.AutoScaling.Inputs.GroupInstanceRefreshPreferencesArgs
    ///                 {
    ///                     MinHealthyPercentage = 50,
    ///                 },
    ///                 Triggers = 
    ///                 {
    ///                     "tag",
    ///                 },
    ///             },
    ///         });
    ///     }
    /// 
    /// }
    /// ```
    /// ### Auto Scaling group with Warm Pool
    /// 
    /// ```csharp
    /// using Pulumi;
    /// using Aws = Pulumi.Aws;
    /// 
    /// class MyStack : Stack
    /// {
    ///     public MyStack()
    ///     {
    ///         var exampleLaunchTemplate = new Aws.Ec2.LaunchTemplate("exampleLaunchTemplate", new Aws.Ec2.LaunchTemplateArgs
    ///         {
    ///             NamePrefix = "example",
    ///             ImageId = data.Aws_ami.Example.Id,
    ///             InstanceType = "c5.large",
    ///         });
    ///         var exampleGroup = new Aws.AutoScaling.Group("exampleGroup", new Aws.AutoScaling.GroupArgs
    ///         {
    ///             AvailabilityZones = 
    ///             {
    ///                 "us-east-1a",
    ///             },
    ///             DesiredCapacity = 1,
    ///             MaxSize = 5,
    ///             MinSize = 1,
    ///             WarmPool = new Aws.AutoScaling.Inputs.GroupWarmPoolArgs
    ///             {
    ///                 PoolState = "Stopped",
    ///                 MinSize = 1,
    ///                 MaxGroupPreparedCapacity = 10,
    ///             },
    ///         });
    ///     }
    /// 
    /// }
    /// ```
    /// ## Waiting for Capacity
    /// 
    /// A newly-created ASG is initially empty and begins to scale to `min_size` (or
    /// `desired_capacity`, if specified) by launching instances using the provided
    /// Launch Configuration. These instances take time to launch and boot.
    /// 
    /// On ASG Update, changes to these values also take time to result in the target
    /// number of instances providing service.
    /// 
    /// This provider provides two mechanisms to help consistently manage ASG scale up
    /// time across dependent resources.
    /// 
    /// #### Waiting for ASG Capacity
    /// 
    /// The first is default behavior. This provider waits after ASG creation for
    /// `min_size` (or `desired_capacity`, if specified) healthy instances to show up
    /// in the ASG before continuing.
    /// 
    /// If `min_size` or `desired_capacity` are changed in a subsequent update,
    /// this provider will also wait for the correct number of healthy instances before
    /// continuing.
    /// 
    /// This provider considers an instance "healthy" when the ASG reports `HealthStatus:
    /// "Healthy"` and `LifecycleState: "InService"`. See the [AWS AutoScaling
    /// Docs](https://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/AutoScalingGroupLifecycle.html)
    /// for more information on an ASG's lifecycle.
    /// 
    /// This provider will wait for healthy instances for up to
    /// `wait_for_capacity_timeout`. If ASG creation is taking more than a few minutes,
    /// it's worth investigating for scaling activity errors, which can be caused by
    /// problems with the selected Launch Configuration.
    /// 
    /// Setting `wait_for_capacity_timeout` to `"0"` disables ASG Capacity waiting.
    /// 
    /// #### Waiting for ELB Capacity
    /// 
    /// The second mechanism is optional, and affects ASGs with attached ELBs specified
    /// via the `load_balancers` attribute or with ALBs specified with `target_group_arns`.
    /// 
    /// The `min_elb_capacity` parameter causes this provider to wait for at least the
    /// requested number of instances to show up `"InService"` in all attached ELBs
    /// during ASG creation.  It has no effect on ASG updates.
    /// 
    /// If `wait_for_elb_capacity` is set, this provider will wait for exactly that number
    /// of Instances to be `"InService"` in all attached ELBs on both creation and
    /// updates.
    /// 
    /// These parameters can be used to ensure that service is being provided before
    /// this provider moves on. If new instances don't pass the ELB's health checks for any
    /// reason, the deployment will time out, and the ASG will be marked as
    /// tainted (i.e. marked to be destroyed in a follow up run).
    /// 
    /// As with ASG Capacity, this provider will wait for up to `wait_for_capacity_timeout`
    /// for the proper number of instances to be healthy.
    /// 
    /// #### Troubleshooting Capacity Waiting Timeouts
    /// 
    /// If ASG creation takes more than a few minutes, this could indicate one of a
    /// number of configuration problems. See the [AWS Docs on Load Balancer
    /// Troubleshooting](https://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/elb-troubleshooting.html)
    /// for more information.
    /// 
    /// ## Import
    /// 
    /// Auto Scaling Groups can be imported using the `name`, e.g.
    /// 
    /// ```sh
    ///  $ pulumi import aws:autoscaling/group:Group web web-asg
    /// ```
    /// </summary>
    [AwsResourceType("aws:autoscaling/group:Group")]
    public partial class Group : Pulumi.CustomResource
    {
        /// <summary>
        /// The ARN for this Auto Scaling Group
        /// </summary>
        [Output("arn")]
        public Output<string> Arn { get; private set; } = null!;

        /// <summary>
        /// A list of one or more availability zones for the group. Used for EC2-Classic and default subnets when not specified with `vpc_zone_identifier` argument. Conflicts with `vpc_zone_identifier`.
        /// </summary>
        [Output("availabilityZones")]
        public Output<ImmutableArray<string>> AvailabilityZones { get; private set; } = null!;

        /// <summary>
        /// Indicates whether capacity rebalance is enabled. Otherwise, capacity rebalance is disabled.
        /// </summary>
        [Output("capacityRebalance")]
        public Output<bool?> CapacityRebalance { get; private set; } = null!;

        /// <summary>
        /// The amount of time, in seconds, after a scaling activity completes before another scaling activity can start.
        /// </summary>
        [Output("defaultCooldown")]
        public Output<int> DefaultCooldown { get; private set; } = null!;

        /// <summary>
        /// The number of Amazon EC2 instances that
        /// should be running in the group. (See also Waiting for
        /// Capacity below.)
        /// </summary>
        [Output("desiredCapacity")]
        public Output<int> DesiredCapacity { get; private set; } = null!;

        /// <summary>
        /// A list of metrics to collect. The allowed values are `GroupDesiredCapacity`, `GroupInServiceCapacity`, `GroupPendingCapacity`, `GroupMinSize`, `GroupMaxSize`, `GroupInServiceInstances`, `GroupPendingInstances`, `GroupStandbyInstances`, `GroupStandbyCapacity`, `GroupTerminatingCapacity`, `GroupTerminatingInstances`, `GroupTotalCapacity`, `GroupTotalInstances`.
        /// </summary>
        [Output("enabledMetrics")]
        public Output<ImmutableArray<string>> EnabledMetrics { get; private set; } = null!;

        /// <summary>
        /// Allows deleting the Auto Scaling Group without waiting
        /// for all instances in the pool to terminate.  You can force an Auto Scaling Group to delete
        /// even if it's in the process of scaling a resource. Normally, this provider
        /// drains all the instances before deleting the group.  This bypasses that
        /// behavior and potentially leaves resources dangling.
        /// </summary>
        [Output("forceDelete")]
        public Output<bool?> ForceDelete { get; private set; } = null!;

        [Output("forceDeleteWarmPool")]
        public Output<bool?> ForceDeleteWarmPool { get; private set; } = null!;

        /// <summary>
        /// Time (in seconds) after instance comes into service before checking health.
        /// </summary>
        [Output("healthCheckGracePeriod")]
        public Output<int?> HealthCheckGracePeriod { get; private set; } = null!;

        /// <summary>
        /// "EC2" or "ELB". Controls how health checking is done.
        /// </summary>
        [Output("healthCheckType")]
        public Output<string> HealthCheckType { get; private set; } = null!;

        /// <summary>
        /// One or more
        /// [Lifecycle Hooks](http://docs.aws.amazon.com/autoscaling/latest/userguide/lifecycle-hooks.html)
        /// to attach to the Auto Scaling Group **before** instances are launched. The
        /// syntax is exactly the same as the separate
        /// `aws.autoscaling.LifecycleHook`
        /// resource, without the `autoscaling_group_name` attribute. Please note that this will only work when creating
        /// a new Auto Scaling Group. For all other use-cases, please use `aws.autoscaling.LifecycleHook` resource.
        /// </summary>
        [Output("initialLifecycleHooks")]
        public Output<ImmutableArray<Outputs.GroupInitialLifecycleHook>> InitialLifecycleHooks { get; private set; } = null!;

        /// <summary>
        /// If this block is configured, start an
        /// [Instance Refresh](https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-instance-refresh.html)
        /// when this Auto Scaling Group is updated. Defined below.
        /// </summary>
        [Output("instanceRefresh")]
        public Output<Outputs.GroupInstanceRefresh?> InstanceRefresh { get; private set; } = null!;

        /// <summary>
        /// The name of the launch configuration to use.
        /// </summary>
        [Output("launchConfiguration")]
        public Output<string?> LaunchConfiguration { get; private set; } = null!;

        /// <summary>
        /// Nested argument containing launch template settings along with the overrides to specify multiple instance types and weights. Defined below.
        /// </summary>
        [Output("launchTemplate")]
        public Output<Outputs.GroupLaunchTemplate?> LaunchTemplate { get; private set; } = null!;

        /// <summary>
        /// A list of elastic load balancer names to add to the autoscaling
        /// group names. Only valid for classic load balancers. For ALBs, use `target_group_arns` instead.
        /// </summary>
        [Output("loadBalancers")]
        public Output<ImmutableArray<string>> LoadBalancers { get; private set; } = null!;

        /// <summary>
        /// The maximum amount of time, in seconds, that an instance can be in service, values must be either equal to 0 or between 604800 and 31536000 seconds.
        /// </summary>
        [Output("maxInstanceLifetime")]
        public Output<int?> MaxInstanceLifetime { get; private set; } = null!;

        /// <summary>
        /// The maximum size of the Auto Scaling Group.
        /// </summary>
        [Output("maxSize")]
        public Output<int> MaxSize { get; private set; } = null!;

        /// <summary>
        /// The granularity to associate with the metrics to collect. The only valid value is `1Minute`. Default is `1Minute`.
        /// </summary>
        [Output("metricsGranularity")]
        public Output<string?> MetricsGranularity { get; private set; } = null!;

        /// <summary>
        /// Setting this causes the provider to wait for
        /// this number of instances from this Auto Scaling Group to show up healthy in the
        /// ELB only on creation. Updates will not wait on ELB instance number changes.
        /// (See also Waiting for Capacity below.)
        /// </summary>
        [Output("minElbCapacity")]
        public Output<int?> MinElbCapacity { get; private set; } = null!;

        /// <summary>
        /// Specifies the minimum number of instances to maintain in the warm pool. This helps you to ensure that there is always a certain number of warmed instances available to handle traffic spikes. Defaults to 0 if not specified.
        /// </summary>
        [Output("minSize")]
        public Output<int> MinSize { get; private set; } = null!;

        /// <summary>
        /// Configuration block containing settings to define launch targets for Auto Scaling groups. Defined below.
        /// </summary>
        [Output("mixedInstancesPolicy")]
        public Output<Outputs.GroupMixedInstancesPolicy?> MixedInstancesPolicy { get; private set; } = null!;

        /// <summary>
        /// The name of the Auto Scaling Group. By default generated by this provider. Conflicts with `name_prefix`.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Creates a unique name beginning with the specified
        /// prefix. Conflicts with `name`.
        /// </summary>
        [Output("namePrefix")]
        public Output<string> NamePrefix { get; private set; } = null!;

        /// <summary>
        /// The name of the placement group into which you'll launch your instances, if any.
        /// </summary>
        [Output("placementGroup")]
        public Output<string?> PlacementGroup { get; private set; } = null!;

        /// <summary>
        /// Allows setting instance protection. The
        /// Auto Scaling Group will not select instances with this setting for termination
        /// during scale in events.
        /// </summary>
        [Output("protectFromScaleIn")]
        public Output<bool?> ProtectFromScaleIn { get; private set; } = null!;

        /// <summary>
        /// The ARN of the service-linked role that the ASG will use to call other AWS services
        /// </summary>
        [Output("serviceLinkedRoleArn")]
        public Output<string> ServiceLinkedRoleArn { get; private set; } = null!;

        /// <summary>
        /// A list of processes to suspend for the Auto Scaling Group. The allowed values are `Launch`, `Terminate`, `HealthCheck`, `ReplaceUnhealthy`, `AZRebalance`, `AlarmNotification`, `ScheduledActions`, `AddToLoadBalancer`.
        /// Note that if you suspend either the `Launch` or `Terminate` process types, it can prevent your Auto Scaling Group from functioning properly.
        /// </summary>
        [Output("suspendedProcesses")]
        public Output<ImmutableArray<string>> SuspendedProcesses { get; private set; } = null!;

        /// <summary>
        /// Configuration block(s) containing resource tags. Conflicts with `tags`. Documented below.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableArray<Outputs.GroupTag>> Tags { get; private set; } = null!;

        /// <summary>
        /// Set of maps containing resource tags. Conflicts with `tag`. Documented below.
        /// </summary>
        [Output("tagsCollection")]
        public Output<ImmutableArray<ImmutableDictionary<string, string>>> TagsCollection { get; private set; } = null!;

        /// <summary>
        /// A set of `aws.alb.TargetGroup` ARNs, for use with Application or Network Load Balancing.
        /// </summary>
        [Output("targetGroupArns")]
        public Output<ImmutableArray<string>> TargetGroupArns { get; private set; } = null!;

        /// <summary>
        /// A list of policies to decide how the instances in the Auto Scaling Group should be terminated. The allowed values are `OldestInstance`, `NewestInstance`, `OldestLaunchConfiguration`, `ClosestToNextInstanceHour`, `OldestLaunchTemplate`, `AllocationStrategy`, `Default`.
        /// </summary>
        [Output("terminationPolicies")]
        public Output<ImmutableArray<string>> TerminationPolicies { get; private set; } = null!;

        /// <summary>
        /// A list of subnet IDs to launch resources in. Subnets automatically determine which availability zones the group will reside. Conflicts with `availability_zones`.
        /// </summary>
        [Output("vpcZoneIdentifiers")]
        public Output<ImmutableArray<string>> VpcZoneIdentifiers { get; private set; } = null!;

        /// <summary>
        /// A maximum
        /// [duration](https://golang.org/pkg/time/#ParseDuration) that this provider should
        /// wait for ASG instances to be healthy before timing out.  (See also Waiting
        /// for Capacity below.) Setting this to "0" causes
        /// this provider to skip all Capacity Waiting behavior.
        /// </summary>
        [Output("waitForCapacityTimeout")]
        public Output<string?> WaitForCapacityTimeout { get; private set; } = null!;

        /// <summary>
        /// Setting this will cause the provider to wait
        /// for exactly this number of healthy instances from this Auto Scaling Group in
        /// all attached load balancers on both create and update operations. (Takes
        /// precedence over `min_elb_capacity` behavior.)
        /// (See also Waiting for Capacity below.)
        /// </summary>
        [Output("waitForElbCapacity")]
        public Output<int?> WaitForElbCapacity { get; private set; } = null!;

        /// <summary>
        /// If this block is configured, add a [Warm Pool](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-warm-pools.html)
        /// to the specified Auto Scaling group. Defined below
        /// </summary>
        [Output("warmPool")]
        public Output<Outputs.GroupWarmPool?> WarmPool { get; private set; } = null!;


        /// <summary>
        /// Create a Group resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Group(string name, GroupArgs args, CustomResourceOptions? options = null)
            : base("aws:autoscaling/group:Group", name, args ?? new GroupArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Group(string name, Input<string> id, GroupState? state = null, CustomResourceOptions? options = null)
            : base("aws:autoscaling/group:Group", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Group resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Group Get(string name, Input<string> id, GroupState? state = null, CustomResourceOptions? options = null)
        {
            return new Group(name, id, state, options);
        }
    }

    public sealed class GroupArgs : Pulumi.ResourceArgs
    {
        [Input("availabilityZones")]
        private InputList<string>? _availabilityZones;

        /// <summary>
        /// A list of one or more availability zones for the group. Used for EC2-Classic and default subnets when not specified with `vpc_zone_identifier` argument. Conflicts with `vpc_zone_identifier`.
        /// </summary>
        public InputList<string> AvailabilityZones
        {
            get => _availabilityZones ?? (_availabilityZones = new InputList<string>());
            set => _availabilityZones = value;
        }

        /// <summary>
        /// Indicates whether capacity rebalance is enabled. Otherwise, capacity rebalance is disabled.
        /// </summary>
        [Input("capacityRebalance")]
        public Input<bool>? CapacityRebalance { get; set; }

        /// <summary>
        /// The amount of time, in seconds, after a scaling activity completes before another scaling activity can start.
        /// </summary>
        [Input("defaultCooldown")]
        public Input<int>? DefaultCooldown { get; set; }

        /// <summary>
        /// The number of Amazon EC2 instances that
        /// should be running in the group. (See also Waiting for
        /// Capacity below.)
        /// </summary>
        [Input("desiredCapacity")]
        public Input<int>? DesiredCapacity { get; set; }

        [Input("enabledMetrics")]
        private InputList<string>? _enabledMetrics;

        /// <summary>
        /// A list of metrics to collect. The allowed values are `GroupDesiredCapacity`, `GroupInServiceCapacity`, `GroupPendingCapacity`, `GroupMinSize`, `GroupMaxSize`, `GroupInServiceInstances`, `GroupPendingInstances`, `GroupStandbyInstances`, `GroupStandbyCapacity`, `GroupTerminatingCapacity`, `GroupTerminatingInstances`, `GroupTotalCapacity`, `GroupTotalInstances`.
        /// </summary>
        public InputList<string> EnabledMetrics
        {
            get => _enabledMetrics ?? (_enabledMetrics = new InputList<string>());
            set => _enabledMetrics = value;
        }

        /// <summary>
        /// Allows deleting the Auto Scaling Group without waiting
        /// for all instances in the pool to terminate.  You can force an Auto Scaling Group to delete
        /// even if it's in the process of scaling a resource. Normally, this provider
        /// drains all the instances before deleting the group.  This bypasses that
        /// behavior and potentially leaves resources dangling.
        /// </summary>
        [Input("forceDelete")]
        public Input<bool>? ForceDelete { get; set; }

        [Input("forceDeleteWarmPool")]
        public Input<bool>? ForceDeleteWarmPool { get; set; }

        /// <summary>
        /// Time (in seconds) after instance comes into service before checking health.
        /// </summary>
        [Input("healthCheckGracePeriod")]
        public Input<int>? HealthCheckGracePeriod { get; set; }

        /// <summary>
        /// "EC2" or "ELB". Controls how health checking is done.
        /// </summary>
        [Input("healthCheckType")]
        public Input<string>? HealthCheckType { get; set; }

        [Input("initialLifecycleHooks")]
        private InputList<Inputs.GroupInitialLifecycleHookArgs>? _initialLifecycleHooks;

        /// <summary>
        /// One or more
        /// [Lifecycle Hooks](http://docs.aws.amazon.com/autoscaling/latest/userguide/lifecycle-hooks.html)
        /// to attach to the Auto Scaling Group **before** instances are launched. The
        /// syntax is exactly the same as the separate
        /// `aws.autoscaling.LifecycleHook`
        /// resource, without the `autoscaling_group_name` attribute. Please note that this will only work when creating
        /// a new Auto Scaling Group. For all other use-cases, please use `aws.autoscaling.LifecycleHook` resource.
        /// </summary>
        public InputList<Inputs.GroupInitialLifecycleHookArgs> InitialLifecycleHooks
        {
            get => _initialLifecycleHooks ?? (_initialLifecycleHooks = new InputList<Inputs.GroupInitialLifecycleHookArgs>());
            set => _initialLifecycleHooks = value;
        }

        /// <summary>
        /// If this block is configured, start an
        /// [Instance Refresh](https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-instance-refresh.html)
        /// when this Auto Scaling Group is updated. Defined below.
        /// </summary>
        [Input("instanceRefresh")]
        public Input<Inputs.GroupInstanceRefreshArgs>? InstanceRefresh { get; set; }

        /// <summary>
        /// The name of the launch configuration to use.
        /// </summary>
        [Input("launchConfiguration")]
        public Input<string>? LaunchConfiguration { get; set; }

        /// <summary>
        /// Nested argument containing launch template settings along with the overrides to specify multiple instance types and weights. Defined below.
        /// </summary>
        [Input("launchTemplate")]
        public Input<Inputs.GroupLaunchTemplateArgs>? LaunchTemplate { get; set; }

        [Input("loadBalancers")]
        private InputList<string>? _loadBalancers;

        /// <summary>
        /// A list of elastic load balancer names to add to the autoscaling
        /// group names. Only valid for classic load balancers. For ALBs, use `target_group_arns` instead.
        /// </summary>
        public InputList<string> LoadBalancers
        {
            get => _loadBalancers ?? (_loadBalancers = new InputList<string>());
            set => _loadBalancers = value;
        }

        /// <summary>
        /// The maximum amount of time, in seconds, that an instance can be in service, values must be either equal to 0 or between 604800 and 31536000 seconds.
        /// </summary>
        [Input("maxInstanceLifetime")]
        public Input<int>? MaxInstanceLifetime { get; set; }

        /// <summary>
        /// The maximum size of the Auto Scaling Group.
        /// </summary>
        [Input("maxSize", required: true)]
        public Input<int> MaxSize { get; set; } = null!;

        /// <summary>
        /// The granularity to associate with the metrics to collect. The only valid value is `1Minute`. Default is `1Minute`.
        /// </summary>
        [Input("metricsGranularity")]
        public InputUnion<string, Pulumi.Aws.AutoScaling.MetricsGranularity>? MetricsGranularity { get; set; }

        /// <summary>
        /// Setting this causes the provider to wait for
        /// this number of instances from this Auto Scaling Group to show up healthy in the
        /// ELB only on creation. Updates will not wait on ELB instance number changes.
        /// (See also Waiting for Capacity below.)
        /// </summary>
        [Input("minElbCapacity")]
        public Input<int>? MinElbCapacity { get; set; }

        /// <summary>
        /// Specifies the minimum number of instances to maintain in the warm pool. This helps you to ensure that there is always a certain number of warmed instances available to handle traffic spikes. Defaults to 0 if not specified.
        /// </summary>
        [Input("minSize", required: true)]
        public Input<int> MinSize { get; set; } = null!;

        /// <summary>
        /// Configuration block containing settings to define launch targets for Auto Scaling groups. Defined below.
        /// </summary>
        [Input("mixedInstancesPolicy")]
        public Input<Inputs.GroupMixedInstancesPolicyArgs>? MixedInstancesPolicy { get; set; }

        /// <summary>
        /// The name of the Auto Scaling Group. By default generated by this provider. Conflicts with `name_prefix`.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Creates a unique name beginning with the specified
        /// prefix. Conflicts with `name`.
        /// </summary>
        [Input("namePrefix")]
        public Input<string>? NamePrefix { get; set; }

        /// <summary>
        /// The name of the placement group into which you'll launch your instances, if any.
        /// </summary>
        [Input("placementGroup")]
        public Input<string>? PlacementGroup { get; set; }

        /// <summary>
        /// Allows setting instance protection. The
        /// Auto Scaling Group will not select instances with this setting for termination
        /// during scale in events.
        /// </summary>
        [Input("protectFromScaleIn")]
        public Input<bool>? ProtectFromScaleIn { get; set; }

        /// <summary>
        /// The ARN of the service-linked role that the ASG will use to call other AWS services
        /// </summary>
        [Input("serviceLinkedRoleArn")]
        public Input<string>? ServiceLinkedRoleArn { get; set; }

        [Input("suspendedProcesses")]
        private InputList<string>? _suspendedProcesses;

        /// <summary>
        /// A list of processes to suspend for the Auto Scaling Group. The allowed values are `Launch`, `Terminate`, `HealthCheck`, `ReplaceUnhealthy`, `AZRebalance`, `AlarmNotification`, `ScheduledActions`, `AddToLoadBalancer`.
        /// Note that if you suspend either the `Launch` or `Terminate` process types, it can prevent your Auto Scaling Group from functioning properly.
        /// </summary>
        public InputList<string> SuspendedProcesses
        {
            get => _suspendedProcesses ?? (_suspendedProcesses = new InputList<string>());
            set => _suspendedProcesses = value;
        }

        [Input("tags")]
        private InputList<Inputs.GroupTagArgs>? _tags;

        /// <summary>
        /// Configuration block(s) containing resource tags. Conflicts with `tags`. Documented below.
        /// </summary>
        public InputList<Inputs.GroupTagArgs> Tags
        {
            get => _tags ?? (_tags = new InputList<Inputs.GroupTagArgs>());
            set => _tags = value;
        }

        [Input("tagsCollection")]
        private InputList<ImmutableDictionary<string, Input<string>>>? _tagsCollection;

        /// <summary>
        /// Set of maps containing resource tags. Conflicts with `tag`. Documented below.
        /// </summary>
        public InputList<ImmutableDictionary<string, Input<string>>> TagsCollection
        {
            get => _tagsCollection ?? (_tagsCollection = new InputList<ImmutableDictionary<string, Input<string>>>());
            set => _tagsCollection = value;
        }

        [Input("targetGroupArns")]
        private InputList<string>? _targetGroupArns;

        /// <summary>
        /// A set of `aws.alb.TargetGroup` ARNs, for use with Application or Network Load Balancing.
        /// </summary>
        public InputList<string> TargetGroupArns
        {
            get => _targetGroupArns ?? (_targetGroupArns = new InputList<string>());
            set => _targetGroupArns = value;
        }

        [Input("terminationPolicies")]
        private InputList<string>? _terminationPolicies;

        /// <summary>
        /// A list of policies to decide how the instances in the Auto Scaling Group should be terminated. The allowed values are `OldestInstance`, `NewestInstance`, `OldestLaunchConfiguration`, `ClosestToNextInstanceHour`, `OldestLaunchTemplate`, `AllocationStrategy`, `Default`.
        /// </summary>
        public InputList<string> TerminationPolicies
        {
            get => _terminationPolicies ?? (_terminationPolicies = new InputList<string>());
            set => _terminationPolicies = value;
        }

        [Input("vpcZoneIdentifiers")]
        private InputList<string>? _vpcZoneIdentifiers;

        /// <summary>
        /// A list of subnet IDs to launch resources in. Subnets automatically determine which availability zones the group will reside. Conflicts with `availability_zones`.
        /// </summary>
        public InputList<string> VpcZoneIdentifiers
        {
            get => _vpcZoneIdentifiers ?? (_vpcZoneIdentifiers = new InputList<string>());
            set => _vpcZoneIdentifiers = value;
        }

        /// <summary>
        /// A maximum
        /// [duration](https://golang.org/pkg/time/#ParseDuration) that this provider should
        /// wait for ASG instances to be healthy before timing out.  (See also Waiting
        /// for Capacity below.) Setting this to "0" causes
        /// this provider to skip all Capacity Waiting behavior.
        /// </summary>
        [Input("waitForCapacityTimeout")]
        public Input<string>? WaitForCapacityTimeout { get; set; }

        /// <summary>
        /// Setting this will cause the provider to wait
        /// for exactly this number of healthy instances from this Auto Scaling Group in
        /// all attached load balancers on both create and update operations. (Takes
        /// precedence over `min_elb_capacity` behavior.)
        /// (See also Waiting for Capacity below.)
        /// </summary>
        [Input("waitForElbCapacity")]
        public Input<int>? WaitForElbCapacity { get; set; }

        /// <summary>
        /// If this block is configured, add a [Warm Pool](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-warm-pools.html)
        /// to the specified Auto Scaling group. Defined below
        /// </summary>
        [Input("warmPool")]
        public Input<Inputs.GroupWarmPoolArgs>? WarmPool { get; set; }

        public GroupArgs()
        {
        }
    }

    public sealed class GroupState : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The ARN for this Auto Scaling Group
        /// </summary>
        [Input("arn")]
        public Input<string>? Arn { get; set; }

        [Input("availabilityZones")]
        private InputList<string>? _availabilityZones;

        /// <summary>
        /// A list of one or more availability zones for the group. Used for EC2-Classic and default subnets when not specified with `vpc_zone_identifier` argument. Conflicts with `vpc_zone_identifier`.
        /// </summary>
        public InputList<string> AvailabilityZones
        {
            get => _availabilityZones ?? (_availabilityZones = new InputList<string>());
            set => _availabilityZones = value;
        }

        /// <summary>
        /// Indicates whether capacity rebalance is enabled. Otherwise, capacity rebalance is disabled.
        /// </summary>
        [Input("capacityRebalance")]
        public Input<bool>? CapacityRebalance { get; set; }

        /// <summary>
        /// The amount of time, in seconds, after a scaling activity completes before another scaling activity can start.
        /// </summary>
        [Input("defaultCooldown")]
        public Input<int>? DefaultCooldown { get; set; }

        /// <summary>
        /// The number of Amazon EC2 instances that
        /// should be running in the group. (See also Waiting for
        /// Capacity below.)
        /// </summary>
        [Input("desiredCapacity")]
        public Input<int>? DesiredCapacity { get; set; }

        [Input("enabledMetrics")]
        private InputList<string>? _enabledMetrics;

        /// <summary>
        /// A list of metrics to collect. The allowed values are `GroupDesiredCapacity`, `GroupInServiceCapacity`, `GroupPendingCapacity`, `GroupMinSize`, `GroupMaxSize`, `GroupInServiceInstances`, `GroupPendingInstances`, `GroupStandbyInstances`, `GroupStandbyCapacity`, `GroupTerminatingCapacity`, `GroupTerminatingInstances`, `GroupTotalCapacity`, `GroupTotalInstances`.
        /// </summary>
        public InputList<string> EnabledMetrics
        {
            get => _enabledMetrics ?? (_enabledMetrics = new InputList<string>());
            set => _enabledMetrics = value;
        }

        /// <summary>
        /// Allows deleting the Auto Scaling Group without waiting
        /// for all instances in the pool to terminate.  You can force an Auto Scaling Group to delete
        /// even if it's in the process of scaling a resource. Normally, this provider
        /// drains all the instances before deleting the group.  This bypasses that
        /// behavior and potentially leaves resources dangling.
        /// </summary>
        [Input("forceDelete")]
        public Input<bool>? ForceDelete { get; set; }

        [Input("forceDeleteWarmPool")]
        public Input<bool>? ForceDeleteWarmPool { get; set; }

        /// <summary>
        /// Time (in seconds) after instance comes into service before checking health.
        /// </summary>
        [Input("healthCheckGracePeriod")]
        public Input<int>? HealthCheckGracePeriod { get; set; }

        /// <summary>
        /// "EC2" or "ELB". Controls how health checking is done.
        /// </summary>
        [Input("healthCheckType")]
        public Input<string>? HealthCheckType { get; set; }

        [Input("initialLifecycleHooks")]
        private InputList<Inputs.GroupInitialLifecycleHookGetArgs>? _initialLifecycleHooks;

        /// <summary>
        /// One or more
        /// [Lifecycle Hooks](http://docs.aws.amazon.com/autoscaling/latest/userguide/lifecycle-hooks.html)
        /// to attach to the Auto Scaling Group **before** instances are launched. The
        /// syntax is exactly the same as the separate
        /// `aws.autoscaling.LifecycleHook`
        /// resource, without the `autoscaling_group_name` attribute. Please note that this will only work when creating
        /// a new Auto Scaling Group. For all other use-cases, please use `aws.autoscaling.LifecycleHook` resource.
        /// </summary>
        public InputList<Inputs.GroupInitialLifecycleHookGetArgs> InitialLifecycleHooks
        {
            get => _initialLifecycleHooks ?? (_initialLifecycleHooks = new InputList<Inputs.GroupInitialLifecycleHookGetArgs>());
            set => _initialLifecycleHooks = value;
        }

        /// <summary>
        /// If this block is configured, start an
        /// [Instance Refresh](https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-instance-refresh.html)
        /// when this Auto Scaling Group is updated. Defined below.
        /// </summary>
        [Input("instanceRefresh")]
        public Input<Inputs.GroupInstanceRefreshGetArgs>? InstanceRefresh { get; set; }

        /// <summary>
        /// The name of the launch configuration to use.
        /// </summary>
        [Input("launchConfiguration")]
        public Input<string>? LaunchConfiguration { get; set; }

        /// <summary>
        /// Nested argument containing launch template settings along with the overrides to specify multiple instance types and weights. Defined below.
        /// </summary>
        [Input("launchTemplate")]
        public Input<Inputs.GroupLaunchTemplateGetArgs>? LaunchTemplate { get; set; }

        [Input("loadBalancers")]
        private InputList<string>? _loadBalancers;

        /// <summary>
        /// A list of elastic load balancer names to add to the autoscaling
        /// group names. Only valid for classic load balancers. For ALBs, use `target_group_arns` instead.
        /// </summary>
        public InputList<string> LoadBalancers
        {
            get => _loadBalancers ?? (_loadBalancers = new InputList<string>());
            set => _loadBalancers = value;
        }

        /// <summary>
        /// The maximum amount of time, in seconds, that an instance can be in service, values must be either equal to 0 or between 604800 and 31536000 seconds.
        /// </summary>
        [Input("maxInstanceLifetime")]
        public Input<int>? MaxInstanceLifetime { get; set; }

        /// <summary>
        /// The maximum size of the Auto Scaling Group.
        /// </summary>
        [Input("maxSize")]
        public Input<int>? MaxSize { get; set; }

        /// <summary>
        /// The granularity to associate with the metrics to collect. The only valid value is `1Minute`. Default is `1Minute`.
        /// </summary>
        [Input("metricsGranularity")]
        public InputUnion<string, Pulumi.Aws.AutoScaling.MetricsGranularity>? MetricsGranularity { get; set; }

        /// <summary>
        /// Setting this causes the provider to wait for
        /// this number of instances from this Auto Scaling Group to show up healthy in the
        /// ELB only on creation. Updates will not wait on ELB instance number changes.
        /// (See also Waiting for Capacity below.)
        /// </summary>
        [Input("minElbCapacity")]
        public Input<int>? MinElbCapacity { get; set; }

        /// <summary>
        /// Specifies the minimum number of instances to maintain in the warm pool. This helps you to ensure that there is always a certain number of warmed instances available to handle traffic spikes. Defaults to 0 if not specified.
        /// </summary>
        [Input("minSize")]
        public Input<int>? MinSize { get; set; }

        /// <summary>
        /// Configuration block containing settings to define launch targets for Auto Scaling groups. Defined below.
        /// </summary>
        [Input("mixedInstancesPolicy")]
        public Input<Inputs.GroupMixedInstancesPolicyGetArgs>? MixedInstancesPolicy { get; set; }

        /// <summary>
        /// The name of the Auto Scaling Group. By default generated by this provider. Conflicts with `name_prefix`.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Creates a unique name beginning with the specified
        /// prefix. Conflicts with `name`.
        /// </summary>
        [Input("namePrefix")]
        public Input<string>? NamePrefix { get; set; }

        /// <summary>
        /// The name of the placement group into which you'll launch your instances, if any.
        /// </summary>
        [Input("placementGroup")]
        public Input<string>? PlacementGroup { get; set; }

        /// <summary>
        /// Allows setting instance protection. The
        /// Auto Scaling Group will not select instances with this setting for termination
        /// during scale in events.
        /// </summary>
        [Input("protectFromScaleIn")]
        public Input<bool>? ProtectFromScaleIn { get; set; }

        /// <summary>
        /// The ARN of the service-linked role that the ASG will use to call other AWS services
        /// </summary>
        [Input("serviceLinkedRoleArn")]
        public Input<string>? ServiceLinkedRoleArn { get; set; }

        [Input("suspendedProcesses")]
        private InputList<string>? _suspendedProcesses;

        /// <summary>
        /// A list of processes to suspend for the Auto Scaling Group. The allowed values are `Launch`, `Terminate`, `HealthCheck`, `ReplaceUnhealthy`, `AZRebalance`, `AlarmNotification`, `ScheduledActions`, `AddToLoadBalancer`.
        /// Note that if you suspend either the `Launch` or `Terminate` process types, it can prevent your Auto Scaling Group from functioning properly.
        /// </summary>
        public InputList<string> SuspendedProcesses
        {
            get => _suspendedProcesses ?? (_suspendedProcesses = new InputList<string>());
            set => _suspendedProcesses = value;
        }

        [Input("tags")]
        private InputList<Inputs.GroupTagGetArgs>? _tags;

        /// <summary>
        /// Configuration block(s) containing resource tags. Conflicts with `tags`. Documented below.
        /// </summary>
        public InputList<Inputs.GroupTagGetArgs> Tags
        {
            get => _tags ?? (_tags = new InputList<Inputs.GroupTagGetArgs>());
            set => _tags = value;
        }

        [Input("tagsCollection")]
        private InputList<ImmutableDictionary<string, Input<string>>>? _tagsCollection;

        /// <summary>
        /// Set of maps containing resource tags. Conflicts with `tag`. Documented below.
        /// </summary>
        public InputList<ImmutableDictionary<string, Input<string>>> TagsCollection
        {
            get => _tagsCollection ?? (_tagsCollection = new InputList<ImmutableDictionary<string, Input<string>>>());
            set => _tagsCollection = value;
        }

        [Input("targetGroupArns")]
        private InputList<string>? _targetGroupArns;

        /// <summary>
        /// A set of `aws.alb.TargetGroup` ARNs, for use with Application or Network Load Balancing.
        /// </summary>
        public InputList<string> TargetGroupArns
        {
            get => _targetGroupArns ?? (_targetGroupArns = new InputList<string>());
            set => _targetGroupArns = value;
        }

        [Input("terminationPolicies")]
        private InputList<string>? _terminationPolicies;

        /// <summary>
        /// A list of policies to decide how the instances in the Auto Scaling Group should be terminated. The allowed values are `OldestInstance`, `NewestInstance`, `OldestLaunchConfiguration`, `ClosestToNextInstanceHour`, `OldestLaunchTemplate`, `AllocationStrategy`, `Default`.
        /// </summary>
        public InputList<string> TerminationPolicies
        {
            get => _terminationPolicies ?? (_terminationPolicies = new InputList<string>());
            set => _terminationPolicies = value;
        }

        [Input("vpcZoneIdentifiers")]
        private InputList<string>? _vpcZoneIdentifiers;

        /// <summary>
        /// A list of subnet IDs to launch resources in. Subnets automatically determine which availability zones the group will reside. Conflicts with `availability_zones`.
        /// </summary>
        public InputList<string> VpcZoneIdentifiers
        {
            get => _vpcZoneIdentifiers ?? (_vpcZoneIdentifiers = new InputList<string>());
            set => _vpcZoneIdentifiers = value;
        }

        /// <summary>
        /// A maximum
        /// [duration](https://golang.org/pkg/time/#ParseDuration) that this provider should
        /// wait for ASG instances to be healthy before timing out.  (See also Waiting
        /// for Capacity below.) Setting this to "0" causes
        /// this provider to skip all Capacity Waiting behavior.
        /// </summary>
        [Input("waitForCapacityTimeout")]
        public Input<string>? WaitForCapacityTimeout { get; set; }

        /// <summary>
        /// Setting this will cause the provider to wait
        /// for exactly this number of healthy instances from this Auto Scaling Group in
        /// all attached load balancers on both create and update operations. (Takes
        /// precedence over `min_elb_capacity` behavior.)
        /// (See also Waiting for Capacity below.)
        /// </summary>
        [Input("waitForElbCapacity")]
        public Input<int>? WaitForElbCapacity { get; set; }

        /// <summary>
        /// If this block is configured, add a [Warm Pool](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-warm-pools.html)
        /// to the specified Auto Scaling group. Defined below
        /// </summary>
        [Input("warmPool")]
        public Input<Inputs.GroupWarmPoolGetArgs>? WarmPool { get; set; }

        public GroupState()
        {
        }
    }
}
