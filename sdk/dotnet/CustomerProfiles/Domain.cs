// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Aws.CustomerProfiles
{
    /// <summary>
    /// Resource for managing an Amazon Customer Profiles Domain.
    /// See the [Create Domain](https://docs.aws.amazon.com/customerprofiles/latest/APIReference/API_CreateDomain.html) for more information.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Aws = Pulumi.Aws;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var example = new Aws.CustomerProfiles.Domain("example", new()
    ///     {
    ///         DomainName = "example",
    ///     });
    /// 
    /// });
    /// ```
    /// ### With SQS DLQ and KMS set
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using System.Text.Json;
    /// using Pulumi;
    /// using Aws = Pulumi.Aws;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var exampleQueue = new Aws.Sqs.Queue("exampleQueue", new()
    ///     {
    ///         Policy = JsonSerializer.Serialize(new Dictionary&lt;string, object?&gt;
    ///         {
    ///             ["Version"] = "2012-10-17",
    ///             ["Statement"] = new[]
    ///             {
    ///                 new Dictionary&lt;string, object?&gt;
    ///                 {
    ///                     ["Sid"] = "Customer Profiles SQS policy",
    ///                     ["Effect"] = "Allow",
    ///                     ["Action"] = new[]
    ///                     {
    ///                         "sqs:SendMessage",
    ///                     },
    ///                     ["Resource"] = "*",
    ///                     ["Principal"] = new Dictionary&lt;string, object?&gt;
    ///                     {
    ///                         ["Service"] = "profile.amazonaws.com",
    ///                     },
    ///                 },
    ///             },
    ///         }),
    ///     });
    /// 
    ///     var exampleKey = new Aws.Kms.Key("exampleKey", new()
    ///     {
    ///         Description = "example",
    ///         DeletionWindowInDays = 10,
    ///     });
    /// 
    ///     var exampleBucketV2 = new Aws.S3.BucketV2("exampleBucketV2", new()
    ///     {
    ///         ForceDestroy = true,
    ///     });
    /// 
    ///     var exampleBucketPolicy = new Aws.S3.BucketPolicy("exampleBucketPolicy", new()
    ///     {
    ///         Bucket = exampleBucketV2.Id,
    ///         Policy = Output.Tuple(exampleBucketV2.Arn, exampleBucketV2.Arn).Apply(values =&gt;
    ///         {
    ///             var exampleBucketV2Arn = values.Item1;
    ///             var exampleBucketV2Arn1 = values.Item2;
    ///             return JsonSerializer.Serialize(new Dictionary&lt;string, object?&gt;
    ///             {
    ///                 ["Version"] = "2012-10-17",
    ///                 ["Statement"] = new[]
    ///                 {
    ///                     new Dictionary&lt;string, object?&gt;
    ///                     {
    ///                         ["Sid"] = "Customer Profiles S3 policy",
    ///                         ["Effect"] = "Allow",
    ///                         ["Action"] = new[]
    ///                         {
    ///                             "s3:GetObject",
    ///                             "s3:PutObject",
    ///                             "s3:ListBucket",
    ///                         },
    ///                         ["Resource"] = new[]
    ///                         {
    ///                             exampleBucketV2Arn,
    ///                             $"{exampleBucketV2Arn1}/*",
    ///                         },
    ///                         ["Principal"] = new Dictionary&lt;string, object?&gt;
    ///                         {
    ///                             ["Service"] = "profile.amazonaws.com",
    ///                         },
    ///                     },
    ///                 },
    ///             });
    ///         }),
    ///     });
    /// 
    ///     var test = new Aws.CustomerProfiles.Domain("test", new()
    ///     {
    ///         DomainName = example,
    ///         DeadLetterQueueUrl = exampleQueue.Id,
    ///         DefaultEncryptionKey = exampleKey.Arn,
    ///         DefaultExpirationDays = 365,
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// Using `pulumi import`, import Amazon Customer Profiles Domain using the resource `id`. For example:
    /// 
    /// ```sh
    ///  $ pulumi import aws:customerprofiles/domain:Domain example e6f777be-22d0-4b40-b307-5d2720ef16b2
    /// ```
    /// </summary>
    [AwsResourceType("aws:customerprofiles/domain:Domain")]
    public partial class Domain : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The Amazon Resource Name (ARN) of the Customer Profiles Domain.
        /// </summary>
        [Output("arn")]
        public Output<string> Arn { get; private set; } = null!;

        /// <summary>
        /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
        /// </summary>
        [Output("deadLetterQueueUrl")]
        public Output<string?> DeadLetterQueueUrl { get; private set; } = null!;

        /// <summary>
        /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
        /// </summary>
        [Output("defaultEncryptionKey")]
        public Output<string?> DefaultEncryptionKey { get; private set; } = null!;

        /// <summary>
        /// The default number of days until the data within the domain expires.
        /// 
        /// The following arguments are optional:
        /// </summary>
        [Output("defaultExpirationDays")]
        public Output<int> DefaultExpirationDays { get; private set; } = null!;

        /// <summary>
        /// The name for your Customer Profile domain. It must be unique for your AWS account.
        /// </summary>
        [Output("domainName")]
        public Output<string> DomainName { get; private set; } = null!;

        /// <summary>
        /// A block that specifies the process of matching duplicate profiles. Documented below.
        /// </summary>
        [Output("matching")]
        public Output<Outputs.DomainMatching?> Matching { get; private set; } = null!;

        /// <summary>
        /// A block that specifies the process of matching duplicate profiles using the Rule-Based matching. Documented below.
        /// </summary>
        [Output("ruleBasedMatching")]
        public Output<Outputs.DomainRuleBasedMatching?> RuleBasedMatching { get; private set; } = null!;

        /// <summary>
        /// Tags to apply to the domain. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableDictionary<string, string>?> Tags { get; private set; } = null!;

        /// <summary>
        /// A map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
        /// </summary>
        [Output("tagsAll")]
        public Output<ImmutableDictionary<string, string>> TagsAll { get; private set; } = null!;


        /// <summary>
        /// Create a Domain resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Domain(string name, DomainArgs args, CustomResourceOptions? options = null)
            : base("aws:customerprofiles/domain:Domain", name, args ?? new DomainArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Domain(string name, Input<string> id, DomainState? state = null, CustomResourceOptions? options = null)
            : base("aws:customerprofiles/domain:Domain", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                AdditionalSecretOutputs =
                {
                    "tagsAll",
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Domain resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Domain Get(string name, Input<string> id, DomainState? state = null, CustomResourceOptions? options = null)
        {
            return new Domain(name, id, state, options);
        }
    }

    public sealed class DomainArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
        /// </summary>
        [Input("deadLetterQueueUrl")]
        public Input<string>? DeadLetterQueueUrl { get; set; }

        /// <summary>
        /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
        /// </summary>
        [Input("defaultEncryptionKey")]
        public Input<string>? DefaultEncryptionKey { get; set; }

        /// <summary>
        /// The default number of days until the data within the domain expires.
        /// 
        /// The following arguments are optional:
        /// </summary>
        [Input("defaultExpirationDays", required: true)]
        public Input<int> DefaultExpirationDays { get; set; } = null!;

        /// <summary>
        /// The name for your Customer Profile domain. It must be unique for your AWS account.
        /// </summary>
        [Input("domainName", required: true)]
        public Input<string> DomainName { get; set; } = null!;

        /// <summary>
        /// A block that specifies the process of matching duplicate profiles. Documented below.
        /// </summary>
        [Input("matching")]
        public Input<Inputs.DomainMatchingArgs>? Matching { get; set; }

        /// <summary>
        /// A block that specifies the process of matching duplicate profiles using the Rule-Based matching. Documented below.
        /// </summary>
        [Input("ruleBasedMatching")]
        public Input<Inputs.DomainRuleBasedMatchingArgs>? RuleBasedMatching { get; set; }

        [Input("tags")]
        private InputMap<string>? _tags;

        /// <summary>
        /// Tags to apply to the domain. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        /// </summary>
        public InputMap<string> Tags
        {
            get => _tags ?? (_tags = new InputMap<string>());
            set => _tags = value;
        }

        public DomainArgs()
        {
        }
        public static new DomainArgs Empty => new DomainArgs();
    }

    public sealed class DomainState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Amazon Resource Name (ARN) of the Customer Profiles Domain.
        /// </summary>
        [Input("arn")]
        public Input<string>? Arn { get; set; }

        /// <summary>
        /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
        /// </summary>
        [Input("deadLetterQueueUrl")]
        public Input<string>? DeadLetterQueueUrl { get; set; }

        /// <summary>
        /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
        /// </summary>
        [Input("defaultEncryptionKey")]
        public Input<string>? DefaultEncryptionKey { get; set; }

        /// <summary>
        /// The default number of days until the data within the domain expires.
        /// 
        /// The following arguments are optional:
        /// </summary>
        [Input("defaultExpirationDays")]
        public Input<int>? DefaultExpirationDays { get; set; }

        /// <summary>
        /// The name for your Customer Profile domain. It must be unique for your AWS account.
        /// </summary>
        [Input("domainName")]
        public Input<string>? DomainName { get; set; }

        /// <summary>
        /// A block that specifies the process of matching duplicate profiles. Documented below.
        /// </summary>
        [Input("matching")]
        public Input<Inputs.DomainMatchingGetArgs>? Matching { get; set; }

        /// <summary>
        /// A block that specifies the process of matching duplicate profiles using the Rule-Based matching. Documented below.
        /// </summary>
        [Input("ruleBasedMatching")]
        public Input<Inputs.DomainRuleBasedMatchingGetArgs>? RuleBasedMatching { get; set; }

        [Input("tags")]
        private InputMap<string>? _tags;

        /// <summary>
        /// Tags to apply to the domain. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        /// </summary>
        public InputMap<string> Tags
        {
            get => _tags ?? (_tags = new InputMap<string>());
            set => _tags = value;
        }

        [Input("tagsAll")]
        private InputMap<string>? _tagsAll;

        /// <summary>
        /// A map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
        /// </summary>
        [Obsolete(@"Please use `tags` instead.")]
        public InputMap<string> TagsAll
        {
            get => _tagsAll ?? (_tagsAll = new InputMap<string>());
            set
            {
                var emptySecret = Output.CreateSecret(ImmutableDictionary.Create<string, string>());
                _tagsAll = Output.All(value, emptySecret).Apply(v => v[0]);
            }
        }

        public DomainState()
        {
        }
        public static new DomainState Empty => new DomainState();
    }
}
