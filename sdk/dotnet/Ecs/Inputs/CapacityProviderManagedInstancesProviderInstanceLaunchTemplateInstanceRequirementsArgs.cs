// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Aws.Ecs.Inputs
{

    public sealed class CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The minimum and maximum number of accelerators for the instance types. This is used when you need instances with specific numbers of GPUs or other accelerators.
        /// </summary>
        [Input("acceleratorCount")]
        public Input<Inputs.CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsAcceleratorCountArgs>? AcceleratorCount { get; set; }

        [Input("acceleratorManufacturers")]
        private InputList<string>? _acceleratorManufacturers;

        /// <summary>
        /// The accelerator manufacturers to include. You can specify `Nvidia`, `Amd`, `amazon-web-services`, `Xilinx`, or `Habana` depending on your accelerator requirements. Valid values are `amazon-web-services`, `Amd`, `Nvidia`, `Xilinx`, `Habana`.
        /// </summary>
        public InputList<string> AcceleratorManufacturers
        {
            get => _acceleratorManufacturers ?? (_acceleratorManufacturers = new InputList<string>());
            set => _acceleratorManufacturers = value;
        }

        [Input("acceleratorNames")]
        private InputList<string>? _acceleratorNames;

        /// <summary>
        /// The specific accelerator names to include. For example, you can specify `A100`, `V100`, `K80`, or other specific accelerator models. Valid values are `A100`, `Inferentia`, `K520`, `K80`, `M60`, `radeon-pro-v520`, `T4`, `Vu9p`, `V100`, `A10g`, `H100`, `T4g`.
        /// </summary>
        public InputList<string> AcceleratorNames
        {
            get => _acceleratorNames ?? (_acceleratorNames = new InputList<string>());
            set => _acceleratorNames = value;
        }

        /// <summary>
        /// The minimum and maximum total accelerator memory in mebibytes (MiB). This is important for GPU workloads that require specific amounts of video memory.
        /// </summary>
        [Input("acceleratorTotalMemoryMib")]
        public Input<Inputs.CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsAcceleratorTotalMemoryMibArgs>? AcceleratorTotalMemoryMib { get; set; }

        [Input("acceleratorTypes")]
        private InputList<string>? _acceleratorTypes;

        /// <summary>
        /// The accelerator types to include. You can specify `Gpu` for graphics processing units, `Fpga` for field programmable gate arrays, or `Inference` for machine learning inference accelerators. Valid values are `Gpu`, `Fpga`, `Inference`.
        /// </summary>
        public InputList<string> AcceleratorTypes
        {
            get => _acceleratorTypes ?? (_acceleratorTypes = new InputList<string>());
            set => _acceleratorTypes = value;
        }

        [Input("allowedInstanceTypes")]
        private InputList<string>? _allowedInstanceTypes;

        /// <summary>
        /// The instance types to include in the selection. When specified, Amazon ECS only considers these instance types, subject to the other requirements specified. Maximum of 400 instance types. You can specify instance type patterns using wildcards (e.g., `m5.*`).
        /// </summary>
        public InputList<string> AllowedInstanceTypes
        {
            get => _allowedInstanceTypes ?? (_allowedInstanceTypes = new InputList<string>());
            set => _allowedInstanceTypes = value;
        }

        /// <summary>
        /// Indicates whether to include bare metal instance types. Set to `Included` to allow bare metal instances, `Excluded` to exclude them, or `Required` to use only bare metal instances. Valid values are `Included`, `Excluded`, `Required`.
        /// </summary>
        [Input("bareMetal")]
        public Input<string>? BareMetal { get; set; }

        /// <summary>
        /// The minimum and maximum baseline Amazon EBS bandwidth in megabits per second (Mbps). This is important for workloads with high storage I/O requirements.
        /// </summary>
        [Input("baselineEbsBandwidthMbps")]
        public Input<Inputs.CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsBaselineEbsBandwidthMbpsArgs>? BaselineEbsBandwidthMbps { get; set; }

        /// <summary>
        /// Indicates whether to include burstable performance instance types (T2, T3, T3a, T4g). Set to `Included` to allow burstable instances, `Excluded` to exclude them, or `Required` to use only burstable instances. Valid values are `Included`, `Excluded`, `Required`.
        /// </summary>
        [Input("burstablePerformance")]
        public Input<string>? BurstablePerformance { get; set; }

        [Input("cpuManufacturers")]
        private InputList<string>? _cpuManufacturers;

        /// <summary>
        /// The CPU manufacturers to include or exclude. You can specify `Intel`, `Amd`, or `amazon-web-services` to control which CPU types are used for your workloads. Valid values are `Intel`, `Amd`, `amazon-web-services`.
        /// </summary>
        public InputList<string> CpuManufacturers
        {
            get => _cpuManufacturers ?? (_cpuManufacturers = new InputList<string>());
            set => _cpuManufacturers = value;
        }

        [Input("excludedInstanceTypes")]
        private InputList<string>? _excludedInstanceTypes;

        /// <summary>
        /// The instance types to exclude from selection. Use this to prevent Amazon ECS from selecting specific instance types that may not be suitable for your workloads. Maximum of 400 instance types.
        /// </summary>
        public InputList<string> ExcludedInstanceTypes
        {
            get => _excludedInstanceTypes ?? (_excludedInstanceTypes = new InputList<string>());
            set => _excludedInstanceTypes = value;
        }

        [Input("instanceGenerations")]
        private InputList<string>? _instanceGenerations;

        /// <summary>
        /// The instance generations to include. You can specify `Current` to use the latest generation instances, or `Previous` to include previous generation instances for cost optimization. Valid values are `Current`, `Previous`.
        /// </summary>
        public InputList<string> InstanceGenerations
        {
            get => _instanceGenerations ?? (_instanceGenerations = new InputList<string>());
            set => _instanceGenerations = value;
        }

        /// <summary>
        /// Indicates whether to include instance types with local storage. Set to `Included` to allow local storage, `Excluded` to exclude it, or `Required` to use only instances with local storage. Valid values are `Included`, `Excluded`, `Required`.
        /// </summary>
        [Input("localStorage")]
        public Input<string>? LocalStorage { get; set; }

        [Input("localStorageTypes")]
        private InputList<string>? _localStorageTypes;

        /// <summary>
        /// The local storage types to include. You can specify `Hdd` for hard disk drives, `Ssd` for solid state drives, or both. Valid values are `Hdd`, `Ssd`.
        /// </summary>
        public InputList<string> LocalStorageTypes
        {
            get => _localStorageTypes ?? (_localStorageTypes = new InputList<string>());
            set => _localStorageTypes = value;
        }

        /// <summary>
        /// The maximum price for Spot instances as a percentage of the optimal On-Demand price. This provides more precise cost control for Spot instance selection.
        /// </summary>
        [Input("maxSpotPriceAsPercentageOfOptimalOnDemandPrice")]
        public Input<int>? MaxSpotPriceAsPercentageOfOptimalOnDemandPrice { get; set; }

        /// <summary>
        /// The minimum and maximum amount of memory per vCPU in gibibytes (GiB). This helps ensure that instance types have the appropriate memory-to-CPU ratio for your workloads.
        /// </summary>
        [Input("memoryGibPerVcpu")]
        public Input<Inputs.CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsMemoryGibPerVcpuArgs>? MemoryGibPerVcpu { get; set; }

        /// <summary>
        /// The minimum and maximum amount of memory in mebibytes (MiB) for the instance types. Amazon ECS selects instance types that have memory within this range.
        /// </summary>
        [Input("memoryMib", required: true)]
        public Input<Inputs.CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsMemoryMibArgs> MemoryMib { get; set; } = null!;

        /// <summary>
        /// The minimum and maximum network bandwidth in gigabits per second (Gbps). This is crucial for network-intensive workloads that require high throughput.
        /// </summary>
        [Input("networkBandwidthGbps")]
        public Input<Inputs.CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsNetworkBandwidthGbpsArgs>? NetworkBandwidthGbps { get; set; }

        /// <summary>
        /// The minimum and maximum number of network interfaces for the instance types. This is useful for workloads that require multiple network interfaces.
        /// </summary>
        [Input("networkInterfaceCount")]
        public Input<Inputs.CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsNetworkInterfaceCountArgs>? NetworkInterfaceCount { get; set; }

        /// <summary>
        /// The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon ECS selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
        /// </summary>
        [Input("onDemandMaxPricePercentageOverLowestPrice")]
        public Input<int>? OnDemandMaxPricePercentageOverLowestPrice { get; set; }

        /// <summary>
        /// Indicates whether the instance types must support hibernation. When set to `True`, only instance types that support hibernation are selected.
        /// </summary>
        [Input("requireHibernateSupport")]
        public Input<bool>? RequireHibernateSupport { get; set; }

        /// <summary>
        /// The maximum price for Spot instances as a percentage over the lowest priced On-Demand instance. This helps control Spot instance costs while maintaining access to capacity.
        /// </summary>
        [Input("spotMaxPricePercentageOverLowestPrice")]
        public Input<int>? SpotMaxPricePercentageOverLowestPrice { get; set; }

        /// <summary>
        /// The minimum and maximum total local storage in gigabytes (GB) for instance types with local storage.
        /// </summary>
        [Input("totalLocalStorageGb")]
        public Input<Inputs.CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsTotalLocalStorageGbArgs>? TotalLocalStorageGb { get; set; }

        /// <summary>
        /// The minimum and maximum number of vCPUs for the instance types. Amazon ECS selects instance types that have vCPU counts within this range.
        /// </summary>
        [Input("vcpuCount", required: true)]
        public Input<Inputs.CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsVcpuCountArgs> VcpuCount { get; set; } = null!;

        public CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsArgs()
        {
        }
        public static new CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsArgs Empty => new CapacityProviderManagedInstancesProviderInstanceLaunchTemplateInstanceRequirementsArgs();
    }
}
