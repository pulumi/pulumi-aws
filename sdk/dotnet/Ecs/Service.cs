// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Aws.Ecs
{
    /// <summary>
    /// &gt; **Note:** To prevent a race condition during service deletion, make sure to set `depends_on` to the related `aws.iam.RolePolicy`; otherwise, the policy may be destroyed too soon and the ECS service will then get stuck in the `DRAINING` state.
    /// 
    /// Provides an ECS service - effectively a task that is expected to run until an error occurs or a user terminates it (typically a webserver or a database).
    /// 
    /// See [ECS Services section in AWS developer guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html).
    /// 
    /// ## capacity_provider_strategy
    /// 
    /// The `capacity_provider_strategy` configuration block supports the following:
    /// 
    /// * `capacity_provider` - (Required) The short name or full Amazon Resource Name (ARN) of the capacity provider.
    /// * `weight` - (Required) The relative percentage of the total number of launched tasks that should use the specified capacity provider.
    /// * `base` - (Optional) The number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
    /// 
    /// ## deployment_controller
    /// 
    /// The `deployment_controller` configuration block supports the following:
    /// 
    /// * `type` - (Optional) Type of deployment controller. Valid values: `CODE_DEPLOY`, `ECS`. Default: `ECS`.
    /// 
    /// ## load_balancer
    /// 
    /// `load_balancer` supports the following:
    /// 
    /// * `elb_name` - (Required for ELB Classic) The name of the ELB (Classic) to associate with the service.
    /// * `target_group_arn` - (Required for ALB/NLB) The ARN of the Load Balancer target group to associate with the service.
    /// * `container_name` - (Required) The name of the container to associate with the load balancer (as it appears in a container definition).
    /// * `container_port` - (Required) The port on the container to associate with the load balancer.
    /// 
    /// &gt; **Version note:** Multiple `load_balancer` configuration block support was added in version 2.22.0 of the provider. This allows configuration of [ECS service support for multiple target groups](https://aws.amazon.com/about-aws/whats-new/2019/07/amazon-ecs-services-now-support-multiple-load-balancer-target-groups/).
    /// 
    /// ## ordered_placement_strategy
    /// 
    /// `ordered_placement_strategy` supports the following:
    /// 
    /// * `type` - (Required) The type of placement strategy. Must be one of: `binpack`, `random`, or `spread`
    /// * `field` - (Optional) For the `spread` placement strategy, valid values are `instanceId` (or `host`,
    ///  which has the same effect), or any platform or custom attribute that is applied to a container instance.
    ///  For the `binpack` type, valid values are `memory` and `cpu`. For the `random` type, this attribute is not
    ///  needed. For more information, see [Placement Strategy](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PlacementStrategy.html).
    /// 
    /// &gt; **Note:** for `spread`, `host` and `instanceId` will be normalized, by AWS, to be `instanceId`. This means the statefile will show `instanceId` but your config will differ if you use `host`.
    /// 
    /// ## placement_constraints
    /// 
    /// `placement_constraints` support the following:
    /// 
    /// * `type` - (Required) The type of constraint. The only valid values at this time are `memberOf` and `distinctInstance`.
    /// * `expression` -  (Optional) Cluster Query Language expression to apply to the constraint. Does not need to be specified
    /// for the `distinctInstance` type.
    /// For more information, see [Cluster Query Language in the Amazon EC2 Container
    /// Service Developer
    /// Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
    /// 
    /// ## network_configuration
    /// 
    /// `network_configuration` support the following:
    /// 
    /// * `subnets` - (Required) The subnets associated with the task or service.
    /// * `security_groups` - (Optional) The security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
    /// * `assign_public_ip` - (Optional) Assign a public IP address to the ENI (Fargate launch type only). Valid values are `true` or `false`. Default `false`.
    /// 
    /// For more information, see [Task Networking](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html)
    /// 
    /// ## service_registries
    /// 
    /// `service_registries` support the following:
    /// 
    /// * `registry_arn` - (Required) The ARN of the Service Registry. The currently supported service registry is Amazon Route 53 Auto Naming Service(`aws.servicediscovery.Service`). For more information, see [Service](https://docs.aws.amazon.com/Route53/latest/APIReference/API_autonaming_Service.html)
    /// * `port` - (Optional) The port value used if your Service Discovery service specified an SRV record.
    /// * `container_port` - (Optional) The port value, already specified in the task definition, to be used for your service discovery service.
    /// * `container_name` - (Optional) The container name value, already specified in the task definition, to be used for your service discovery service.
    /// 
    /// &gt; This content is derived from https://github.com/terraform-providers/terraform-provider-aws/blob/master/website/docs/r/ecs_service.html.markdown.
    /// </summary>
    public partial class Service : Pulumi.CustomResource
    {
        /// <summary>
        /// The capacity provider strategy to use for the service. Can be one or more.  Defined below.
        /// </summary>
        [Output("capacityProviderStrategies")]
        public Output<ImmutableArray<Outputs.ServiceCapacityProviderStrategies>> CapacityProviderStrategies { get; private set; } = null!;

        /// <summary>
        /// ARN of an ECS cluster
        /// </summary>
        [Output("cluster")]
        public Output<string> Cluster { get; private set; } = null!;

        /// <summary>
        /// Configuration block containing deployment controller configuration. Defined below.
        /// </summary>
        [Output("deploymentController")]
        public Output<Outputs.ServiceDeploymentController?> DeploymentController { get; private set; } = null!;

        /// <summary>
        /// The upper limit (as a percentage of the service's desiredCount) of the number of running tasks that can be running in a service during a deployment. Not valid when using the `DAEMON` scheduling strategy.
        /// </summary>
        [Output("deploymentMaximumPercent")]
        public Output<int?> DeploymentMaximumPercent { get; private set; } = null!;

        /// <summary>
        /// The lower limit (as a percentage of the service's desiredCount) of the number of running tasks that must remain running and healthy in a service during a deployment.
        /// </summary>
        [Output("deploymentMinimumHealthyPercent")]
        public Output<int?> DeploymentMinimumHealthyPercent { get; private set; } = null!;

        /// <summary>
        /// The number of instances of the task definition to place and keep running. Defaults to 0. Do not specify if using the `DAEMON` scheduling strategy.
        /// </summary>
        [Output("desiredCount")]
        public Output<int?> DesiredCount { get; private set; } = null!;

        /// <summary>
        /// Specifies whether to enable Amazon ECS managed tags for the tasks within the service.
        /// </summary>
        [Output("enableEcsManagedTags")]
        public Output<bool?> EnableEcsManagedTags { get; private set; } = null!;

        /// <summary>
        /// Seconds to ignore failing load balancer health checks on newly instantiated tasks to prevent premature shutdown, up to 2147483647. Only valid for services configured to use load balancers.
        /// </summary>
        [Output("healthCheckGracePeriodSeconds")]
        public Output<int?> HealthCheckGracePeriodSeconds { get; private set; } = null!;

        /// <summary>
        /// ARN of the IAM role that allows Amazon ECS to make calls to your load balancer on your behalf. This parameter is required if you are using a load balancer with your service, but only if your task definition does not use the `awsvpc` network mode. If using `awsvpc` network mode, do not specify this role. If your account has already created the Amazon ECS service-linked role, that role is used by default for your service unless you specify a role here.
        /// </summary>
        [Output("iamRole")]
        public Output<string> IamRole { get; private set; } = null!;

        /// <summary>
        /// The launch type on which to run your service. The valid values are `EC2` and `FARGATE`. Defaults to `EC2`.
        /// </summary>
        [Output("launchType")]
        public Output<string> LaunchType { get; private set; } = null!;

        /// <summary>
        /// A load balancer block. Load balancers documented below.
        /// </summary>
        [Output("loadBalancers")]
        public Output<ImmutableArray<Outputs.ServiceLoadBalancers>> LoadBalancers { get; private set; } = null!;

        /// <summary>
        /// The name of the service (up to 255 letters, numbers, hyphens, and underscores)
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The network configuration for the service. This parameter is required for task definitions that use the `awsvpc` network mode to receive their own Elastic Network Interface, and it is not supported for other network modes.
        /// </summary>
        [Output("networkConfiguration")]
        public Output<Outputs.ServiceNetworkConfiguration?> NetworkConfiguration { get; private set; } = null!;

        /// <summary>
        /// Service level strategy rules that are taken into consideration during task placement. List from top to bottom in order of precedence. The maximum number of `ordered_placement_strategy` blocks is `5`. Defined below.
        /// </summary>
        [Output("orderedPlacementStrategies")]
        public Output<ImmutableArray<Outputs.ServiceOrderedPlacementStrategies>> OrderedPlacementStrategies { get; private set; } = null!;

        /// <summary>
        /// rules that are taken into consideration during task placement. Maximum number of
        /// `placement_constraints` is `10`. Defined below.
        /// </summary>
        [Output("placementConstraints")]
        public Output<ImmutableArray<Outputs.ServicePlacementConstraints>> PlacementConstraints { get; private set; } = null!;

        /// <summary>
        /// The platform version on which to run your service. Only applicable for `launch_type` set to `FARGATE`. Defaults to `LATEST`. More information about Fargate platform versions can be found in the [AWS ECS User Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html).
        /// </summary>
        [Output("platformVersion")]
        public Output<string> PlatformVersion { get; private set; } = null!;

        /// <summary>
        /// Specifies whether to propagate the tags from the task definition or the service to the tasks. The valid values are `SERVICE` and `TASK_DEFINITION`.
        /// </summary>
        [Output("propagateTags")]
        public Output<string?> PropagateTags { get; private set; } = null!;

        /// <summary>
        /// The scheduling strategy to use for the service. The valid values are `REPLICA` and `DAEMON`. Defaults to `REPLICA`. Note that [*Fargate tasks do not support the `DAEMON` scheduling strategy*](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/scheduling_tasks.html).
        /// </summary>
        [Output("schedulingStrategy")]
        public Output<string?> SchedulingStrategy { get; private set; } = null!;

        /// <summary>
        /// The service discovery registries for the service. The maximum number of `service_registries` blocks is `1`.
        /// </summary>
        [Output("serviceRegistries")]
        public Output<Outputs.ServiceServiceRegistries?> ServiceRegistries { get; private set; } = null!;

        /// <summary>
        /// Key-value mapping of resource tags
        /// </summary>
        [Output("tags")]
        public Output<ImmutableDictionary<string, object>?> Tags { get; private set; } = null!;

        /// <summary>
        /// The family and revision (`family:revision`) or full ARN of the task definition that you want to run in your service.
        /// </summary>
        [Output("taskDefinition")]
        public Output<string> TaskDefinition { get; private set; } = null!;

        /// <summary>
        /// If `true`, this provider will wait for the service to reach a steady state (like [`aws ecs wait services-stable`](https://docs.aws.amazon.com/cli/latest/reference/ecs/wait/services-stable.html)) before continuing. Default `false`.
        /// </summary>
        [Output("waitForSteadyState")]
        public Output<bool?> WaitForSteadyState { get; private set; } = null!;


        /// <summary>
        /// Create a Service resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Service(string name, ServiceArgs args, CustomResourceOptions? options = null)
            : base("aws:ecs/service:Service", name, args ?? ResourceArgs.Empty, MakeResourceOptions(options, ""))
        {
        }

        private Service(string name, Input<string> id, ServiceState? state = null, CustomResourceOptions? options = null)
            : base("aws:ecs/service:Service", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Service resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Service Get(string name, Input<string> id, ServiceState? state = null, CustomResourceOptions? options = null)
        {
            return new Service(name, id, state, options);
        }
    }

    public sealed class ServiceArgs : Pulumi.ResourceArgs
    {
        [Input("capacityProviderStrategies")]
        private InputList<Inputs.ServiceCapacityProviderStrategiesArgs>? _capacityProviderStrategies;

        /// <summary>
        /// The capacity provider strategy to use for the service. Can be one or more.  Defined below.
        /// </summary>
        public InputList<Inputs.ServiceCapacityProviderStrategiesArgs> CapacityProviderStrategies
        {
            get => _capacityProviderStrategies ?? (_capacityProviderStrategies = new InputList<Inputs.ServiceCapacityProviderStrategiesArgs>());
            set => _capacityProviderStrategies = value;
        }

        /// <summary>
        /// ARN of an ECS cluster
        /// </summary>
        [Input("cluster")]
        public Input<string>? Cluster { get; set; }

        /// <summary>
        /// Configuration block containing deployment controller configuration. Defined below.
        /// </summary>
        [Input("deploymentController")]
        public Input<Inputs.ServiceDeploymentControllerArgs>? DeploymentController { get; set; }

        /// <summary>
        /// The upper limit (as a percentage of the service's desiredCount) of the number of running tasks that can be running in a service during a deployment. Not valid when using the `DAEMON` scheduling strategy.
        /// </summary>
        [Input("deploymentMaximumPercent")]
        public Input<int>? DeploymentMaximumPercent { get; set; }

        /// <summary>
        /// The lower limit (as a percentage of the service's desiredCount) of the number of running tasks that must remain running and healthy in a service during a deployment.
        /// </summary>
        [Input("deploymentMinimumHealthyPercent")]
        public Input<int>? DeploymentMinimumHealthyPercent { get; set; }

        /// <summary>
        /// The number of instances of the task definition to place and keep running. Defaults to 0. Do not specify if using the `DAEMON` scheduling strategy.
        /// </summary>
        [Input("desiredCount")]
        public Input<int>? DesiredCount { get; set; }

        /// <summary>
        /// Specifies whether to enable Amazon ECS managed tags for the tasks within the service.
        /// </summary>
        [Input("enableEcsManagedTags")]
        public Input<bool>? EnableEcsManagedTags { get; set; }

        /// <summary>
        /// Seconds to ignore failing load balancer health checks on newly instantiated tasks to prevent premature shutdown, up to 2147483647. Only valid for services configured to use load balancers.
        /// </summary>
        [Input("healthCheckGracePeriodSeconds")]
        public Input<int>? HealthCheckGracePeriodSeconds { get; set; }

        /// <summary>
        /// ARN of the IAM role that allows Amazon ECS to make calls to your load balancer on your behalf. This parameter is required if you are using a load balancer with your service, but only if your task definition does not use the `awsvpc` network mode. If using `awsvpc` network mode, do not specify this role. If your account has already created the Amazon ECS service-linked role, that role is used by default for your service unless you specify a role here.
        /// </summary>
        [Input("iamRole")]
        public Input<string>? IamRole { get; set; }

        /// <summary>
        /// The launch type on which to run your service. The valid values are `EC2` and `FARGATE`. Defaults to `EC2`.
        /// </summary>
        [Input("launchType")]
        public Input<string>? LaunchType { get; set; }

        [Input("loadBalancers")]
        private InputList<Inputs.ServiceLoadBalancersArgs>? _loadBalancers;

        /// <summary>
        /// A load balancer block. Load balancers documented below.
        /// </summary>
        public InputList<Inputs.ServiceLoadBalancersArgs> LoadBalancers
        {
            get => _loadBalancers ?? (_loadBalancers = new InputList<Inputs.ServiceLoadBalancersArgs>());
            set => _loadBalancers = value;
        }

        /// <summary>
        /// The name of the service (up to 255 letters, numbers, hyphens, and underscores)
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The network configuration for the service. This parameter is required for task definitions that use the `awsvpc` network mode to receive their own Elastic Network Interface, and it is not supported for other network modes.
        /// </summary>
        [Input("networkConfiguration")]
        public Input<Inputs.ServiceNetworkConfigurationArgs>? NetworkConfiguration { get; set; }

        [Input("orderedPlacementStrategies")]
        private InputList<Inputs.ServiceOrderedPlacementStrategiesArgs>? _orderedPlacementStrategies;

        /// <summary>
        /// Service level strategy rules that are taken into consideration during task placement. List from top to bottom in order of precedence. The maximum number of `ordered_placement_strategy` blocks is `5`. Defined below.
        /// </summary>
        public InputList<Inputs.ServiceOrderedPlacementStrategiesArgs> OrderedPlacementStrategies
        {
            get => _orderedPlacementStrategies ?? (_orderedPlacementStrategies = new InputList<Inputs.ServiceOrderedPlacementStrategiesArgs>());
            set => _orderedPlacementStrategies = value;
        }

        [Input("placementConstraints")]
        private InputList<Inputs.ServicePlacementConstraintsArgs>? _placementConstraints;

        /// <summary>
        /// rules that are taken into consideration during task placement. Maximum number of
        /// `placement_constraints` is `10`. Defined below.
        /// </summary>
        public InputList<Inputs.ServicePlacementConstraintsArgs> PlacementConstraints
        {
            get => _placementConstraints ?? (_placementConstraints = new InputList<Inputs.ServicePlacementConstraintsArgs>());
            set => _placementConstraints = value;
        }

        /// <summary>
        /// The platform version on which to run your service. Only applicable for `launch_type` set to `FARGATE`. Defaults to `LATEST`. More information about Fargate platform versions can be found in the [AWS ECS User Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html).
        /// </summary>
        [Input("platformVersion")]
        public Input<string>? PlatformVersion { get; set; }

        /// <summary>
        /// Specifies whether to propagate the tags from the task definition or the service to the tasks. The valid values are `SERVICE` and `TASK_DEFINITION`.
        /// </summary>
        [Input("propagateTags")]
        public Input<string>? PropagateTags { get; set; }

        /// <summary>
        /// The scheduling strategy to use for the service. The valid values are `REPLICA` and `DAEMON`. Defaults to `REPLICA`. Note that [*Fargate tasks do not support the `DAEMON` scheduling strategy*](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/scheduling_tasks.html).
        /// </summary>
        [Input("schedulingStrategy")]
        public Input<string>? SchedulingStrategy { get; set; }

        /// <summary>
        /// The service discovery registries for the service. The maximum number of `service_registries` blocks is `1`.
        /// </summary>
        [Input("serviceRegistries")]
        public Input<Inputs.ServiceServiceRegistriesArgs>? ServiceRegistries { get; set; }

        [Input("tags")]
        private InputMap<object>? _tags;

        /// <summary>
        /// Key-value mapping of resource tags
        /// </summary>
        public InputMap<object> Tags
        {
            get => _tags ?? (_tags = new InputMap<object>());
            set => _tags = value;
        }

        /// <summary>
        /// The family and revision (`family:revision`) or full ARN of the task definition that you want to run in your service.
        /// </summary>
        [Input("taskDefinition", required: true)]
        public Input<string> TaskDefinition { get; set; } = null!;

        /// <summary>
        /// If `true`, this provider will wait for the service to reach a steady state (like [`aws ecs wait services-stable`](https://docs.aws.amazon.com/cli/latest/reference/ecs/wait/services-stable.html)) before continuing. Default `false`.
        /// </summary>
        [Input("waitForSteadyState")]
        public Input<bool>? WaitForSteadyState { get; set; }

        public ServiceArgs()
        {
        }
    }

    public sealed class ServiceState : Pulumi.ResourceArgs
    {
        [Input("capacityProviderStrategies")]
        private InputList<Inputs.ServiceCapacityProviderStrategiesGetArgs>? _capacityProviderStrategies;

        /// <summary>
        /// The capacity provider strategy to use for the service. Can be one or more.  Defined below.
        /// </summary>
        public InputList<Inputs.ServiceCapacityProviderStrategiesGetArgs> CapacityProviderStrategies
        {
            get => _capacityProviderStrategies ?? (_capacityProviderStrategies = new InputList<Inputs.ServiceCapacityProviderStrategiesGetArgs>());
            set => _capacityProviderStrategies = value;
        }

        /// <summary>
        /// ARN of an ECS cluster
        /// </summary>
        [Input("cluster")]
        public Input<string>? Cluster { get; set; }

        /// <summary>
        /// Configuration block containing deployment controller configuration. Defined below.
        /// </summary>
        [Input("deploymentController")]
        public Input<Inputs.ServiceDeploymentControllerGetArgs>? DeploymentController { get; set; }

        /// <summary>
        /// The upper limit (as a percentage of the service's desiredCount) of the number of running tasks that can be running in a service during a deployment. Not valid when using the `DAEMON` scheduling strategy.
        /// </summary>
        [Input("deploymentMaximumPercent")]
        public Input<int>? DeploymentMaximumPercent { get; set; }

        /// <summary>
        /// The lower limit (as a percentage of the service's desiredCount) of the number of running tasks that must remain running and healthy in a service during a deployment.
        /// </summary>
        [Input("deploymentMinimumHealthyPercent")]
        public Input<int>? DeploymentMinimumHealthyPercent { get; set; }

        /// <summary>
        /// The number of instances of the task definition to place and keep running. Defaults to 0. Do not specify if using the `DAEMON` scheduling strategy.
        /// </summary>
        [Input("desiredCount")]
        public Input<int>? DesiredCount { get; set; }

        /// <summary>
        /// Specifies whether to enable Amazon ECS managed tags for the tasks within the service.
        /// </summary>
        [Input("enableEcsManagedTags")]
        public Input<bool>? EnableEcsManagedTags { get; set; }

        /// <summary>
        /// Seconds to ignore failing load balancer health checks on newly instantiated tasks to prevent premature shutdown, up to 2147483647. Only valid for services configured to use load balancers.
        /// </summary>
        [Input("healthCheckGracePeriodSeconds")]
        public Input<int>? HealthCheckGracePeriodSeconds { get; set; }

        /// <summary>
        /// ARN of the IAM role that allows Amazon ECS to make calls to your load balancer on your behalf. This parameter is required if you are using a load balancer with your service, but only if your task definition does not use the `awsvpc` network mode. If using `awsvpc` network mode, do not specify this role. If your account has already created the Amazon ECS service-linked role, that role is used by default for your service unless you specify a role here.
        /// </summary>
        [Input("iamRole")]
        public Input<string>? IamRole { get; set; }

        /// <summary>
        /// The launch type on which to run your service. The valid values are `EC2` and `FARGATE`. Defaults to `EC2`.
        /// </summary>
        [Input("launchType")]
        public Input<string>? LaunchType { get; set; }

        [Input("loadBalancers")]
        private InputList<Inputs.ServiceLoadBalancersGetArgs>? _loadBalancers;

        /// <summary>
        /// A load balancer block. Load balancers documented below.
        /// </summary>
        public InputList<Inputs.ServiceLoadBalancersGetArgs> LoadBalancers
        {
            get => _loadBalancers ?? (_loadBalancers = new InputList<Inputs.ServiceLoadBalancersGetArgs>());
            set => _loadBalancers = value;
        }

        /// <summary>
        /// The name of the service (up to 255 letters, numbers, hyphens, and underscores)
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The network configuration for the service. This parameter is required for task definitions that use the `awsvpc` network mode to receive their own Elastic Network Interface, and it is not supported for other network modes.
        /// </summary>
        [Input("networkConfiguration")]
        public Input<Inputs.ServiceNetworkConfigurationGetArgs>? NetworkConfiguration { get; set; }

        [Input("orderedPlacementStrategies")]
        private InputList<Inputs.ServiceOrderedPlacementStrategiesGetArgs>? _orderedPlacementStrategies;

        /// <summary>
        /// Service level strategy rules that are taken into consideration during task placement. List from top to bottom in order of precedence. The maximum number of `ordered_placement_strategy` blocks is `5`. Defined below.
        /// </summary>
        public InputList<Inputs.ServiceOrderedPlacementStrategiesGetArgs> OrderedPlacementStrategies
        {
            get => _orderedPlacementStrategies ?? (_orderedPlacementStrategies = new InputList<Inputs.ServiceOrderedPlacementStrategiesGetArgs>());
            set => _orderedPlacementStrategies = value;
        }

        [Input("placementConstraints")]
        private InputList<Inputs.ServicePlacementConstraintsGetArgs>? _placementConstraints;

        /// <summary>
        /// rules that are taken into consideration during task placement. Maximum number of
        /// `placement_constraints` is `10`. Defined below.
        /// </summary>
        public InputList<Inputs.ServicePlacementConstraintsGetArgs> PlacementConstraints
        {
            get => _placementConstraints ?? (_placementConstraints = new InputList<Inputs.ServicePlacementConstraintsGetArgs>());
            set => _placementConstraints = value;
        }

        /// <summary>
        /// The platform version on which to run your service. Only applicable for `launch_type` set to `FARGATE`. Defaults to `LATEST`. More information about Fargate platform versions can be found in the [AWS ECS User Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html).
        /// </summary>
        [Input("platformVersion")]
        public Input<string>? PlatformVersion { get; set; }

        /// <summary>
        /// Specifies whether to propagate the tags from the task definition or the service to the tasks. The valid values are `SERVICE` and `TASK_DEFINITION`.
        /// </summary>
        [Input("propagateTags")]
        public Input<string>? PropagateTags { get; set; }

        /// <summary>
        /// The scheduling strategy to use for the service. The valid values are `REPLICA` and `DAEMON`. Defaults to `REPLICA`. Note that [*Fargate tasks do not support the `DAEMON` scheduling strategy*](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/scheduling_tasks.html).
        /// </summary>
        [Input("schedulingStrategy")]
        public Input<string>? SchedulingStrategy { get; set; }

        /// <summary>
        /// The service discovery registries for the service. The maximum number of `service_registries` blocks is `1`.
        /// </summary>
        [Input("serviceRegistries")]
        public Input<Inputs.ServiceServiceRegistriesGetArgs>? ServiceRegistries { get; set; }

        [Input("tags")]
        private InputMap<object>? _tags;

        /// <summary>
        /// Key-value mapping of resource tags
        /// </summary>
        public InputMap<object> Tags
        {
            get => _tags ?? (_tags = new InputMap<object>());
            set => _tags = value;
        }

        /// <summary>
        /// The family and revision (`family:revision`) or full ARN of the task definition that you want to run in your service.
        /// </summary>
        [Input("taskDefinition")]
        public Input<string>? TaskDefinition { get; set; }

        /// <summary>
        /// If `true`, this provider will wait for the service to reach a steady state (like [`aws ecs wait services-stable`](https://docs.aws.amazon.com/cli/latest/reference/ecs/wait/services-stable.html)) before continuing. Default `false`.
        /// </summary>
        [Input("waitForSteadyState")]
        public Input<bool>? WaitForSteadyState { get; set; }

        public ServiceState()
        {
        }
    }

    namespace Inputs
    {

    public sealed class ServiceCapacityProviderStrategiesArgs : Pulumi.ResourceArgs
    {
        [Input("base")]
        public Input<int>? Base { get; set; }

        [Input("capacityProvider", required: true)]
        public Input<string> CapacityProvider { get; set; } = null!;

        [Input("weight")]
        public Input<int>? Weight { get; set; }

        public ServiceCapacityProviderStrategiesArgs()
        {
        }
    }

    public sealed class ServiceCapacityProviderStrategiesGetArgs : Pulumi.ResourceArgs
    {
        [Input("base")]
        public Input<int>? Base { get; set; }

        [Input("capacityProvider", required: true)]
        public Input<string> CapacityProvider { get; set; } = null!;

        [Input("weight")]
        public Input<int>? Weight { get; set; }

        public ServiceCapacityProviderStrategiesGetArgs()
        {
        }
    }

    public sealed class ServiceDeploymentControllerArgs : Pulumi.ResourceArgs
    {
        [Input("type")]
        public Input<string>? Type { get; set; }

        public ServiceDeploymentControllerArgs()
        {
        }
    }

    public sealed class ServiceDeploymentControllerGetArgs : Pulumi.ResourceArgs
    {
        [Input("type")]
        public Input<string>? Type { get; set; }

        public ServiceDeploymentControllerGetArgs()
        {
        }
    }

    public sealed class ServiceLoadBalancersArgs : Pulumi.ResourceArgs
    {
        [Input("containerName", required: true)]
        public Input<string> ContainerName { get; set; } = null!;

        [Input("containerPort", required: true)]
        public Input<int> ContainerPort { get; set; } = null!;

        [Input("elbName")]
        public Input<string>? ElbName { get; set; }

        [Input("targetGroupArn")]
        public Input<string>? TargetGroupArn { get; set; }

        public ServiceLoadBalancersArgs()
        {
        }
    }

    public sealed class ServiceLoadBalancersGetArgs : Pulumi.ResourceArgs
    {
        [Input("containerName", required: true)]
        public Input<string> ContainerName { get; set; } = null!;

        [Input("containerPort", required: true)]
        public Input<int> ContainerPort { get; set; } = null!;

        [Input("elbName")]
        public Input<string>? ElbName { get; set; }

        [Input("targetGroupArn")]
        public Input<string>? TargetGroupArn { get; set; }

        public ServiceLoadBalancersGetArgs()
        {
        }
    }

    public sealed class ServiceNetworkConfigurationArgs : Pulumi.ResourceArgs
    {
        [Input("assignPublicIp")]
        public Input<bool>? AssignPublicIp { get; set; }

        [Input("securityGroups")]
        private InputList<string>? _securityGroups;
        public InputList<string> SecurityGroups
        {
            get => _securityGroups ?? (_securityGroups = new InputList<string>());
            set => _securityGroups = value;
        }

        [Input("subnets", required: true)]
        private InputList<string>? _subnets;
        public InputList<string> Subnets
        {
            get => _subnets ?? (_subnets = new InputList<string>());
            set => _subnets = value;
        }

        public ServiceNetworkConfigurationArgs()
        {
        }
    }

    public sealed class ServiceNetworkConfigurationGetArgs : Pulumi.ResourceArgs
    {
        [Input("assignPublicIp")]
        public Input<bool>? AssignPublicIp { get; set; }

        [Input("securityGroups")]
        private InputList<string>? _securityGroups;
        public InputList<string> SecurityGroups
        {
            get => _securityGroups ?? (_securityGroups = new InputList<string>());
            set => _securityGroups = value;
        }

        [Input("subnets", required: true)]
        private InputList<string>? _subnets;
        public InputList<string> Subnets
        {
            get => _subnets ?? (_subnets = new InputList<string>());
            set => _subnets = value;
        }

        public ServiceNetworkConfigurationGetArgs()
        {
        }
    }

    public sealed class ServiceOrderedPlacementStrategiesArgs : Pulumi.ResourceArgs
    {
        [Input("field")]
        public Input<string>? Field { get; set; }

        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        public ServiceOrderedPlacementStrategiesArgs()
        {
        }
    }

    public sealed class ServiceOrderedPlacementStrategiesGetArgs : Pulumi.ResourceArgs
    {
        [Input("field")]
        public Input<string>? Field { get; set; }

        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        public ServiceOrderedPlacementStrategiesGetArgs()
        {
        }
    }

    public sealed class ServicePlacementConstraintsArgs : Pulumi.ResourceArgs
    {
        [Input("expression")]
        public Input<string>? Expression { get; set; }

        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        public ServicePlacementConstraintsArgs()
        {
        }
    }

    public sealed class ServicePlacementConstraintsGetArgs : Pulumi.ResourceArgs
    {
        [Input("expression")]
        public Input<string>? Expression { get; set; }

        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        public ServicePlacementConstraintsGetArgs()
        {
        }
    }

    public sealed class ServiceServiceRegistriesArgs : Pulumi.ResourceArgs
    {
        [Input("containerName")]
        public Input<string>? ContainerName { get; set; }

        [Input("containerPort")]
        public Input<int>? ContainerPort { get; set; }

        [Input("port")]
        public Input<int>? Port { get; set; }

        [Input("registryArn", required: true)]
        public Input<string> RegistryArn { get; set; } = null!;

        public ServiceServiceRegistriesArgs()
        {
        }
    }

    public sealed class ServiceServiceRegistriesGetArgs : Pulumi.ResourceArgs
    {
        [Input("containerName")]
        public Input<string>? ContainerName { get; set; }

        [Input("containerPort")]
        public Input<int>? ContainerPort { get; set; }

        [Input("port")]
        public Input<int>? Port { get; set; }

        [Input("registryArn", required: true)]
        public Input<string> RegistryArn { get; set; } = null!;

        public ServiceServiceRegistriesGetArgs()
        {
        }
    }
    }

    namespace Outputs
    {

    [OutputType]
    public sealed class ServiceCapacityProviderStrategies
    {
        public readonly int? Base;
        public readonly string CapacityProvider;
        public readonly int? Weight;

        [OutputConstructor]
        private ServiceCapacityProviderStrategies(
            int? @base,
            string capacityProvider,
            int? weight)
        {
            Base = @base;
            CapacityProvider = capacityProvider;
            Weight = weight;
        }
    }

    [OutputType]
    public sealed class ServiceDeploymentController
    {
        public readonly string? Type;

        [OutputConstructor]
        private ServiceDeploymentController(string? type)
        {
            Type = type;
        }
    }

    [OutputType]
    public sealed class ServiceLoadBalancers
    {
        public readonly string ContainerName;
        public readonly int ContainerPort;
        public readonly string? ElbName;
        public readonly string? TargetGroupArn;

        [OutputConstructor]
        private ServiceLoadBalancers(
            string containerName,
            int containerPort,
            string? elbName,
            string? targetGroupArn)
        {
            ContainerName = containerName;
            ContainerPort = containerPort;
            ElbName = elbName;
            TargetGroupArn = targetGroupArn;
        }
    }

    [OutputType]
    public sealed class ServiceNetworkConfiguration
    {
        public readonly bool? AssignPublicIp;
        public readonly ImmutableArray<string> SecurityGroups;
        public readonly ImmutableArray<string> Subnets;

        [OutputConstructor]
        private ServiceNetworkConfiguration(
            bool? assignPublicIp,
            ImmutableArray<string> securityGroups,
            ImmutableArray<string> subnets)
        {
            AssignPublicIp = assignPublicIp;
            SecurityGroups = securityGroups;
            Subnets = subnets;
        }
    }

    [OutputType]
    public sealed class ServiceOrderedPlacementStrategies
    {
        public readonly string? Field;
        public readonly string Type;

        [OutputConstructor]
        private ServiceOrderedPlacementStrategies(
            string? field,
            string type)
        {
            Field = field;
            Type = type;
        }
    }

    [OutputType]
    public sealed class ServicePlacementConstraints
    {
        public readonly string? Expression;
        public readonly string Type;

        [OutputConstructor]
        private ServicePlacementConstraints(
            string? expression,
            string type)
        {
            Expression = expression;
            Type = type;
        }
    }

    [OutputType]
    public sealed class ServiceServiceRegistries
    {
        public readonly string? ContainerName;
        public readonly int? ContainerPort;
        public readonly int? Port;
        public readonly string RegistryArn;

        [OutputConstructor]
        private ServiceServiceRegistries(
            string? containerName,
            int? containerPort,
            int? port,
            string registryArn)
        {
            ContainerName = containerName;
            ContainerPort = containerPort;
            Port = port;
            RegistryArn = registryArn;
        }
    }
    }
}
