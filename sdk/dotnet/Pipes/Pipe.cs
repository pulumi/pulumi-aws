// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Aws.Pipes
{
    /// <summary>
    /// Resource for managing an AWS EventBridge Pipes Pipe.
    /// 
    /// You can find out more about EventBridge Pipes in the [User Guide](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-pipes.html).
    /// 
    /// EventBridge Pipes are very configurable, and may require IAM permissions to work correctly. More information on the configuration options and IAM permissions can be found in the [User Guide](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-pipes.html).
    /// 
    /// &gt; **Note:** EventBridge was formerly known as CloudWatch Events. The functionality is identical.
    /// 
    /// ## Example Usage
    /// 
    /// ### Basic Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using System.Text.Json;
    /// using Pulumi;
    /// using Aws = Pulumi.Aws;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var main = Aws.GetCallerIdentity.Invoke();
    /// 
    ///     var example = new Aws.Iam.Role("example", new()
    ///     {
    ///         AssumeRolePolicy = JsonSerializer.Serialize(new Dictionary&lt;string, object?&gt;
    ///         {
    ///             ["Version"] = "2012-10-17",
    ///             ["Statement"] = new Dictionary&lt;string, object?&gt;
    ///             {
    ///                 ["Effect"] = "Allow",
    ///                 ["Action"] = "sts:AssumeRole",
    ///                 ["Principal"] = new Dictionary&lt;string, object?&gt;
    ///                 {
    ///                     ["Service"] = "pipes.amazonaws.com",
    ///                 },
    ///                 ["Condition"] = new Dictionary&lt;string, object?&gt;
    ///                 {
    ///                     ["StringEquals"] = new Dictionary&lt;string, object?&gt;
    ///                     {
    ///                         ["aws:SourceAccount"] = main.Apply(getCallerIdentityResult =&gt; getCallerIdentityResult.AccountId),
    ///                     },
    ///                 },
    ///             },
    ///         }),
    ///     });
    /// 
    ///     var sourceQueue = new Aws.Sqs.Queue("source");
    /// 
    ///     var source = new Aws.Iam.RolePolicy("source", new()
    ///     {
    ///         Role = example.Id,
    ///         Policy = Output.JsonSerialize(Output.Create(new Dictionary&lt;string, object?&gt;
    ///         {
    ///             ["Version"] = "2012-10-17",
    ///             ["Statement"] = new[]
    ///             {
    ///                 new Dictionary&lt;string, object?&gt;
    ///                 {
    ///                     ["Effect"] = "Allow",
    ///                     ["Action"] = new[]
    ///                     {
    ///                         "sqs:DeleteMessage",
    ///                         "sqs:GetQueueAttributes",
    ///                         "sqs:ReceiveMessage",
    ///                     },
    ///                     ["Resource"] = new[]
    ///                     {
    ///                         sourceQueue.Arn,
    ///                     },
    ///                 },
    ///             },
    ///         })),
    ///     });
    /// 
    ///     var targetQueue = new Aws.Sqs.Queue("target");
    /// 
    ///     var target = new Aws.Iam.RolePolicy("target", new()
    ///     {
    ///         Role = example.Id,
    ///         Policy = Output.JsonSerialize(Output.Create(new Dictionary&lt;string, object?&gt;
    ///         {
    ///             ["Version"] = "2012-10-17",
    ///             ["Statement"] = new[]
    ///             {
    ///                 new Dictionary&lt;string, object?&gt;
    ///                 {
    ///                     ["Effect"] = "Allow",
    ///                     ["Action"] = new[]
    ///                     {
    ///                         "sqs:SendMessage",
    ///                     },
    ///                     ["Resource"] = new[]
    ///                     {
    ///                         targetQueue.Arn,
    ///                     },
    ///                 },
    ///             },
    ///         })),
    ///     });
    /// 
    ///     var examplePipe = new Aws.Pipes.Pipe("example", new()
    ///     {
    ///         Name = "example-pipe",
    ///         RoleArn = example.Arn,
    ///         Source = sourceQueue.Arn,
    ///         Target = targetQueue.Arn,
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn =
    ///         {
    ///             source,
    ///             target,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Enrichment Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Aws = Pulumi.Aws;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var example = new Aws.Pipes.Pipe("example", new()
    ///     {
    ///         Name = "example-pipe",
    ///         RoleArn = exampleAwsIamRole.Arn,
    ///         Source = source.Arn,
    ///         Target = target.Arn,
    ///         Enrichment = exampleAwsCloudwatchEventApiDestination.Arn,
    ///         EnrichmentParameters = new Aws.Pipes.Inputs.PipeEnrichmentParametersArgs
    ///         {
    ///             HttpParameters = new Aws.Pipes.Inputs.PipeEnrichmentParametersHttpParametersArgs
    ///             {
    ///                 PathParameterValues = "example-path-param",
    ///                 HeaderParameters = 
    ///                 {
    ///                     { "example-header", "example-value" },
    ///                     { "second-example-header", "second-example-value" },
    ///                 },
    ///                 QueryStringParameters = 
    ///                 {
    ///                     { "example-query-string", "example-value" },
    ///                     { "second-example-query-string", "second-example-value" },
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Filter Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using System.Text.Json;
    /// using Pulumi;
    /// using Aws = Pulumi.Aws;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var example = new Aws.Pipes.Pipe("example", new()
    ///     {
    ///         Name = "example-pipe",
    ///         RoleArn = exampleAwsIamRole.Arn,
    ///         Source = source.Arn,
    ///         Target = target.Arn,
    ///         SourceParameters = new Aws.Pipes.Inputs.PipeSourceParametersArgs
    ///         {
    ///             FilterCriteria = new Aws.Pipes.Inputs.PipeSourceParametersFilterCriteriaArgs
    ///             {
    ///                 Filters = new[]
    ///                 {
    ///                     new Aws.Pipes.Inputs.PipeSourceParametersFilterCriteriaFilterArgs
    ///                     {
    ///                         Pattern = JsonSerializer.Serialize(new Dictionary&lt;string, object?&gt;
    ///                         {
    ///                             ["source"] = new[]
    ///                             {
    ///                                 "event-source",
    ///                             },
    ///                         }),
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### CloudWatch Logs Logging Configuration Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Aws = Pulumi.Aws;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var example = new Aws.CloudWatch.LogGroup("example", new()
    ///     {
    ///         Name = "example-pipe-target",
    ///     });
    /// 
    ///     var examplePipe = new Aws.Pipes.Pipe("example", new()
    ///     {
    ///         Name = "example-pipe",
    ///         RoleArn = exampleAwsIamRole.Arn,
    ///         Source = sourceAwsSqsQueue.Arn,
    ///         Target = targetAwsSqsQueue.Arn,
    ///         LogConfiguration = new Aws.Pipes.Inputs.PipeLogConfigurationArgs
    ///         {
    ///             IncludeExecutionDatas = new[]
    ///             {
    ///                 "ALL",
    ///             },
    ///             Level = "INFO",
    ///             CloudwatchLogsLogDestination = new Aws.Pipes.Inputs.PipeLogConfigurationCloudwatchLogsLogDestinationArgs
    ///             {
    ///                 LogGroupArn = targetAwsCloudwatchLogGroup.Arn,
    ///             },
    ///         },
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn =
    ///         {
    ///             source,
    ///             target,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### SQS Source and Target Configuration Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Aws = Pulumi.Aws;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var example = new Aws.Pipes.Pipe("example", new()
    ///     {
    ///         Name = "example-pipe",
    ///         RoleArn = exampleAwsIamRole.Arn,
    ///         Source = source.Arn,
    ///         Target = target.Arn,
    ///         SourceParameters = new Aws.Pipes.Inputs.PipeSourceParametersArgs
    ///         {
    ///             SqsQueueParameters = new Aws.Pipes.Inputs.PipeSourceParametersSqsQueueParametersArgs
    ///             {
    ///                 BatchSize = 1,
    ///                 MaximumBatchingWindowInSeconds = 2,
    ///             },
    ///         },
    ///         TargetParameters = new Aws.Pipes.Inputs.PipeTargetParametersArgs
    ///         {
    ///             SqsQueueParameters = new Aws.Pipes.Inputs.PipeTargetParametersSqsQueueParametersArgs
    ///             {
    ///                 MessageDeduplicationId = "example-dedupe",
    ///                 MessageGroupId = "example-group",
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// Using `pulumi import`, import pipes using the `name`. For example:
    /// 
    /// ```sh
    /// $ pulumi import aws:pipes/pipe:Pipe example my-pipe
    /// ```
    /// </summary>
    [AwsResourceType("aws:pipes/pipe:Pipe")]
    public partial class Pipe : global::Pulumi.CustomResource
    {
        /// <summary>
        /// ARN of this pipe.
        /// </summary>
        [Output("arn")]
        public Output<string> Arn { get; private set; } = null!;

        /// <summary>
        /// A description of the pipe. At most 512 characters.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// The state the pipe should be in. One of: `RUNNING`, `STOPPED`.
        /// </summary>
        [Output("desiredState")]
        public Output<string?> DesiredState { get; private set; } = null!;

        /// <summary>
        /// Enrichment resource of the pipe (typically an ARN). Read more about enrichment in the [User Guide](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-pipes.html#pipes-enrichment).
        /// </summary>
        [Output("enrichment")]
        public Output<string?> Enrichment { get; private set; } = null!;

        /// <summary>
        /// Parameters to configure enrichment for your pipe. Detailed below.
        /// </summary>
        [Output("enrichmentParameters")]
        public Output<Outputs.PipeEnrichmentParameters?> EnrichmentParameters { get; private set; } = null!;

        /// <summary>
        /// Identifier of the AWS KMS customer managed key for EventBridge to use, if you choose to use a customer managed key to encrypt pipe data. The identifier can be the key Amazon Resource Name (ARN), KeyId, key alias, or key alias ARN. If not set, EventBridge uses an AWS owned key to encrypt pipe data.
        /// </summary>
        [Output("kmsKeyIdentifier")]
        public Output<string?> KmsKeyIdentifier { get; private set; } = null!;

        /// <summary>
        /// Logging configuration settings for the pipe. Detailed below.
        /// </summary>
        [Output("logConfiguration")]
        public Output<Outputs.PipeLogConfiguration?> LogConfiguration { get; private set; } = null!;

        /// <summary>
        /// Name of the pipe. If omitted, the provider will assign a random, unique name. Conflicts with `name_prefix`.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Creates a unique name beginning with the specified prefix. Conflicts with `name`.
        /// </summary>
        [Output("namePrefix")]
        public Output<string> NamePrefix { get; private set; } = null!;

        /// <summary>
        /// ARN of the role that allows the pipe to send data to the target.
        /// </summary>
        [Output("roleArn")]
        public Output<string> RoleArn { get; private set; } = null!;

        /// <summary>
        /// Source resource of the pipe. This field typically requires an ARN (Amazon Resource Name). However, when using a self-managed Kafka cluster, you should use a different format. Instead of an ARN, use 'smk://' followed by the bootstrap server's address.
        /// </summary>
        [Output("source")]
        public Output<string> Source { get; private set; } = null!;

        /// <summary>
        /// Parameters to configure a source for the pipe. Detailed below.
        /// </summary>
        [Output("sourceParameters")]
        public Output<Outputs.PipeSourceParameters> SourceParameters { get; private set; } = null!;

        /// <summary>
        /// Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableDictionary<string, string>?> Tags { get; private set; } = null!;

        /// <summary>
        /// Map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
        /// </summary>
        [Output("tagsAll")]
        public Output<ImmutableDictionary<string, string>> TagsAll { get; private set; } = null!;

        /// <summary>
        /// Target resource of the pipe (typically an ARN).
        /// 
        /// The following arguments are optional:
        /// </summary>
        [Output("target")]
        public Output<string> Target { get; private set; } = null!;

        /// <summary>
        /// Parameters to configure a target for your pipe. Detailed below.
        /// </summary>
        [Output("targetParameters")]
        public Output<Outputs.PipeTargetParameters?> TargetParameters { get; private set; } = null!;


        /// <summary>
        /// Create a Pipe resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Pipe(string name, PipeArgs args, CustomResourceOptions? options = null)
            : base("aws:pipes/pipe:Pipe", name, args ?? new PipeArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Pipe(string name, Input<string> id, PipeState? state = null, CustomResourceOptions? options = null)
            : base("aws:pipes/pipe:Pipe", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Pipe resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Pipe Get(string name, Input<string> id, PipeState? state = null, CustomResourceOptions? options = null)
        {
            return new Pipe(name, id, state, options);
        }
    }

    public sealed class PipeArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// A description of the pipe. At most 512 characters.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The state the pipe should be in. One of: `RUNNING`, `STOPPED`.
        /// </summary>
        [Input("desiredState")]
        public Input<string>? DesiredState { get; set; }

        /// <summary>
        /// Enrichment resource of the pipe (typically an ARN). Read more about enrichment in the [User Guide](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-pipes.html#pipes-enrichment).
        /// </summary>
        [Input("enrichment")]
        public Input<string>? Enrichment { get; set; }

        /// <summary>
        /// Parameters to configure enrichment for your pipe. Detailed below.
        /// </summary>
        [Input("enrichmentParameters")]
        public Input<Inputs.PipeEnrichmentParametersArgs>? EnrichmentParameters { get; set; }

        /// <summary>
        /// Identifier of the AWS KMS customer managed key for EventBridge to use, if you choose to use a customer managed key to encrypt pipe data. The identifier can be the key Amazon Resource Name (ARN), KeyId, key alias, or key alias ARN. If not set, EventBridge uses an AWS owned key to encrypt pipe data.
        /// </summary>
        [Input("kmsKeyIdentifier")]
        public Input<string>? KmsKeyIdentifier { get; set; }

        /// <summary>
        /// Logging configuration settings for the pipe. Detailed below.
        /// </summary>
        [Input("logConfiguration")]
        public Input<Inputs.PipeLogConfigurationArgs>? LogConfiguration { get; set; }

        /// <summary>
        /// Name of the pipe. If omitted, the provider will assign a random, unique name. Conflicts with `name_prefix`.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Creates a unique name beginning with the specified prefix. Conflicts with `name`.
        /// </summary>
        [Input("namePrefix")]
        public Input<string>? NamePrefix { get; set; }

        /// <summary>
        /// ARN of the role that allows the pipe to send data to the target.
        /// </summary>
        [Input("roleArn", required: true)]
        public Input<string> RoleArn { get; set; } = null!;

        /// <summary>
        /// Source resource of the pipe. This field typically requires an ARN (Amazon Resource Name). However, when using a self-managed Kafka cluster, you should use a different format. Instead of an ARN, use 'smk://' followed by the bootstrap server's address.
        /// </summary>
        [Input("source", required: true)]
        public Input<string> Source { get; set; } = null!;

        /// <summary>
        /// Parameters to configure a source for the pipe. Detailed below.
        /// </summary>
        [Input("sourceParameters")]
        public Input<Inputs.PipeSourceParametersArgs>? SourceParameters { get; set; }

        [Input("tags")]
        private InputMap<string>? _tags;

        /// <summary>
        /// Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        /// </summary>
        public InputMap<string> Tags
        {
            get => _tags ?? (_tags = new InputMap<string>());
            set => _tags = value;
        }

        /// <summary>
        /// Target resource of the pipe (typically an ARN).
        /// 
        /// The following arguments are optional:
        /// </summary>
        [Input("target", required: true)]
        public Input<string> Target { get; set; } = null!;

        /// <summary>
        /// Parameters to configure a target for your pipe. Detailed below.
        /// </summary>
        [Input("targetParameters")]
        public Input<Inputs.PipeTargetParametersArgs>? TargetParameters { get; set; }

        public PipeArgs()
        {
        }
        public static new PipeArgs Empty => new PipeArgs();
    }

    public sealed class PipeState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// ARN of this pipe.
        /// </summary>
        [Input("arn")]
        public Input<string>? Arn { get; set; }

        /// <summary>
        /// A description of the pipe. At most 512 characters.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The state the pipe should be in. One of: `RUNNING`, `STOPPED`.
        /// </summary>
        [Input("desiredState")]
        public Input<string>? DesiredState { get; set; }

        /// <summary>
        /// Enrichment resource of the pipe (typically an ARN). Read more about enrichment in the [User Guide](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-pipes.html#pipes-enrichment).
        /// </summary>
        [Input("enrichment")]
        public Input<string>? Enrichment { get; set; }

        /// <summary>
        /// Parameters to configure enrichment for your pipe. Detailed below.
        /// </summary>
        [Input("enrichmentParameters")]
        public Input<Inputs.PipeEnrichmentParametersGetArgs>? EnrichmentParameters { get; set; }

        /// <summary>
        /// Identifier of the AWS KMS customer managed key for EventBridge to use, if you choose to use a customer managed key to encrypt pipe data. The identifier can be the key Amazon Resource Name (ARN), KeyId, key alias, or key alias ARN. If not set, EventBridge uses an AWS owned key to encrypt pipe data.
        /// </summary>
        [Input("kmsKeyIdentifier")]
        public Input<string>? KmsKeyIdentifier { get; set; }

        /// <summary>
        /// Logging configuration settings for the pipe. Detailed below.
        /// </summary>
        [Input("logConfiguration")]
        public Input<Inputs.PipeLogConfigurationGetArgs>? LogConfiguration { get; set; }

        /// <summary>
        /// Name of the pipe. If omitted, the provider will assign a random, unique name. Conflicts with `name_prefix`.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Creates a unique name beginning with the specified prefix. Conflicts with `name`.
        /// </summary>
        [Input("namePrefix")]
        public Input<string>? NamePrefix { get; set; }

        /// <summary>
        /// ARN of the role that allows the pipe to send data to the target.
        /// </summary>
        [Input("roleArn")]
        public Input<string>? RoleArn { get; set; }

        /// <summary>
        /// Source resource of the pipe. This field typically requires an ARN (Amazon Resource Name). However, when using a self-managed Kafka cluster, you should use a different format. Instead of an ARN, use 'smk://' followed by the bootstrap server's address.
        /// </summary>
        [Input("source")]
        public Input<string>? Source { get; set; }

        /// <summary>
        /// Parameters to configure a source for the pipe. Detailed below.
        /// </summary>
        [Input("sourceParameters")]
        public Input<Inputs.PipeSourceParametersGetArgs>? SourceParameters { get; set; }

        [Input("tags")]
        private InputMap<string>? _tags;

        /// <summary>
        /// Key-value mapping of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        /// </summary>
        public InputMap<string> Tags
        {
            get => _tags ?? (_tags = new InputMap<string>());
            set => _tags = value;
        }

        [Input("tagsAll")]
        private InputMap<string>? _tagsAll;

        /// <summary>
        /// Map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
        /// </summary>
        public InputMap<string> TagsAll
        {
            get => _tagsAll ?? (_tagsAll = new InputMap<string>());
            set => _tagsAll = value;
        }

        /// <summary>
        /// Target resource of the pipe (typically an ARN).
        /// 
        /// The following arguments are optional:
        /// </summary>
        [Input("target")]
        public Input<string>? Target { get; set; }

        /// <summary>
        /// Parameters to configure a target for your pipe. Detailed below.
        /// </summary>
        [Input("targetParameters")]
        public Input<Inputs.PipeTargetParametersGetArgs>? TargetParameters { get; set; }

        public PipeState()
        {
        }
        public static new PipeState Empty => new PipeState();
    }
}
