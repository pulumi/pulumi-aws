# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'CustomActionTypeConfigurationPropertyArgs',
    'CustomActionTypeConfigurationPropertyArgsDict',
    'CustomActionTypeInputArtifactDetailsArgs',
    'CustomActionTypeInputArtifactDetailsArgsDict',
    'CustomActionTypeOutputArtifactDetailsArgs',
    'CustomActionTypeOutputArtifactDetailsArgsDict',
    'CustomActionTypeSettingsArgs',
    'CustomActionTypeSettingsArgsDict',
    'PipelineArtifactStoreArgs',
    'PipelineArtifactStoreArgsDict',
    'PipelineArtifactStoreEncryptionKeyArgs',
    'PipelineArtifactStoreEncryptionKeyArgsDict',
    'PipelineStageArgs',
    'PipelineStageArgsDict',
    'PipelineStageActionArgs',
    'PipelineStageActionArgsDict',
    'PipelineStageBeforeEntryArgs',
    'PipelineStageBeforeEntryArgsDict',
    'PipelineStageBeforeEntryConditionArgs',
    'PipelineStageBeforeEntryConditionArgsDict',
    'PipelineStageBeforeEntryConditionRuleArgs',
    'PipelineStageBeforeEntryConditionRuleArgsDict',
    'PipelineStageBeforeEntryConditionRuleRuleTypeIdArgs',
    'PipelineStageBeforeEntryConditionRuleRuleTypeIdArgsDict',
    'PipelineStageOnFailureArgs',
    'PipelineStageOnFailureArgsDict',
    'PipelineStageOnFailureConditionArgs',
    'PipelineStageOnFailureConditionArgsDict',
    'PipelineStageOnFailureConditionRuleArgs',
    'PipelineStageOnFailureConditionRuleArgsDict',
    'PipelineStageOnFailureConditionRuleRuleTypeIdArgs',
    'PipelineStageOnFailureConditionRuleRuleTypeIdArgsDict',
    'PipelineStageOnFailureRetryConfigurationArgs',
    'PipelineStageOnFailureRetryConfigurationArgsDict',
    'PipelineStageOnSuccessArgs',
    'PipelineStageOnSuccessArgsDict',
    'PipelineStageOnSuccessConditionArgs',
    'PipelineStageOnSuccessConditionArgsDict',
    'PipelineStageOnSuccessConditionRuleArgs',
    'PipelineStageOnSuccessConditionRuleArgsDict',
    'PipelineStageOnSuccessConditionRuleRuleTypeIdArgs',
    'PipelineStageOnSuccessConditionRuleRuleTypeIdArgsDict',
    'PipelineTriggerArgs',
    'PipelineTriggerArgsDict',
    'PipelineTriggerAllArgs',
    'PipelineTriggerAllArgsDict',
    'PipelineTriggerAllGitConfigurationArgs',
    'PipelineTriggerAllGitConfigurationArgsDict',
    'PipelineTriggerAllGitConfigurationPullRequestArgs',
    'PipelineTriggerAllGitConfigurationPullRequestArgsDict',
    'PipelineTriggerAllGitConfigurationPullRequestBranchArgs',
    'PipelineTriggerAllGitConfigurationPullRequestBranchArgsDict',
    'PipelineTriggerAllGitConfigurationPullRequestFilePathArgs',
    'PipelineTriggerAllGitConfigurationPullRequestFilePathArgsDict',
    'PipelineTriggerAllGitConfigurationPushArgs',
    'PipelineTriggerAllGitConfigurationPushArgsDict',
    'PipelineTriggerAllGitConfigurationPushBranchArgs',
    'PipelineTriggerAllGitConfigurationPushBranchArgsDict',
    'PipelineTriggerAllGitConfigurationPushFilePathArgs',
    'PipelineTriggerAllGitConfigurationPushFilePathArgsDict',
    'PipelineTriggerAllGitConfigurationPushTagArgs',
    'PipelineTriggerAllGitConfigurationPushTagArgsDict',
    'PipelineTriggerGitConfigurationArgs',
    'PipelineTriggerGitConfigurationArgsDict',
    'PipelineTriggerGitConfigurationPullRequestArgs',
    'PipelineTriggerGitConfigurationPullRequestArgsDict',
    'PipelineTriggerGitConfigurationPullRequestBranchesArgs',
    'PipelineTriggerGitConfigurationPullRequestBranchesArgsDict',
    'PipelineTriggerGitConfigurationPullRequestFilePathsArgs',
    'PipelineTriggerGitConfigurationPullRequestFilePathsArgsDict',
    'PipelineTriggerGitConfigurationPushArgs',
    'PipelineTriggerGitConfigurationPushArgsDict',
    'PipelineTriggerGitConfigurationPushBranchesArgs',
    'PipelineTriggerGitConfigurationPushBranchesArgsDict',
    'PipelineTriggerGitConfigurationPushFilePathsArgs',
    'PipelineTriggerGitConfigurationPushFilePathsArgsDict',
    'PipelineTriggerGitConfigurationPushTagsArgs',
    'PipelineTriggerGitConfigurationPushTagsArgsDict',
    'PipelineVariableArgs',
    'PipelineVariableArgsDict',
    'WebhookAuthenticationConfigurationArgs',
    'WebhookAuthenticationConfigurationArgsDict',
    'WebhookFilterArgs',
    'WebhookFilterArgsDict',
]

MYPY = False

if not MYPY:
    class CustomActionTypeConfigurationPropertyArgsDict(TypedDict):
        key: pulumi.Input[builtins.bool]
        """
        Whether the configuration property is a key.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the action configuration property.
        """
        required: pulumi.Input[builtins.bool]
        """
        Whether the configuration property is a required value.
        """
        secret: pulumi.Input[builtins.bool]
        """
        Whether the configuration property is secret.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The description of the action configuration property.
        """
        queryable: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates that the property will be used in conjunction with PollForJobs.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The type of the configuration property. Valid values: `String`, `Number`, `Boolean`
        """
elif False:
    CustomActionTypeConfigurationPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomActionTypeConfigurationPropertyArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.bool],
                 name: pulumi.Input[builtins.str],
                 required: pulumi.Input[builtins.bool],
                 secret: pulumi.Input[builtins.bool],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 queryable: Optional[pulumi.Input[builtins.bool]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] key: Whether the configuration property is a key.
        :param pulumi.Input[builtins.str] name: The name of the action configuration property.
        :param pulumi.Input[builtins.bool] required: Whether the configuration property is a required value.
        :param pulumi.Input[builtins.bool] secret: Whether the configuration property is secret.
        :param pulumi.Input[builtins.str] description: The description of the action configuration property.
        :param pulumi.Input[builtins.bool] queryable: Indicates that the property will be used in conjunction with PollForJobs.
        :param pulumi.Input[builtins.str] type: The type of the configuration property. Valid values: `String`, `Number`, `Boolean`
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "required", required)
        pulumi.set(__self__, "secret", secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if queryable is not None:
            pulumi.set(__self__, "queryable", queryable)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.bool]:
        """
        Whether the configuration property is a key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the action configuration property.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def required(self) -> pulumi.Input[builtins.bool]:
        """
        Whether the configuration property is a required value.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[builtins.bool]:
        """
        Whether the configuration property is secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of the action configuration property.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def queryable(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates that the property will be used in conjunction with PollForJobs.
        """
        return pulumi.get(self, "queryable")

    @queryable.setter
    def queryable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "queryable", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The type of the configuration property. Valid values: `String`, `Number`, `Boolean`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CustomActionTypeInputArtifactDetailsArgsDict(TypedDict):
        maximum_count: pulumi.Input[builtins.int]
        """
        The maximum number of artifacts allowed for the action type. Min: 0, Max: 5
        """
        minimum_count: pulumi.Input[builtins.int]
        """
        The minimum number of artifacts allowed for the action type. Min: 0, Max: 5
        """
elif False:
    CustomActionTypeInputArtifactDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomActionTypeInputArtifactDetailsArgs:
    def __init__(__self__, *,
                 maximum_count: pulumi.Input[builtins.int],
                 minimum_count: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.int] maximum_count: The maximum number of artifacts allowed for the action type. Min: 0, Max: 5
        :param pulumi.Input[builtins.int] minimum_count: The minimum number of artifacts allowed for the action type. Min: 0, Max: 5
        """
        pulumi.set(__self__, "maximum_count", maximum_count)
        pulumi.set(__self__, "minimum_count", minimum_count)

    @property
    @pulumi.getter(name="maximumCount")
    def maximum_count(self) -> pulumi.Input[builtins.int]:
        """
        The maximum number of artifacts allowed for the action type. Min: 0, Max: 5
        """
        return pulumi.get(self, "maximum_count")

    @maximum_count.setter
    def maximum_count(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "maximum_count", value)

    @property
    @pulumi.getter(name="minimumCount")
    def minimum_count(self) -> pulumi.Input[builtins.int]:
        """
        The minimum number of artifacts allowed for the action type. Min: 0, Max: 5
        """
        return pulumi.get(self, "minimum_count")

    @minimum_count.setter
    def minimum_count(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "minimum_count", value)


if not MYPY:
    class CustomActionTypeOutputArtifactDetailsArgsDict(TypedDict):
        maximum_count: pulumi.Input[builtins.int]
        """
        The maximum number of artifacts allowed for the action type. Min: 0, Max: 5
        """
        minimum_count: pulumi.Input[builtins.int]
        """
        The minimum number of artifacts allowed for the action type. Min: 0, Max: 5
        """
elif False:
    CustomActionTypeOutputArtifactDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomActionTypeOutputArtifactDetailsArgs:
    def __init__(__self__, *,
                 maximum_count: pulumi.Input[builtins.int],
                 minimum_count: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.int] maximum_count: The maximum number of artifacts allowed for the action type. Min: 0, Max: 5
        :param pulumi.Input[builtins.int] minimum_count: The minimum number of artifacts allowed for the action type. Min: 0, Max: 5
        """
        pulumi.set(__self__, "maximum_count", maximum_count)
        pulumi.set(__self__, "minimum_count", minimum_count)

    @property
    @pulumi.getter(name="maximumCount")
    def maximum_count(self) -> pulumi.Input[builtins.int]:
        """
        The maximum number of artifacts allowed for the action type. Min: 0, Max: 5
        """
        return pulumi.get(self, "maximum_count")

    @maximum_count.setter
    def maximum_count(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "maximum_count", value)

    @property
    @pulumi.getter(name="minimumCount")
    def minimum_count(self) -> pulumi.Input[builtins.int]:
        """
        The minimum number of artifacts allowed for the action type. Min: 0, Max: 5
        """
        return pulumi.get(self, "minimum_count")

    @minimum_count.setter
    def minimum_count(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "minimum_count", value)


if not MYPY:
    class CustomActionTypeSettingsArgsDict(TypedDict):
        entity_url_template: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL returned to the AWS CodePipeline console that provides a deep link to the resources of the external system.
        """
        execution_url_template: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL returned to the AWS CodePipeline console that contains a link to the top-level landing page for the external system.
        """
        revision_url_template: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL returned to the AWS CodePipeline console that contains a link to the page where customers can update or change the configuration of the external action.
        """
        third_party_configuration_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL of a sign-up page where users can sign up for an external service and perform initial configuration of the action provided by that service.
        """
elif False:
    CustomActionTypeSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomActionTypeSettingsArgs:
    def __init__(__self__, *,
                 entity_url_template: Optional[pulumi.Input[builtins.str]] = None,
                 execution_url_template: Optional[pulumi.Input[builtins.str]] = None,
                 revision_url_template: Optional[pulumi.Input[builtins.str]] = None,
                 third_party_configuration_url: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] entity_url_template: The URL returned to the AWS CodePipeline console that provides a deep link to the resources of the external system.
        :param pulumi.Input[builtins.str] execution_url_template: The URL returned to the AWS CodePipeline console that contains a link to the top-level landing page for the external system.
        :param pulumi.Input[builtins.str] revision_url_template: The URL returned to the AWS CodePipeline console that contains a link to the page where customers can update or change the configuration of the external action.
        :param pulumi.Input[builtins.str] third_party_configuration_url: The URL of a sign-up page where users can sign up for an external service and perform initial configuration of the action provided by that service.
        """
        if entity_url_template is not None:
            pulumi.set(__self__, "entity_url_template", entity_url_template)
        if execution_url_template is not None:
            pulumi.set(__self__, "execution_url_template", execution_url_template)
        if revision_url_template is not None:
            pulumi.set(__self__, "revision_url_template", revision_url_template)
        if third_party_configuration_url is not None:
            pulumi.set(__self__, "third_party_configuration_url", third_party_configuration_url)

    @property
    @pulumi.getter(name="entityUrlTemplate")
    def entity_url_template(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL returned to the AWS CodePipeline console that provides a deep link to the resources of the external system.
        """
        return pulumi.get(self, "entity_url_template")

    @entity_url_template.setter
    def entity_url_template(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "entity_url_template", value)

    @property
    @pulumi.getter(name="executionUrlTemplate")
    def execution_url_template(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL returned to the AWS CodePipeline console that contains a link to the top-level landing page for the external system.
        """
        return pulumi.get(self, "execution_url_template")

    @execution_url_template.setter
    def execution_url_template(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "execution_url_template", value)

    @property
    @pulumi.getter(name="revisionUrlTemplate")
    def revision_url_template(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL returned to the AWS CodePipeline console that contains a link to the page where customers can update or change the configuration of the external action.
        """
        return pulumi.get(self, "revision_url_template")

    @revision_url_template.setter
    def revision_url_template(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "revision_url_template", value)

    @property
    @pulumi.getter(name="thirdPartyConfigurationUrl")
    def third_party_configuration_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL of a sign-up page where users can sign up for an external service and perform initial configuration of the action provided by that service.
        """
        return pulumi.get(self, "third_party_configuration_url")

    @third_party_configuration_url.setter
    def third_party_configuration_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "third_party_configuration_url", value)


if not MYPY:
    class PipelineArtifactStoreArgsDict(TypedDict):
        location: pulumi.Input[builtins.str]
        """
        The location where AWS CodePipeline stores artifacts for a pipeline; currently only `S3` is supported.
        """
        type: pulumi.Input[builtins.str]
        """
        The type of the artifact store, such as Amazon S3
        """
        encryption_key: NotRequired[pulumi.Input['PipelineArtifactStoreEncryptionKeyArgsDict']]
        """
        The encryption key block AWS CodePipeline uses to encrypt the data in the artifact store, such as an AWS Key Management Service (AWS KMS) key. If you don't specify a key, AWS CodePipeline uses the default key for Amazon Simple Storage Service (Amazon S3). An `encryption_key` block is documented below.
        """
        region: NotRequired[pulumi.Input[builtins.str]]
        """
        The region where the artifact store is located. Required for a cross-region CodePipeline, do not provide for a single-region CodePipeline.
        """
elif False:
    PipelineArtifactStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineArtifactStoreArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 encryption_key: Optional[pulumi.Input['PipelineArtifactStoreEncryptionKeyArgs']] = None,
                 region: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] location: The location where AWS CodePipeline stores artifacts for a pipeline; currently only `S3` is supported.
        :param pulumi.Input[builtins.str] type: The type of the artifact store, such as Amazon S3
        :param pulumi.Input['PipelineArtifactStoreEncryptionKeyArgs'] encryption_key: The encryption key block AWS CodePipeline uses to encrypt the data in the artifact store, such as an AWS Key Management Service (AWS KMS) key. If you don't specify a key, AWS CodePipeline uses the default key for Amazon Simple Storage Service (Amazon S3). An `encryption_key` block is documented below.
        :param pulumi.Input[builtins.str] region: The region where the artifact store is located. Required for a cross-region CodePipeline, do not provide for a single-region CodePipeline.
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "type", type)
        if encryption_key is not None:
            pulumi.set(__self__, "encryption_key", encryption_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[builtins.str]:
        """
        The location where AWS CodePipeline stores artifacts for a pipeline; currently only `S3` is supported.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of the artifact store, such as Amazon S3
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="encryptionKey")
    def encryption_key(self) -> Optional[pulumi.Input['PipelineArtifactStoreEncryptionKeyArgs']]:
        """
        The encryption key block AWS CodePipeline uses to encrypt the data in the artifact store, such as an AWS Key Management Service (AWS KMS) key. If you don't specify a key, AWS CodePipeline uses the default key for Amazon Simple Storage Service (Amazon S3). An `encryption_key` block is documented below.
        """
        return pulumi.get(self, "encryption_key")

    @encryption_key.setter
    def encryption_key(self, value: Optional[pulumi.Input['PipelineArtifactStoreEncryptionKeyArgs']]):
        pulumi.set(self, "encryption_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The region where the artifact store is located. Required for a cross-region CodePipeline, do not provide for a single-region CodePipeline.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class PipelineArtifactStoreEncryptionKeyArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        """
        The KMS key ARN or ID
        """
        type: pulumi.Input[builtins.str]
        """
        The type of key; currently only `KMS` is supported
        """
elif False:
    PipelineArtifactStoreEncryptionKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineArtifactStoreEncryptionKeyArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] id: The KMS key ARN or ID
        :param pulumi.Input[builtins.str] type: The type of key; currently only `KMS` is supported
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        The KMS key ARN or ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of key; currently only `KMS` is supported
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PipelineStageArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input['PipelineStageActionArgsDict']]]
        """
        The action(s) to include in the stage. Defined as an `action` block below
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the stage.
        """
        before_entry: NotRequired[pulumi.Input['PipelineStageBeforeEntryArgsDict']]
        """
        The method to use when a stage allows entry. For example, configuring this field for conditions will allow entry to the stage when the conditions are met.
        """
        on_failure: NotRequired[pulumi.Input['PipelineStageOnFailureArgsDict']]
        """
        The method to use when a stage has not completed successfully. For example, configuring this field for rollback will roll back a failed stage automatically to the last successful pipeline execution in the stage.
        """
        on_success: NotRequired[pulumi.Input['PipelineStageOnSuccessArgsDict']]
        """
        The method to use when a stage has succeeded. For example, configuring this field for conditions will allow the stage to succeed when the conditions are met.
        """
elif False:
    PipelineStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input['PipelineStageActionArgs']]],
                 name: pulumi.Input[builtins.str],
                 before_entry: Optional[pulumi.Input['PipelineStageBeforeEntryArgs']] = None,
                 on_failure: Optional[pulumi.Input['PipelineStageOnFailureArgs']] = None,
                 on_success: Optional[pulumi.Input['PipelineStageOnSuccessArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PipelineStageActionArgs']]] actions: The action(s) to include in the stage. Defined as an `action` block below
        :param pulumi.Input[builtins.str] name: The name of the stage.
        :param pulumi.Input['PipelineStageBeforeEntryArgs'] before_entry: The method to use when a stage allows entry. For example, configuring this field for conditions will allow entry to the stage when the conditions are met.
        :param pulumi.Input['PipelineStageOnFailureArgs'] on_failure: The method to use when a stage has not completed successfully. For example, configuring this field for rollback will roll back a failed stage automatically to the last successful pipeline execution in the stage.
        :param pulumi.Input['PipelineStageOnSuccessArgs'] on_success: The method to use when a stage has succeeded. For example, configuring this field for conditions will allow the stage to succeed when the conditions are met.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "name", name)
        if before_entry is not None:
            pulumi.set(__self__, "before_entry", before_entry)
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_success is not None:
            pulumi.set(__self__, "on_success", on_success)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input['PipelineStageActionArgs']]]:
        """
        The action(s) to include in the stage. Defined as an `action` block below
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input['PipelineStageActionArgs']]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the stage.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="beforeEntry")
    def before_entry(self) -> Optional[pulumi.Input['PipelineStageBeforeEntryArgs']]:
        """
        The method to use when a stage allows entry. For example, configuring this field for conditions will allow entry to the stage when the conditions are met.
        """
        return pulumi.get(self, "before_entry")

    @before_entry.setter
    def before_entry(self, value: Optional[pulumi.Input['PipelineStageBeforeEntryArgs']]):
        pulumi.set(self, "before_entry", value)

    @property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['PipelineStageOnFailureArgs']]:
        """
        The method to use when a stage has not completed successfully. For example, configuring this field for rollback will roll back a failed stage automatically to the last successful pipeline execution in the stage.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['PipelineStageOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)

    @property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional[pulumi.Input['PipelineStageOnSuccessArgs']]:
        """
        The method to use when a stage has succeeded. For example, configuring this field for conditions will allow the stage to succeed when the conditions are met.
        """
        return pulumi.get(self, "on_success")

    @on_success.setter
    def on_success(self, value: Optional[pulumi.Input['PipelineStageOnSuccessArgs']]):
        pulumi.set(self, "on_success", value)


if not MYPY:
    class PipelineStageActionArgsDict(TypedDict):
        category: pulumi.Input[builtins.str]
        """
        A category defines what kind of action can be taken in the stage, and constrains the provider type for the action. Possible values are `Approval`, `Build`, `Deploy`, `Invoke`, `Source` and `Test`.
        """
        name: pulumi.Input[builtins.str]
        """
        The action declaration's name.
        """
        owner: pulumi.Input[builtins.str]
        """
        The creator of the action being called. Possible values are `AWS`, `Custom` and `ThirdParty`.
        """
        provider: pulumi.Input[builtins.str]
        """
        The provider of the service being called by the action. Valid providers are determined by the action category. Provider names are listed in the [Action Structure Reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/action-reference.html) documentation.
        """
        version: pulumi.Input[builtins.str]
        """
        A string that identifies the action type.
        """
        configuration: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        A map of the action declaration's configuration. Configurations options for action types and providers can be found in the [Pipeline Structure Reference](http://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html#action-requirements) and [Action Structure Reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/action-reference.html) documentation. Note: The `DetectChanges` parameter (optional, default value is true) in the `configuration` section causes CodePipeline to automatically start your pipeline upon new commits. Please refer to AWS Documentation for more details: https://docs.aws.amazon.com/codepipeline/latest/userguide/action-reference-CodestarConnectionSource.html#action-reference-CodestarConnectionSource-config.
        """
        input_artifacts: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of artifact names to be worked on.
        """
        namespace: NotRequired[pulumi.Input[builtins.str]]
        """
        The namespace all output variables will be accessed from.
        """
        output_artifacts: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of artifact names to output. Output artifact names must be unique within a pipeline.
        """
        region: NotRequired[pulumi.Input[builtins.str]]
        """
        The region in which to run the action.
        """
        role_arn: NotRequired[pulumi.Input[builtins.str]]
        """
        The ARN of the IAM service role that will perform the declared action. This is assumed through the roleArn for the pipeline.
        """
        run_order: NotRequired[pulumi.Input[builtins.int]]
        """
        The order in which actions are run.
        """
        timeout_in_minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        The action timeout for the rule.
        """
elif False:
    PipelineStageActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageActionArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 owner: pulumi.Input[builtins.str],
                 provider: pulumi.Input[builtins.str],
                 version: pulumi.Input[builtins.str],
                 configuration: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 input_artifacts: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 namespace: Optional[pulumi.Input[builtins.str]] = None,
                 output_artifacts: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 region: Optional[pulumi.Input[builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[builtins.str]] = None,
                 run_order: Optional[pulumi.Input[builtins.int]] = None,
                 timeout_in_minutes: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] category: A category defines what kind of action can be taken in the stage, and constrains the provider type for the action. Possible values are `Approval`, `Build`, `Deploy`, `Invoke`, `Source` and `Test`.
        :param pulumi.Input[builtins.str] name: The action declaration's name.
        :param pulumi.Input[builtins.str] owner: The creator of the action being called. Possible values are `AWS`, `Custom` and `ThirdParty`.
        :param pulumi.Input[builtins.str] provider: The provider of the service being called by the action. Valid providers are determined by the action category. Provider names are listed in the [Action Structure Reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/action-reference.html) documentation.
        :param pulumi.Input[builtins.str] version: A string that identifies the action type.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] configuration: A map of the action declaration's configuration. Configurations options for action types and providers can be found in the [Pipeline Structure Reference](http://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html#action-requirements) and [Action Structure Reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/action-reference.html) documentation. Note: The `DetectChanges` parameter (optional, default value is true) in the `configuration` section causes CodePipeline to automatically start your pipeline upon new commits. Please refer to AWS Documentation for more details: https://docs.aws.amazon.com/codepipeline/latest/userguide/action-reference-CodestarConnectionSource.html#action-reference-CodestarConnectionSource-config.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] input_artifacts: A list of artifact names to be worked on.
        :param pulumi.Input[builtins.str] namespace: The namespace all output variables will be accessed from.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] output_artifacts: A list of artifact names to output. Output artifact names must be unique within a pipeline.
        :param pulumi.Input[builtins.str] region: The region in which to run the action.
        :param pulumi.Input[builtins.str] role_arn: The ARN of the IAM service role that will perform the declared action. This is assumed through the roleArn for the pipeline.
        :param pulumi.Input[builtins.int] run_order: The order in which actions are run.
        :param pulumi.Input[builtins.int] timeout_in_minutes: The action timeout for the rule.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "version", version)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if input_artifacts is not None:
            pulumi.set(__self__, "input_artifacts", input_artifacts)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if output_artifacts is not None:
            pulumi.set(__self__, "output_artifacts", output_artifacts)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if run_order is not None:
            pulumi.set(__self__, "run_order", run_order)
        if timeout_in_minutes is not None:
            pulumi.set(__self__, "timeout_in_minutes", timeout_in_minutes)

    @property
    @pulumi.getter
    def category(self) -> pulumi.Input[builtins.str]:
        """
        A category defines what kind of action can be taken in the stage, and constrains the provider type for the action. Possible values are `Approval`, `Build`, `Deploy`, `Invoke`, `Source` and `Test`.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The action declaration's name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def owner(self) -> pulumi.Input[builtins.str]:
        """
        The creator of the action being called. Possible values are `AWS`, `Custom` and `ThirdParty`.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter
    def provider(self) -> pulumi.Input[builtins.str]:
        """
        The provider of the service being called by the action. Valid providers are determined by the action category. Provider names are listed in the [Action Structure Reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/action-reference.html) documentation.
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[builtins.str]:
        """
        A string that identifies the action type.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        A map of the action declaration's configuration. Configurations options for action types and providers can be found in the [Pipeline Structure Reference](http://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html#action-requirements) and [Action Structure Reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/action-reference.html) documentation. Note: The `DetectChanges` parameter (optional, default value is true) in the `configuration` section causes CodePipeline to automatically start your pipeline upon new commits. Please refer to AWS Documentation for more details: https://docs.aws.amazon.com/codepipeline/latest/userguide/action-reference-CodestarConnectionSource.html#action-reference-CodestarConnectionSource-config.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter(name="inputArtifacts")
    def input_artifacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of artifact names to be worked on.
        """
        return pulumi.get(self, "input_artifacts")

    @input_artifacts.setter
    def input_artifacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "input_artifacts", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The namespace all output variables will be accessed from.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="outputArtifacts")
    def output_artifacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of artifact names to output. Output artifact names must be unique within a pipeline.
        """
        return pulumi.get(self, "output_artifacts")

    @output_artifacts.setter
    def output_artifacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "output_artifacts", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The region in which to run the action.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ARN of the IAM service role that will perform the declared action. This is assumed through the roleArn for the pipeline.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="runOrder")
    def run_order(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The order in which actions are run.
        """
        return pulumi.get(self, "run_order")

    @run_order.setter
    def run_order(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "run_order", value)

    @property
    @pulumi.getter(name="timeoutInMinutes")
    def timeout_in_minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The action timeout for the rule.
        """
        return pulumi.get(self, "timeout_in_minutes")

    @timeout_in_minutes.setter
    def timeout_in_minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout_in_minutes", value)


if not MYPY:
    class PipelineStageBeforeEntryArgsDict(TypedDict):
        condition: pulumi.Input['PipelineStageBeforeEntryConditionArgsDict']
        """
        The conditions that are configured as entry condition. Defined as a `condition` block below.
        """
elif False:
    PipelineStageBeforeEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageBeforeEntryArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input['PipelineStageBeforeEntryConditionArgs']):
        """
        :param pulumi.Input['PipelineStageBeforeEntryConditionArgs'] condition: The conditions that are configured as entry condition. Defined as a `condition` block below.
        """
        pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input['PipelineStageBeforeEntryConditionArgs']:
        """
        The conditions that are configured as entry condition. Defined as a `condition` block below.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['PipelineStageBeforeEntryConditionArgs']):
        pulumi.set(self, "condition", value)


if not MYPY:
    class PipelineStageBeforeEntryConditionArgsDict(TypedDict):
        rules: pulumi.Input[Sequence[pulumi.Input['PipelineStageBeforeEntryConditionRuleArgsDict']]]
        """
        The rules that make up the condition. Defined as a `rule` block below.
        """
        result: NotRequired[pulumi.Input[builtins.str]]
        """
        The action to be done when the condition is met. For example, rolling back an execution for a failure condition. Possible values are `ROLLBACK`, `FAIL`, `RETRY` and `SKIP`.
        """
elif False:
    PipelineStageBeforeEntryConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageBeforeEntryConditionArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['PipelineStageBeforeEntryConditionRuleArgs']]],
                 result: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PipelineStageBeforeEntryConditionRuleArgs']]] rules: The rules that make up the condition. Defined as a `rule` block below.
        :param pulumi.Input[builtins.str] result: The action to be done when the condition is met. For example, rolling back an execution for a failure condition. Possible values are `ROLLBACK`, `FAIL`, `RETRY` and `SKIP`.
        """
        pulumi.set(__self__, "rules", rules)
        if result is not None:
            pulumi.set(__self__, "result", result)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['PipelineStageBeforeEntryConditionRuleArgs']]]:
        """
        The rules that make up the condition. Defined as a `rule` block below.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['PipelineStageBeforeEntryConditionRuleArgs']]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter
    def result(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The action to be done when the condition is met. For example, rolling back an execution for a failure condition. Possible values are `ROLLBACK`, `FAIL`, `RETRY` and `SKIP`.
        """
        return pulumi.get(self, "result")

    @result.setter
    def result(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "result", value)


if not MYPY:
    class PipelineStageBeforeEntryConditionRuleArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        The name of the rule that is created for the condition, such as `VariableCheck`.
        """
        rule_type_id: pulumi.Input['PipelineStageBeforeEntryConditionRuleRuleTypeIdArgsDict']
        """
        The ID for the rule type, which is made up of the combined values for `category`, `owner`, `provider`, and `version`. Defined as an `rule_type_id` block below.
        """
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The shell commands to run with your commands rule in CodePipeline. All commands are supported except multi-line formats.
        """
        configuration: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        The action configuration fields for the rule. Configurations options for rule types and providers can be found in the [Rule structure reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/rule-reference.html).
        """
        input_artifacts: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of the input artifacts fields for the rule, such as specifying an input file for the rule.
        """
        region: NotRequired[pulumi.Input[builtins.str]]
        """
        The Region for the condition associated with the rule.
        """
        role_arn: NotRequired[pulumi.Input[builtins.str]]
        """
        The pipeline role ARN associated with the rule.
        """
        timeout_in_minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        The action timeout for the rule.
        """
elif False:
    PipelineStageBeforeEntryConditionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageBeforeEntryConditionRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 rule_type_id: pulumi.Input['PipelineStageBeforeEntryConditionRuleRuleTypeIdArgs'],
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 configuration: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 input_artifacts: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 region: Optional[pulumi.Input[builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[builtins.str]] = None,
                 timeout_in_minutes: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] name: The name of the rule that is created for the condition, such as `VariableCheck`.
        :param pulumi.Input['PipelineStageBeforeEntryConditionRuleRuleTypeIdArgs'] rule_type_id: The ID for the rule type, which is made up of the combined values for `category`, `owner`, `provider`, and `version`. Defined as an `rule_type_id` block below.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] commands: The shell commands to run with your commands rule in CodePipeline. All commands are supported except multi-line formats.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] configuration: The action configuration fields for the rule. Configurations options for rule types and providers can be found in the [Rule structure reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/rule-reference.html).
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] input_artifacts: The list of the input artifacts fields for the rule, such as specifying an input file for the rule.
        :param pulumi.Input[builtins.str] region: The Region for the condition associated with the rule.
        :param pulumi.Input[builtins.str] role_arn: The pipeline role ARN associated with the rule.
        :param pulumi.Input[builtins.int] timeout_in_minutes: The action timeout for the rule.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rule_type_id", rule_type_id)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if input_artifacts is not None:
            pulumi.set(__self__, "input_artifacts", input_artifacts)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if timeout_in_minutes is not None:
            pulumi.set(__self__, "timeout_in_minutes", timeout_in_minutes)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the rule that is created for the condition, such as `VariableCheck`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ruleTypeId")
    def rule_type_id(self) -> pulumi.Input['PipelineStageBeforeEntryConditionRuleRuleTypeIdArgs']:
        """
        The ID for the rule type, which is made up of the combined values for `category`, `owner`, `provider`, and `version`. Defined as an `rule_type_id` block below.
        """
        return pulumi.get(self, "rule_type_id")

    @rule_type_id.setter
    def rule_type_id(self, value: pulumi.Input['PipelineStageBeforeEntryConditionRuleRuleTypeIdArgs']):
        pulumi.set(self, "rule_type_id", value)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The shell commands to run with your commands rule in CodePipeline. All commands are supported except multi-line formats.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        The action configuration fields for the rule. Configurations options for rule types and providers can be found in the [Rule structure reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/rule-reference.html).
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter(name="inputArtifacts")
    def input_artifacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of the input artifacts fields for the rule, such as specifying an input file for the rule.
        """
        return pulumi.get(self, "input_artifacts")

    @input_artifacts.setter
    def input_artifacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "input_artifacts", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Region for the condition associated with the rule.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The pipeline role ARN associated with the rule.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="timeoutInMinutes")
    def timeout_in_minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The action timeout for the rule.
        """
        return pulumi.get(self, "timeout_in_minutes")

    @timeout_in_minutes.setter
    def timeout_in_minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout_in_minutes", value)


if not MYPY:
    class PipelineStageBeforeEntryConditionRuleRuleTypeIdArgsDict(TypedDict):
        category: pulumi.Input[builtins.str]
        """
        A category defines what kind of rule can be run in the stage, and constrains the provider type for the rule. The valid category is `Rule`.
        """
        provider: pulumi.Input[builtins.str]
        """
        The rule provider, such as the DeploymentWindow rule. For a list of rule provider names, see the rules listed in the [AWS CodePipeline rule reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/rule-reference.html).
        """
        owner: NotRequired[pulumi.Input[builtins.str]]
        """
        The creator of the rule being called. The valid value for the Owner field in the rule category is `AWS`.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that describes the rule version.
        """
elif False:
    PipelineStageBeforeEntryConditionRuleRuleTypeIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageBeforeEntryConditionRuleRuleTypeIdArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[builtins.str],
                 provider: pulumi.Input[builtins.str],
                 owner: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] category: A category defines what kind of rule can be run in the stage, and constrains the provider type for the rule. The valid category is `Rule`.
        :param pulumi.Input[builtins.str] provider: The rule provider, such as the DeploymentWindow rule. For a list of rule provider names, see the rules listed in the [AWS CodePipeline rule reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/rule-reference.html).
        :param pulumi.Input[builtins.str] owner: The creator of the rule being called. The valid value for the Owner field in the rule category is `AWS`.
        :param pulumi.Input[builtins.str] version: A string that describes the rule version.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "provider", provider)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def category(self) -> pulumi.Input[builtins.str]:
        """
        A category defines what kind of rule can be run in the stage, and constrains the provider type for the rule. The valid category is `Rule`.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def provider(self) -> pulumi.Input[builtins.str]:
        """
        The rule provider, such as the DeploymentWindow rule. For a list of rule provider names, see the rules listed in the [AWS CodePipeline rule reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/rule-reference.html).
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The creator of the rule being called. The valid value for the Owner field in the rule category is `AWS`.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that describes the rule version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PipelineStageOnFailureArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input['PipelineStageOnFailureConditionArgsDict']]
        """
        The conditions that are failure conditions. Defined as a `condition` block below.
        """
        result: NotRequired[pulumi.Input[builtins.str]]
        """
        The conditions that are configured as failure conditions. Possible values are `ROLLBACK`,  `FAIL`, `RETRY` and `SKIP`.
        """
        retry_configuration: NotRequired[pulumi.Input['PipelineStageOnFailureRetryConfigurationArgsDict']]
        """
        The retry configuration specifies automatic retry for a failed stage, along with the configured retry mode. Defined as a `retry_configuration` block below.
        """
elif False:
    PipelineStageOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageOnFailureArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input['PipelineStageOnFailureConditionArgs']] = None,
                 result: Optional[pulumi.Input[builtins.str]] = None,
                 retry_configuration: Optional[pulumi.Input['PipelineStageOnFailureRetryConfigurationArgs']] = None):
        """
        :param pulumi.Input['PipelineStageOnFailureConditionArgs'] condition: The conditions that are failure conditions. Defined as a `condition` block below.
        :param pulumi.Input[builtins.str] result: The conditions that are configured as failure conditions. Possible values are `ROLLBACK`,  `FAIL`, `RETRY` and `SKIP`.
        :param pulumi.Input['PipelineStageOnFailureRetryConfigurationArgs'] retry_configuration: The retry configuration specifies automatic retry for a failed stage, along with the configured retry mode. Defined as a `retry_configuration` block below.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if result is not None:
            pulumi.set(__self__, "result", result)
        if retry_configuration is not None:
            pulumi.set(__self__, "retry_configuration", retry_configuration)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['PipelineStageOnFailureConditionArgs']]:
        """
        The conditions that are failure conditions. Defined as a `condition` block below.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['PipelineStageOnFailureConditionArgs']]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def result(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The conditions that are configured as failure conditions. Possible values are `ROLLBACK`,  `FAIL`, `RETRY` and `SKIP`.
        """
        return pulumi.get(self, "result")

    @result.setter
    def result(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "result", value)

    @property
    @pulumi.getter(name="retryConfiguration")
    def retry_configuration(self) -> Optional[pulumi.Input['PipelineStageOnFailureRetryConfigurationArgs']]:
        """
        The retry configuration specifies automatic retry for a failed stage, along with the configured retry mode. Defined as a `retry_configuration` block below.
        """
        return pulumi.get(self, "retry_configuration")

    @retry_configuration.setter
    def retry_configuration(self, value: Optional[pulumi.Input['PipelineStageOnFailureRetryConfigurationArgs']]):
        pulumi.set(self, "retry_configuration", value)


if not MYPY:
    class PipelineStageOnFailureConditionArgsDict(TypedDict):
        rules: pulumi.Input[Sequence[pulumi.Input['PipelineStageOnFailureConditionRuleArgsDict']]]
        """
        The rules that make up the condition. Defined as a `rule` block below.
        """
        result: NotRequired[pulumi.Input[builtins.str]]
        """
        The action to be done when the condition is met. For example, rolling back an execution for a failure condition. Possible values are `ROLLBACK`, `FAIL`, `RETRY` and `SKIP`.
        """
elif False:
    PipelineStageOnFailureConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageOnFailureConditionArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['PipelineStageOnFailureConditionRuleArgs']]],
                 result: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PipelineStageOnFailureConditionRuleArgs']]] rules: The rules that make up the condition. Defined as a `rule` block below.
        :param pulumi.Input[builtins.str] result: The action to be done when the condition is met. For example, rolling back an execution for a failure condition. Possible values are `ROLLBACK`, `FAIL`, `RETRY` and `SKIP`.
        """
        pulumi.set(__self__, "rules", rules)
        if result is not None:
            pulumi.set(__self__, "result", result)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['PipelineStageOnFailureConditionRuleArgs']]]:
        """
        The rules that make up the condition. Defined as a `rule` block below.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['PipelineStageOnFailureConditionRuleArgs']]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter
    def result(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The action to be done when the condition is met. For example, rolling back an execution for a failure condition. Possible values are `ROLLBACK`, `FAIL`, `RETRY` and `SKIP`.
        """
        return pulumi.get(self, "result")

    @result.setter
    def result(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "result", value)


if not MYPY:
    class PipelineStageOnFailureConditionRuleArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        The name of the rule that is created for the condition, such as `VariableCheck`.
        """
        rule_type_id: pulumi.Input['PipelineStageOnFailureConditionRuleRuleTypeIdArgsDict']
        """
        The ID for the rule type, which is made up of the combined values for `category`, `owner`, `provider`, and `version`. Defined as an `rule_type_id` block below.
        """
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The shell commands to run with your commands rule in CodePipeline. All commands are supported except multi-line formats.
        """
        configuration: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        The action configuration fields for the rule. Configurations options for rule types and providers can be found in the [Rule structure reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/rule-reference.html).
        """
        input_artifacts: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of the input artifacts fields for the rule, such as specifying an input file for the rule.
        """
        region: NotRequired[pulumi.Input[builtins.str]]
        """
        The Region for the condition associated with the rule.
        """
        role_arn: NotRequired[pulumi.Input[builtins.str]]
        """
        The pipeline role ARN associated with the rule.
        """
        timeout_in_minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        The action timeout for the rule.
        """
elif False:
    PipelineStageOnFailureConditionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageOnFailureConditionRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 rule_type_id: pulumi.Input['PipelineStageOnFailureConditionRuleRuleTypeIdArgs'],
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 configuration: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 input_artifacts: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 region: Optional[pulumi.Input[builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[builtins.str]] = None,
                 timeout_in_minutes: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] name: The name of the rule that is created for the condition, such as `VariableCheck`.
        :param pulumi.Input['PipelineStageOnFailureConditionRuleRuleTypeIdArgs'] rule_type_id: The ID for the rule type, which is made up of the combined values for `category`, `owner`, `provider`, and `version`. Defined as an `rule_type_id` block below.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] commands: The shell commands to run with your commands rule in CodePipeline. All commands are supported except multi-line formats.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] configuration: The action configuration fields for the rule. Configurations options for rule types and providers can be found in the [Rule structure reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/rule-reference.html).
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] input_artifacts: The list of the input artifacts fields for the rule, such as specifying an input file for the rule.
        :param pulumi.Input[builtins.str] region: The Region for the condition associated with the rule.
        :param pulumi.Input[builtins.str] role_arn: The pipeline role ARN associated with the rule.
        :param pulumi.Input[builtins.int] timeout_in_minutes: The action timeout for the rule.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rule_type_id", rule_type_id)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if input_artifacts is not None:
            pulumi.set(__self__, "input_artifacts", input_artifacts)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if timeout_in_minutes is not None:
            pulumi.set(__self__, "timeout_in_minutes", timeout_in_minutes)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the rule that is created for the condition, such as `VariableCheck`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ruleTypeId")
    def rule_type_id(self) -> pulumi.Input['PipelineStageOnFailureConditionRuleRuleTypeIdArgs']:
        """
        The ID for the rule type, which is made up of the combined values for `category`, `owner`, `provider`, and `version`. Defined as an `rule_type_id` block below.
        """
        return pulumi.get(self, "rule_type_id")

    @rule_type_id.setter
    def rule_type_id(self, value: pulumi.Input['PipelineStageOnFailureConditionRuleRuleTypeIdArgs']):
        pulumi.set(self, "rule_type_id", value)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The shell commands to run with your commands rule in CodePipeline. All commands are supported except multi-line formats.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        The action configuration fields for the rule. Configurations options for rule types and providers can be found in the [Rule structure reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/rule-reference.html).
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter(name="inputArtifacts")
    def input_artifacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of the input artifacts fields for the rule, such as specifying an input file for the rule.
        """
        return pulumi.get(self, "input_artifacts")

    @input_artifacts.setter
    def input_artifacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "input_artifacts", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Region for the condition associated with the rule.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The pipeline role ARN associated with the rule.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="timeoutInMinutes")
    def timeout_in_minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The action timeout for the rule.
        """
        return pulumi.get(self, "timeout_in_minutes")

    @timeout_in_minutes.setter
    def timeout_in_minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout_in_minutes", value)


if not MYPY:
    class PipelineStageOnFailureConditionRuleRuleTypeIdArgsDict(TypedDict):
        category: pulumi.Input[builtins.str]
        """
        A category defines what kind of rule can be run in the stage, and constrains the provider type for the rule. The valid category is `Rule`.
        """
        provider: pulumi.Input[builtins.str]
        """
        The rule provider, such as the DeploymentWindow rule. For a list of rule provider names, see the rules listed in the [AWS CodePipeline rule reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/rule-reference.html).
        """
        owner: NotRequired[pulumi.Input[builtins.str]]
        """
        The creator of the rule being called. The valid value for the Owner field in the rule category is `AWS`.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that describes the rule version.
        """
elif False:
    PipelineStageOnFailureConditionRuleRuleTypeIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageOnFailureConditionRuleRuleTypeIdArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[builtins.str],
                 provider: pulumi.Input[builtins.str],
                 owner: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] category: A category defines what kind of rule can be run in the stage, and constrains the provider type for the rule. The valid category is `Rule`.
        :param pulumi.Input[builtins.str] provider: The rule provider, such as the DeploymentWindow rule. For a list of rule provider names, see the rules listed in the [AWS CodePipeline rule reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/rule-reference.html).
        :param pulumi.Input[builtins.str] owner: The creator of the rule being called. The valid value for the Owner field in the rule category is `AWS`.
        :param pulumi.Input[builtins.str] version: A string that describes the rule version.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "provider", provider)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def category(self) -> pulumi.Input[builtins.str]:
        """
        A category defines what kind of rule can be run in the stage, and constrains the provider type for the rule. The valid category is `Rule`.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def provider(self) -> pulumi.Input[builtins.str]:
        """
        The rule provider, such as the DeploymentWindow rule. For a list of rule provider names, see the rules listed in the [AWS CodePipeline rule reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/rule-reference.html).
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The creator of the rule being called. The valid value for the Owner field in the rule category is `AWS`.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that describes the rule version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PipelineStageOnFailureRetryConfigurationArgsDict(TypedDict):
        retry_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        The method that you want to configure for automatic stage retry on stage failure. You can specify to retry only failed action in the stage or all actions in the stage. Possible values are `FAILED_ACTIONS` and `ALL_ACTIONS`.
        """
elif False:
    PipelineStageOnFailureRetryConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageOnFailureRetryConfigurationArgs:
    def __init__(__self__, *,
                 retry_mode: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] retry_mode: The method that you want to configure for automatic stage retry on stage failure. You can specify to retry only failed action in the stage or all actions in the stage. Possible values are `FAILED_ACTIONS` and `ALL_ACTIONS`.
        """
        if retry_mode is not None:
            pulumi.set(__self__, "retry_mode", retry_mode)

    @property
    @pulumi.getter(name="retryMode")
    def retry_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The method that you want to configure for automatic stage retry on stage failure. You can specify to retry only failed action in the stage or all actions in the stage. Possible values are `FAILED_ACTIONS` and `ALL_ACTIONS`.
        """
        return pulumi.get(self, "retry_mode")

    @retry_mode.setter
    def retry_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "retry_mode", value)


if not MYPY:
    class PipelineStageOnSuccessArgsDict(TypedDict):
        condition: pulumi.Input['PipelineStageOnSuccessConditionArgsDict']
        """
        The conditions that are success conditions. Defined as a `condition` block below.
        """
elif False:
    PipelineStageOnSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageOnSuccessArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input['PipelineStageOnSuccessConditionArgs']):
        """
        :param pulumi.Input['PipelineStageOnSuccessConditionArgs'] condition: The conditions that are success conditions. Defined as a `condition` block below.
        """
        pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input['PipelineStageOnSuccessConditionArgs']:
        """
        The conditions that are success conditions. Defined as a `condition` block below.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['PipelineStageOnSuccessConditionArgs']):
        pulumi.set(self, "condition", value)


if not MYPY:
    class PipelineStageOnSuccessConditionArgsDict(TypedDict):
        rules: pulumi.Input[Sequence[pulumi.Input['PipelineStageOnSuccessConditionRuleArgsDict']]]
        """
        The rules that make up the condition. Defined as a `rule` block below.
        """
        result: NotRequired[pulumi.Input[builtins.str]]
        """
        The action to be done when the condition is met. For example, rolling back an execution for a failure condition. Possible values are `ROLLBACK`, `FAIL`, `RETRY` and `SKIP`.
        """
elif False:
    PipelineStageOnSuccessConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageOnSuccessConditionArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['PipelineStageOnSuccessConditionRuleArgs']]],
                 result: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PipelineStageOnSuccessConditionRuleArgs']]] rules: The rules that make up the condition. Defined as a `rule` block below.
        :param pulumi.Input[builtins.str] result: The action to be done when the condition is met. For example, rolling back an execution for a failure condition. Possible values are `ROLLBACK`, `FAIL`, `RETRY` and `SKIP`.
        """
        pulumi.set(__self__, "rules", rules)
        if result is not None:
            pulumi.set(__self__, "result", result)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['PipelineStageOnSuccessConditionRuleArgs']]]:
        """
        The rules that make up the condition. Defined as a `rule` block below.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['PipelineStageOnSuccessConditionRuleArgs']]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter
    def result(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The action to be done when the condition is met. For example, rolling back an execution for a failure condition. Possible values are `ROLLBACK`, `FAIL`, `RETRY` and `SKIP`.
        """
        return pulumi.get(self, "result")

    @result.setter
    def result(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "result", value)


if not MYPY:
    class PipelineStageOnSuccessConditionRuleArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        The name of the rule that is created for the condition, such as `VariableCheck`.
        """
        rule_type_id: pulumi.Input['PipelineStageOnSuccessConditionRuleRuleTypeIdArgsDict']
        """
        The ID for the rule type, which is made up of the combined values for `category`, `owner`, `provider`, and `version`. Defined as an `rule_type_id` block below.
        """
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The shell commands to run with your commands rule in CodePipeline. All commands are supported except multi-line formats.
        """
        configuration: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        The action configuration fields for the rule. Configurations options for rule types and providers can be found in the [Rule structure reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/rule-reference.html).
        """
        input_artifacts: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of the input artifacts fields for the rule, such as specifying an input file for the rule.
        """
        region: NotRequired[pulumi.Input[builtins.str]]
        """
        The Region for the condition associated with the rule.
        """
        role_arn: NotRequired[pulumi.Input[builtins.str]]
        """
        The pipeline role ARN associated with the rule.
        """
        timeout_in_minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        The action timeout for the rule.
        """
elif False:
    PipelineStageOnSuccessConditionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageOnSuccessConditionRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 rule_type_id: pulumi.Input['PipelineStageOnSuccessConditionRuleRuleTypeIdArgs'],
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 configuration: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 input_artifacts: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 region: Optional[pulumi.Input[builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[builtins.str]] = None,
                 timeout_in_minutes: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] name: The name of the rule that is created for the condition, such as `VariableCheck`.
        :param pulumi.Input['PipelineStageOnSuccessConditionRuleRuleTypeIdArgs'] rule_type_id: The ID for the rule type, which is made up of the combined values for `category`, `owner`, `provider`, and `version`. Defined as an `rule_type_id` block below.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] commands: The shell commands to run with your commands rule in CodePipeline. All commands are supported except multi-line formats.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] configuration: The action configuration fields for the rule. Configurations options for rule types and providers can be found in the [Rule structure reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/rule-reference.html).
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] input_artifacts: The list of the input artifacts fields for the rule, such as specifying an input file for the rule.
        :param pulumi.Input[builtins.str] region: The Region for the condition associated with the rule.
        :param pulumi.Input[builtins.str] role_arn: The pipeline role ARN associated with the rule.
        :param pulumi.Input[builtins.int] timeout_in_minutes: The action timeout for the rule.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rule_type_id", rule_type_id)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if input_artifacts is not None:
            pulumi.set(__self__, "input_artifacts", input_artifacts)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if timeout_in_minutes is not None:
            pulumi.set(__self__, "timeout_in_minutes", timeout_in_minutes)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the rule that is created for the condition, such as `VariableCheck`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ruleTypeId")
    def rule_type_id(self) -> pulumi.Input['PipelineStageOnSuccessConditionRuleRuleTypeIdArgs']:
        """
        The ID for the rule type, which is made up of the combined values for `category`, `owner`, `provider`, and `version`. Defined as an `rule_type_id` block below.
        """
        return pulumi.get(self, "rule_type_id")

    @rule_type_id.setter
    def rule_type_id(self, value: pulumi.Input['PipelineStageOnSuccessConditionRuleRuleTypeIdArgs']):
        pulumi.set(self, "rule_type_id", value)

    @property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The shell commands to run with your commands rule in CodePipeline. All commands are supported except multi-line formats.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        The action configuration fields for the rule. Configurations options for rule types and providers can be found in the [Rule structure reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/rule-reference.html).
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter(name="inputArtifacts")
    def input_artifacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of the input artifacts fields for the rule, such as specifying an input file for the rule.
        """
        return pulumi.get(self, "input_artifacts")

    @input_artifacts.setter
    def input_artifacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "input_artifacts", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Region for the condition associated with the rule.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The pipeline role ARN associated with the rule.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="timeoutInMinutes")
    def timeout_in_minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The action timeout for the rule.
        """
        return pulumi.get(self, "timeout_in_minutes")

    @timeout_in_minutes.setter
    def timeout_in_minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout_in_minutes", value)


if not MYPY:
    class PipelineStageOnSuccessConditionRuleRuleTypeIdArgsDict(TypedDict):
        category: pulumi.Input[builtins.str]
        """
        A category defines what kind of rule can be run in the stage, and constrains the provider type for the rule. The valid category is `Rule`.
        """
        provider: pulumi.Input[builtins.str]
        """
        The rule provider, such as the DeploymentWindow rule. For a list of rule provider names, see the rules listed in the [AWS CodePipeline rule reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/rule-reference.html).
        """
        owner: NotRequired[pulumi.Input[builtins.str]]
        """
        The creator of the rule being called. The valid value for the Owner field in the rule category is `AWS`.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that describes the rule version.
        """
elif False:
    PipelineStageOnSuccessConditionRuleRuleTypeIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageOnSuccessConditionRuleRuleTypeIdArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[builtins.str],
                 provider: pulumi.Input[builtins.str],
                 owner: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] category: A category defines what kind of rule can be run in the stage, and constrains the provider type for the rule. The valid category is `Rule`.
        :param pulumi.Input[builtins.str] provider: The rule provider, such as the DeploymentWindow rule. For a list of rule provider names, see the rules listed in the [AWS CodePipeline rule reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/rule-reference.html).
        :param pulumi.Input[builtins.str] owner: The creator of the rule being called. The valid value for the Owner field in the rule category is `AWS`.
        :param pulumi.Input[builtins.str] version: A string that describes the rule version.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "provider", provider)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def category(self) -> pulumi.Input[builtins.str]:
        """
        A category defines what kind of rule can be run in the stage, and constrains the provider type for the rule. The valid category is `Rule`.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def provider(self) -> pulumi.Input[builtins.str]:
        """
        The rule provider, such as the DeploymentWindow rule. For a list of rule provider names, see the rules listed in the [AWS CodePipeline rule reference](https://docs.aws.amazon.com/codepipeline/latest/userguide/rule-reference.html).
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The creator of the rule being called. The valid value for the Owner field in the rule category is `AWS`.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that describes the rule version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PipelineTriggerArgsDict(TypedDict):
        git_configuration: pulumi.Input['PipelineTriggerGitConfigurationArgsDict']
        """
        Provides the filter criteria and the source stage for the repository event that starts the pipeline. For more information, refer to the [AWS documentation](https://docs.aws.amazon.com/codepipeline/latest/userguide/pipelines-filter.html). A `git_configuration` block is documented below.
        """
        provider_type: pulumi.Input[builtins.str]
        """
        The source provider for the event. Possible value is `CodeStarSourceConnection`.
        """
elif False:
    PipelineTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerArgs:
    def __init__(__self__, *,
                 git_configuration: pulumi.Input['PipelineTriggerGitConfigurationArgs'],
                 provider_type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input['PipelineTriggerGitConfigurationArgs'] git_configuration: Provides the filter criteria and the source stage for the repository event that starts the pipeline. For more information, refer to the [AWS documentation](https://docs.aws.amazon.com/codepipeline/latest/userguide/pipelines-filter.html). A `git_configuration` block is documented below.
        :param pulumi.Input[builtins.str] provider_type: The source provider for the event. Possible value is `CodeStarSourceConnection`.
        """
        pulumi.set(__self__, "git_configuration", git_configuration)
        pulumi.set(__self__, "provider_type", provider_type)

    @property
    @pulumi.getter(name="gitConfiguration")
    def git_configuration(self) -> pulumi.Input['PipelineTriggerGitConfigurationArgs']:
        """
        Provides the filter criteria and the source stage for the repository event that starts the pipeline. For more information, refer to the [AWS documentation](https://docs.aws.amazon.com/codepipeline/latest/userguide/pipelines-filter.html). A `git_configuration` block is documented below.
        """
        return pulumi.get(self, "git_configuration")

    @git_configuration.setter
    def git_configuration(self, value: pulumi.Input['PipelineTriggerGitConfigurationArgs']):
        pulumi.set(self, "git_configuration", value)

    @property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> pulumi.Input[builtins.str]:
        """
        The source provider for the event. Possible value is `CodeStarSourceConnection`.
        """
        return pulumi.get(self, "provider_type")

    @provider_type.setter
    def provider_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "provider_type", value)


if not MYPY:
    class PipelineTriggerAllArgsDict(TypedDict):
        git_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationArgsDict']]]]
        """
        Provides the filter criteria and the source stage for the repository event that starts the pipeline. For more information, refer to the [AWS documentation](https://docs.aws.amazon.com/codepipeline/latest/userguide/pipelines-filter.html). A `git_configuration` block is documented below.
        """
        provider_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The source provider for the event. Possible value is `CodeStarSourceConnection`.
        """
elif False:
    PipelineTriggerAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerAllArgs:
    def __init__(__self__, *,
                 git_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationArgs']]]] = None,
                 provider_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationArgs']]] git_configurations: Provides the filter criteria and the source stage for the repository event that starts the pipeline. For more information, refer to the [AWS documentation](https://docs.aws.amazon.com/codepipeline/latest/userguide/pipelines-filter.html). A `git_configuration` block is documented below.
        :param pulumi.Input[builtins.str] provider_type: The source provider for the event. Possible value is `CodeStarSourceConnection`.
        """
        if git_configurations is not None:
            pulumi.set(__self__, "git_configurations", git_configurations)
        if provider_type is not None:
            pulumi.set(__self__, "provider_type", provider_type)

    @property
    @pulumi.getter(name="gitConfigurations")
    def git_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationArgs']]]]:
        """
        Provides the filter criteria and the source stage for the repository event that starts the pipeline. For more information, refer to the [AWS documentation](https://docs.aws.amazon.com/codepipeline/latest/userguide/pipelines-filter.html). A `git_configuration` block is documented below.
        """
        return pulumi.get(self, "git_configurations")

    @git_configurations.setter
    def git_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationArgs']]]]):
        pulumi.set(self, "git_configurations", value)

    @property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The source provider for the event. Possible value is `CodeStarSourceConnection`.
        """
        return pulumi.get(self, "provider_type")

    @provider_type.setter
    def provider_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "provider_type", value)


if not MYPY:
    class PipelineTriggerAllGitConfigurationArgsDict(TypedDict):
        pull_requests: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestArgsDict']]]]
        """
        The field where the repository event that will start the pipeline is specified as pull requests. A `pull_request` block is documented below.
        """
        pushes: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushArgsDict']]]]
        """
        The field where the repository event that will start the pipeline, such as pushing Git tags, is specified with details. A `push` block is documented below.
        """
        source_action_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the pipeline source action where the trigger configuration, such as Git tags, is specified. The trigger configuration will start the pipeline upon the specified change only.
        """
elif False:
    PipelineTriggerAllGitConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerAllGitConfigurationArgs:
    def __init__(__self__, *,
                 pull_requests: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestArgs']]]] = None,
                 pushes: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushArgs']]]] = None,
                 source_action_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestArgs']]] pull_requests: The field where the repository event that will start the pipeline is specified as pull requests. A `pull_request` block is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushArgs']]] pushes: The field where the repository event that will start the pipeline, such as pushing Git tags, is specified with details. A `push` block is documented below.
        :param pulumi.Input[builtins.str] source_action_name: The name of the pipeline source action where the trigger configuration, such as Git tags, is specified. The trigger configuration will start the pipeline upon the specified change only.
        """
        if pull_requests is not None:
            pulumi.set(__self__, "pull_requests", pull_requests)
        if pushes is not None:
            pulumi.set(__self__, "pushes", pushes)
        if source_action_name is not None:
            pulumi.set(__self__, "source_action_name", source_action_name)

    @property
    @pulumi.getter(name="pullRequests")
    def pull_requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestArgs']]]]:
        """
        The field where the repository event that will start the pipeline is specified as pull requests. A `pull_request` block is documented below.
        """
        return pulumi.get(self, "pull_requests")

    @pull_requests.setter
    def pull_requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestArgs']]]]):
        pulumi.set(self, "pull_requests", value)

    @property
    @pulumi.getter
    def pushes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushArgs']]]]:
        """
        The field where the repository event that will start the pipeline, such as pushing Git tags, is specified with details. A `push` block is documented below.
        """
        return pulumi.get(self, "pushes")

    @pushes.setter
    def pushes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushArgs']]]]):
        pulumi.set(self, "pushes", value)

    @property
    @pulumi.getter(name="sourceActionName")
    def source_action_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the pipeline source action where the trigger configuration, such as Git tags, is specified. The trigger configuration will start the pipeline upon the specified change only.
        """
        return pulumi.get(self, "source_action_name")

    @source_action_name.setter
    def source_action_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_action_name", value)


if not MYPY:
    class PipelineTriggerAllGitConfigurationPullRequestArgsDict(TypedDict):
        branches: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestBranchArgsDict']]]]
        """
        The field that specifies to filter on branches for the pull request trigger configuration. A `branches` block is documented below.
        """
        events: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list that specifies which pull request events to filter on (opened, updated, closed) for the trigger configuration. Possible values are `OPEN`, `UPDATED ` and `CLOSED`.
        """
        file_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestFilePathArgsDict']]]]
        """
        The field that specifies to filter on file paths for the pull request trigger configuration. A `file_paths` block is documented below.
        """
elif False:
    PipelineTriggerAllGitConfigurationPullRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerAllGitConfigurationPullRequestArgs:
    def __init__(__self__, *,
                 branches: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestBranchArgs']]]] = None,
                 events: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 file_paths: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestFilePathArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestBranchArgs']]] branches: The field that specifies to filter on branches for the pull request trigger configuration. A `branches` block is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] events: A list that specifies which pull request events to filter on (opened, updated, closed) for the trigger configuration. Possible values are `OPEN`, `UPDATED ` and `CLOSED`.
        :param pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestFilePathArgs']]] file_paths: The field that specifies to filter on file paths for the pull request trigger configuration. A `file_paths` block is documented below.
        """
        if branches is not None:
            pulumi.set(__self__, "branches", branches)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if file_paths is not None:
            pulumi.set(__self__, "file_paths", file_paths)

    @property
    @pulumi.getter
    def branches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestBranchArgs']]]]:
        """
        The field that specifies to filter on branches for the pull request trigger configuration. A `branches` block is documented below.
        """
        return pulumi.get(self, "branches")

    @branches.setter
    def branches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestBranchArgs']]]]):
        pulumi.set(self, "branches", value)

    @property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list that specifies which pull request events to filter on (opened, updated, closed) for the trigger configuration. Possible values are `OPEN`, `UPDATED ` and `CLOSED`.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter(name="filePaths")
    def file_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestFilePathArgs']]]]:
        """
        The field that specifies to filter on file paths for the pull request trigger configuration. A `file_paths` block is documented below.
        """
        return pulumi.get(self, "file_paths")

    @file_paths.setter
    def file_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestFilePathArgs']]]]):
        pulumi.set(self, "file_paths", value)


if not MYPY:
    class PipelineTriggerAllGitConfigurationPullRequestBranchArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of patterns of Git branches that, when a commit is pushed, are to be excluded from starting the pipeline.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of patterns of Git branches that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
elif False:
    PipelineTriggerAllGitConfigurationPullRequestBranchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerAllGitConfigurationPullRequestBranchArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] excludes: A list of patterns of Git branches that, when a commit is pushed, are to be excluded from starting the pipeline.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] includes: A list of patterns of Git branches that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of patterns of Git branches that, when a commit is pushed, are to be excluded from starting the pipeline.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of patterns of Git branches that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineTriggerAllGitConfigurationPullRequestFilePathArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of patterns of Git repository file paths that, when a commit is pushed, are to be excluded from starting the pipeline.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of patterns of Git repository file paths that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
elif False:
    PipelineTriggerAllGitConfigurationPullRequestFilePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerAllGitConfigurationPullRequestFilePathArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] excludes: A list of patterns of Git repository file paths that, when a commit is pushed, are to be excluded from starting the pipeline.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] includes: A list of patterns of Git repository file paths that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of patterns of Git repository file paths that, when a commit is pushed, are to be excluded from starting the pipeline.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of patterns of Git repository file paths that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineTriggerAllGitConfigurationPushArgsDict(TypedDict):
        branches: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushBranchArgsDict']]]]
        """
        The field that specifies to filter on branches for the push trigger configuration. A `branches` block is documented below.
        """
        file_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushFilePathArgsDict']]]]
        """
        The field that specifies to filter on file paths for the push trigger configuration. A `file_paths` block is documented below.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushTagArgsDict']]]]
        """
        The field that contains the details for the Git tags trigger configuration. A `tags` block is documented below.
        """
elif False:
    PipelineTriggerAllGitConfigurationPushArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerAllGitConfigurationPushArgs:
    def __init__(__self__, *,
                 branches: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushBranchArgs']]]] = None,
                 file_paths: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushFilePathArgs']]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushTagArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushBranchArgs']]] branches: The field that specifies to filter on branches for the push trigger configuration. A `branches` block is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushFilePathArgs']]] file_paths: The field that specifies to filter on file paths for the push trigger configuration. A `file_paths` block is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushTagArgs']]] tags: The field that contains the details for the Git tags trigger configuration. A `tags` block is documented below.
        """
        if branches is not None:
            pulumi.set(__self__, "branches", branches)
        if file_paths is not None:
            pulumi.set(__self__, "file_paths", file_paths)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def branches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushBranchArgs']]]]:
        """
        The field that specifies to filter on branches for the push trigger configuration. A `branches` block is documented below.
        """
        return pulumi.get(self, "branches")

    @branches.setter
    def branches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushBranchArgs']]]]):
        pulumi.set(self, "branches", value)

    @property
    @pulumi.getter(name="filePaths")
    def file_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushFilePathArgs']]]]:
        """
        The field that specifies to filter on file paths for the push trigger configuration. A `file_paths` block is documented below.
        """
        return pulumi.get(self, "file_paths")

    @file_paths.setter
    def file_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushFilePathArgs']]]]):
        pulumi.set(self, "file_paths", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushTagArgs']]]]:
        """
        The field that contains the details for the Git tags trigger configuration. A `tags` block is documented below.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushTagArgs']]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class PipelineTriggerAllGitConfigurationPushBranchArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of patterns of Git branches that, when a commit is pushed, are to be excluded from starting the pipeline.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of patterns of Git branches that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
elif False:
    PipelineTriggerAllGitConfigurationPushBranchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerAllGitConfigurationPushBranchArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] excludes: A list of patterns of Git branches that, when a commit is pushed, are to be excluded from starting the pipeline.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] includes: A list of patterns of Git branches that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of patterns of Git branches that, when a commit is pushed, are to be excluded from starting the pipeline.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of patterns of Git branches that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineTriggerAllGitConfigurationPushFilePathArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of patterns of Git repository file paths that, when a commit is pushed, are to be excluded from starting the pipeline.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of patterns of Git repository file paths that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
elif False:
    PipelineTriggerAllGitConfigurationPushFilePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerAllGitConfigurationPushFilePathArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] excludes: A list of patterns of Git repository file paths that, when a commit is pushed, are to be excluded from starting the pipeline.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] includes: A list of patterns of Git repository file paths that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of patterns of Git repository file paths that, when a commit is pushed, are to be excluded from starting the pipeline.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of patterns of Git repository file paths that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineTriggerAllGitConfigurationPushTagArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of patterns of Git tags that, when pushed, are to be excluded from starting the pipeline.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of patterns of Git tags that, when pushed, are to be included as criteria that starts the pipeline.
        """
elif False:
    PipelineTriggerAllGitConfigurationPushTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerAllGitConfigurationPushTagArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] excludes: A list of patterns of Git tags that, when pushed, are to be excluded from starting the pipeline.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] includes: A list of patterns of Git tags that, when pushed, are to be included as criteria that starts the pipeline.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of patterns of Git tags that, when pushed, are to be excluded from starting the pipeline.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of patterns of Git tags that, when pushed, are to be included as criteria that starts the pipeline.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineTriggerGitConfigurationArgsDict(TypedDict):
        source_action_name: pulumi.Input[builtins.str]
        """
        The name of the pipeline source action where the trigger configuration, such as Git tags, is specified. The trigger configuration will start the pipeline upon the specified change only.
        """
        pull_requests: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerGitConfigurationPullRequestArgsDict']]]]
        """
        The field where the repository event that will start the pipeline is specified as pull requests. A `pull_request` block is documented below.
        """
        pushes: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerGitConfigurationPushArgsDict']]]]
        """
        The field where the repository event that will start the pipeline, such as pushing Git tags, is specified with details. A `push` block is documented below.
        """
elif False:
    PipelineTriggerGitConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerGitConfigurationArgs:
    def __init__(__self__, *,
                 source_action_name: pulumi.Input[builtins.str],
                 pull_requests: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerGitConfigurationPullRequestArgs']]]] = None,
                 pushes: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerGitConfigurationPushArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] source_action_name: The name of the pipeline source action where the trigger configuration, such as Git tags, is specified. The trigger configuration will start the pipeline upon the specified change only.
        :param pulumi.Input[Sequence[pulumi.Input['PipelineTriggerGitConfigurationPullRequestArgs']]] pull_requests: The field where the repository event that will start the pipeline is specified as pull requests. A `pull_request` block is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['PipelineTriggerGitConfigurationPushArgs']]] pushes: The field where the repository event that will start the pipeline, such as pushing Git tags, is specified with details. A `push` block is documented below.
        """
        pulumi.set(__self__, "source_action_name", source_action_name)
        if pull_requests is not None:
            pulumi.set(__self__, "pull_requests", pull_requests)
        if pushes is not None:
            pulumi.set(__self__, "pushes", pushes)

    @property
    @pulumi.getter(name="sourceActionName")
    def source_action_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the pipeline source action where the trigger configuration, such as Git tags, is specified. The trigger configuration will start the pipeline upon the specified change only.
        """
        return pulumi.get(self, "source_action_name")

    @source_action_name.setter
    def source_action_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "source_action_name", value)

    @property
    @pulumi.getter(name="pullRequests")
    def pull_requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerGitConfigurationPullRequestArgs']]]]:
        """
        The field where the repository event that will start the pipeline is specified as pull requests. A `pull_request` block is documented below.
        """
        return pulumi.get(self, "pull_requests")

    @pull_requests.setter
    def pull_requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerGitConfigurationPullRequestArgs']]]]):
        pulumi.set(self, "pull_requests", value)

    @property
    @pulumi.getter
    def pushes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerGitConfigurationPushArgs']]]]:
        """
        The field where the repository event that will start the pipeline, such as pushing Git tags, is specified with details. A `push` block is documented below.
        """
        return pulumi.get(self, "pushes")

    @pushes.setter
    def pushes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerGitConfigurationPushArgs']]]]):
        pulumi.set(self, "pushes", value)


if not MYPY:
    class PipelineTriggerGitConfigurationPullRequestArgsDict(TypedDict):
        branches: NotRequired[pulumi.Input['PipelineTriggerGitConfigurationPullRequestBranchesArgsDict']]
        """
        The field that specifies to filter on branches for the pull request trigger configuration. A `branches` block is documented below.
        """
        events: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list that specifies which pull request events to filter on (opened, updated, closed) for the trigger configuration. Possible values are `OPEN`, `UPDATED ` and `CLOSED`.
        """
        file_paths: NotRequired[pulumi.Input['PipelineTriggerGitConfigurationPullRequestFilePathsArgsDict']]
        """
        The field that specifies to filter on file paths for the pull request trigger configuration. A `file_paths` block is documented below.
        """
elif False:
    PipelineTriggerGitConfigurationPullRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerGitConfigurationPullRequestArgs:
    def __init__(__self__, *,
                 branches: Optional[pulumi.Input['PipelineTriggerGitConfigurationPullRequestBranchesArgs']] = None,
                 events: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 file_paths: Optional[pulumi.Input['PipelineTriggerGitConfigurationPullRequestFilePathsArgs']] = None):
        """
        :param pulumi.Input['PipelineTriggerGitConfigurationPullRequestBranchesArgs'] branches: The field that specifies to filter on branches for the pull request trigger configuration. A `branches` block is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] events: A list that specifies which pull request events to filter on (opened, updated, closed) for the trigger configuration. Possible values are `OPEN`, `UPDATED ` and `CLOSED`.
        :param pulumi.Input['PipelineTriggerGitConfigurationPullRequestFilePathsArgs'] file_paths: The field that specifies to filter on file paths for the pull request trigger configuration. A `file_paths` block is documented below.
        """
        if branches is not None:
            pulumi.set(__self__, "branches", branches)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if file_paths is not None:
            pulumi.set(__self__, "file_paths", file_paths)

    @property
    @pulumi.getter
    def branches(self) -> Optional[pulumi.Input['PipelineTriggerGitConfigurationPullRequestBranchesArgs']]:
        """
        The field that specifies to filter on branches for the pull request trigger configuration. A `branches` block is documented below.
        """
        return pulumi.get(self, "branches")

    @branches.setter
    def branches(self, value: Optional[pulumi.Input['PipelineTriggerGitConfigurationPullRequestBranchesArgs']]):
        pulumi.set(self, "branches", value)

    @property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list that specifies which pull request events to filter on (opened, updated, closed) for the trigger configuration. Possible values are `OPEN`, `UPDATED ` and `CLOSED`.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter(name="filePaths")
    def file_paths(self) -> Optional[pulumi.Input['PipelineTriggerGitConfigurationPullRequestFilePathsArgs']]:
        """
        The field that specifies to filter on file paths for the pull request trigger configuration. A `file_paths` block is documented below.
        """
        return pulumi.get(self, "file_paths")

    @file_paths.setter
    def file_paths(self, value: Optional[pulumi.Input['PipelineTriggerGitConfigurationPullRequestFilePathsArgs']]):
        pulumi.set(self, "file_paths", value)


if not MYPY:
    class PipelineTriggerGitConfigurationPullRequestBranchesArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of patterns of Git branches that, when a commit is pushed, are to be excluded from starting the pipeline.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of patterns of Git branches that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
elif False:
    PipelineTriggerGitConfigurationPullRequestBranchesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerGitConfigurationPullRequestBranchesArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] excludes: A list of patterns of Git branches that, when a commit is pushed, are to be excluded from starting the pipeline.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] includes: A list of patterns of Git branches that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of patterns of Git branches that, when a commit is pushed, are to be excluded from starting the pipeline.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of patterns of Git branches that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineTriggerGitConfigurationPullRequestFilePathsArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of patterns of Git repository file paths that, when a commit is pushed, are to be excluded from starting the pipeline.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of patterns of Git repository file paths that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
elif False:
    PipelineTriggerGitConfigurationPullRequestFilePathsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerGitConfigurationPullRequestFilePathsArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] excludes: A list of patterns of Git repository file paths that, when a commit is pushed, are to be excluded from starting the pipeline.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] includes: A list of patterns of Git repository file paths that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of patterns of Git repository file paths that, when a commit is pushed, are to be excluded from starting the pipeline.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of patterns of Git repository file paths that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineTriggerGitConfigurationPushArgsDict(TypedDict):
        branches: NotRequired[pulumi.Input['PipelineTriggerGitConfigurationPushBranchesArgsDict']]
        """
        The field that specifies to filter on branches for the push trigger configuration. A `branches` block is documented below.
        """
        file_paths: NotRequired[pulumi.Input['PipelineTriggerGitConfigurationPushFilePathsArgsDict']]
        """
        The field that specifies to filter on file paths for the push trigger configuration. A `file_paths` block is documented below.
        """
        tags: NotRequired[pulumi.Input['PipelineTriggerGitConfigurationPushTagsArgsDict']]
        """
        The field that contains the details for the Git tags trigger configuration. A `tags` block is documented below.
        """
elif False:
    PipelineTriggerGitConfigurationPushArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerGitConfigurationPushArgs:
    def __init__(__self__, *,
                 branches: Optional[pulumi.Input['PipelineTriggerGitConfigurationPushBranchesArgs']] = None,
                 file_paths: Optional[pulumi.Input['PipelineTriggerGitConfigurationPushFilePathsArgs']] = None,
                 tags: Optional[pulumi.Input['PipelineTriggerGitConfigurationPushTagsArgs']] = None):
        """
        :param pulumi.Input['PipelineTriggerGitConfigurationPushBranchesArgs'] branches: The field that specifies to filter on branches for the push trigger configuration. A `branches` block is documented below.
        :param pulumi.Input['PipelineTriggerGitConfigurationPushFilePathsArgs'] file_paths: The field that specifies to filter on file paths for the push trigger configuration. A `file_paths` block is documented below.
        :param pulumi.Input['PipelineTriggerGitConfigurationPushTagsArgs'] tags: The field that contains the details for the Git tags trigger configuration. A `tags` block is documented below.
        """
        if branches is not None:
            pulumi.set(__self__, "branches", branches)
        if file_paths is not None:
            pulumi.set(__self__, "file_paths", file_paths)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def branches(self) -> Optional[pulumi.Input['PipelineTriggerGitConfigurationPushBranchesArgs']]:
        """
        The field that specifies to filter on branches for the push trigger configuration. A `branches` block is documented below.
        """
        return pulumi.get(self, "branches")

    @branches.setter
    def branches(self, value: Optional[pulumi.Input['PipelineTriggerGitConfigurationPushBranchesArgs']]):
        pulumi.set(self, "branches", value)

    @property
    @pulumi.getter(name="filePaths")
    def file_paths(self) -> Optional[pulumi.Input['PipelineTriggerGitConfigurationPushFilePathsArgs']]:
        """
        The field that specifies to filter on file paths for the push trigger configuration. A `file_paths` block is documented below.
        """
        return pulumi.get(self, "file_paths")

    @file_paths.setter
    def file_paths(self, value: Optional[pulumi.Input['PipelineTriggerGitConfigurationPushFilePathsArgs']]):
        pulumi.set(self, "file_paths", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['PipelineTriggerGitConfigurationPushTagsArgs']]:
        """
        The field that contains the details for the Git tags trigger configuration. A `tags` block is documented below.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['PipelineTriggerGitConfigurationPushTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class PipelineTriggerGitConfigurationPushBranchesArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of patterns of Git branches that, when a commit is pushed, are to be excluded from starting the pipeline.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of patterns of Git branches that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
elif False:
    PipelineTriggerGitConfigurationPushBranchesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerGitConfigurationPushBranchesArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] excludes: A list of patterns of Git branches that, when a commit is pushed, are to be excluded from starting the pipeline.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] includes: A list of patterns of Git branches that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of patterns of Git branches that, when a commit is pushed, are to be excluded from starting the pipeline.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of patterns of Git branches that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineTriggerGitConfigurationPushFilePathsArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of patterns of Git repository file paths that, when a commit is pushed, are to be excluded from starting the pipeline.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of patterns of Git repository file paths that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
elif False:
    PipelineTriggerGitConfigurationPushFilePathsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerGitConfigurationPushFilePathsArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] excludes: A list of patterns of Git repository file paths that, when a commit is pushed, are to be excluded from starting the pipeline.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] includes: A list of patterns of Git repository file paths that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of patterns of Git repository file paths that, when a commit is pushed, are to be excluded from starting the pipeline.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of patterns of Git repository file paths that, when a commit is pushed, are to be included as criteria that starts the pipeline.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineTriggerGitConfigurationPushTagsArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of patterns of Git tags that, when pushed, are to be excluded from starting the pipeline.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of patterns of Git tags that, when pushed, are to be included as criteria that starts the pipeline.
        """
elif False:
    PipelineTriggerGitConfigurationPushTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerGitConfigurationPushTagsArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] excludes: A list of patterns of Git tags that, when pushed, are to be excluded from starting the pipeline.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] includes: A list of patterns of Git tags that, when pushed, are to be included as criteria that starts the pipeline.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of patterns of Git tags that, when pushed, are to be excluded from starting the pipeline.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of patterns of Git tags that, when pushed, are to be included as criteria that starts the pipeline.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineVariableArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        The name of a pipeline-level variable.
        """
        default_value: NotRequired[pulumi.Input[builtins.str]]
        """
        The default value of a pipeline-level variable.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The description of a pipeline-level variable.
        """
elif False:
    PipelineVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 default_value: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: The name of a pipeline-level variable.
        :param pulumi.Input[builtins.str] default_value: The default value of a pipeline-level variable.
        :param pulumi.Input[builtins.str] description: The description of a pipeline-level variable.
        """
        pulumi.set(__self__, "name", name)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of a pipeline-level variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The default value of a pipeline-level variable.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of a pipeline-level variable.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class WebhookAuthenticationConfigurationArgsDict(TypedDict):
        allowed_ip_range: NotRequired[pulumi.Input[builtins.str]]
        """
        A valid CIDR block for `IP` filtering. Required for `IP`.
        """
        secret_token: NotRequired[pulumi.Input[builtins.str]]
        """
        The shared secret for the GitHub repository webhook. Set this as `secret` in your `github_repository_webhook`'s `configuration` block. Required for `GITHUB_HMAC`.
        """
elif False:
    WebhookAuthenticationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhookAuthenticationConfigurationArgs:
    def __init__(__self__, *,
                 allowed_ip_range: Optional[pulumi.Input[builtins.str]] = None,
                 secret_token: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] allowed_ip_range: A valid CIDR block for `IP` filtering. Required for `IP`.
        :param pulumi.Input[builtins.str] secret_token: The shared secret for the GitHub repository webhook. Set this as `secret` in your `github_repository_webhook`'s `configuration` block. Required for `GITHUB_HMAC`.
        """
        if allowed_ip_range is not None:
            pulumi.set(__self__, "allowed_ip_range", allowed_ip_range)
        if secret_token is not None:
            pulumi.set(__self__, "secret_token", secret_token)

    @property
    @pulumi.getter(name="allowedIpRange")
    def allowed_ip_range(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A valid CIDR block for `IP` filtering. Required for `IP`.
        """
        return pulumi.get(self, "allowed_ip_range")

    @allowed_ip_range.setter
    def allowed_ip_range(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "allowed_ip_range", value)

    @property
    @pulumi.getter(name="secretToken")
    def secret_token(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The shared secret for the GitHub repository webhook. Set this as `secret` in your `github_repository_webhook`'s `configuration` block. Required for `GITHUB_HMAC`.
        """
        return pulumi.get(self, "secret_token")

    @secret_token.setter
    def secret_token(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret_token", value)


if not MYPY:
    class WebhookFilterArgsDict(TypedDict):
        json_path: pulumi.Input[builtins.str]
        """
        The [JSON path](https://github.com/json-path/JsonPath) to filter on.
        """
        match_equals: pulumi.Input[builtins.str]
        """
        The value to match on (e.g., `refs/heads/{Branch}`). See [AWS docs](https://docs.aws.amazon.com/codepipeline/latest/APIReference/API_WebhookFilterRule.html) for details.
        """
elif False:
    WebhookFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhookFilterArgs:
    def __init__(__self__, *,
                 json_path: pulumi.Input[builtins.str],
                 match_equals: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] json_path: The [JSON path](https://github.com/json-path/JsonPath) to filter on.
        :param pulumi.Input[builtins.str] match_equals: The value to match on (e.g., `refs/heads/{Branch}`). See [AWS docs](https://docs.aws.amazon.com/codepipeline/latest/APIReference/API_WebhookFilterRule.html) for details.
        """
        pulumi.set(__self__, "json_path", json_path)
        pulumi.set(__self__, "match_equals", match_equals)

    @property
    @pulumi.getter(name="jsonPath")
    def json_path(self) -> pulumi.Input[builtins.str]:
        """
        The [JSON path](https://github.com/json-path/JsonPath) to filter on.
        """
        return pulumi.get(self, "json_path")

    @json_path.setter
    def json_path(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "json_path", value)

    @property
    @pulumi.getter(name="matchEquals")
    def match_equals(self) -> pulumi.Input[builtins.str]:
        """
        The value to match on (e.g., `refs/heads/{Branch}`). See [AWS docs](https://docs.aws.amazon.com/codepipeline/latest/APIReference/API_WebhookFilterRule.html) for details.
        """
        return pulumi.get(self, "match_equals")

    @match_equals.setter
    def match_equals(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "match_equals", value)


