# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'CustomActionTypeConfigurationPropertyArgs',
    'CustomActionTypeConfigurationPropertyArgsDict',
    'CustomActionTypeInputArtifactDetailsArgs',
    'CustomActionTypeInputArtifactDetailsArgsDict',
    'CustomActionTypeOutputArtifactDetailsArgs',
    'CustomActionTypeOutputArtifactDetailsArgsDict',
    'CustomActionTypeSettingsArgs',
    'CustomActionTypeSettingsArgsDict',
    'PipelineArtifactStoreArgs',
    'PipelineArtifactStoreArgsDict',
    'PipelineArtifactStoreEncryptionKeyArgs',
    'PipelineArtifactStoreEncryptionKeyArgsDict',
    'PipelineStageArgs',
    'PipelineStageArgsDict',
    'PipelineStageActionArgs',
    'PipelineStageActionArgsDict',
    'PipelineStageBeforeEntryArgs',
    'PipelineStageBeforeEntryArgsDict',
    'PipelineStageBeforeEntryConditionArgs',
    'PipelineStageBeforeEntryConditionArgsDict',
    'PipelineStageBeforeEntryConditionRuleArgs',
    'PipelineStageBeforeEntryConditionRuleArgsDict',
    'PipelineStageBeforeEntryConditionRuleRuleTypeIdArgs',
    'PipelineStageBeforeEntryConditionRuleRuleTypeIdArgsDict',
    'PipelineStageOnFailureArgs',
    'PipelineStageOnFailureArgsDict',
    'PipelineStageOnFailureConditionArgs',
    'PipelineStageOnFailureConditionArgsDict',
    'PipelineStageOnFailureConditionRuleArgs',
    'PipelineStageOnFailureConditionRuleArgsDict',
    'PipelineStageOnFailureConditionRuleRuleTypeIdArgs',
    'PipelineStageOnFailureConditionRuleRuleTypeIdArgsDict',
    'PipelineStageOnFailureRetryConfigurationArgs',
    'PipelineStageOnFailureRetryConfigurationArgsDict',
    'PipelineStageOnSuccessArgs',
    'PipelineStageOnSuccessArgsDict',
    'PipelineStageOnSuccessConditionArgs',
    'PipelineStageOnSuccessConditionArgsDict',
    'PipelineStageOnSuccessConditionRuleArgs',
    'PipelineStageOnSuccessConditionRuleArgsDict',
    'PipelineStageOnSuccessConditionRuleRuleTypeIdArgs',
    'PipelineStageOnSuccessConditionRuleRuleTypeIdArgsDict',
    'PipelineTriggerArgs',
    'PipelineTriggerArgsDict',
    'PipelineTriggerAllArgs',
    'PipelineTriggerAllArgsDict',
    'PipelineTriggerAllGitConfigurationArgs',
    'PipelineTriggerAllGitConfigurationArgsDict',
    'PipelineTriggerAllGitConfigurationPullRequestArgs',
    'PipelineTriggerAllGitConfigurationPullRequestArgsDict',
    'PipelineTriggerAllGitConfigurationPullRequestBranchArgs',
    'PipelineTriggerAllGitConfigurationPullRequestBranchArgsDict',
    'PipelineTriggerAllGitConfigurationPullRequestFilePathArgs',
    'PipelineTriggerAllGitConfigurationPullRequestFilePathArgsDict',
    'PipelineTriggerAllGitConfigurationPushArgs',
    'PipelineTriggerAllGitConfigurationPushArgsDict',
    'PipelineTriggerAllGitConfigurationPushBranchArgs',
    'PipelineTriggerAllGitConfigurationPushBranchArgsDict',
    'PipelineTriggerAllGitConfigurationPushFilePathArgs',
    'PipelineTriggerAllGitConfigurationPushFilePathArgsDict',
    'PipelineTriggerAllGitConfigurationPushTagArgs',
    'PipelineTriggerAllGitConfigurationPushTagArgsDict',
    'PipelineTriggerGitConfigurationArgs',
    'PipelineTriggerGitConfigurationArgsDict',
    'PipelineTriggerGitConfigurationPullRequestArgs',
    'PipelineTriggerGitConfigurationPullRequestArgsDict',
    'PipelineTriggerGitConfigurationPullRequestBranchesArgs',
    'PipelineTriggerGitConfigurationPullRequestBranchesArgsDict',
    'PipelineTriggerGitConfigurationPullRequestFilePathsArgs',
    'PipelineTriggerGitConfigurationPullRequestFilePathsArgsDict',
    'PipelineTriggerGitConfigurationPushArgs',
    'PipelineTriggerGitConfigurationPushArgsDict',
    'PipelineTriggerGitConfigurationPushBranchesArgs',
    'PipelineTriggerGitConfigurationPushBranchesArgsDict',
    'PipelineTriggerGitConfigurationPushFilePathsArgs',
    'PipelineTriggerGitConfigurationPushFilePathsArgsDict',
    'PipelineTriggerGitConfigurationPushTagsArgs',
    'PipelineTriggerGitConfigurationPushTagsArgsDict',
    'PipelineVariableArgs',
    'PipelineVariableArgsDict',
    'WebhookAuthenticationConfigurationArgs',
    'WebhookAuthenticationConfigurationArgsDict',
    'WebhookFilterArgs',
    'WebhookFilterArgsDict',
]

MYPY = False

if not MYPY:
    class CustomActionTypeConfigurationPropertyArgsDict(TypedDict):
        key: pulumi.Input[_builtins.bool]
        name: pulumi.Input[_builtins.str]
        required: pulumi.Input[_builtins.bool]
        secret: pulumi.Input[_builtins.bool]
        description: NotRequired[pulumi.Input[_builtins.str]]
        queryable: NotRequired[pulumi.Input[_builtins.bool]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CustomActionTypeConfigurationPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomActionTypeConfigurationPropertyArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.bool],
                 name: pulumi.Input[_builtins.str],
                 required: pulumi.Input[_builtins.bool],
                 secret: pulumi.Input[_builtins.bool],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 queryable: Optional[pulumi.Input[_builtins.bool]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "required", required)
        pulumi.set(__self__, "secret", secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if queryable is not None:
            pulumi.set(__self__, "queryable", queryable)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "required", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def queryable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "queryable")

    @queryable.setter
    def queryable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "queryable", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CustomActionTypeInputArtifactDetailsArgsDict(TypedDict):
        maximum_count: pulumi.Input[_builtins.int]
        minimum_count: pulumi.Input[_builtins.int]
elif False:
    CustomActionTypeInputArtifactDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomActionTypeInputArtifactDetailsArgs:
    def __init__(__self__, *,
                 maximum_count: pulumi.Input[_builtins.int],
                 minimum_count: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "maximum_count", maximum_count)
        pulumi.set(__self__, "minimum_count", minimum_count)

    @_builtins.property
    @pulumi.getter(name="maximumCount")
    def maximum_count(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "maximum_count")

    @maximum_count.setter
    def maximum_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "maximum_count", value)

    @_builtins.property
    @pulumi.getter(name="minimumCount")
    def minimum_count(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "minimum_count")

    @minimum_count.setter
    def minimum_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minimum_count", value)


if not MYPY:
    class CustomActionTypeOutputArtifactDetailsArgsDict(TypedDict):
        maximum_count: pulumi.Input[_builtins.int]
        minimum_count: pulumi.Input[_builtins.int]
elif False:
    CustomActionTypeOutputArtifactDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomActionTypeOutputArtifactDetailsArgs:
    def __init__(__self__, *,
                 maximum_count: pulumi.Input[_builtins.int],
                 minimum_count: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "maximum_count", maximum_count)
        pulumi.set(__self__, "minimum_count", minimum_count)

    @_builtins.property
    @pulumi.getter(name="maximumCount")
    def maximum_count(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "maximum_count")

    @maximum_count.setter
    def maximum_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "maximum_count", value)

    @_builtins.property
    @pulumi.getter(name="minimumCount")
    def minimum_count(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "minimum_count")

    @minimum_count.setter
    def minimum_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minimum_count", value)


if not MYPY:
    class CustomActionTypeSettingsArgsDict(TypedDict):
        entity_url_template: NotRequired[pulumi.Input[_builtins.str]]
        execution_url_template: NotRequired[pulumi.Input[_builtins.str]]
        revision_url_template: NotRequired[pulumi.Input[_builtins.str]]
        third_party_configuration_url: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CustomActionTypeSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomActionTypeSettingsArgs:
    def __init__(__self__, *,
                 entity_url_template: Optional[pulumi.Input[_builtins.str]] = None,
                 execution_url_template: Optional[pulumi.Input[_builtins.str]] = None,
                 revision_url_template: Optional[pulumi.Input[_builtins.str]] = None,
                 third_party_configuration_url: Optional[pulumi.Input[_builtins.str]] = None):
        if entity_url_template is not None:
            pulumi.set(__self__, "entity_url_template", entity_url_template)
        if execution_url_template is not None:
            pulumi.set(__self__, "execution_url_template", execution_url_template)
        if revision_url_template is not None:
            pulumi.set(__self__, "revision_url_template", revision_url_template)
        if third_party_configuration_url is not None:
            pulumi.set(__self__, "third_party_configuration_url", third_party_configuration_url)

    @_builtins.property
    @pulumi.getter(name="entityUrlTemplate")
    def entity_url_template(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "entity_url_template")

    @entity_url_template.setter
    def entity_url_template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entity_url_template", value)

    @_builtins.property
    @pulumi.getter(name="executionUrlTemplate")
    def execution_url_template(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "execution_url_template")

    @execution_url_template.setter
    def execution_url_template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "execution_url_template", value)

    @_builtins.property
    @pulumi.getter(name="revisionUrlTemplate")
    def revision_url_template(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "revision_url_template")

    @revision_url_template.setter
    def revision_url_template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "revision_url_template", value)

    @_builtins.property
    @pulumi.getter(name="thirdPartyConfigurationUrl")
    def third_party_configuration_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "third_party_configuration_url")

    @third_party_configuration_url.setter
    def third_party_configuration_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "third_party_configuration_url", value)


if not MYPY:
    class PipelineArtifactStoreArgsDict(TypedDict):
        location: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
        encryption_key: NotRequired[pulumi.Input['PipelineArtifactStoreEncryptionKeyArgsDict']]
        region: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PipelineArtifactStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineArtifactStoreArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 encryption_key: Optional[pulumi.Input['PipelineArtifactStoreEncryptionKeyArgs']] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "type", type)
        if encryption_key is not None:
            pulumi.set(__self__, "encryption_key", encryption_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def location(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="encryptionKey")
    def encryption_key(self) -> Optional[pulumi.Input['PipelineArtifactStoreEncryptionKeyArgs']]:
        return pulumi.get(self, "encryption_key")

    @encryption_key.setter
    def encryption_key(self, value: Optional[pulumi.Input['PipelineArtifactStoreEncryptionKeyArgs']]):
        pulumi.set(self, "encryption_key", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class PipelineArtifactStoreEncryptionKeyArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
elif False:
    PipelineArtifactStoreEncryptionKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineArtifactStoreEncryptionKeyArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PipelineStageArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input['PipelineStageActionArgsDict']]]
        name: pulumi.Input[_builtins.str]
        before_entry: NotRequired[pulumi.Input['PipelineStageBeforeEntryArgsDict']]
        on_failure: NotRequired[pulumi.Input['PipelineStageOnFailureArgsDict']]
        on_success: NotRequired[pulumi.Input['PipelineStageOnSuccessArgsDict']]
elif False:
    PipelineStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input['PipelineStageActionArgs']]],
                 name: pulumi.Input[_builtins.str],
                 before_entry: Optional[pulumi.Input['PipelineStageBeforeEntryArgs']] = None,
                 on_failure: Optional[pulumi.Input['PipelineStageOnFailureArgs']] = None,
                 on_success: Optional[pulumi.Input['PipelineStageOnSuccessArgs']] = None):
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "name", name)
        if before_entry is not None:
            pulumi.set(__self__, "before_entry", before_entry)
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_success is not None:
            pulumi.set(__self__, "on_success", on_success)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input['PipelineStageActionArgs']]]:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input['PipelineStageActionArgs']]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="beforeEntry")
    def before_entry(self) -> Optional[pulumi.Input['PipelineStageBeforeEntryArgs']]:
        return pulumi.get(self, "before_entry")

    @before_entry.setter
    def before_entry(self, value: Optional[pulumi.Input['PipelineStageBeforeEntryArgs']]):
        pulumi.set(self, "before_entry", value)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['PipelineStageOnFailureArgs']]:
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['PipelineStageOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)

    @_builtins.property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional[pulumi.Input['PipelineStageOnSuccessArgs']]:
        return pulumi.get(self, "on_success")

    @on_success.setter
    def on_success(self, value: Optional[pulumi.Input['PipelineStageOnSuccessArgs']]):
        pulumi.set(self, "on_success", value)


if not MYPY:
    class PipelineStageActionArgsDict(TypedDict):
        category: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        owner: pulumi.Input[_builtins.str]
        provider: pulumi.Input[_builtins.str]
        version: pulumi.Input[_builtins.str]
        configuration: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        input_artifacts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        output_artifacts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        region: NotRequired[pulumi.Input[_builtins.str]]
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        run_order: NotRequired[pulumi.Input[_builtins.int]]
        timeout_in_minutes: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    PipelineStageActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageActionArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 owner: pulumi.Input[_builtins.str],
                 provider: pulumi.Input[_builtins.str],
                 version: pulumi.Input[_builtins.str],
                 configuration: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 input_artifacts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 output_artifacts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 run_order: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_in_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "version", version)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if input_artifacts is not None:
            pulumi.set(__self__, "input_artifacts", input_artifacts)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if output_artifacts is not None:
            pulumi.set(__self__, "output_artifacts", output_artifacts)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if run_order is not None:
            pulumi.set(__self__, "run_order", run_order)
        if timeout_in_minutes is not None:
            pulumi.set(__self__, "timeout_in_minutes", timeout_in_minutes)

    @_builtins.property
    @pulumi.getter
    def category(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def owner(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "owner", value)

    @_builtins.property
    @pulumi.getter
    def provider(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "provider", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "configuration", value)

    @_builtins.property
    @pulumi.getter(name="inputArtifacts")
    def input_artifacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "input_artifacts")

    @input_artifacts.setter
    def input_artifacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "input_artifacts", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="outputArtifacts")
    def output_artifacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "output_artifacts")

    @output_artifacts.setter
    def output_artifacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "output_artifacts", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="runOrder")
    def run_order(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "run_order")

    @run_order.setter
    def run_order(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "run_order", value)

    @_builtins.property
    @pulumi.getter(name="timeoutInMinutes")
    def timeout_in_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "timeout_in_minutes")

    @timeout_in_minutes.setter
    def timeout_in_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_in_minutes", value)


if not MYPY:
    class PipelineStageBeforeEntryArgsDict(TypedDict):
        condition: pulumi.Input['PipelineStageBeforeEntryConditionArgsDict']
elif False:
    PipelineStageBeforeEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageBeforeEntryArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input['PipelineStageBeforeEntryConditionArgs']):
        pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input['PipelineStageBeforeEntryConditionArgs']:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['PipelineStageBeforeEntryConditionArgs']):
        pulumi.set(self, "condition", value)


if not MYPY:
    class PipelineStageBeforeEntryConditionArgsDict(TypedDict):
        rules: pulumi.Input[Sequence[pulumi.Input['PipelineStageBeforeEntryConditionRuleArgsDict']]]
        result: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PipelineStageBeforeEntryConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageBeforeEntryConditionArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['PipelineStageBeforeEntryConditionRuleArgs']]],
                 result: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "rules", rules)
        if result is not None:
            pulumi.set(__self__, "result", result)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['PipelineStageBeforeEntryConditionRuleArgs']]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['PipelineStageBeforeEntryConditionRuleArgs']]]):
        pulumi.set(self, "rules", value)

    @_builtins.property
    @pulumi.getter
    def result(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "result")

    @result.setter
    def result(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "result", value)


if not MYPY:
    class PipelineStageBeforeEntryConditionRuleArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        rule_type_id: pulumi.Input['PipelineStageBeforeEntryConditionRuleRuleTypeIdArgsDict']
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        configuration: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        input_artifacts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        region: NotRequired[pulumi.Input[_builtins.str]]
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        timeout_in_minutes: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    PipelineStageBeforeEntryConditionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageBeforeEntryConditionRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 rule_type_id: pulumi.Input['PipelineStageBeforeEntryConditionRuleRuleTypeIdArgs'],
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 configuration: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 input_artifacts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout_in_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rule_type_id", rule_type_id)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if input_artifacts is not None:
            pulumi.set(__self__, "input_artifacts", input_artifacts)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if timeout_in_minutes is not None:
            pulumi.set(__self__, "timeout_in_minutes", timeout_in_minutes)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="ruleTypeId")
    def rule_type_id(self) -> pulumi.Input['PipelineStageBeforeEntryConditionRuleRuleTypeIdArgs']:
        return pulumi.get(self, "rule_type_id")

    @rule_type_id.setter
    def rule_type_id(self, value: pulumi.Input['PipelineStageBeforeEntryConditionRuleRuleTypeIdArgs']):
        pulumi.set(self, "rule_type_id", value)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "configuration", value)

    @_builtins.property
    @pulumi.getter(name="inputArtifacts")
    def input_artifacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "input_artifacts")

    @input_artifacts.setter
    def input_artifacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "input_artifacts", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="timeoutInMinutes")
    def timeout_in_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "timeout_in_minutes")

    @timeout_in_minutes.setter
    def timeout_in_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_in_minutes", value)


if not MYPY:
    class PipelineStageBeforeEntryConditionRuleRuleTypeIdArgsDict(TypedDict):
        category: pulumi.Input[_builtins.str]
        provider: pulumi.Input[_builtins.str]
        owner: NotRequired[pulumi.Input[_builtins.str]]
        version: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PipelineStageBeforeEntryConditionRuleRuleTypeIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageBeforeEntryConditionRuleRuleTypeIdArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[_builtins.str],
                 provider: pulumi.Input[_builtins.str],
                 owner: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "provider", provider)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def category(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def provider(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "provider", value)

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "owner", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PipelineStageOnFailureArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input['PipelineStageOnFailureConditionArgsDict']]
        result: NotRequired[pulumi.Input[_builtins.str]]
        retry_configuration: NotRequired[pulumi.Input['PipelineStageOnFailureRetryConfigurationArgsDict']]
elif False:
    PipelineStageOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageOnFailureArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input['PipelineStageOnFailureConditionArgs']] = None,
                 result: Optional[pulumi.Input[_builtins.str]] = None,
                 retry_configuration: Optional[pulumi.Input['PipelineStageOnFailureRetryConfigurationArgs']] = None):
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if result is not None:
            pulumi.set(__self__, "result", result)
        if retry_configuration is not None:
            pulumi.set(__self__, "retry_configuration", retry_configuration)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['PipelineStageOnFailureConditionArgs']]:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['PipelineStageOnFailureConditionArgs']]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter
    def result(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "result")

    @result.setter
    def result(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "result", value)

    @_builtins.property
    @pulumi.getter(name="retryConfiguration")
    def retry_configuration(self) -> Optional[pulumi.Input['PipelineStageOnFailureRetryConfigurationArgs']]:
        return pulumi.get(self, "retry_configuration")

    @retry_configuration.setter
    def retry_configuration(self, value: Optional[pulumi.Input['PipelineStageOnFailureRetryConfigurationArgs']]):
        pulumi.set(self, "retry_configuration", value)


if not MYPY:
    class PipelineStageOnFailureConditionArgsDict(TypedDict):
        rules: pulumi.Input[Sequence[pulumi.Input['PipelineStageOnFailureConditionRuleArgsDict']]]
        result: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PipelineStageOnFailureConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageOnFailureConditionArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['PipelineStageOnFailureConditionRuleArgs']]],
                 result: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "rules", rules)
        if result is not None:
            pulumi.set(__self__, "result", result)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['PipelineStageOnFailureConditionRuleArgs']]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['PipelineStageOnFailureConditionRuleArgs']]]):
        pulumi.set(self, "rules", value)

    @_builtins.property
    @pulumi.getter
    def result(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "result")

    @result.setter
    def result(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "result", value)


if not MYPY:
    class PipelineStageOnFailureConditionRuleArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        rule_type_id: pulumi.Input['PipelineStageOnFailureConditionRuleRuleTypeIdArgsDict']
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        configuration: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        input_artifacts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        region: NotRequired[pulumi.Input[_builtins.str]]
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        timeout_in_minutes: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    PipelineStageOnFailureConditionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageOnFailureConditionRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 rule_type_id: pulumi.Input['PipelineStageOnFailureConditionRuleRuleTypeIdArgs'],
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 configuration: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 input_artifacts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout_in_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rule_type_id", rule_type_id)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if input_artifacts is not None:
            pulumi.set(__self__, "input_artifacts", input_artifacts)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if timeout_in_minutes is not None:
            pulumi.set(__self__, "timeout_in_minutes", timeout_in_minutes)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="ruleTypeId")
    def rule_type_id(self) -> pulumi.Input['PipelineStageOnFailureConditionRuleRuleTypeIdArgs']:
        return pulumi.get(self, "rule_type_id")

    @rule_type_id.setter
    def rule_type_id(self, value: pulumi.Input['PipelineStageOnFailureConditionRuleRuleTypeIdArgs']):
        pulumi.set(self, "rule_type_id", value)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "configuration", value)

    @_builtins.property
    @pulumi.getter(name="inputArtifacts")
    def input_artifacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "input_artifacts")

    @input_artifacts.setter
    def input_artifacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "input_artifacts", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="timeoutInMinutes")
    def timeout_in_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "timeout_in_minutes")

    @timeout_in_minutes.setter
    def timeout_in_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_in_minutes", value)


if not MYPY:
    class PipelineStageOnFailureConditionRuleRuleTypeIdArgsDict(TypedDict):
        category: pulumi.Input[_builtins.str]
        provider: pulumi.Input[_builtins.str]
        owner: NotRequired[pulumi.Input[_builtins.str]]
        version: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PipelineStageOnFailureConditionRuleRuleTypeIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageOnFailureConditionRuleRuleTypeIdArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[_builtins.str],
                 provider: pulumi.Input[_builtins.str],
                 owner: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "provider", provider)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def category(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def provider(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "provider", value)

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "owner", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PipelineStageOnFailureRetryConfigurationArgsDict(TypedDict):
        retry_mode: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PipelineStageOnFailureRetryConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageOnFailureRetryConfigurationArgs:
    def __init__(__self__, *,
                 retry_mode: Optional[pulumi.Input[_builtins.str]] = None):
        if retry_mode is not None:
            pulumi.set(__self__, "retry_mode", retry_mode)

    @_builtins.property
    @pulumi.getter(name="retryMode")
    def retry_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "retry_mode")

    @retry_mode.setter
    def retry_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "retry_mode", value)


if not MYPY:
    class PipelineStageOnSuccessArgsDict(TypedDict):
        condition: pulumi.Input['PipelineStageOnSuccessConditionArgsDict']
elif False:
    PipelineStageOnSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageOnSuccessArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input['PipelineStageOnSuccessConditionArgs']):
        pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input['PipelineStageOnSuccessConditionArgs']:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['PipelineStageOnSuccessConditionArgs']):
        pulumi.set(self, "condition", value)


if not MYPY:
    class PipelineStageOnSuccessConditionArgsDict(TypedDict):
        rules: pulumi.Input[Sequence[pulumi.Input['PipelineStageOnSuccessConditionRuleArgsDict']]]
        result: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PipelineStageOnSuccessConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageOnSuccessConditionArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['PipelineStageOnSuccessConditionRuleArgs']]],
                 result: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "rules", rules)
        if result is not None:
            pulumi.set(__self__, "result", result)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['PipelineStageOnSuccessConditionRuleArgs']]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['PipelineStageOnSuccessConditionRuleArgs']]]):
        pulumi.set(self, "rules", value)

    @_builtins.property
    @pulumi.getter
    def result(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "result")

    @result.setter
    def result(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "result", value)


if not MYPY:
    class PipelineStageOnSuccessConditionRuleArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        rule_type_id: pulumi.Input['PipelineStageOnSuccessConditionRuleRuleTypeIdArgsDict']
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        configuration: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        input_artifacts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        region: NotRequired[pulumi.Input[_builtins.str]]
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        timeout_in_minutes: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    PipelineStageOnSuccessConditionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageOnSuccessConditionRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 rule_type_id: pulumi.Input['PipelineStageOnSuccessConditionRuleRuleTypeIdArgs'],
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 configuration: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 input_artifacts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout_in_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rule_type_id", rule_type_id)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if input_artifacts is not None:
            pulumi.set(__self__, "input_artifacts", input_artifacts)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if timeout_in_minutes is not None:
            pulumi.set(__self__, "timeout_in_minutes", timeout_in_minutes)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="ruleTypeId")
    def rule_type_id(self) -> pulumi.Input['PipelineStageOnSuccessConditionRuleRuleTypeIdArgs']:
        return pulumi.get(self, "rule_type_id")

    @rule_type_id.setter
    def rule_type_id(self, value: pulumi.Input['PipelineStageOnSuccessConditionRuleRuleTypeIdArgs']):
        pulumi.set(self, "rule_type_id", value)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "configuration", value)

    @_builtins.property
    @pulumi.getter(name="inputArtifacts")
    def input_artifacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "input_artifacts")

    @input_artifacts.setter
    def input_artifacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "input_artifacts", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="timeoutInMinutes")
    def timeout_in_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "timeout_in_minutes")

    @timeout_in_minutes.setter
    def timeout_in_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_in_minutes", value)


if not MYPY:
    class PipelineStageOnSuccessConditionRuleRuleTypeIdArgsDict(TypedDict):
        category: pulumi.Input[_builtins.str]
        provider: pulumi.Input[_builtins.str]
        owner: NotRequired[pulumi.Input[_builtins.str]]
        version: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PipelineStageOnSuccessConditionRuleRuleTypeIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineStageOnSuccessConditionRuleRuleTypeIdArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[_builtins.str],
                 provider: pulumi.Input[_builtins.str],
                 owner: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "provider", provider)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def category(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def provider(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "provider", value)

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "owner", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PipelineTriggerArgsDict(TypedDict):
        git_configuration: pulumi.Input['PipelineTriggerGitConfigurationArgsDict']
        provider_type: pulumi.Input[_builtins.str]
elif False:
    PipelineTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerArgs:
    def __init__(__self__, *,
                 git_configuration: pulumi.Input['PipelineTriggerGitConfigurationArgs'],
                 provider_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "git_configuration", git_configuration)
        pulumi.set(__self__, "provider_type", provider_type)

    @_builtins.property
    @pulumi.getter(name="gitConfiguration")
    def git_configuration(self) -> pulumi.Input['PipelineTriggerGitConfigurationArgs']:
        return pulumi.get(self, "git_configuration")

    @git_configuration.setter
    def git_configuration(self, value: pulumi.Input['PipelineTriggerGitConfigurationArgs']):
        pulumi.set(self, "git_configuration", value)

    @_builtins.property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "provider_type")

    @provider_type.setter
    def provider_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "provider_type", value)


if not MYPY:
    class PipelineTriggerAllArgsDict(TypedDict):
        git_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationArgsDict']]]]
        provider_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PipelineTriggerAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerAllArgs:
    def __init__(__self__, *,
                 git_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationArgs']]]] = None,
                 provider_type: Optional[pulumi.Input[_builtins.str]] = None):
        if git_configurations is not None:
            pulumi.set(__self__, "git_configurations", git_configurations)
        if provider_type is not None:
            pulumi.set(__self__, "provider_type", provider_type)

    @_builtins.property
    @pulumi.getter(name="gitConfigurations")
    def git_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationArgs']]]]:
        return pulumi.get(self, "git_configurations")

    @git_configurations.setter
    def git_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationArgs']]]]):
        pulumi.set(self, "git_configurations", value)

    @_builtins.property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "provider_type")

    @provider_type.setter
    def provider_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "provider_type", value)


if not MYPY:
    class PipelineTriggerAllGitConfigurationArgsDict(TypedDict):
        pull_requests: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestArgsDict']]]]
        pushes: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushArgsDict']]]]
        source_action_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PipelineTriggerAllGitConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerAllGitConfigurationArgs:
    def __init__(__self__, *,
                 pull_requests: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestArgs']]]] = None,
                 pushes: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushArgs']]]] = None,
                 source_action_name: Optional[pulumi.Input[_builtins.str]] = None):
        if pull_requests is not None:
            pulumi.set(__self__, "pull_requests", pull_requests)
        if pushes is not None:
            pulumi.set(__self__, "pushes", pushes)
        if source_action_name is not None:
            pulumi.set(__self__, "source_action_name", source_action_name)

    @_builtins.property
    @pulumi.getter(name="pullRequests")
    def pull_requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestArgs']]]]:
        return pulumi.get(self, "pull_requests")

    @pull_requests.setter
    def pull_requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestArgs']]]]):
        pulumi.set(self, "pull_requests", value)

    @_builtins.property
    @pulumi.getter
    def pushes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushArgs']]]]:
        return pulumi.get(self, "pushes")

    @pushes.setter
    def pushes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushArgs']]]]):
        pulumi.set(self, "pushes", value)

    @_builtins.property
    @pulumi.getter(name="sourceActionName")
    def source_action_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source_action_name")

    @source_action_name.setter
    def source_action_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_action_name", value)


if not MYPY:
    class PipelineTriggerAllGitConfigurationPullRequestArgsDict(TypedDict):
        branches: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestBranchArgsDict']]]]
        events: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        file_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestFilePathArgsDict']]]]
elif False:
    PipelineTriggerAllGitConfigurationPullRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerAllGitConfigurationPullRequestArgs:
    def __init__(__self__, *,
                 branches: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestBranchArgs']]]] = None,
                 events: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 file_paths: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestFilePathArgs']]]] = None):
        if branches is not None:
            pulumi.set(__self__, "branches", branches)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if file_paths is not None:
            pulumi.set(__self__, "file_paths", file_paths)

    @_builtins.property
    @pulumi.getter
    def branches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestBranchArgs']]]]:
        return pulumi.get(self, "branches")

    @branches.setter
    def branches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestBranchArgs']]]]):
        pulumi.set(self, "branches", value)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "events", value)

    @_builtins.property
    @pulumi.getter(name="filePaths")
    def file_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestFilePathArgs']]]]:
        return pulumi.get(self, "file_paths")

    @file_paths.setter
    def file_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPullRequestFilePathArgs']]]]):
        pulumi.set(self, "file_paths", value)


if not MYPY:
    class PipelineTriggerAllGitConfigurationPullRequestBranchArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PipelineTriggerAllGitConfigurationPullRequestBranchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerAllGitConfigurationPullRequestBranchArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineTriggerAllGitConfigurationPullRequestFilePathArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PipelineTriggerAllGitConfigurationPullRequestFilePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerAllGitConfigurationPullRequestFilePathArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineTriggerAllGitConfigurationPushArgsDict(TypedDict):
        branches: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushBranchArgsDict']]]]
        file_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushFilePathArgsDict']]]]
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushTagArgsDict']]]]
elif False:
    PipelineTriggerAllGitConfigurationPushArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerAllGitConfigurationPushArgs:
    def __init__(__self__, *,
                 branches: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushBranchArgs']]]] = None,
                 file_paths: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushFilePathArgs']]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushTagArgs']]]] = None):
        if branches is not None:
            pulumi.set(__self__, "branches", branches)
        if file_paths is not None:
            pulumi.set(__self__, "file_paths", file_paths)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def branches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushBranchArgs']]]]:
        return pulumi.get(self, "branches")

    @branches.setter
    def branches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushBranchArgs']]]]):
        pulumi.set(self, "branches", value)

    @_builtins.property
    @pulumi.getter(name="filePaths")
    def file_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushFilePathArgs']]]]:
        return pulumi.get(self, "file_paths")

    @file_paths.setter
    def file_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushFilePathArgs']]]]):
        pulumi.set(self, "file_paths", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushTagArgs']]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerAllGitConfigurationPushTagArgs']]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class PipelineTriggerAllGitConfigurationPushBranchArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PipelineTriggerAllGitConfigurationPushBranchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerAllGitConfigurationPushBranchArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineTriggerAllGitConfigurationPushFilePathArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PipelineTriggerAllGitConfigurationPushFilePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerAllGitConfigurationPushFilePathArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineTriggerAllGitConfigurationPushTagArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PipelineTriggerAllGitConfigurationPushTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerAllGitConfigurationPushTagArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineTriggerGitConfigurationArgsDict(TypedDict):
        source_action_name: pulumi.Input[_builtins.str]
        pull_requests: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerGitConfigurationPullRequestArgsDict']]]]
        pushes: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerGitConfigurationPushArgsDict']]]]
elif False:
    PipelineTriggerGitConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerGitConfigurationArgs:
    def __init__(__self__, *,
                 source_action_name: pulumi.Input[_builtins.str],
                 pull_requests: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerGitConfigurationPullRequestArgs']]]] = None,
                 pushes: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerGitConfigurationPushArgs']]]] = None):
        pulumi.set(__self__, "source_action_name", source_action_name)
        if pull_requests is not None:
            pulumi.set(__self__, "pull_requests", pull_requests)
        if pushes is not None:
            pulumi.set(__self__, "pushes", pushes)

    @_builtins.property
    @pulumi.getter(name="sourceActionName")
    def source_action_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source_action_name")

    @source_action_name.setter
    def source_action_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_action_name", value)

    @_builtins.property
    @pulumi.getter(name="pullRequests")
    def pull_requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerGitConfigurationPullRequestArgs']]]]:
        return pulumi.get(self, "pull_requests")

    @pull_requests.setter
    def pull_requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerGitConfigurationPullRequestArgs']]]]):
        pulumi.set(self, "pull_requests", value)

    @_builtins.property
    @pulumi.getter
    def pushes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerGitConfigurationPushArgs']]]]:
        return pulumi.get(self, "pushes")

    @pushes.setter
    def pushes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineTriggerGitConfigurationPushArgs']]]]):
        pulumi.set(self, "pushes", value)


if not MYPY:
    class PipelineTriggerGitConfigurationPullRequestArgsDict(TypedDict):
        branches: NotRequired[pulumi.Input['PipelineTriggerGitConfigurationPullRequestBranchesArgsDict']]
        events: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        file_paths: NotRequired[pulumi.Input['PipelineTriggerGitConfigurationPullRequestFilePathsArgsDict']]
elif False:
    PipelineTriggerGitConfigurationPullRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerGitConfigurationPullRequestArgs:
    def __init__(__self__, *,
                 branches: Optional[pulumi.Input['PipelineTriggerGitConfigurationPullRequestBranchesArgs']] = None,
                 events: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 file_paths: Optional[pulumi.Input['PipelineTriggerGitConfigurationPullRequestFilePathsArgs']] = None):
        if branches is not None:
            pulumi.set(__self__, "branches", branches)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if file_paths is not None:
            pulumi.set(__self__, "file_paths", file_paths)

    @_builtins.property
    @pulumi.getter
    def branches(self) -> Optional[pulumi.Input['PipelineTriggerGitConfigurationPullRequestBranchesArgs']]:
        return pulumi.get(self, "branches")

    @branches.setter
    def branches(self, value: Optional[pulumi.Input['PipelineTriggerGitConfigurationPullRequestBranchesArgs']]):
        pulumi.set(self, "branches", value)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "events", value)

    @_builtins.property
    @pulumi.getter(name="filePaths")
    def file_paths(self) -> Optional[pulumi.Input['PipelineTriggerGitConfigurationPullRequestFilePathsArgs']]:
        return pulumi.get(self, "file_paths")

    @file_paths.setter
    def file_paths(self, value: Optional[pulumi.Input['PipelineTriggerGitConfigurationPullRequestFilePathsArgs']]):
        pulumi.set(self, "file_paths", value)


if not MYPY:
    class PipelineTriggerGitConfigurationPullRequestBranchesArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PipelineTriggerGitConfigurationPullRequestBranchesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerGitConfigurationPullRequestBranchesArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineTriggerGitConfigurationPullRequestFilePathsArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PipelineTriggerGitConfigurationPullRequestFilePathsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerGitConfigurationPullRequestFilePathsArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineTriggerGitConfigurationPushArgsDict(TypedDict):
        branches: NotRequired[pulumi.Input['PipelineTriggerGitConfigurationPushBranchesArgsDict']]
        file_paths: NotRequired[pulumi.Input['PipelineTriggerGitConfigurationPushFilePathsArgsDict']]
        tags: NotRequired[pulumi.Input['PipelineTriggerGitConfigurationPushTagsArgsDict']]
elif False:
    PipelineTriggerGitConfigurationPushArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerGitConfigurationPushArgs:
    def __init__(__self__, *,
                 branches: Optional[pulumi.Input['PipelineTriggerGitConfigurationPushBranchesArgs']] = None,
                 file_paths: Optional[pulumi.Input['PipelineTriggerGitConfigurationPushFilePathsArgs']] = None,
                 tags: Optional[pulumi.Input['PipelineTriggerGitConfigurationPushTagsArgs']] = None):
        if branches is not None:
            pulumi.set(__self__, "branches", branches)
        if file_paths is not None:
            pulumi.set(__self__, "file_paths", file_paths)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def branches(self) -> Optional[pulumi.Input['PipelineTriggerGitConfigurationPushBranchesArgs']]:
        return pulumi.get(self, "branches")

    @branches.setter
    def branches(self, value: Optional[pulumi.Input['PipelineTriggerGitConfigurationPushBranchesArgs']]):
        pulumi.set(self, "branches", value)

    @_builtins.property
    @pulumi.getter(name="filePaths")
    def file_paths(self) -> Optional[pulumi.Input['PipelineTriggerGitConfigurationPushFilePathsArgs']]:
        return pulumi.get(self, "file_paths")

    @file_paths.setter
    def file_paths(self, value: Optional[pulumi.Input['PipelineTriggerGitConfigurationPushFilePathsArgs']]):
        pulumi.set(self, "file_paths", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input['PipelineTriggerGitConfigurationPushTagsArgs']]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input['PipelineTriggerGitConfigurationPushTagsArgs']]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class PipelineTriggerGitConfigurationPushBranchesArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PipelineTriggerGitConfigurationPushBranchesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerGitConfigurationPushBranchesArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineTriggerGitConfigurationPushFilePathsArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PipelineTriggerGitConfigurationPushFilePathsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerGitConfigurationPushFilePathsArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineTriggerGitConfigurationPushTagsArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PipelineTriggerGitConfigurationPushTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerGitConfigurationPushTagsArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineVariableArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        default_value: NotRequired[pulumi.Input[_builtins.str]]
        description: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PipelineVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 default_value: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_value", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class WebhookAuthenticationConfigurationArgsDict(TypedDict):
        allowed_ip_range: NotRequired[pulumi.Input[_builtins.str]]
        secret_token: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebhookAuthenticationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhookAuthenticationConfigurationArgs:
    def __init__(__self__, *,
                 allowed_ip_range: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_token: Optional[pulumi.Input[_builtins.str]] = None):
        if allowed_ip_range is not None:
            pulumi.set(__self__, "allowed_ip_range", allowed_ip_range)
        if secret_token is not None:
            pulumi.set(__self__, "secret_token", secret_token)

    @_builtins.property
    @pulumi.getter(name="allowedIpRange")
    def allowed_ip_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "allowed_ip_range")

    @allowed_ip_range.setter
    def allowed_ip_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "allowed_ip_range", value)

    @_builtins.property
    @pulumi.getter(name="secretToken")
    def secret_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "secret_token")

    @secret_token.setter
    def secret_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_token", value)


if not MYPY:
    class WebhookFilterArgsDict(TypedDict):
        json_path: pulumi.Input[_builtins.str]
        match_equals: pulumi.Input[_builtins.str]
elif False:
    WebhookFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhookFilterArgs:
    def __init__(__self__, *,
                 json_path: pulumi.Input[_builtins.str],
                 match_equals: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "json_path", json_path)
        pulumi.set(__self__, "match_equals", match_equals)

    @_builtins.property
    @pulumi.getter(name="jsonPath")
    def json_path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "json_path")

    @json_path.setter
    def json_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "json_path", value)

    @_builtins.property
    @pulumi.getter(name="matchEquals")
    def match_equals(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_equals")

    @match_equals.setter
    def match_equals(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_equals", value)


