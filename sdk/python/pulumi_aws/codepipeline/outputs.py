# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'CustomActionTypeConfigurationProperty',
    'CustomActionTypeInputArtifactDetails',
    'CustomActionTypeOutputArtifactDetails',
    'CustomActionTypeSettings',
    'PipelineArtifactStore',
    'PipelineArtifactStoreEncryptionKey',
    'PipelineStage',
    'PipelineStageAction',
    'PipelineStageBeforeEntry',
    'PipelineStageBeforeEntryCondition',
    'PipelineStageBeforeEntryConditionRule',
    'PipelineStageBeforeEntryConditionRuleRuleTypeId',
    'PipelineStageOnFailure',
    'PipelineStageOnFailureCondition',
    'PipelineStageOnFailureConditionRule',
    'PipelineStageOnFailureConditionRuleRuleTypeId',
    'PipelineStageOnFailureRetryConfiguration',
    'PipelineStageOnSuccess',
    'PipelineStageOnSuccessCondition',
    'PipelineStageOnSuccessConditionRule',
    'PipelineStageOnSuccessConditionRuleRuleTypeId',
    'PipelineTrigger',
    'PipelineTriggerAll',
    'PipelineTriggerAllGitConfiguration',
    'PipelineTriggerAllGitConfigurationPullRequest',
    'PipelineTriggerAllGitConfigurationPullRequestBranch',
    'PipelineTriggerAllGitConfigurationPullRequestFilePath',
    'PipelineTriggerAllGitConfigurationPush',
    'PipelineTriggerAllGitConfigurationPushBranch',
    'PipelineTriggerAllGitConfigurationPushFilePath',
    'PipelineTriggerAllGitConfigurationPushTag',
    'PipelineTriggerGitConfiguration',
    'PipelineTriggerGitConfigurationPullRequest',
    'PipelineTriggerGitConfigurationPullRequestBranches',
    'PipelineTriggerGitConfigurationPullRequestFilePaths',
    'PipelineTriggerGitConfigurationPush',
    'PipelineTriggerGitConfigurationPushBranches',
    'PipelineTriggerGitConfigurationPushFilePaths',
    'PipelineTriggerGitConfigurationPushTags',
    'PipelineVariable',
    'WebhookAuthenticationConfiguration',
    'WebhookFilter',
]

@pulumi.output_type
class CustomActionTypeConfigurationProperty(dict):
    def __init__(__self__, *,
                 key: _builtins.bool,
                 name: _builtins.str,
                 required: _builtins.bool,
                 secret: _builtins.bool,
                 description: Optional[_builtins.str] = None,
                 queryable: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "required", required)
        pulumi.set(__self__, "secret", secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if queryable is not None:
            pulumi.set(__self__, "queryable", queryable)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.bool:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def required(self) -> _builtins.bool:
        return pulumi.get(self, "required")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.bool:
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def queryable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "queryable")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class CustomActionTypeInputArtifactDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumCount":
            suggest = "maximum_count"
        elif key == "minimumCount":
            suggest = "minimum_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomActionTypeInputArtifactDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomActionTypeInputArtifactDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomActionTypeInputArtifactDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_count: _builtins.int,
                 minimum_count: _builtins.int):
        pulumi.set(__self__, "maximum_count", maximum_count)
        pulumi.set(__self__, "minimum_count", minimum_count)

    @_builtins.property
    @pulumi.getter(name="maximumCount")
    def maximum_count(self) -> _builtins.int:
        return pulumi.get(self, "maximum_count")

    @_builtins.property
    @pulumi.getter(name="minimumCount")
    def minimum_count(self) -> _builtins.int:
        return pulumi.get(self, "minimum_count")


@pulumi.output_type
class CustomActionTypeOutputArtifactDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumCount":
            suggest = "maximum_count"
        elif key == "minimumCount":
            suggest = "minimum_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomActionTypeOutputArtifactDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomActionTypeOutputArtifactDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomActionTypeOutputArtifactDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_count: _builtins.int,
                 minimum_count: _builtins.int):
        pulumi.set(__self__, "maximum_count", maximum_count)
        pulumi.set(__self__, "minimum_count", minimum_count)

    @_builtins.property
    @pulumi.getter(name="maximumCount")
    def maximum_count(self) -> _builtins.int:
        return pulumi.get(self, "maximum_count")

    @_builtins.property
    @pulumi.getter(name="minimumCount")
    def minimum_count(self) -> _builtins.int:
        return pulumi.get(self, "minimum_count")


@pulumi.output_type
class CustomActionTypeSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityUrlTemplate":
            suggest = "entity_url_template"
        elif key == "executionUrlTemplate":
            suggest = "execution_url_template"
        elif key == "revisionUrlTemplate":
            suggest = "revision_url_template"
        elif key == "thirdPartyConfigurationUrl":
            suggest = "third_party_configuration_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomActionTypeSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomActionTypeSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomActionTypeSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_url_template: Optional[_builtins.str] = None,
                 execution_url_template: Optional[_builtins.str] = None,
                 revision_url_template: Optional[_builtins.str] = None,
                 third_party_configuration_url: Optional[_builtins.str] = None):
        if entity_url_template is not None:
            pulumi.set(__self__, "entity_url_template", entity_url_template)
        if execution_url_template is not None:
            pulumi.set(__self__, "execution_url_template", execution_url_template)
        if revision_url_template is not None:
            pulumi.set(__self__, "revision_url_template", revision_url_template)
        if third_party_configuration_url is not None:
            pulumi.set(__self__, "third_party_configuration_url", third_party_configuration_url)

    @_builtins.property
    @pulumi.getter(name="entityUrlTemplate")
    def entity_url_template(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "entity_url_template")

    @_builtins.property
    @pulumi.getter(name="executionUrlTemplate")
    def execution_url_template(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "execution_url_template")

    @_builtins.property
    @pulumi.getter(name="revisionUrlTemplate")
    def revision_url_template(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "revision_url_template")

    @_builtins.property
    @pulumi.getter(name="thirdPartyConfigurationUrl")
    def third_party_configuration_url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "third_party_configuration_url")


@pulumi.output_type
class PipelineArtifactStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionKey":
            suggest = "encryption_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineArtifactStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineArtifactStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineArtifactStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: _builtins.str,
                 type: _builtins.str,
                 encryption_key: Optional['outputs.PipelineArtifactStoreEncryptionKey'] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "type", type)
        if encryption_key is not None:
            pulumi.set(__self__, "encryption_key", encryption_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="encryptionKey")
    def encryption_key(self) -> Optional['outputs.PipelineArtifactStoreEncryptionKey']:
        return pulumi.get(self, "encryption_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class PipelineArtifactStoreEncryptionKey(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 type: _builtins.str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class PipelineStage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beforeEntry":
            suggest = "before_entry"
        elif key == "onFailure":
            suggest = "on_failure"
        elif key == "onSuccess":
            suggest = "on_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineStage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineStage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineStage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Sequence['outputs.PipelineStageAction'],
                 name: _builtins.str,
                 before_entry: Optional['outputs.PipelineStageBeforeEntry'] = None,
                 on_failure: Optional['outputs.PipelineStageOnFailure'] = None,
                 on_success: Optional['outputs.PipelineStageOnSuccess'] = None):
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "name", name)
        if before_entry is not None:
            pulumi.set(__self__, "before_entry", before_entry)
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_success is not None:
            pulumi.set(__self__, "on_success", on_success)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.PipelineStageAction']:
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="beforeEntry")
    def before_entry(self) -> Optional['outputs.PipelineStageBeforeEntry']:
        return pulumi.get(self, "before_entry")

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional['outputs.PipelineStageOnFailure']:
        return pulumi.get(self, "on_failure")

    @_builtins.property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional['outputs.PipelineStageOnSuccess']:
        return pulumi.get(self, "on_success")


@pulumi.output_type
class PipelineStageAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputArtifacts":
            suggest = "input_artifacts"
        elif key == "outputArtifacts":
            suggest = "output_artifacts"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "runOrder":
            suggest = "run_order"
        elif key == "timeoutInMinutes":
            suggest = "timeout_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineStageAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineStageAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineStageAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: _builtins.str,
                 name: _builtins.str,
                 owner: _builtins.str,
                 provider: _builtins.str,
                 version: _builtins.str,
                 configuration: Optional[Mapping[str, _builtins.str]] = None,
                 input_artifacts: Optional[Sequence[_builtins.str]] = None,
                 namespace: Optional[_builtins.str] = None,
                 output_artifacts: Optional[Sequence[_builtins.str]] = None,
                 region: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 run_order: Optional[_builtins.int] = None,
                 timeout_in_minutes: Optional[_builtins.int] = None):
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "version", version)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if input_artifacts is not None:
            pulumi.set(__self__, "input_artifacts", input_artifacts)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if output_artifacts is not None:
            pulumi.set(__self__, "output_artifacts", output_artifacts)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if run_order is not None:
            pulumi.set(__self__, "run_order", run_order)
        if timeout_in_minutes is not None:
            pulumi.set(__self__, "timeout_in_minutes", timeout_in_minutes)

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> _builtins.str:
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter(name="inputArtifacts")
    def input_artifacts(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "input_artifacts")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="outputArtifacts")
    def output_artifacts(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "output_artifacts")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="runOrder")
    def run_order(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "run_order")

    @_builtins.property
    @pulumi.getter(name="timeoutInMinutes")
    def timeout_in_minutes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout_in_minutes")


@pulumi.output_type
class PipelineStageBeforeEntry(dict):
    def __init__(__self__, *,
                 condition: 'outputs.PipelineStageBeforeEntryCondition'):
        pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> 'outputs.PipelineStageBeforeEntryCondition':
        return pulumi.get(self, "condition")


@pulumi.output_type
class PipelineStageBeforeEntryCondition(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.PipelineStageBeforeEntryConditionRule'],
                 result: Optional[_builtins.str] = None):
        pulumi.set(__self__, "rules", rules)
        if result is not None:
            pulumi.set(__self__, "result", result)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.PipelineStageBeforeEntryConditionRule']:
        return pulumi.get(self, "rules")

    @_builtins.property
    @pulumi.getter
    def result(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "result")


@pulumi.output_type
class PipelineStageBeforeEntryConditionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleTypeId":
            suggest = "rule_type_id"
        elif key == "inputArtifacts":
            suggest = "input_artifacts"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "timeoutInMinutes":
            suggest = "timeout_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineStageBeforeEntryConditionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineStageBeforeEntryConditionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineStageBeforeEntryConditionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 rule_type_id: 'outputs.PipelineStageBeforeEntryConditionRuleRuleTypeId',
                 commands: Optional[Sequence[_builtins.str]] = None,
                 configuration: Optional[Mapping[str, _builtins.str]] = None,
                 input_artifacts: Optional[Sequence[_builtins.str]] = None,
                 region: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 timeout_in_minutes: Optional[_builtins.int] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rule_type_id", rule_type_id)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if input_artifacts is not None:
            pulumi.set(__self__, "input_artifacts", input_artifacts)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if timeout_in_minutes is not None:
            pulumi.set(__self__, "timeout_in_minutes", timeout_in_minutes)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="ruleTypeId")
    def rule_type_id(self) -> 'outputs.PipelineStageBeforeEntryConditionRuleRuleTypeId':
        return pulumi.get(self, "rule_type_id")

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "commands")

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter(name="inputArtifacts")
    def input_artifacts(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "input_artifacts")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="timeoutInMinutes")
    def timeout_in_minutes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout_in_minutes")


@pulumi.output_type
class PipelineStageBeforeEntryConditionRuleRuleTypeId(dict):
    def __init__(__self__, *,
                 category: _builtins.str,
                 provider: _builtins.str,
                 owner: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "provider", provider)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class PipelineStageOnFailure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retryConfiguration":
            suggest = "retry_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineStageOnFailure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineStageOnFailure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineStageOnFailure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: Optional['outputs.PipelineStageOnFailureCondition'] = None,
                 result: Optional[_builtins.str] = None,
                 retry_configuration: Optional['outputs.PipelineStageOnFailureRetryConfiguration'] = None):
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if result is not None:
            pulumi.set(__self__, "result", result)
        if retry_configuration is not None:
            pulumi.set(__self__, "retry_configuration", retry_configuration)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional['outputs.PipelineStageOnFailureCondition']:
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def result(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "result")

    @_builtins.property
    @pulumi.getter(name="retryConfiguration")
    def retry_configuration(self) -> Optional['outputs.PipelineStageOnFailureRetryConfiguration']:
        return pulumi.get(self, "retry_configuration")


@pulumi.output_type
class PipelineStageOnFailureCondition(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.PipelineStageOnFailureConditionRule'],
                 result: Optional[_builtins.str] = None):
        pulumi.set(__self__, "rules", rules)
        if result is not None:
            pulumi.set(__self__, "result", result)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.PipelineStageOnFailureConditionRule']:
        return pulumi.get(self, "rules")

    @_builtins.property
    @pulumi.getter
    def result(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "result")


@pulumi.output_type
class PipelineStageOnFailureConditionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleTypeId":
            suggest = "rule_type_id"
        elif key == "inputArtifacts":
            suggest = "input_artifacts"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "timeoutInMinutes":
            suggest = "timeout_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineStageOnFailureConditionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineStageOnFailureConditionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineStageOnFailureConditionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 rule_type_id: 'outputs.PipelineStageOnFailureConditionRuleRuleTypeId',
                 commands: Optional[Sequence[_builtins.str]] = None,
                 configuration: Optional[Mapping[str, _builtins.str]] = None,
                 input_artifacts: Optional[Sequence[_builtins.str]] = None,
                 region: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 timeout_in_minutes: Optional[_builtins.int] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rule_type_id", rule_type_id)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if input_artifacts is not None:
            pulumi.set(__self__, "input_artifacts", input_artifacts)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if timeout_in_minutes is not None:
            pulumi.set(__self__, "timeout_in_minutes", timeout_in_minutes)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="ruleTypeId")
    def rule_type_id(self) -> 'outputs.PipelineStageOnFailureConditionRuleRuleTypeId':
        return pulumi.get(self, "rule_type_id")

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "commands")

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter(name="inputArtifacts")
    def input_artifacts(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "input_artifacts")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="timeoutInMinutes")
    def timeout_in_minutes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout_in_minutes")


@pulumi.output_type
class PipelineStageOnFailureConditionRuleRuleTypeId(dict):
    def __init__(__self__, *,
                 category: _builtins.str,
                 provider: _builtins.str,
                 owner: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "provider", provider)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class PipelineStageOnFailureRetryConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retryMode":
            suggest = "retry_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineStageOnFailureRetryConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineStageOnFailureRetryConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineStageOnFailureRetryConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retry_mode: Optional[_builtins.str] = None):
        if retry_mode is not None:
            pulumi.set(__self__, "retry_mode", retry_mode)

    @_builtins.property
    @pulumi.getter(name="retryMode")
    def retry_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "retry_mode")


@pulumi.output_type
class PipelineStageOnSuccess(dict):
    def __init__(__self__, *,
                 condition: 'outputs.PipelineStageOnSuccessCondition'):
        pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> 'outputs.PipelineStageOnSuccessCondition':
        return pulumi.get(self, "condition")


@pulumi.output_type
class PipelineStageOnSuccessCondition(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.PipelineStageOnSuccessConditionRule'],
                 result: Optional[_builtins.str] = None):
        pulumi.set(__self__, "rules", rules)
        if result is not None:
            pulumi.set(__self__, "result", result)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.PipelineStageOnSuccessConditionRule']:
        return pulumi.get(self, "rules")

    @_builtins.property
    @pulumi.getter
    def result(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "result")


@pulumi.output_type
class PipelineStageOnSuccessConditionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleTypeId":
            suggest = "rule_type_id"
        elif key == "inputArtifacts":
            suggest = "input_artifacts"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "timeoutInMinutes":
            suggest = "timeout_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineStageOnSuccessConditionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineStageOnSuccessConditionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineStageOnSuccessConditionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 rule_type_id: 'outputs.PipelineStageOnSuccessConditionRuleRuleTypeId',
                 commands: Optional[Sequence[_builtins.str]] = None,
                 configuration: Optional[Mapping[str, _builtins.str]] = None,
                 input_artifacts: Optional[Sequence[_builtins.str]] = None,
                 region: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 timeout_in_minutes: Optional[_builtins.int] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rule_type_id", rule_type_id)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if input_artifacts is not None:
            pulumi.set(__self__, "input_artifacts", input_artifacts)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if timeout_in_minutes is not None:
            pulumi.set(__self__, "timeout_in_minutes", timeout_in_minutes)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="ruleTypeId")
    def rule_type_id(self) -> 'outputs.PipelineStageOnSuccessConditionRuleRuleTypeId':
        return pulumi.get(self, "rule_type_id")

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "commands")

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter(name="inputArtifacts")
    def input_artifacts(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "input_artifacts")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="timeoutInMinutes")
    def timeout_in_minutes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout_in_minutes")


@pulumi.output_type
class PipelineStageOnSuccessConditionRuleRuleTypeId(dict):
    def __init__(__self__, *,
                 category: _builtins.str,
                 provider: _builtins.str,
                 owner: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "provider", provider)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class PipelineTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gitConfiguration":
            suggest = "git_configuration"
        elif key == "providerType":
            suggest = "provider_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 git_configuration: 'outputs.PipelineTriggerGitConfiguration',
                 provider_type: _builtins.str):
        pulumi.set(__self__, "git_configuration", git_configuration)
        pulumi.set(__self__, "provider_type", provider_type)

    @_builtins.property
    @pulumi.getter(name="gitConfiguration")
    def git_configuration(self) -> 'outputs.PipelineTriggerGitConfiguration':
        return pulumi.get(self, "git_configuration")

    @_builtins.property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> _builtins.str:
        return pulumi.get(self, "provider_type")


@pulumi.output_type
class PipelineTriggerAll(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gitConfigurations":
            suggest = "git_configurations"
        elif key == "providerType":
            suggest = "provider_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineTriggerAll. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineTriggerAll.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineTriggerAll.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 git_configurations: Optional[Sequence['outputs.PipelineTriggerAllGitConfiguration']] = None,
                 provider_type: Optional[_builtins.str] = None):
        if git_configurations is not None:
            pulumi.set(__self__, "git_configurations", git_configurations)
        if provider_type is not None:
            pulumi.set(__self__, "provider_type", provider_type)

    @_builtins.property
    @pulumi.getter(name="gitConfigurations")
    def git_configurations(self) -> Optional[Sequence['outputs.PipelineTriggerAllGitConfiguration']]:
        return pulumi.get(self, "git_configurations")

    @_builtins.property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "provider_type")


@pulumi.output_type
class PipelineTriggerAllGitConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pullRequests":
            suggest = "pull_requests"
        elif key == "sourceActionName":
            suggest = "source_action_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineTriggerAllGitConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineTriggerAllGitConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineTriggerAllGitConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pull_requests: Optional[Sequence['outputs.PipelineTriggerAllGitConfigurationPullRequest']] = None,
                 pushes: Optional[Sequence['outputs.PipelineTriggerAllGitConfigurationPush']] = None,
                 source_action_name: Optional[_builtins.str] = None):
        if pull_requests is not None:
            pulumi.set(__self__, "pull_requests", pull_requests)
        if pushes is not None:
            pulumi.set(__self__, "pushes", pushes)
        if source_action_name is not None:
            pulumi.set(__self__, "source_action_name", source_action_name)

    @_builtins.property
    @pulumi.getter(name="pullRequests")
    def pull_requests(self) -> Optional[Sequence['outputs.PipelineTriggerAllGitConfigurationPullRequest']]:
        return pulumi.get(self, "pull_requests")

    @_builtins.property
    @pulumi.getter
    def pushes(self) -> Optional[Sequence['outputs.PipelineTriggerAllGitConfigurationPush']]:
        return pulumi.get(self, "pushes")

    @_builtins.property
    @pulumi.getter(name="sourceActionName")
    def source_action_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_action_name")


@pulumi.output_type
class PipelineTriggerAllGitConfigurationPullRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filePaths":
            suggest = "file_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineTriggerAllGitConfigurationPullRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineTriggerAllGitConfigurationPullRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineTriggerAllGitConfigurationPullRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branches: Optional[Sequence['outputs.PipelineTriggerAllGitConfigurationPullRequestBranch']] = None,
                 events: Optional[Sequence[_builtins.str]] = None,
                 file_paths: Optional[Sequence['outputs.PipelineTriggerAllGitConfigurationPullRequestFilePath']] = None):
        if branches is not None:
            pulumi.set(__self__, "branches", branches)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if file_paths is not None:
            pulumi.set(__self__, "file_paths", file_paths)

    @_builtins.property
    @pulumi.getter
    def branches(self) -> Optional[Sequence['outputs.PipelineTriggerAllGitConfigurationPullRequestBranch']]:
        return pulumi.get(self, "branches")

    @_builtins.property
    @pulumi.getter
    def events(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "events")

    @_builtins.property
    @pulumi.getter(name="filePaths")
    def file_paths(self) -> Optional[Sequence['outputs.PipelineTriggerAllGitConfigurationPullRequestFilePath']]:
        return pulumi.get(self, "file_paths")


@pulumi.output_type
class PipelineTriggerAllGitConfigurationPullRequestBranch(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[_builtins.str]] = None,
                 includes: Optional[Sequence[_builtins.str]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "includes")


@pulumi.output_type
class PipelineTriggerAllGitConfigurationPullRequestFilePath(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[_builtins.str]] = None,
                 includes: Optional[Sequence[_builtins.str]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "includes")


@pulumi.output_type
class PipelineTriggerAllGitConfigurationPush(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filePaths":
            suggest = "file_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineTriggerAllGitConfigurationPush. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineTriggerAllGitConfigurationPush.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineTriggerAllGitConfigurationPush.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branches: Optional[Sequence['outputs.PipelineTriggerAllGitConfigurationPushBranch']] = None,
                 file_paths: Optional[Sequence['outputs.PipelineTriggerAllGitConfigurationPushFilePath']] = None,
                 tags: Optional[Sequence['outputs.PipelineTriggerAllGitConfigurationPushTag']] = None):
        if branches is not None:
            pulumi.set(__self__, "branches", branches)
        if file_paths is not None:
            pulumi.set(__self__, "file_paths", file_paths)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def branches(self) -> Optional[Sequence['outputs.PipelineTriggerAllGitConfigurationPushBranch']]:
        return pulumi.get(self, "branches")

    @_builtins.property
    @pulumi.getter(name="filePaths")
    def file_paths(self) -> Optional[Sequence['outputs.PipelineTriggerAllGitConfigurationPushFilePath']]:
        return pulumi.get(self, "file_paths")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.PipelineTriggerAllGitConfigurationPushTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class PipelineTriggerAllGitConfigurationPushBranch(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[_builtins.str]] = None,
                 includes: Optional[Sequence[_builtins.str]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "includes")


@pulumi.output_type
class PipelineTriggerAllGitConfigurationPushFilePath(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[_builtins.str]] = None,
                 includes: Optional[Sequence[_builtins.str]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "includes")


@pulumi.output_type
class PipelineTriggerAllGitConfigurationPushTag(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[_builtins.str]] = None,
                 includes: Optional[Sequence[_builtins.str]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "includes")


@pulumi.output_type
class PipelineTriggerGitConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceActionName":
            suggest = "source_action_name"
        elif key == "pullRequests":
            suggest = "pull_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineTriggerGitConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineTriggerGitConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineTriggerGitConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_action_name: _builtins.str,
                 pull_requests: Optional[Sequence['outputs.PipelineTriggerGitConfigurationPullRequest']] = None,
                 pushes: Optional[Sequence['outputs.PipelineTriggerGitConfigurationPush']] = None):
        pulumi.set(__self__, "source_action_name", source_action_name)
        if pull_requests is not None:
            pulumi.set(__self__, "pull_requests", pull_requests)
        if pushes is not None:
            pulumi.set(__self__, "pushes", pushes)

    @_builtins.property
    @pulumi.getter(name="sourceActionName")
    def source_action_name(self) -> _builtins.str:
        return pulumi.get(self, "source_action_name")

    @_builtins.property
    @pulumi.getter(name="pullRequests")
    def pull_requests(self) -> Optional[Sequence['outputs.PipelineTriggerGitConfigurationPullRequest']]:
        return pulumi.get(self, "pull_requests")

    @_builtins.property
    @pulumi.getter
    def pushes(self) -> Optional[Sequence['outputs.PipelineTriggerGitConfigurationPush']]:
        return pulumi.get(self, "pushes")


@pulumi.output_type
class PipelineTriggerGitConfigurationPullRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filePaths":
            suggest = "file_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineTriggerGitConfigurationPullRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineTriggerGitConfigurationPullRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineTriggerGitConfigurationPullRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branches: Optional['outputs.PipelineTriggerGitConfigurationPullRequestBranches'] = None,
                 events: Optional[Sequence[_builtins.str]] = None,
                 file_paths: Optional['outputs.PipelineTriggerGitConfigurationPullRequestFilePaths'] = None):
        if branches is not None:
            pulumi.set(__self__, "branches", branches)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if file_paths is not None:
            pulumi.set(__self__, "file_paths", file_paths)

    @_builtins.property
    @pulumi.getter
    def branches(self) -> Optional['outputs.PipelineTriggerGitConfigurationPullRequestBranches']:
        return pulumi.get(self, "branches")

    @_builtins.property
    @pulumi.getter
    def events(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "events")

    @_builtins.property
    @pulumi.getter(name="filePaths")
    def file_paths(self) -> Optional['outputs.PipelineTriggerGitConfigurationPullRequestFilePaths']:
        return pulumi.get(self, "file_paths")


@pulumi.output_type
class PipelineTriggerGitConfigurationPullRequestBranches(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[_builtins.str]] = None,
                 includes: Optional[Sequence[_builtins.str]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "includes")


@pulumi.output_type
class PipelineTriggerGitConfigurationPullRequestFilePaths(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[_builtins.str]] = None,
                 includes: Optional[Sequence[_builtins.str]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "includes")


@pulumi.output_type
class PipelineTriggerGitConfigurationPush(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filePaths":
            suggest = "file_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineTriggerGitConfigurationPush. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineTriggerGitConfigurationPush.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineTriggerGitConfigurationPush.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branches: Optional['outputs.PipelineTriggerGitConfigurationPushBranches'] = None,
                 file_paths: Optional['outputs.PipelineTriggerGitConfigurationPushFilePaths'] = None,
                 tags: Optional['outputs.PipelineTriggerGitConfigurationPushTags'] = None):
        if branches is not None:
            pulumi.set(__self__, "branches", branches)
        if file_paths is not None:
            pulumi.set(__self__, "file_paths", file_paths)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def branches(self) -> Optional['outputs.PipelineTriggerGitConfigurationPushBranches']:
        return pulumi.get(self, "branches")

    @_builtins.property
    @pulumi.getter(name="filePaths")
    def file_paths(self) -> Optional['outputs.PipelineTriggerGitConfigurationPushFilePaths']:
        return pulumi.get(self, "file_paths")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional['outputs.PipelineTriggerGitConfigurationPushTags']:
        return pulumi.get(self, "tags")


@pulumi.output_type
class PipelineTriggerGitConfigurationPushBranches(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[_builtins.str]] = None,
                 includes: Optional[Sequence[_builtins.str]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "includes")


@pulumi.output_type
class PipelineTriggerGitConfigurationPushFilePaths(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[_builtins.str]] = None,
                 includes: Optional[Sequence[_builtins.str]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "includes")


@pulumi.output_type
class PipelineTriggerGitConfigurationPushTags(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[_builtins.str]] = None,
                 includes: Optional[Sequence[_builtins.str]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "includes")


@pulumi.output_type
class PipelineVariable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineVariable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineVariable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineVariable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 default_value: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None):
        pulumi.set(__self__, "name", name)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default_value")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class WebhookAuthenticationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedIpRange":
            suggest = "allowed_ip_range"
        elif key == "secretToken":
            suggest = "secret_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebhookAuthenticationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebhookAuthenticationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebhookAuthenticationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_ip_range: Optional[_builtins.str] = None,
                 secret_token: Optional[_builtins.str] = None):
        if allowed_ip_range is not None:
            pulumi.set(__self__, "allowed_ip_range", allowed_ip_range)
        if secret_token is not None:
            pulumi.set(__self__, "secret_token", secret_token)

    @_builtins.property
    @pulumi.getter(name="allowedIpRange")
    def allowed_ip_range(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "allowed_ip_range")

    @_builtins.property
    @pulumi.getter(name="secretToken")
    def secret_token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "secret_token")


@pulumi.output_type
class WebhookFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonPath":
            suggest = "json_path"
        elif key == "matchEquals":
            suggest = "match_equals"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebhookFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebhookFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebhookFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 json_path: _builtins.str,
                 match_equals: _builtins.str):
        pulumi.set(__self__, "json_path", json_path)
        pulumi.set(__self__, "match_equals", match_equals)

    @_builtins.property
    @pulumi.getter(name="jsonPath")
    def json_path(self) -> _builtins.str:
        return pulumi.get(self, "json_path")

    @_builtins.property
    @pulumi.getter(name="matchEquals")
    def match_equals(self) -> _builtins.str:
        return pulumi.get(self, "match_equals")


