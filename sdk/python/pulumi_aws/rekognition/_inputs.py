# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'CollectionTimeoutsArgs',
    'CollectionTimeoutsArgsDict',
    'ProjectTimeoutsArgs',
    'ProjectTimeoutsArgsDict',
    'StreamProcessorDataSharingPreferenceArgs',
    'StreamProcessorDataSharingPreferenceArgsDict',
    'StreamProcessorInputArgs',
    'StreamProcessorInputArgsDict',
    'StreamProcessorInputKinesisVideoStreamArgs',
    'StreamProcessorInputKinesisVideoStreamArgsDict',
    'StreamProcessorNotificationChannelArgs',
    'StreamProcessorNotificationChannelArgsDict',
    'StreamProcessorOutputArgs',
    'StreamProcessorOutputArgsDict',
    'StreamProcessorOutputKinesisDataStreamArgs',
    'StreamProcessorOutputKinesisDataStreamArgsDict',
    'StreamProcessorOutputS3DestinationArgs',
    'StreamProcessorOutputS3DestinationArgsDict',
    'StreamProcessorRegionsOfInterestArgs',
    'StreamProcessorRegionsOfInterestArgsDict',
    'StreamProcessorRegionsOfInterestBoundingBoxArgs',
    'StreamProcessorRegionsOfInterestBoundingBoxArgsDict',
    'StreamProcessorRegionsOfInterestPolygonArgs',
    'StreamProcessorRegionsOfInterestPolygonArgsDict',
    'StreamProcessorSettingsArgs',
    'StreamProcessorSettingsArgsDict',
    'StreamProcessorSettingsConnectedHomeArgs',
    'StreamProcessorSettingsConnectedHomeArgsDict',
    'StreamProcessorSettingsFaceSearchArgs',
    'StreamProcessorSettingsFaceSearchArgsDict',
    'StreamProcessorTimeoutsArgs',
    'StreamProcessorTimeoutsArgsDict',
]

MYPY = False

if not MYPY:
    class CollectionTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    CollectionTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CollectionTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)


if not MYPY:
    class ProjectTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    ProjectTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class StreamProcessorDataSharingPreferenceArgsDict(TypedDict):
        opt_in: pulumi.Input[bool]
        """
        Whether you are sharing data with Rekognition to improve model performance.
        """
elif False:
    StreamProcessorDataSharingPreferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamProcessorDataSharingPreferenceArgs:
    def __init__(__self__, *,
                 opt_in: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] opt_in: Whether you are sharing data with Rekognition to improve model performance.
        """
        pulumi.set(__self__, "opt_in", opt_in)

    @property
    @pulumi.getter(name="optIn")
    def opt_in(self) -> pulumi.Input[bool]:
        """
        Whether you are sharing data with Rekognition to improve model performance.
        """
        return pulumi.get(self, "opt_in")

    @opt_in.setter
    def opt_in(self, value: pulumi.Input[bool]):
        pulumi.set(self, "opt_in", value)


if not MYPY:
    class StreamProcessorInputArgsDict(TypedDict):
        kinesis_video_stream: NotRequired[pulumi.Input['StreamProcessorInputKinesisVideoStreamArgsDict']]
        """
        Kinesis input stream. See `kinesis_video_stream`.
        """
elif False:
    StreamProcessorInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamProcessorInputArgs:
    def __init__(__self__, *,
                 kinesis_video_stream: Optional[pulumi.Input['StreamProcessorInputKinesisVideoStreamArgs']] = None):
        """
        :param pulumi.Input['StreamProcessorInputKinesisVideoStreamArgs'] kinesis_video_stream: Kinesis input stream. See `kinesis_video_stream`.
        """
        if kinesis_video_stream is not None:
            pulumi.set(__self__, "kinesis_video_stream", kinesis_video_stream)

    @property
    @pulumi.getter(name="kinesisVideoStream")
    def kinesis_video_stream(self) -> Optional[pulumi.Input['StreamProcessorInputKinesisVideoStreamArgs']]:
        """
        Kinesis input stream. See `kinesis_video_stream`.
        """
        return pulumi.get(self, "kinesis_video_stream")

    @kinesis_video_stream.setter
    def kinesis_video_stream(self, value: Optional[pulumi.Input['StreamProcessorInputKinesisVideoStreamArgs']]):
        pulumi.set(self, "kinesis_video_stream", value)


if not MYPY:
    class StreamProcessorInputKinesisVideoStreamArgsDict(TypedDict):
        arn: pulumi.Input[str]
        """
        ARN of the Kinesis video stream stream that streams the source video.
        """
elif False:
    StreamProcessorInputKinesisVideoStreamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamProcessorInputKinesisVideoStreamArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] arn: ARN of the Kinesis video stream stream that streams the source video.
        """
        pulumi.set(__self__, "arn", arn)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        ARN of the Kinesis video stream stream that streams the source video.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class StreamProcessorNotificationChannelArgsDict(TypedDict):
        sns_topic_arn: NotRequired[pulumi.Input[str]]
        """
        The Amazon Resource Number (ARN) of the Amazon Amazon Simple Notification Service topic to which Amazon Rekognition posts the completion status.
        """
elif False:
    StreamProcessorNotificationChannelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamProcessorNotificationChannelArgs:
    def __init__(__self__, *,
                 sns_topic_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] sns_topic_arn: The Amazon Resource Number (ARN) of the Amazon Amazon Simple Notification Service topic to which Amazon Rekognition posts the completion status.
        """
        if sns_topic_arn is not None:
            pulumi.set(__self__, "sns_topic_arn", sns_topic_arn)

    @property
    @pulumi.getter(name="snsTopicArn")
    def sns_topic_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Number (ARN) of the Amazon Amazon Simple Notification Service topic to which Amazon Rekognition posts the completion status.
        """
        return pulumi.get(self, "sns_topic_arn")

    @sns_topic_arn.setter
    def sns_topic_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sns_topic_arn", value)


if not MYPY:
    class StreamProcessorOutputArgsDict(TypedDict):
        kinesis_data_stream: NotRequired[pulumi.Input['StreamProcessorOutputKinesisDataStreamArgsDict']]
        """
        The Amazon Kinesis Data Streams stream to which the Amazon Rekognition stream processor streams the analysis results. See `kinesis_data_stream`.
        """
        s3_destination: NotRequired[pulumi.Input['StreamProcessorOutputS3DestinationArgsDict']]
        """
        The Amazon S3 bucket location to which Amazon Rekognition publishes the detailed inference results of a video analysis operation. See `s3_destination`.
        """
elif False:
    StreamProcessorOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamProcessorOutputArgs:
    def __init__(__self__, *,
                 kinesis_data_stream: Optional[pulumi.Input['StreamProcessorOutputKinesisDataStreamArgs']] = None,
                 s3_destination: Optional[pulumi.Input['StreamProcessorOutputS3DestinationArgs']] = None):
        """
        :param pulumi.Input['StreamProcessorOutputKinesisDataStreamArgs'] kinesis_data_stream: The Amazon Kinesis Data Streams stream to which the Amazon Rekognition stream processor streams the analysis results. See `kinesis_data_stream`.
        :param pulumi.Input['StreamProcessorOutputS3DestinationArgs'] s3_destination: The Amazon S3 bucket location to which Amazon Rekognition publishes the detailed inference results of a video analysis operation. See `s3_destination`.
        """
        if kinesis_data_stream is not None:
            pulumi.set(__self__, "kinesis_data_stream", kinesis_data_stream)
        if s3_destination is not None:
            pulumi.set(__self__, "s3_destination", s3_destination)

    @property
    @pulumi.getter(name="kinesisDataStream")
    def kinesis_data_stream(self) -> Optional[pulumi.Input['StreamProcessorOutputKinesisDataStreamArgs']]:
        """
        The Amazon Kinesis Data Streams stream to which the Amazon Rekognition stream processor streams the analysis results. See `kinesis_data_stream`.
        """
        return pulumi.get(self, "kinesis_data_stream")

    @kinesis_data_stream.setter
    def kinesis_data_stream(self, value: Optional[pulumi.Input['StreamProcessorOutputKinesisDataStreamArgs']]):
        pulumi.set(self, "kinesis_data_stream", value)

    @property
    @pulumi.getter(name="s3Destination")
    def s3_destination(self) -> Optional[pulumi.Input['StreamProcessorOutputS3DestinationArgs']]:
        """
        The Amazon S3 bucket location to which Amazon Rekognition publishes the detailed inference results of a video analysis operation. See `s3_destination`.
        """
        return pulumi.get(self, "s3_destination")

    @s3_destination.setter
    def s3_destination(self, value: Optional[pulumi.Input['StreamProcessorOutputS3DestinationArgs']]):
        pulumi.set(self, "s3_destination", value)


if not MYPY:
    class StreamProcessorOutputKinesisDataStreamArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[str]]
        """
        ARN of the output Amazon Kinesis Data Streams stream.
        """
elif False:
    StreamProcessorOutputKinesisDataStreamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamProcessorOutputKinesisDataStreamArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] arn: ARN of the output Amazon Kinesis Data Streams stream.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        """
        ARN of the output Amazon Kinesis Data Streams stream.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class StreamProcessorOutputS3DestinationArgsDict(TypedDict):
        bucket: NotRequired[pulumi.Input[str]]
        """
        Name of the Amazon S3 bucket you want to associate with the streaming video project.
        """
        key_prefix: NotRequired[pulumi.Input[str]]
        """
        The prefix value of the location within the bucket that you want the information to be published to.
        """
elif False:
    StreamProcessorOutputS3DestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamProcessorOutputS3DestinationArgs:
    def __init__(__self__, *,
                 bucket: Optional[pulumi.Input[str]] = None,
                 key_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: Name of the Amazon S3 bucket you want to associate with the streaming video project.
        :param pulumi.Input[str] key_prefix: The prefix value of the location within the bucket that you want the information to be published to.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if key_prefix is not None:
            pulumi.set(__self__, "key_prefix", key_prefix)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Amazon S3 bucket you want to associate with the streaming video project.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="keyPrefix")
    def key_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix value of the location within the bucket that you want the information to be published to.
        """
        return pulumi.get(self, "key_prefix")

    @key_prefix.setter
    def key_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_prefix", value)


if not MYPY:
    class StreamProcessorRegionsOfInterestArgsDict(TypedDict):
        polygons: pulumi.Input[Sequence[pulumi.Input['StreamProcessorRegionsOfInterestPolygonArgsDict']]]
        """
        Shape made up of up to 10 Point objects to define a region of interest. See `polygon`.
        """
        bounding_box: NotRequired[pulumi.Input['StreamProcessorRegionsOfInterestBoundingBoxArgsDict']]
        """
        Box representing a region of interest on screen. Only 1 per region is allowed. See `bounding_box`.
        """
elif False:
    StreamProcessorRegionsOfInterestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamProcessorRegionsOfInterestArgs:
    def __init__(__self__, *,
                 polygons: pulumi.Input[Sequence[pulumi.Input['StreamProcessorRegionsOfInterestPolygonArgs']]],
                 bounding_box: Optional[pulumi.Input['StreamProcessorRegionsOfInterestBoundingBoxArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['StreamProcessorRegionsOfInterestPolygonArgs']]] polygons: Shape made up of up to 10 Point objects to define a region of interest. See `polygon`.
        :param pulumi.Input['StreamProcessorRegionsOfInterestBoundingBoxArgs'] bounding_box: Box representing a region of interest on screen. Only 1 per region is allowed. See `bounding_box`.
        """
        pulumi.set(__self__, "polygons", polygons)
        if bounding_box is not None:
            pulumi.set(__self__, "bounding_box", bounding_box)

    @property
    @pulumi.getter
    def polygons(self) -> pulumi.Input[Sequence[pulumi.Input['StreamProcessorRegionsOfInterestPolygonArgs']]]:
        """
        Shape made up of up to 10 Point objects to define a region of interest. See `polygon`.
        """
        return pulumi.get(self, "polygons")

    @polygons.setter
    def polygons(self, value: pulumi.Input[Sequence[pulumi.Input['StreamProcessorRegionsOfInterestPolygonArgs']]]):
        pulumi.set(self, "polygons", value)

    @property
    @pulumi.getter(name="boundingBox")
    def bounding_box(self) -> Optional[pulumi.Input['StreamProcessorRegionsOfInterestBoundingBoxArgs']]:
        """
        Box representing a region of interest on screen. Only 1 per region is allowed. See `bounding_box`.
        """
        return pulumi.get(self, "bounding_box")

    @bounding_box.setter
    def bounding_box(self, value: Optional[pulumi.Input['StreamProcessorRegionsOfInterestBoundingBoxArgs']]):
        pulumi.set(self, "bounding_box", value)


if not MYPY:
    class StreamProcessorRegionsOfInterestBoundingBoxArgsDict(TypedDict):
        height: NotRequired[pulumi.Input[float]]
        """
        Height of the bounding box as a ratio of the overall image height.
        """
        left: NotRequired[pulumi.Input[float]]
        """
        Left coordinate of the bounding box as a ratio of overall image width.
        """
        top: NotRequired[pulumi.Input[float]]
        """
        Top coordinate of the bounding box as a ratio of overall image height.
        """
        width: NotRequired[pulumi.Input[float]]
        """
        Width of the bounding box as a ratio of the overall image width.
        """
elif False:
    StreamProcessorRegionsOfInterestBoundingBoxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamProcessorRegionsOfInterestBoundingBoxArgs:
    def __init__(__self__, *,
                 height: Optional[pulumi.Input[float]] = None,
                 left: Optional[pulumi.Input[float]] = None,
                 top: Optional[pulumi.Input[float]] = None,
                 width: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] height: Height of the bounding box as a ratio of the overall image height.
        :param pulumi.Input[float] left: Left coordinate of the bounding box as a ratio of overall image width.
        :param pulumi.Input[float] top: Top coordinate of the bounding box as a ratio of overall image height.
        :param pulumi.Input[float] width: Width of the bounding box as a ratio of the overall image width.
        """
        if height is not None:
            pulumi.set(__self__, "height", height)
        if left is not None:
            pulumi.set(__self__, "left", left)
        if top is not None:
            pulumi.set(__self__, "top", top)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[float]]:
        """
        Height of the bounding box as a ratio of the overall image height.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def left(self) -> Optional[pulumi.Input[float]]:
        """
        Left coordinate of the bounding box as a ratio of overall image width.
        """
        return pulumi.get(self, "left")

    @left.setter
    def left(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "left", value)

    @property
    @pulumi.getter
    def top(self) -> Optional[pulumi.Input[float]]:
        """
        Top coordinate of the bounding box as a ratio of overall image height.
        """
        return pulumi.get(self, "top")

    @top.setter
    def top(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "top", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[float]]:
        """
        Width of the bounding box as a ratio of the overall image width.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "width", value)


if not MYPY:
    class StreamProcessorRegionsOfInterestPolygonArgsDict(TypedDict):
        x: NotRequired[pulumi.Input[float]]
        """
        The value of the X coordinate for a point on a Polygon.
        """
        y: NotRequired[pulumi.Input[float]]
        """
        The value of the Y coordinate for a point on a Polygon.
        """
elif False:
    StreamProcessorRegionsOfInterestPolygonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamProcessorRegionsOfInterestPolygonArgs:
    def __init__(__self__, *,
                 x: Optional[pulumi.Input[float]] = None,
                 y: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] x: The value of the X coordinate for a point on a Polygon.
        :param pulumi.Input[float] y: The value of the Y coordinate for a point on a Polygon.
        """
        if x is not None:
            pulumi.set(__self__, "x", x)
        if y is not None:
            pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def x(self) -> Optional[pulumi.Input[float]]:
        """
        The value of the X coordinate for a point on a Polygon.
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "x", value)

    @property
    @pulumi.getter
    def y(self) -> Optional[pulumi.Input[float]]:
        """
        The value of the Y coordinate for a point on a Polygon.
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "y", value)


if not MYPY:
    class StreamProcessorSettingsArgsDict(TypedDict):
        connected_home: NotRequired[pulumi.Input['StreamProcessorSettingsConnectedHomeArgsDict']]
        """
        Label detection settings to use on a streaming video. See `connected_home`.
        """
        face_search: NotRequired[pulumi.Input['StreamProcessorSettingsFaceSearchArgsDict']]
        """
        Input face recognition parameters for an Amazon Rekognition stream processor. See `face_search`.
        """
elif False:
    StreamProcessorSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamProcessorSettingsArgs:
    def __init__(__self__, *,
                 connected_home: Optional[pulumi.Input['StreamProcessorSettingsConnectedHomeArgs']] = None,
                 face_search: Optional[pulumi.Input['StreamProcessorSettingsFaceSearchArgs']] = None):
        """
        :param pulumi.Input['StreamProcessorSettingsConnectedHomeArgs'] connected_home: Label detection settings to use on a streaming video. See `connected_home`.
        :param pulumi.Input['StreamProcessorSettingsFaceSearchArgs'] face_search: Input face recognition parameters for an Amazon Rekognition stream processor. See `face_search`.
        """
        if connected_home is not None:
            pulumi.set(__self__, "connected_home", connected_home)
        if face_search is not None:
            pulumi.set(__self__, "face_search", face_search)

    @property
    @pulumi.getter(name="connectedHome")
    def connected_home(self) -> Optional[pulumi.Input['StreamProcessorSettingsConnectedHomeArgs']]:
        """
        Label detection settings to use on a streaming video. See `connected_home`.
        """
        return pulumi.get(self, "connected_home")

    @connected_home.setter
    def connected_home(self, value: Optional[pulumi.Input['StreamProcessorSettingsConnectedHomeArgs']]):
        pulumi.set(self, "connected_home", value)

    @property
    @pulumi.getter(name="faceSearch")
    def face_search(self) -> Optional[pulumi.Input['StreamProcessorSettingsFaceSearchArgs']]:
        """
        Input face recognition parameters for an Amazon Rekognition stream processor. See `face_search`.
        """
        return pulumi.get(self, "face_search")

    @face_search.setter
    def face_search(self, value: Optional[pulumi.Input['StreamProcessorSettingsFaceSearchArgs']]):
        pulumi.set(self, "face_search", value)


if not MYPY:
    class StreamProcessorSettingsConnectedHomeArgsDict(TypedDict):
        labels: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies what you want to detect in the video, such as people, packages, or pets. The current valid labels you can include in this list are: `PERSON`, `PET`, `PACKAGE`, and `ALL`.
        """
        min_confidence: NotRequired[pulumi.Input[float]]
        """
        Minimum confidence required to label an object in the video.
        """
elif False:
    StreamProcessorSettingsConnectedHomeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamProcessorSettingsConnectedHomeArgs:
    def __init__(__self__, *,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 min_confidence: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] labels: Specifies what you want to detect in the video, such as people, packages, or pets. The current valid labels you can include in this list are: `PERSON`, `PET`, `PACKAGE`, and `ALL`.
        :param pulumi.Input[float] min_confidence: Minimum confidence required to label an object in the video.
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if min_confidence is not None:
            pulumi.set(__self__, "min_confidence", min_confidence)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies what you want to detect in the video, such as people, packages, or pets. The current valid labels you can include in this list are: `PERSON`, `PET`, `PACKAGE`, and `ALL`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="minConfidence")
    def min_confidence(self) -> Optional[pulumi.Input[float]]:
        """
        Minimum confidence required to label an object in the video.
        """
        return pulumi.get(self, "min_confidence")

    @min_confidence.setter
    def min_confidence(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_confidence", value)


if not MYPY:
    class StreamProcessorSettingsFaceSearchArgsDict(TypedDict):
        collection_id: pulumi.Input[str]
        """
        ID of a collection that contains faces that you want to search for.
        """
        face_match_threshold: NotRequired[pulumi.Input[float]]
        """
        Minimum face match confidence score that must be met to return a result for a recognized face.
        """
elif False:
    StreamProcessorSettingsFaceSearchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamProcessorSettingsFaceSearchArgs:
    def __init__(__self__, *,
                 collection_id: pulumi.Input[str],
                 face_match_threshold: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] collection_id: ID of a collection that contains faces that you want to search for.
        :param pulumi.Input[float] face_match_threshold: Minimum face match confidence score that must be met to return a result for a recognized face.
        """
        pulumi.set(__self__, "collection_id", collection_id)
        if face_match_threshold is not None:
            pulumi.set(__self__, "face_match_threshold", face_match_threshold)

    @property
    @pulumi.getter(name="collectionId")
    def collection_id(self) -> pulumi.Input[str]:
        """
        ID of a collection that contains faces that you want to search for.
        """
        return pulumi.get(self, "collection_id")

    @collection_id.setter
    def collection_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "collection_id", value)

    @property
    @pulumi.getter(name="faceMatchThreshold")
    def face_match_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        Minimum face match confidence score that must be met to return a result for a recognized face.
        """
        return pulumi.get(self, "face_match_threshold")

    @face_match_threshold.setter
    def face_match_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "face_match_threshold", value)


if not MYPY:
    class StreamProcessorTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    StreamProcessorTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamProcessorTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None,
                 update: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update", value)


