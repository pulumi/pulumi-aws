# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._inputs import *

__all__ = [
    'GetRouteTableRoutesResult',
    'AwaitableGetRouteTableRoutesResult',
    'get_route_table_routes',
    'get_route_table_routes_output',
]

@pulumi.output_type
class GetRouteTableRoutesResult:
    """
    A collection of values returned by getRouteTableRoutes.
    """
    def __init__(__self__, filters=None, id=None, routes=None, transit_gateway_route_table_id=None):
        if filters and not isinstance(filters, list):
            raise TypeError("Expected argument 'filters' to be a list")
        pulumi.set(__self__, "filters", filters)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if routes and not isinstance(routes, list):
            raise TypeError("Expected argument 'routes' to be a list")
        pulumi.set(__self__, "routes", routes)
        if transit_gateway_route_table_id and not isinstance(transit_gateway_route_table_id, str):
            raise TypeError("Expected argument 'transit_gateway_route_table_id' to be a str")
        pulumi.set(__self__, "transit_gateway_route_table_id", transit_gateway_route_table_id)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.GetRouteTableRoutesFilterResult']:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The provider-assigned unique ID for this managed resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def routes(self) -> Sequence['outputs.GetRouteTableRoutesRouteResult']:
        """
        List of Transit Gateway Routes.
        """
        return pulumi.get(self, "routes")

    @property
    @pulumi.getter(name="transitGatewayRouteTableId")
    def transit_gateway_route_table_id(self) -> str:
        return pulumi.get(self, "transit_gateway_route_table_id")


class AwaitableGetRouteTableRoutesResult(GetRouteTableRoutesResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetRouteTableRoutesResult(
            filters=self.filters,
            id=self.id,
            routes=self.routes,
            transit_gateway_route_table_id=self.transit_gateway_route_table_id)


def get_route_table_routes(filters: Optional[Sequence[pulumi.InputType['GetRouteTableRoutesFilterArgs']]] = None,
                           transit_gateway_route_table_id: Optional[str] = None,
                           opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetRouteTableRoutesResult:
    """
    Provides informations for routes of a specific transit gateway, such as state, type, cidr

    ## Example Usage

    ```python
    import pulumi
    import pulumi_aws as aws

    test = aws.ec2transitgateway.get_route_table_routes(filters=[aws.ec2transitgateway.GetRouteTableRoutesFilterArgs(
            name="type",
            values=["propagated"],
        )],
        transit_gateway_route_table_id=example["id"])
    ```
    ### Complexe use case with transit gateway peering

    This example allow to create a mesh of transit gateway for diff√©rent regions routing all traffic to on-prem VPN

    ```python
    import pulumi
    import pulumi_aws as aws


    def not_implemented(msg):
        raise NotImplementedError(msg)

    this = aws.ec2transitgateway.TransitGateway("this",
        default_route_table_association="disable",
        default_route_table_propagation="disable")
    this_vpc_attachment = aws.ec2transitgateway.VpcAttachment("this",
        subnet_ids=[s["id"] for s in private],
        transit_gateway_id=this[0]["id"],
        vpc_id=this_aws_vpc["id"],
        transit_gateway_default_route_table_association=False,
        transit_gateway_default_route_table_propagation=False)
    this_route_table = aws.ec2transitgateway.RouteTable("this", transit_gateway_id=my_transit_gateway_id)
    vpc = aws.ec2transitgateway.RouteTableAssociation("vpc",
        transit_gateway_attachment_id=this_vpc_attachment.id,
        transit_gateway_route_table_id=my_transit_gateway_id_route_table)
    vpn = aws.ec2transitgateway.RouteTableAssociation("vpn",
        transit_gateway_attachment_id=this_aws_vpn_connection[0]["transitGatewayAttachmentId"],
        transit_gateway_route_table_id=my_transit_gateway_id_route_table)
    vpc_route_table_propagation = aws.ec2transitgateway.RouteTablePropagation("vpc",
        transit_gateway_attachment_id=this_vpc_attachment.id,
        transit_gateway_route_table_id=this_route_table.id)
    vpn_route_table_propagation = aws.ec2transitgateway.RouteTablePropagation("vpn",
        transit_gateway_attachment_id=this_aws_vpn_connection[0]["transitGatewayAttachmentId"],
        transit_gateway_route_table_id=this_route_table.id)
    eu_central_1 = aws.ec2transitgateway.TransitGateway("eu-central-1",
        default_route_table_association="disable",
        default_route_table_propagation="disable")
    eu_central_1_peering_attachment = aws.ec2transitgateway.PeeringAttachment("eu-central-1",
        peer_region="eu-central-1",
        peer_transit_gateway_id=eu_central_1.id,
        transit_gateway_id=this[0]["id"],
        tags={
            "Name": "TGW mesh from eu-central-1",
        })
    eu_central_1_route_table = aws.ec2transitgateway.RouteTable("eu-central-1",
        transit_gateway_id=eu_central_1.id,
        tags=not_implemented("merge({Name=\\"wl-transit-gateway-routetable-eu-central-1\\"},local.global_tags)"))
    eu_central_1_peering_attachment_accepter = aws.ec2transitgateway.PeeringAttachmentAccepter("eu-central-1",
        transit_gateway_attachment_id=eu_central_1_peering_attachment.id,
        tags={
            "Name": "Accepter TGW peering eu-central-1",
        })
    filtered_eu_central_1 = aws.ec2transitgateway.get_vpc_attachments(filters=[aws.ec2transitgateway.GetVpcAttachmentsFilterArgs(
        name="state",
        values=[
            "pendingAcceptance",
            "available",
        ],
    )])
    unit_eu_central_1 = {__key: aws.ec2transitgateway.get_vpc_attachment(id=__value) for __key, __value in not_implemented("toset(data.aws_ec2_transit_gateway_vpc_attachments.filtered-eu-central-1.ids)")}
    trusted_aws_accounts_ids = {}
    trusted_vpc_attachments_list_eu_central_1 = not_implemented("compact([fork,tvaindata.aws_ec2_transit_gateway_vpc_attachment.unit-eu-central-1:contains(local.trusted_aws_accounts_ids,lookup(tva,\\"vpc_owner_id\\",\\"\\"))?tva.id:\\"\\"])")
    ## create a map with all vpc attachments trusted to be able to use for_each to avoid conflict on plan/apply ##
    trusted_vpc_attachements_eu_central_1 = not_implemented("toset(sort(local.trusted_vpc_attachments_list_eu-central-1))")
    trusted_accounts_eu_central_1_tgw = []
    for range in [{"value": i} for i in range(0, trusted_vpc_attachements_eu_central_1)]:
        trusted_accounts_eu_central_1_tgw.append(aws.ec2transitgateway.VpcAttachmentAccepter(f"trusted_accounts_eu-central-1_tgw-{range['value']}",
            transit_gateway_attachment_id=range["value"],
            transit_gateway_default_route_table_propagation=False,
            transit_gateway_default_route_table_association=False,
            tags=global_tags))
    trusted_accounts_eu_central_1 = []
    def create_trusted_accounts_eu_central_1(range_body):
        for range in [{"key": k, "value": v} for [k, v] in enumerate(range_body)]:
            trusted_accounts_eu_central_1.append(aws.ec2transitgateway.RouteTableAssociation(f"trusted_accounts_eu-central-1-{range['key']}",
                transit_gateway_attachment_id=range["value"],
                transit_gateway_route_table_id=eu_central_1_route_table.id))

    trusted_accounts_eu_central_1_tgw.apply(create_trusted_accounts_eu_central_1)
    trusted_accounts_eu_central_1_route_table_propagation = []
    def create_trusted_accounts_eu_central_1(range_body):
        for range in [{"key": k, "value": v} for [k, v] in enumerate(range_body)]:
            trusted_accounts_eu_central_1_route_table_propagation.append(aws.ec2transitgateway.RouteTablePropagation(f"trusted_accounts_eu-central-1-{range['key']}",
                transit_gateway_attachment_id=range["value"],
                transit_gateway_route_table_id=eu_central_1_route_table.id))

    trusted_accounts_eu_central_1_tgw.apply(create_trusted_accounts_eu_central_1)
    test = aws.ec2transitgateway.get_route_table_routes_output(filters=[aws.ec2transitgateway.GetRouteTableRoutesFilterArgs(
            name="type",
            values=["propagated"],
        )],
        transit_gateway_route_table_id=eu_central_1_route_table.id)
    default_region_to_eu_central_1 = []
    def create_default_region_to_eu_central_1(range_body):
        for range in [{"key": k, "value": v} for [k, v] in enumerate(range_body)]:
            default_region_to_eu_central_1.append(aws.ec2transitgateway.Route(f"default-region-to-eu-central-1-{range['key']}",
                destination_cidr_block=range["key"],
                transit_gateway_route_table_id=this_route_table.id,
                transit_gateway_attachment_id=eu_central_1_peering_attachment.id))

    test.apply(lambda resolved_outputs: create_default_region_to_eu_central_1({r.destination_cidr_block: r for r in test.routes}))
    ```


    :param Sequence[pulumi.InputType['GetRouteTableRoutesFilterArgs']] filters: Custom filter block as described below.
    :param str transit_gateway_route_table_id: Identifier of EC2 Transit Gateway Route Table.
           
           More complex filters can be expressed using one or more `filter` sub-blocks,
           which take the following arguments:
    """
    __args__ = dict()
    __args__['filters'] = filters
    __args__['transitGatewayRouteTableId'] = transit_gateway_route_table_id
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('aws:ec2transitgateway/getRouteTableRoutes:getRouteTableRoutes', __args__, opts=opts, typ=GetRouteTableRoutesResult).value

    return AwaitableGetRouteTableRoutesResult(
        filters=pulumi.get(__ret__, 'filters'),
        id=pulumi.get(__ret__, 'id'),
        routes=pulumi.get(__ret__, 'routes'),
        transit_gateway_route_table_id=pulumi.get(__ret__, 'transit_gateway_route_table_id'))


@_utilities.lift_output_func(get_route_table_routes)
def get_route_table_routes_output(filters: Optional[pulumi.Input[Sequence[pulumi.InputType['GetRouteTableRoutesFilterArgs']]]] = None,
                                  transit_gateway_route_table_id: Optional[pulumi.Input[str]] = None,
                                  opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetRouteTableRoutesResult]:
    """
    Provides informations for routes of a specific transit gateway, such as state, type, cidr

    ## Example Usage

    ```python
    import pulumi
    import pulumi_aws as aws

    test = aws.ec2transitgateway.get_route_table_routes(filters=[aws.ec2transitgateway.GetRouteTableRoutesFilterArgs(
            name="type",
            values=["propagated"],
        )],
        transit_gateway_route_table_id=example["id"])
    ```
    ### Complexe use case with transit gateway peering

    This example allow to create a mesh of transit gateway for diff√©rent regions routing all traffic to on-prem VPN

    ```python
    import pulumi
    import pulumi_aws as aws


    def not_implemented(msg):
        raise NotImplementedError(msg)

    this = aws.ec2transitgateway.TransitGateway("this",
        default_route_table_association="disable",
        default_route_table_propagation="disable")
    this_vpc_attachment = aws.ec2transitgateway.VpcAttachment("this",
        subnet_ids=[s["id"] for s in private],
        transit_gateway_id=this[0]["id"],
        vpc_id=this_aws_vpc["id"],
        transit_gateway_default_route_table_association=False,
        transit_gateway_default_route_table_propagation=False)
    this_route_table = aws.ec2transitgateway.RouteTable("this", transit_gateway_id=my_transit_gateway_id)
    vpc = aws.ec2transitgateway.RouteTableAssociation("vpc",
        transit_gateway_attachment_id=this_vpc_attachment.id,
        transit_gateway_route_table_id=my_transit_gateway_id_route_table)
    vpn = aws.ec2transitgateway.RouteTableAssociation("vpn",
        transit_gateway_attachment_id=this_aws_vpn_connection[0]["transitGatewayAttachmentId"],
        transit_gateway_route_table_id=my_transit_gateway_id_route_table)
    vpc_route_table_propagation = aws.ec2transitgateway.RouteTablePropagation("vpc",
        transit_gateway_attachment_id=this_vpc_attachment.id,
        transit_gateway_route_table_id=this_route_table.id)
    vpn_route_table_propagation = aws.ec2transitgateway.RouteTablePropagation("vpn",
        transit_gateway_attachment_id=this_aws_vpn_connection[0]["transitGatewayAttachmentId"],
        transit_gateway_route_table_id=this_route_table.id)
    eu_central_1 = aws.ec2transitgateway.TransitGateway("eu-central-1",
        default_route_table_association="disable",
        default_route_table_propagation="disable")
    eu_central_1_peering_attachment = aws.ec2transitgateway.PeeringAttachment("eu-central-1",
        peer_region="eu-central-1",
        peer_transit_gateway_id=eu_central_1.id,
        transit_gateway_id=this[0]["id"],
        tags={
            "Name": "TGW mesh from eu-central-1",
        })
    eu_central_1_route_table = aws.ec2transitgateway.RouteTable("eu-central-1",
        transit_gateway_id=eu_central_1.id,
        tags=not_implemented("merge({Name=\\"wl-transit-gateway-routetable-eu-central-1\\"},local.global_tags)"))
    eu_central_1_peering_attachment_accepter = aws.ec2transitgateway.PeeringAttachmentAccepter("eu-central-1",
        transit_gateway_attachment_id=eu_central_1_peering_attachment.id,
        tags={
            "Name": "Accepter TGW peering eu-central-1",
        })
    filtered_eu_central_1 = aws.ec2transitgateway.get_vpc_attachments(filters=[aws.ec2transitgateway.GetVpcAttachmentsFilterArgs(
        name="state",
        values=[
            "pendingAcceptance",
            "available",
        ],
    )])
    unit_eu_central_1 = {__key: aws.ec2transitgateway.get_vpc_attachment(id=__value) for __key, __value in not_implemented("toset(data.aws_ec2_transit_gateway_vpc_attachments.filtered-eu-central-1.ids)")}
    trusted_aws_accounts_ids = {}
    trusted_vpc_attachments_list_eu_central_1 = not_implemented("compact([fork,tvaindata.aws_ec2_transit_gateway_vpc_attachment.unit-eu-central-1:contains(local.trusted_aws_accounts_ids,lookup(tva,\\"vpc_owner_id\\",\\"\\"))?tva.id:\\"\\"])")
    ## create a map with all vpc attachments trusted to be able to use for_each to avoid conflict on plan/apply ##
    trusted_vpc_attachements_eu_central_1 = not_implemented("toset(sort(local.trusted_vpc_attachments_list_eu-central-1))")
    trusted_accounts_eu_central_1_tgw = []
    for range in [{"value": i} for i in range(0, trusted_vpc_attachements_eu_central_1)]:
        trusted_accounts_eu_central_1_tgw.append(aws.ec2transitgateway.VpcAttachmentAccepter(f"trusted_accounts_eu-central-1_tgw-{range['value']}",
            transit_gateway_attachment_id=range["value"],
            transit_gateway_default_route_table_propagation=False,
            transit_gateway_default_route_table_association=False,
            tags=global_tags))
    trusted_accounts_eu_central_1 = []
    def create_trusted_accounts_eu_central_1(range_body):
        for range in [{"key": k, "value": v} for [k, v] in enumerate(range_body)]:
            trusted_accounts_eu_central_1.append(aws.ec2transitgateway.RouteTableAssociation(f"trusted_accounts_eu-central-1-{range['key']}",
                transit_gateway_attachment_id=range["value"],
                transit_gateway_route_table_id=eu_central_1_route_table.id))

    trusted_accounts_eu_central_1_tgw.apply(create_trusted_accounts_eu_central_1)
    trusted_accounts_eu_central_1_route_table_propagation = []
    def create_trusted_accounts_eu_central_1(range_body):
        for range in [{"key": k, "value": v} for [k, v] in enumerate(range_body)]:
            trusted_accounts_eu_central_1_route_table_propagation.append(aws.ec2transitgateway.RouteTablePropagation(f"trusted_accounts_eu-central-1-{range['key']}",
                transit_gateway_attachment_id=range["value"],
                transit_gateway_route_table_id=eu_central_1_route_table.id))

    trusted_accounts_eu_central_1_tgw.apply(create_trusted_accounts_eu_central_1)
    test = aws.ec2transitgateway.get_route_table_routes_output(filters=[aws.ec2transitgateway.GetRouteTableRoutesFilterArgs(
            name="type",
            values=["propagated"],
        )],
        transit_gateway_route_table_id=eu_central_1_route_table.id)
    default_region_to_eu_central_1 = []
    def create_default_region_to_eu_central_1(range_body):
        for range in [{"key": k, "value": v} for [k, v] in enumerate(range_body)]:
            default_region_to_eu_central_1.append(aws.ec2transitgateway.Route(f"default-region-to-eu-central-1-{range['key']}",
                destination_cidr_block=range["key"],
                transit_gateway_route_table_id=this_route_table.id,
                transit_gateway_attachment_id=eu_central_1_peering_attachment.id))

    test.apply(lambda resolved_outputs: create_default_region_to_eu_central_1({r.destination_cidr_block: r for r in test.routes}))
    ```


    :param Sequence[pulumi.InputType['GetRouteTableRoutesFilterArgs']] filters: Custom filter block as described below.
    :param str transit_gateway_route_table_id: Identifier of EC2 Transit Gateway Route Table.
           
           More complex filters can be expressed using one or more `filter` sub-blocks,
           which take the following arguments:
    """
    ...
