# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AnalysisParametersArgs',
    'AnalysisParametersArgsDict',
    'AnalysisParametersDateTimeParameterArgs',
    'AnalysisParametersDateTimeParameterArgsDict',
    'AnalysisParametersDecimalParameterArgs',
    'AnalysisParametersDecimalParameterArgsDict',
    'AnalysisParametersIntegerParameterArgs',
    'AnalysisParametersIntegerParameterArgsDict',
    'AnalysisParametersStringParameterArgs',
    'AnalysisParametersStringParameterArgsDict',
    'AnalysisPermissionArgs',
    'AnalysisPermissionArgsDict',
    'AnalysisSourceEntityArgs',
    'AnalysisSourceEntityArgsDict',
    'AnalysisSourceEntitySourceTemplateArgs',
    'AnalysisSourceEntitySourceTemplateArgsDict',
    'AnalysisSourceEntitySourceTemplateDataSetReferenceArgs',
    'AnalysisSourceEntitySourceTemplateDataSetReferenceArgsDict',
    'DashboardDashboardPublishOptionsArgs',
    'DashboardDashboardPublishOptionsArgsDict',
    'DashboardDashboardPublishOptionsAdHocFilteringOptionArgs',
    'DashboardDashboardPublishOptionsAdHocFilteringOptionArgsDict',
    'DashboardDashboardPublishOptionsDataPointDrillUpDownOptionArgs',
    'DashboardDashboardPublishOptionsDataPointDrillUpDownOptionArgsDict',
    'DashboardDashboardPublishOptionsDataPointMenuLabelOptionArgs',
    'DashboardDashboardPublishOptionsDataPointMenuLabelOptionArgsDict',
    'DashboardDashboardPublishOptionsDataPointTooltipOptionArgs',
    'DashboardDashboardPublishOptionsDataPointTooltipOptionArgsDict',
    'DashboardDashboardPublishOptionsExportToCsvOptionArgs',
    'DashboardDashboardPublishOptionsExportToCsvOptionArgsDict',
    'DashboardDashboardPublishOptionsExportWithHiddenFieldsOptionArgs',
    'DashboardDashboardPublishOptionsExportWithHiddenFieldsOptionArgsDict',
    'DashboardDashboardPublishOptionsSheetControlsOptionArgs',
    'DashboardDashboardPublishOptionsSheetControlsOptionArgsDict',
    'DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOptionArgs',
    'DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOptionArgsDict',
    'DashboardDashboardPublishOptionsVisualAxisSortOptionArgs',
    'DashboardDashboardPublishOptionsVisualAxisSortOptionArgsDict',
    'DashboardDashboardPublishOptionsVisualMenuOptionArgs',
    'DashboardDashboardPublishOptionsVisualMenuOptionArgsDict',
    'DashboardParametersArgs',
    'DashboardParametersArgsDict',
    'DashboardParametersDateTimeParameterArgs',
    'DashboardParametersDateTimeParameterArgsDict',
    'DashboardParametersDecimalParameterArgs',
    'DashboardParametersDecimalParameterArgsDict',
    'DashboardParametersIntegerParameterArgs',
    'DashboardParametersIntegerParameterArgsDict',
    'DashboardParametersStringParameterArgs',
    'DashboardParametersStringParameterArgsDict',
    'DashboardPermissionArgs',
    'DashboardPermissionArgsDict',
    'DashboardSourceEntityArgs',
    'DashboardSourceEntityArgsDict',
    'DashboardSourceEntitySourceTemplateArgs',
    'DashboardSourceEntitySourceTemplateArgsDict',
    'DashboardSourceEntitySourceTemplateDataSetReferenceArgs',
    'DashboardSourceEntitySourceTemplateDataSetReferenceArgsDict',
    'DataSetColumnGroupArgs',
    'DataSetColumnGroupArgsDict',
    'DataSetColumnGroupGeoSpatialColumnGroupArgs',
    'DataSetColumnGroupGeoSpatialColumnGroupArgsDict',
    'DataSetColumnLevelPermissionRuleArgs',
    'DataSetColumnLevelPermissionRuleArgsDict',
    'DataSetDataSetUsageConfigurationArgs',
    'DataSetDataSetUsageConfigurationArgsDict',
    'DataSetFieldFolderArgs',
    'DataSetFieldFolderArgsDict',
    'DataSetLogicalTableMapArgs',
    'DataSetLogicalTableMapArgsDict',
    'DataSetLogicalTableMapDataTransformArgs',
    'DataSetLogicalTableMapDataTransformArgsDict',
    'DataSetLogicalTableMapDataTransformCastColumnTypeOperationArgs',
    'DataSetLogicalTableMapDataTransformCastColumnTypeOperationArgsDict',
    'DataSetLogicalTableMapDataTransformCreateColumnsOperationArgs',
    'DataSetLogicalTableMapDataTransformCreateColumnsOperationArgsDict',
    'DataSetLogicalTableMapDataTransformCreateColumnsOperationColumnArgs',
    'DataSetLogicalTableMapDataTransformCreateColumnsOperationColumnArgsDict',
    'DataSetLogicalTableMapDataTransformFilterOperationArgs',
    'DataSetLogicalTableMapDataTransformFilterOperationArgsDict',
    'DataSetLogicalTableMapDataTransformProjectOperationArgs',
    'DataSetLogicalTableMapDataTransformProjectOperationArgsDict',
    'DataSetLogicalTableMapDataTransformRenameColumnOperationArgs',
    'DataSetLogicalTableMapDataTransformRenameColumnOperationArgsDict',
    'DataSetLogicalTableMapDataTransformTagColumnOperationArgs',
    'DataSetLogicalTableMapDataTransformTagColumnOperationArgsDict',
    'DataSetLogicalTableMapDataTransformTagColumnOperationTagArgs',
    'DataSetLogicalTableMapDataTransformTagColumnOperationTagArgsDict',
    'DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionArgs',
    'DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionArgsDict',
    'DataSetLogicalTableMapDataTransformUntagColumnOperationArgs',
    'DataSetLogicalTableMapDataTransformUntagColumnOperationArgsDict',
    'DataSetLogicalTableMapSourceArgs',
    'DataSetLogicalTableMapSourceArgsDict',
    'DataSetLogicalTableMapSourceJoinInstructionArgs',
    'DataSetLogicalTableMapSourceJoinInstructionArgsDict',
    'DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertiesArgs',
    'DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertiesArgsDict',
    'DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertiesArgs',
    'DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertiesArgsDict',
    'DataSetOutputColumnArgs',
    'DataSetOutputColumnArgsDict',
    'DataSetPermissionArgs',
    'DataSetPermissionArgsDict',
    'DataSetPhysicalTableMapArgs',
    'DataSetPhysicalTableMapArgsDict',
    'DataSetPhysicalTableMapCustomSqlArgs',
    'DataSetPhysicalTableMapCustomSqlArgsDict',
    'DataSetPhysicalTableMapCustomSqlColumnArgs',
    'DataSetPhysicalTableMapCustomSqlColumnArgsDict',
    'DataSetPhysicalTableMapRelationalTableArgs',
    'DataSetPhysicalTableMapRelationalTableArgsDict',
    'DataSetPhysicalTableMapRelationalTableInputColumnArgs',
    'DataSetPhysicalTableMapRelationalTableInputColumnArgsDict',
    'DataSetPhysicalTableMapS3SourceArgs',
    'DataSetPhysicalTableMapS3SourceArgsDict',
    'DataSetPhysicalTableMapS3SourceInputColumnArgs',
    'DataSetPhysicalTableMapS3SourceInputColumnArgsDict',
    'DataSetPhysicalTableMapS3SourceUploadSettingsArgs',
    'DataSetPhysicalTableMapS3SourceUploadSettingsArgsDict',
    'DataSetRefreshPropertiesArgs',
    'DataSetRefreshPropertiesArgsDict',
    'DataSetRefreshPropertiesRefreshConfigurationArgs',
    'DataSetRefreshPropertiesRefreshConfigurationArgsDict',
    'DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshArgs',
    'DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshArgsDict',
    'DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindowArgs',
    'DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindowArgsDict',
    'DataSetRowLevelPermissionDataSetArgs',
    'DataSetRowLevelPermissionDataSetArgsDict',
    'DataSetRowLevelPermissionTagConfigurationArgs',
    'DataSetRowLevelPermissionTagConfigurationArgsDict',
    'DataSetRowLevelPermissionTagConfigurationTagRuleArgs',
    'DataSetRowLevelPermissionTagConfigurationTagRuleArgsDict',
    'DataSourceCredentialsArgs',
    'DataSourceCredentialsArgsDict',
    'DataSourceCredentialsCredentialPairArgs',
    'DataSourceCredentialsCredentialPairArgsDict',
    'DataSourceParametersArgs',
    'DataSourceParametersArgsDict',
    'DataSourceParametersAmazonElasticsearchArgs',
    'DataSourceParametersAmazonElasticsearchArgsDict',
    'DataSourceParametersAthenaArgs',
    'DataSourceParametersAthenaArgsDict',
    'DataSourceParametersAuroraArgs',
    'DataSourceParametersAuroraArgsDict',
    'DataSourceParametersAuroraPostgresqlArgs',
    'DataSourceParametersAuroraPostgresqlArgsDict',
    'DataSourceParametersAwsIotAnalyticsArgs',
    'DataSourceParametersAwsIotAnalyticsArgsDict',
    'DataSourceParametersDatabricksArgs',
    'DataSourceParametersDatabricksArgsDict',
    'DataSourceParametersJiraArgs',
    'DataSourceParametersJiraArgsDict',
    'DataSourceParametersMariaDbArgs',
    'DataSourceParametersMariaDbArgsDict',
    'DataSourceParametersMysqlArgs',
    'DataSourceParametersMysqlArgsDict',
    'DataSourceParametersOracleArgs',
    'DataSourceParametersOracleArgsDict',
    'DataSourceParametersPostgresqlArgs',
    'DataSourceParametersPostgresqlArgsDict',
    'DataSourceParametersPrestoArgs',
    'DataSourceParametersPrestoArgsDict',
    'DataSourceParametersRdsArgs',
    'DataSourceParametersRdsArgsDict',
    'DataSourceParametersRedshiftArgs',
    'DataSourceParametersRedshiftArgsDict',
    'DataSourceParametersS3Args',
    'DataSourceParametersS3ArgsDict',
    'DataSourceParametersS3ManifestFileLocationArgs',
    'DataSourceParametersS3ManifestFileLocationArgsDict',
    'DataSourceParametersServiceNowArgs',
    'DataSourceParametersServiceNowArgsDict',
    'DataSourceParametersSnowflakeArgs',
    'DataSourceParametersSnowflakeArgsDict',
    'DataSourceParametersSparkArgs',
    'DataSourceParametersSparkArgsDict',
    'DataSourceParametersSqlServerArgs',
    'DataSourceParametersSqlServerArgsDict',
    'DataSourceParametersTeradataArgs',
    'DataSourceParametersTeradataArgsDict',
    'DataSourceParametersTwitterArgs',
    'DataSourceParametersTwitterArgsDict',
    'DataSourcePermissionArgs',
    'DataSourcePermissionArgsDict',
    'DataSourceSslPropertiesArgs',
    'DataSourceSslPropertiesArgsDict',
    'DataSourceVpcConnectionPropertiesArgs',
    'DataSourceVpcConnectionPropertiesArgsDict',
    'FolderPermissionArgs',
    'FolderPermissionArgsDict',
    'IamPolicyAssignmentIdentitiesArgs',
    'IamPolicyAssignmentIdentitiesArgsDict',
    'NamespaceTimeoutsArgs',
    'NamespaceTimeoutsArgsDict',
    'RefreshScheduleScheduleArgs',
    'RefreshScheduleScheduleArgsDict',
    'RefreshScheduleScheduleScheduleFrequencyArgs',
    'RefreshScheduleScheduleScheduleFrequencyArgsDict',
    'RefreshScheduleScheduleScheduleFrequencyRefreshOnDayArgs',
    'RefreshScheduleScheduleScheduleFrequencyRefreshOnDayArgsDict',
    'TemplatePermissionArgs',
    'TemplatePermissionArgsDict',
    'TemplateSourceEntityArgs',
    'TemplateSourceEntityArgsDict',
    'TemplateSourceEntitySourceAnalysisArgs',
    'TemplateSourceEntitySourceAnalysisArgsDict',
    'TemplateSourceEntitySourceAnalysisDataSetReferenceArgs',
    'TemplateSourceEntitySourceAnalysisDataSetReferenceArgsDict',
    'TemplateSourceEntitySourceTemplateArgs',
    'TemplateSourceEntitySourceTemplateArgsDict',
    'ThemeConfigurationArgs',
    'ThemeConfigurationArgsDict',
    'ThemeConfigurationDataColorPaletteArgs',
    'ThemeConfigurationDataColorPaletteArgsDict',
    'ThemeConfigurationSheetArgs',
    'ThemeConfigurationSheetArgsDict',
    'ThemeConfigurationSheetTileArgs',
    'ThemeConfigurationSheetTileArgsDict',
    'ThemeConfigurationSheetTileBorderArgs',
    'ThemeConfigurationSheetTileBorderArgsDict',
    'ThemeConfigurationSheetTileLayoutArgs',
    'ThemeConfigurationSheetTileLayoutArgsDict',
    'ThemeConfigurationSheetTileLayoutGutterArgs',
    'ThemeConfigurationSheetTileLayoutGutterArgsDict',
    'ThemeConfigurationSheetTileLayoutMarginArgs',
    'ThemeConfigurationSheetTileLayoutMarginArgsDict',
    'ThemeConfigurationTypographyArgs',
    'ThemeConfigurationTypographyArgsDict',
    'ThemeConfigurationTypographyFontFamilyArgs',
    'ThemeConfigurationTypographyFontFamilyArgsDict',
    'ThemeConfigurationUiColorPaletteArgs',
    'ThemeConfigurationUiColorPaletteArgsDict',
    'ThemePermissionArgs',
    'ThemePermissionArgsDict',
    'VpcConnectionTimeoutsArgs',
    'VpcConnectionTimeoutsArgsDict',
]

MYPY = False

if not MYPY:
    class AnalysisParametersArgsDict(TypedDict):
        date_time_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersDateTimeParameterArgsDict']]]]
        """
        A list of parameters that have a data type of date-time. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DateTimeParameter.html).
        """
        decimal_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersDecimalParameterArgsDict']]]]
        """
        A list of parameters that have a data type of decimal. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DecimalParameter.html).
        """
        integer_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersIntegerParameterArgsDict']]]]
        """
        A list of parameters that have a data type of integer. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_IntegerParameter.html).
        """
        string_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersStringParameterArgsDict']]]]
        """
        A list of parameters that have a data type of string. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_StringParameter.html).
        """
elif False:
    AnalysisParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisParametersArgs:
    def __init__(__self__, *,
                 date_time_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersDateTimeParameterArgs']]]] = None,
                 decimal_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersDecimalParameterArgs']]]] = None,
                 integer_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersIntegerParameterArgs']]]] = None,
                 string_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersStringParameterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AnalysisParametersDateTimeParameterArgs']]] date_time_parameters: A list of parameters that have a data type of date-time. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DateTimeParameter.html).
        :param pulumi.Input[Sequence[pulumi.Input['AnalysisParametersDecimalParameterArgs']]] decimal_parameters: A list of parameters that have a data type of decimal. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DecimalParameter.html).
        :param pulumi.Input[Sequence[pulumi.Input['AnalysisParametersIntegerParameterArgs']]] integer_parameters: A list of parameters that have a data type of integer. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_IntegerParameter.html).
        :param pulumi.Input[Sequence[pulumi.Input['AnalysisParametersStringParameterArgs']]] string_parameters: A list of parameters that have a data type of string. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_StringParameter.html).
        """
        if date_time_parameters is not None:
            pulumi.set(__self__, "date_time_parameters", date_time_parameters)
        if decimal_parameters is not None:
            pulumi.set(__self__, "decimal_parameters", decimal_parameters)
        if integer_parameters is not None:
            pulumi.set(__self__, "integer_parameters", integer_parameters)
        if string_parameters is not None:
            pulumi.set(__self__, "string_parameters", string_parameters)

    @property
    @pulumi.getter(name="dateTimeParameters")
    def date_time_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersDateTimeParameterArgs']]]]:
        """
        A list of parameters that have a data type of date-time. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DateTimeParameter.html).
        """
        return pulumi.get(self, "date_time_parameters")

    @date_time_parameters.setter
    def date_time_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersDateTimeParameterArgs']]]]):
        pulumi.set(self, "date_time_parameters", value)

    @property
    @pulumi.getter(name="decimalParameters")
    def decimal_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersDecimalParameterArgs']]]]:
        """
        A list of parameters that have a data type of decimal. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DecimalParameter.html).
        """
        return pulumi.get(self, "decimal_parameters")

    @decimal_parameters.setter
    def decimal_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersDecimalParameterArgs']]]]):
        pulumi.set(self, "decimal_parameters", value)

    @property
    @pulumi.getter(name="integerParameters")
    def integer_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersIntegerParameterArgs']]]]:
        """
        A list of parameters that have a data type of integer. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_IntegerParameter.html).
        """
        return pulumi.get(self, "integer_parameters")

    @integer_parameters.setter
    def integer_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersIntegerParameterArgs']]]]):
        pulumi.set(self, "integer_parameters", value)

    @property
    @pulumi.getter(name="stringParameters")
    def string_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersStringParameterArgs']]]]:
        """
        A list of parameters that have a data type of string. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_StringParameter.html).
        """
        return pulumi.get(self, "string_parameters")

    @string_parameters.setter
    def string_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersStringParameterArgs']]]]):
        pulumi.set(self, "string_parameters", value)


if not MYPY:
    class AnalysisParametersDateTimeParameterArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Display name for the analysis.

        The following arguments are optional:
        """
        values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    AnalysisParametersDateTimeParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisParametersDateTimeParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[builtins.str] name: Display name for the analysis.
               
               The following arguments are optional:
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Display name for the analysis.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnalysisParametersDecimalParameterArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Display name for the analysis.

        The following arguments are optional:
        """
        values: pulumi.Input[Sequence[pulumi.Input[builtins.float]]]
elif False:
    AnalysisParametersDecimalParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisParametersDecimalParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[builtins.float]]]):
        """
        :param pulumi.Input[builtins.str] name: Display name for the analysis.
               
               The following arguments are optional:
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Display name for the analysis.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.float]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.float]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnalysisParametersIntegerParameterArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Display name for the analysis.

        The following arguments are optional:
        """
        values: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]
elif False:
    AnalysisParametersIntegerParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisParametersIntegerParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]):
        """
        :param pulumi.Input[builtins.str] name: Display name for the analysis.
               
               The following arguments are optional:
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Display name for the analysis.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.int]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnalysisParametersStringParameterArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Display name for the analysis.

        The following arguments are optional:
        """
        values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    AnalysisParametersStringParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisParametersStringParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[builtins.str] name: Display name for the analysis.
               
               The following arguments are optional:
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Display name for the analysis.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnalysisPermissionArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        List of IAM actions to grant or revoke permissions on.
        """
        principal: pulumi.Input[builtins.str]
        """
        ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
elif False:
    AnalysisPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisPermissionArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 principal: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: List of IAM actions to grant or revoke permissions on.
        :param pulumi.Input[builtins.str] principal: ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "principal", principal)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        List of IAM actions to grant or revoke permissions on.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def principal(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class AnalysisSourceEntityArgsDict(TypedDict):
        source_template: NotRequired[pulumi.Input['AnalysisSourceEntitySourceTemplateArgsDict']]
        """
        The source template. See source_template.
        """
elif False:
    AnalysisSourceEntityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisSourceEntityArgs:
    def __init__(__self__, *,
                 source_template: Optional[pulumi.Input['AnalysisSourceEntitySourceTemplateArgs']] = None):
        """
        :param pulumi.Input['AnalysisSourceEntitySourceTemplateArgs'] source_template: The source template. See source_template.
        """
        if source_template is not None:
            pulumi.set(__self__, "source_template", source_template)

    @property
    @pulumi.getter(name="sourceTemplate")
    def source_template(self) -> Optional[pulumi.Input['AnalysisSourceEntitySourceTemplateArgs']]:
        """
        The source template. See source_template.
        """
        return pulumi.get(self, "source_template")

    @source_template.setter
    def source_template(self, value: Optional[pulumi.Input['AnalysisSourceEntitySourceTemplateArgs']]):
        pulumi.set(self, "source_template", value)


if not MYPY:
    class AnalysisSourceEntitySourceTemplateArgsDict(TypedDict):
        arn: pulumi.Input[builtins.str]
        """
        The Amazon Resource Name (ARN) of the resource.
        """
        data_set_references: pulumi.Input[Sequence[pulumi.Input['AnalysisSourceEntitySourceTemplateDataSetReferenceArgsDict']]]
        """
        List of dataset references. See data_set_references.
        """
elif False:
    AnalysisSourceEntitySourceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisSourceEntitySourceTemplateArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[builtins.str],
                 data_set_references: pulumi.Input[Sequence[pulumi.Input['AnalysisSourceEntitySourceTemplateDataSetReferenceArgs']]]):
        """
        :param pulumi.Input[builtins.str] arn: The Amazon Resource Name (ARN) of the resource.
        :param pulumi.Input[Sequence[pulumi.Input['AnalysisSourceEntitySourceTemplateDataSetReferenceArgs']]] data_set_references: List of dataset references. See data_set_references.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "data_set_references", data_set_references)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[builtins.str]:
        """
        The Amazon Resource Name (ARN) of the resource.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="dataSetReferences")
    def data_set_references(self) -> pulumi.Input[Sequence[pulumi.Input['AnalysisSourceEntitySourceTemplateDataSetReferenceArgs']]]:
        """
        List of dataset references. See data_set_references.
        """
        return pulumi.get(self, "data_set_references")

    @data_set_references.setter
    def data_set_references(self, value: pulumi.Input[Sequence[pulumi.Input['AnalysisSourceEntitySourceTemplateDataSetReferenceArgs']]]):
        pulumi.set(self, "data_set_references", value)


if not MYPY:
    class AnalysisSourceEntitySourceTemplateDataSetReferenceArgsDict(TypedDict):
        data_set_arn: pulumi.Input[builtins.str]
        """
        Dataset Amazon Resource Name (ARN).
        """
        data_set_placeholder: pulumi.Input[builtins.str]
        """
        Dataset placeholder.
        """
elif False:
    AnalysisSourceEntitySourceTemplateDataSetReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisSourceEntitySourceTemplateDataSetReferenceArgs:
    def __init__(__self__, *,
                 data_set_arn: pulumi.Input[builtins.str],
                 data_set_placeholder: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] data_set_arn: Dataset Amazon Resource Name (ARN).
        :param pulumi.Input[builtins.str] data_set_placeholder: Dataset placeholder.
        """
        pulumi.set(__self__, "data_set_arn", data_set_arn)
        pulumi.set(__self__, "data_set_placeholder", data_set_placeholder)

    @property
    @pulumi.getter(name="dataSetArn")
    def data_set_arn(self) -> pulumi.Input[builtins.str]:
        """
        Dataset Amazon Resource Name (ARN).
        """
        return pulumi.get(self, "data_set_arn")

    @data_set_arn.setter
    def data_set_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data_set_arn", value)

    @property
    @pulumi.getter(name="dataSetPlaceholder")
    def data_set_placeholder(self) -> pulumi.Input[builtins.str]:
        """
        Dataset placeholder.
        """
        return pulumi.get(self, "data_set_placeholder")

    @data_set_placeholder.setter
    def data_set_placeholder(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data_set_placeholder", value)


if not MYPY:
    class DashboardDashboardPublishOptionsArgsDict(TypedDict):
        ad_hoc_filtering_option: NotRequired[pulumi.Input['DashboardDashboardPublishOptionsAdHocFilteringOptionArgsDict']]
        """
        Ad hoc (one-time) filtering option. See ad_hoc_filtering_option.
        """
        data_point_drill_up_down_option: NotRequired[pulumi.Input['DashboardDashboardPublishOptionsDataPointDrillUpDownOptionArgsDict']]
        """
        The drill-down options of data points in a dashboard. See data_point_drill_up_down_option.
        """
        data_point_menu_label_option: NotRequired[pulumi.Input['DashboardDashboardPublishOptionsDataPointMenuLabelOptionArgsDict']]
        """
        The data point menu label options of a dashboard. See data_point_menu_label_option.
        """
        data_point_tooltip_option: NotRequired[pulumi.Input['DashboardDashboardPublishOptionsDataPointTooltipOptionArgsDict']]
        """
        The data point tool tip options of a dashboard. See data_point_tooltip_option.
        """
        export_to_csv_option: NotRequired[pulumi.Input['DashboardDashboardPublishOptionsExportToCsvOptionArgsDict']]
        """
        Export to .csv option. See export_to_csv_option.
        """
        export_with_hidden_fields_option: NotRequired[pulumi.Input['DashboardDashboardPublishOptionsExportWithHiddenFieldsOptionArgsDict']]
        """
        Determines if hidden fields are exported with a dashboard. See export_with_hidden_fields_option.
        """
        sheet_controls_option: NotRequired[pulumi.Input['DashboardDashboardPublishOptionsSheetControlsOptionArgsDict']]
        """
        Sheet controls option. See sheet_controls_option.
        """
        sheet_layout_element_maximization_option: NotRequired[pulumi.Input['DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOptionArgsDict']]
        """
        The sheet layout maximization options of a dashboard. See sheet_layout_element_maximization_option.
        """
        visual_axis_sort_option: NotRequired[pulumi.Input['DashboardDashboardPublishOptionsVisualAxisSortOptionArgsDict']]
        """
        The axis sort options of a dashboard. See visual_axis_sort_option.
        """
        visual_menu_option: NotRequired[pulumi.Input['DashboardDashboardPublishOptionsVisualMenuOptionArgsDict']]
        """
        The menu options of a visual in a dashboard. See visual_menu_option.
        """
elif False:
    DashboardDashboardPublishOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsArgs:
    def __init__(__self__, *,
                 ad_hoc_filtering_option: Optional[pulumi.Input['DashboardDashboardPublishOptionsAdHocFilteringOptionArgs']] = None,
                 data_point_drill_up_down_option: Optional[pulumi.Input['DashboardDashboardPublishOptionsDataPointDrillUpDownOptionArgs']] = None,
                 data_point_menu_label_option: Optional[pulumi.Input['DashboardDashboardPublishOptionsDataPointMenuLabelOptionArgs']] = None,
                 data_point_tooltip_option: Optional[pulumi.Input['DashboardDashboardPublishOptionsDataPointTooltipOptionArgs']] = None,
                 export_to_csv_option: Optional[pulumi.Input['DashboardDashboardPublishOptionsExportToCsvOptionArgs']] = None,
                 export_with_hidden_fields_option: Optional[pulumi.Input['DashboardDashboardPublishOptionsExportWithHiddenFieldsOptionArgs']] = None,
                 sheet_controls_option: Optional[pulumi.Input['DashboardDashboardPublishOptionsSheetControlsOptionArgs']] = None,
                 sheet_layout_element_maximization_option: Optional[pulumi.Input['DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOptionArgs']] = None,
                 visual_axis_sort_option: Optional[pulumi.Input['DashboardDashboardPublishOptionsVisualAxisSortOptionArgs']] = None,
                 visual_menu_option: Optional[pulumi.Input['DashboardDashboardPublishOptionsVisualMenuOptionArgs']] = None):
        """
        :param pulumi.Input['DashboardDashboardPublishOptionsAdHocFilteringOptionArgs'] ad_hoc_filtering_option: Ad hoc (one-time) filtering option. See ad_hoc_filtering_option.
        :param pulumi.Input['DashboardDashboardPublishOptionsDataPointDrillUpDownOptionArgs'] data_point_drill_up_down_option: The drill-down options of data points in a dashboard. See data_point_drill_up_down_option.
        :param pulumi.Input['DashboardDashboardPublishOptionsDataPointMenuLabelOptionArgs'] data_point_menu_label_option: The data point menu label options of a dashboard. See data_point_menu_label_option.
        :param pulumi.Input['DashboardDashboardPublishOptionsDataPointTooltipOptionArgs'] data_point_tooltip_option: The data point tool tip options of a dashboard. See data_point_tooltip_option.
        :param pulumi.Input['DashboardDashboardPublishOptionsExportToCsvOptionArgs'] export_to_csv_option: Export to .csv option. See export_to_csv_option.
        :param pulumi.Input['DashboardDashboardPublishOptionsExportWithHiddenFieldsOptionArgs'] export_with_hidden_fields_option: Determines if hidden fields are exported with a dashboard. See export_with_hidden_fields_option.
        :param pulumi.Input['DashboardDashboardPublishOptionsSheetControlsOptionArgs'] sheet_controls_option: Sheet controls option. See sheet_controls_option.
        :param pulumi.Input['DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOptionArgs'] sheet_layout_element_maximization_option: The sheet layout maximization options of a dashboard. See sheet_layout_element_maximization_option.
        :param pulumi.Input['DashboardDashboardPublishOptionsVisualAxisSortOptionArgs'] visual_axis_sort_option: The axis sort options of a dashboard. See visual_axis_sort_option.
        :param pulumi.Input['DashboardDashboardPublishOptionsVisualMenuOptionArgs'] visual_menu_option: The menu options of a visual in a dashboard. See visual_menu_option.
        """
        if ad_hoc_filtering_option is not None:
            pulumi.set(__self__, "ad_hoc_filtering_option", ad_hoc_filtering_option)
        if data_point_drill_up_down_option is not None:
            pulumi.set(__self__, "data_point_drill_up_down_option", data_point_drill_up_down_option)
        if data_point_menu_label_option is not None:
            pulumi.set(__self__, "data_point_menu_label_option", data_point_menu_label_option)
        if data_point_tooltip_option is not None:
            pulumi.set(__self__, "data_point_tooltip_option", data_point_tooltip_option)
        if export_to_csv_option is not None:
            pulumi.set(__self__, "export_to_csv_option", export_to_csv_option)
        if export_with_hidden_fields_option is not None:
            pulumi.set(__self__, "export_with_hidden_fields_option", export_with_hidden_fields_option)
        if sheet_controls_option is not None:
            pulumi.set(__self__, "sheet_controls_option", sheet_controls_option)
        if sheet_layout_element_maximization_option is not None:
            pulumi.set(__self__, "sheet_layout_element_maximization_option", sheet_layout_element_maximization_option)
        if visual_axis_sort_option is not None:
            pulumi.set(__self__, "visual_axis_sort_option", visual_axis_sort_option)
        if visual_menu_option is not None:
            pulumi.set(__self__, "visual_menu_option", visual_menu_option)

    @property
    @pulumi.getter(name="adHocFilteringOption")
    def ad_hoc_filtering_option(self) -> Optional[pulumi.Input['DashboardDashboardPublishOptionsAdHocFilteringOptionArgs']]:
        """
        Ad hoc (one-time) filtering option. See ad_hoc_filtering_option.
        """
        return pulumi.get(self, "ad_hoc_filtering_option")

    @ad_hoc_filtering_option.setter
    def ad_hoc_filtering_option(self, value: Optional[pulumi.Input['DashboardDashboardPublishOptionsAdHocFilteringOptionArgs']]):
        pulumi.set(self, "ad_hoc_filtering_option", value)

    @property
    @pulumi.getter(name="dataPointDrillUpDownOption")
    def data_point_drill_up_down_option(self) -> Optional[pulumi.Input['DashboardDashboardPublishOptionsDataPointDrillUpDownOptionArgs']]:
        """
        The drill-down options of data points in a dashboard. See data_point_drill_up_down_option.
        """
        return pulumi.get(self, "data_point_drill_up_down_option")

    @data_point_drill_up_down_option.setter
    def data_point_drill_up_down_option(self, value: Optional[pulumi.Input['DashboardDashboardPublishOptionsDataPointDrillUpDownOptionArgs']]):
        pulumi.set(self, "data_point_drill_up_down_option", value)

    @property
    @pulumi.getter(name="dataPointMenuLabelOption")
    def data_point_menu_label_option(self) -> Optional[pulumi.Input['DashboardDashboardPublishOptionsDataPointMenuLabelOptionArgs']]:
        """
        The data point menu label options of a dashboard. See data_point_menu_label_option.
        """
        return pulumi.get(self, "data_point_menu_label_option")

    @data_point_menu_label_option.setter
    def data_point_menu_label_option(self, value: Optional[pulumi.Input['DashboardDashboardPublishOptionsDataPointMenuLabelOptionArgs']]):
        pulumi.set(self, "data_point_menu_label_option", value)

    @property
    @pulumi.getter(name="dataPointTooltipOption")
    def data_point_tooltip_option(self) -> Optional[pulumi.Input['DashboardDashboardPublishOptionsDataPointTooltipOptionArgs']]:
        """
        The data point tool tip options of a dashboard. See data_point_tooltip_option.
        """
        return pulumi.get(self, "data_point_tooltip_option")

    @data_point_tooltip_option.setter
    def data_point_tooltip_option(self, value: Optional[pulumi.Input['DashboardDashboardPublishOptionsDataPointTooltipOptionArgs']]):
        pulumi.set(self, "data_point_tooltip_option", value)

    @property
    @pulumi.getter(name="exportToCsvOption")
    def export_to_csv_option(self) -> Optional[pulumi.Input['DashboardDashboardPublishOptionsExportToCsvOptionArgs']]:
        """
        Export to .csv option. See export_to_csv_option.
        """
        return pulumi.get(self, "export_to_csv_option")

    @export_to_csv_option.setter
    def export_to_csv_option(self, value: Optional[pulumi.Input['DashboardDashboardPublishOptionsExportToCsvOptionArgs']]):
        pulumi.set(self, "export_to_csv_option", value)

    @property
    @pulumi.getter(name="exportWithHiddenFieldsOption")
    def export_with_hidden_fields_option(self) -> Optional[pulumi.Input['DashboardDashboardPublishOptionsExportWithHiddenFieldsOptionArgs']]:
        """
        Determines if hidden fields are exported with a dashboard. See export_with_hidden_fields_option.
        """
        return pulumi.get(self, "export_with_hidden_fields_option")

    @export_with_hidden_fields_option.setter
    def export_with_hidden_fields_option(self, value: Optional[pulumi.Input['DashboardDashboardPublishOptionsExportWithHiddenFieldsOptionArgs']]):
        pulumi.set(self, "export_with_hidden_fields_option", value)

    @property
    @pulumi.getter(name="sheetControlsOption")
    def sheet_controls_option(self) -> Optional[pulumi.Input['DashboardDashboardPublishOptionsSheetControlsOptionArgs']]:
        """
        Sheet controls option. See sheet_controls_option.
        """
        return pulumi.get(self, "sheet_controls_option")

    @sheet_controls_option.setter
    def sheet_controls_option(self, value: Optional[pulumi.Input['DashboardDashboardPublishOptionsSheetControlsOptionArgs']]):
        pulumi.set(self, "sheet_controls_option", value)

    @property
    @pulumi.getter(name="sheetLayoutElementMaximizationOption")
    def sheet_layout_element_maximization_option(self) -> Optional[pulumi.Input['DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOptionArgs']]:
        """
        The sheet layout maximization options of a dashboard. See sheet_layout_element_maximization_option.
        """
        return pulumi.get(self, "sheet_layout_element_maximization_option")

    @sheet_layout_element_maximization_option.setter
    def sheet_layout_element_maximization_option(self, value: Optional[pulumi.Input['DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOptionArgs']]):
        pulumi.set(self, "sheet_layout_element_maximization_option", value)

    @property
    @pulumi.getter(name="visualAxisSortOption")
    def visual_axis_sort_option(self) -> Optional[pulumi.Input['DashboardDashboardPublishOptionsVisualAxisSortOptionArgs']]:
        """
        The axis sort options of a dashboard. See visual_axis_sort_option.
        """
        return pulumi.get(self, "visual_axis_sort_option")

    @visual_axis_sort_option.setter
    def visual_axis_sort_option(self, value: Optional[pulumi.Input['DashboardDashboardPublishOptionsVisualAxisSortOptionArgs']]):
        pulumi.set(self, "visual_axis_sort_option", value)

    @property
    @pulumi.getter(name="visualMenuOption")
    def visual_menu_option(self) -> Optional[pulumi.Input['DashboardDashboardPublishOptionsVisualMenuOptionArgs']]:
        """
        The menu options of a visual in a dashboard. See visual_menu_option.
        """
        return pulumi.get(self, "visual_menu_option")

    @visual_menu_option.setter
    def visual_menu_option(self, value: Optional[pulumi.Input['DashboardDashboardPublishOptionsVisualMenuOptionArgs']]):
        pulumi.set(self, "visual_menu_option", value)


if not MYPY:
    class DashboardDashboardPublishOptionsAdHocFilteringOptionArgsDict(TypedDict):
        availability_status: NotRequired[pulumi.Input[builtins.str]]
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
elif False:
    DashboardDashboardPublishOptionsAdHocFilteringOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsAdHocFilteringOptionArgs:
    def __init__(__self__, *,
                 availability_status: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] availability_status: Availability status. Possibles values: ENABLED, DISABLED.
        """
        if availability_status is not None:
            pulumi.set(__self__, "availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
        return pulumi.get(self, "availability_status")

    @availability_status.setter
    def availability_status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "availability_status", value)


if not MYPY:
    class DashboardDashboardPublishOptionsDataPointDrillUpDownOptionArgsDict(TypedDict):
        availability_status: NotRequired[pulumi.Input[builtins.str]]
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
elif False:
    DashboardDashboardPublishOptionsDataPointDrillUpDownOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsDataPointDrillUpDownOptionArgs:
    def __init__(__self__, *,
                 availability_status: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] availability_status: Availability status. Possibles values: ENABLED, DISABLED.
        """
        if availability_status is not None:
            pulumi.set(__self__, "availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
        return pulumi.get(self, "availability_status")

    @availability_status.setter
    def availability_status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "availability_status", value)


if not MYPY:
    class DashboardDashboardPublishOptionsDataPointMenuLabelOptionArgsDict(TypedDict):
        availability_status: NotRequired[pulumi.Input[builtins.str]]
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
elif False:
    DashboardDashboardPublishOptionsDataPointMenuLabelOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsDataPointMenuLabelOptionArgs:
    def __init__(__self__, *,
                 availability_status: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] availability_status: Availability status. Possibles values: ENABLED, DISABLED.
        """
        if availability_status is not None:
            pulumi.set(__self__, "availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
        return pulumi.get(self, "availability_status")

    @availability_status.setter
    def availability_status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "availability_status", value)


if not MYPY:
    class DashboardDashboardPublishOptionsDataPointTooltipOptionArgsDict(TypedDict):
        availability_status: NotRequired[pulumi.Input[builtins.str]]
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
elif False:
    DashboardDashboardPublishOptionsDataPointTooltipOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsDataPointTooltipOptionArgs:
    def __init__(__self__, *,
                 availability_status: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] availability_status: Availability status. Possibles values: ENABLED, DISABLED.
        """
        if availability_status is not None:
            pulumi.set(__self__, "availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
        return pulumi.get(self, "availability_status")

    @availability_status.setter
    def availability_status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "availability_status", value)


if not MYPY:
    class DashboardDashboardPublishOptionsExportToCsvOptionArgsDict(TypedDict):
        availability_status: NotRequired[pulumi.Input[builtins.str]]
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
elif False:
    DashboardDashboardPublishOptionsExportToCsvOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsExportToCsvOptionArgs:
    def __init__(__self__, *,
                 availability_status: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] availability_status: Availability status. Possibles values: ENABLED, DISABLED.
        """
        if availability_status is not None:
            pulumi.set(__self__, "availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
        return pulumi.get(self, "availability_status")

    @availability_status.setter
    def availability_status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "availability_status", value)


if not MYPY:
    class DashboardDashboardPublishOptionsExportWithHiddenFieldsOptionArgsDict(TypedDict):
        availability_status: NotRequired[pulumi.Input[builtins.str]]
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
elif False:
    DashboardDashboardPublishOptionsExportWithHiddenFieldsOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsExportWithHiddenFieldsOptionArgs:
    def __init__(__self__, *,
                 availability_status: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] availability_status: Availability status. Possibles values: ENABLED, DISABLED.
        """
        if availability_status is not None:
            pulumi.set(__self__, "availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
        return pulumi.get(self, "availability_status")

    @availability_status.setter
    def availability_status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "availability_status", value)


if not MYPY:
    class DashboardDashboardPublishOptionsSheetControlsOptionArgsDict(TypedDict):
        visibility_state: NotRequired[pulumi.Input[builtins.str]]
        """
        Visibility state. Possibles values: EXPANDED, COLLAPSED.
        """
elif False:
    DashboardDashboardPublishOptionsSheetControlsOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsSheetControlsOptionArgs:
    def __init__(__self__, *,
                 visibility_state: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] visibility_state: Visibility state. Possibles values: EXPANDED, COLLAPSED.
        """
        if visibility_state is not None:
            pulumi.set(__self__, "visibility_state", visibility_state)

    @property
    @pulumi.getter(name="visibilityState")
    def visibility_state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Visibility state. Possibles values: EXPANDED, COLLAPSED.
        """
        return pulumi.get(self, "visibility_state")

    @visibility_state.setter
    def visibility_state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "visibility_state", value)


if not MYPY:
    class DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOptionArgsDict(TypedDict):
        availability_status: NotRequired[pulumi.Input[builtins.str]]
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
elif False:
    DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOptionArgs:
    def __init__(__self__, *,
                 availability_status: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] availability_status: Availability status. Possibles values: ENABLED, DISABLED.
        """
        if availability_status is not None:
            pulumi.set(__self__, "availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
        return pulumi.get(self, "availability_status")

    @availability_status.setter
    def availability_status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "availability_status", value)


if not MYPY:
    class DashboardDashboardPublishOptionsVisualAxisSortOptionArgsDict(TypedDict):
        availability_status: NotRequired[pulumi.Input[builtins.str]]
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
elif False:
    DashboardDashboardPublishOptionsVisualAxisSortOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsVisualAxisSortOptionArgs:
    def __init__(__self__, *,
                 availability_status: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] availability_status: Availability status. Possibles values: ENABLED, DISABLED.
        """
        if availability_status is not None:
            pulumi.set(__self__, "availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
        return pulumi.get(self, "availability_status")

    @availability_status.setter
    def availability_status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "availability_status", value)


if not MYPY:
    class DashboardDashboardPublishOptionsVisualMenuOptionArgsDict(TypedDict):
        availability_status: NotRequired[pulumi.Input[builtins.str]]
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
elif False:
    DashboardDashboardPublishOptionsVisualMenuOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsVisualMenuOptionArgs:
    def __init__(__self__, *,
                 availability_status: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] availability_status: Availability status. Possibles values: ENABLED, DISABLED.
        """
        if availability_status is not None:
            pulumi.set(__self__, "availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
        return pulumi.get(self, "availability_status")

    @availability_status.setter
    def availability_status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "availability_status", value)


if not MYPY:
    class DashboardParametersArgsDict(TypedDict):
        date_time_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['DashboardParametersDateTimeParameterArgsDict']]]]
        """
        A list of parameters that have a data type of date-time. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DateTimeParameter.html).
        """
        decimal_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['DashboardParametersDecimalParameterArgsDict']]]]
        """
        A list of parameters that have a data type of decimal. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DecimalParameter.html).
        """
        integer_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['DashboardParametersIntegerParameterArgsDict']]]]
        """
        A list of parameters that have a data type of integer. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_IntegerParameter.html).
        """
        string_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['DashboardParametersStringParameterArgsDict']]]]
        """
        A list of parameters that have a data type of string. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_StringParameter.html).
        """
elif False:
    DashboardParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardParametersArgs:
    def __init__(__self__, *,
                 date_time_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersDateTimeParameterArgs']]]] = None,
                 decimal_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersDecimalParameterArgs']]]] = None,
                 integer_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersIntegerParameterArgs']]]] = None,
                 string_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersStringParameterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardParametersDateTimeParameterArgs']]] date_time_parameters: A list of parameters that have a data type of date-time. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DateTimeParameter.html).
        :param pulumi.Input[Sequence[pulumi.Input['DashboardParametersDecimalParameterArgs']]] decimal_parameters: A list of parameters that have a data type of decimal. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DecimalParameter.html).
        :param pulumi.Input[Sequence[pulumi.Input['DashboardParametersIntegerParameterArgs']]] integer_parameters: A list of parameters that have a data type of integer. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_IntegerParameter.html).
        :param pulumi.Input[Sequence[pulumi.Input['DashboardParametersStringParameterArgs']]] string_parameters: A list of parameters that have a data type of string. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_StringParameter.html).
        """
        if date_time_parameters is not None:
            pulumi.set(__self__, "date_time_parameters", date_time_parameters)
        if decimal_parameters is not None:
            pulumi.set(__self__, "decimal_parameters", decimal_parameters)
        if integer_parameters is not None:
            pulumi.set(__self__, "integer_parameters", integer_parameters)
        if string_parameters is not None:
            pulumi.set(__self__, "string_parameters", string_parameters)

    @property
    @pulumi.getter(name="dateTimeParameters")
    def date_time_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersDateTimeParameterArgs']]]]:
        """
        A list of parameters that have a data type of date-time. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DateTimeParameter.html).
        """
        return pulumi.get(self, "date_time_parameters")

    @date_time_parameters.setter
    def date_time_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersDateTimeParameterArgs']]]]):
        pulumi.set(self, "date_time_parameters", value)

    @property
    @pulumi.getter(name="decimalParameters")
    def decimal_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersDecimalParameterArgs']]]]:
        """
        A list of parameters that have a data type of decimal. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DecimalParameter.html).
        """
        return pulumi.get(self, "decimal_parameters")

    @decimal_parameters.setter
    def decimal_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersDecimalParameterArgs']]]]):
        pulumi.set(self, "decimal_parameters", value)

    @property
    @pulumi.getter(name="integerParameters")
    def integer_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersIntegerParameterArgs']]]]:
        """
        A list of parameters that have a data type of integer. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_IntegerParameter.html).
        """
        return pulumi.get(self, "integer_parameters")

    @integer_parameters.setter
    def integer_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersIntegerParameterArgs']]]]):
        pulumi.set(self, "integer_parameters", value)

    @property
    @pulumi.getter(name="stringParameters")
    def string_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersStringParameterArgs']]]]:
        """
        A list of parameters that have a data type of string. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_StringParameter.html).
        """
        return pulumi.get(self, "string_parameters")

    @string_parameters.setter
    def string_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersStringParameterArgs']]]]):
        pulumi.set(self, "string_parameters", value)


if not MYPY:
    class DashboardParametersDateTimeParameterArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Display name for the dashboard.
        """
        values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    DashboardParametersDateTimeParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardParametersDateTimeParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[builtins.str] name: Display name for the dashboard.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Display name for the dashboard.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DashboardParametersDecimalParameterArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Display name for the dashboard.
        """
        values: pulumi.Input[Sequence[pulumi.Input[builtins.float]]]
elif False:
    DashboardParametersDecimalParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardParametersDecimalParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[builtins.float]]]):
        """
        :param pulumi.Input[builtins.str] name: Display name for the dashboard.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Display name for the dashboard.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.float]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.float]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DashboardParametersIntegerParameterArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Display name for the dashboard.
        """
        values: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]
elif False:
    DashboardParametersIntegerParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardParametersIntegerParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]):
        """
        :param pulumi.Input[builtins.str] name: Display name for the dashboard.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Display name for the dashboard.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.int]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DashboardParametersStringParameterArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Display name for the dashboard.
        """
        values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    DashboardParametersStringParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardParametersStringParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[builtins.str] name: Display name for the dashboard.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Display name for the dashboard.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DashboardPermissionArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        List of IAM actions to grant or revoke permissions on.
        """
        principal: pulumi.Input[builtins.str]
        """
        ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
elif False:
    DashboardPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPermissionArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 principal: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: List of IAM actions to grant or revoke permissions on.
        :param pulumi.Input[builtins.str] principal: ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "principal", principal)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        List of IAM actions to grant or revoke permissions on.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def principal(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class DashboardSourceEntityArgsDict(TypedDict):
        source_template: NotRequired[pulumi.Input['DashboardSourceEntitySourceTemplateArgsDict']]
        """
        The source template. See source_template.
        """
elif False:
    DashboardSourceEntityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardSourceEntityArgs:
    def __init__(__self__, *,
                 source_template: Optional[pulumi.Input['DashboardSourceEntitySourceTemplateArgs']] = None):
        """
        :param pulumi.Input['DashboardSourceEntitySourceTemplateArgs'] source_template: The source template. See source_template.
        """
        if source_template is not None:
            pulumi.set(__self__, "source_template", source_template)

    @property
    @pulumi.getter(name="sourceTemplate")
    def source_template(self) -> Optional[pulumi.Input['DashboardSourceEntitySourceTemplateArgs']]:
        """
        The source template. See source_template.
        """
        return pulumi.get(self, "source_template")

    @source_template.setter
    def source_template(self, value: Optional[pulumi.Input['DashboardSourceEntitySourceTemplateArgs']]):
        pulumi.set(self, "source_template", value)


if not MYPY:
    class DashboardSourceEntitySourceTemplateArgsDict(TypedDict):
        arn: pulumi.Input[builtins.str]
        """
        The Amazon Resource Name (ARN) of the resource.
        """
        data_set_references: pulumi.Input[Sequence[pulumi.Input['DashboardSourceEntitySourceTemplateDataSetReferenceArgsDict']]]
        """
        List of dataset references. See data_set_references.
        """
elif False:
    DashboardSourceEntitySourceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardSourceEntitySourceTemplateArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[builtins.str],
                 data_set_references: pulumi.Input[Sequence[pulumi.Input['DashboardSourceEntitySourceTemplateDataSetReferenceArgs']]]):
        """
        :param pulumi.Input[builtins.str] arn: The Amazon Resource Name (ARN) of the resource.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardSourceEntitySourceTemplateDataSetReferenceArgs']]] data_set_references: List of dataset references. See data_set_references.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "data_set_references", data_set_references)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[builtins.str]:
        """
        The Amazon Resource Name (ARN) of the resource.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="dataSetReferences")
    def data_set_references(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardSourceEntitySourceTemplateDataSetReferenceArgs']]]:
        """
        List of dataset references. See data_set_references.
        """
        return pulumi.get(self, "data_set_references")

    @data_set_references.setter
    def data_set_references(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardSourceEntitySourceTemplateDataSetReferenceArgs']]]):
        pulumi.set(self, "data_set_references", value)


if not MYPY:
    class DashboardSourceEntitySourceTemplateDataSetReferenceArgsDict(TypedDict):
        data_set_arn: pulumi.Input[builtins.str]
        """
        Dataset Amazon Resource Name (ARN).
        """
        data_set_placeholder: pulumi.Input[builtins.str]
        """
        Dataset placeholder.
        """
elif False:
    DashboardSourceEntitySourceTemplateDataSetReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardSourceEntitySourceTemplateDataSetReferenceArgs:
    def __init__(__self__, *,
                 data_set_arn: pulumi.Input[builtins.str],
                 data_set_placeholder: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] data_set_arn: Dataset Amazon Resource Name (ARN).
        :param pulumi.Input[builtins.str] data_set_placeholder: Dataset placeholder.
        """
        pulumi.set(__self__, "data_set_arn", data_set_arn)
        pulumi.set(__self__, "data_set_placeholder", data_set_placeholder)

    @property
    @pulumi.getter(name="dataSetArn")
    def data_set_arn(self) -> pulumi.Input[builtins.str]:
        """
        Dataset Amazon Resource Name (ARN).
        """
        return pulumi.get(self, "data_set_arn")

    @data_set_arn.setter
    def data_set_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data_set_arn", value)

    @property
    @pulumi.getter(name="dataSetPlaceholder")
    def data_set_placeholder(self) -> pulumi.Input[builtins.str]:
        """
        Dataset placeholder.
        """
        return pulumi.get(self, "data_set_placeholder")

    @data_set_placeholder.setter
    def data_set_placeholder(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data_set_placeholder", value)


if not MYPY:
    class DataSetColumnGroupArgsDict(TypedDict):
        geo_spatial_column_group: NotRequired[pulumi.Input['DataSetColumnGroupGeoSpatialColumnGroupArgsDict']]
        """
        Geospatial column group that denotes a hierarchy. See geo_spatial_column_group.
        """
elif False:
    DataSetColumnGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetColumnGroupArgs:
    def __init__(__self__, *,
                 geo_spatial_column_group: Optional[pulumi.Input['DataSetColumnGroupGeoSpatialColumnGroupArgs']] = None):
        """
        :param pulumi.Input['DataSetColumnGroupGeoSpatialColumnGroupArgs'] geo_spatial_column_group: Geospatial column group that denotes a hierarchy. See geo_spatial_column_group.
        """
        if geo_spatial_column_group is not None:
            pulumi.set(__self__, "geo_spatial_column_group", geo_spatial_column_group)

    @property
    @pulumi.getter(name="geoSpatialColumnGroup")
    def geo_spatial_column_group(self) -> Optional[pulumi.Input['DataSetColumnGroupGeoSpatialColumnGroupArgs']]:
        """
        Geospatial column group that denotes a hierarchy. See geo_spatial_column_group.
        """
        return pulumi.get(self, "geo_spatial_column_group")

    @geo_spatial_column_group.setter
    def geo_spatial_column_group(self, value: Optional[pulumi.Input['DataSetColumnGroupGeoSpatialColumnGroupArgs']]):
        pulumi.set(self, "geo_spatial_column_group", value)


if not MYPY:
    class DataSetColumnGroupGeoSpatialColumnGroupArgsDict(TypedDict):
        columns: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Columns in this hierarchy.
        """
        country_code: pulumi.Input[builtins.str]
        """
        Country code. Valid values are `US`.
        """
        name: pulumi.Input[builtins.str]
        """
        A display name for the hierarchy.
        """
elif False:
    DataSetColumnGroupGeoSpatialColumnGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetColumnGroupGeoSpatialColumnGroupArgs:
    def __init__(__self__, *,
                 columns: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 country_code: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] columns: Columns in this hierarchy.
        :param pulumi.Input[builtins.str] country_code: Country code. Valid values are `US`.
        :param pulumi.Input[builtins.str] name: A display name for the hierarchy.
        """
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def columns(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Columns in this hierarchy.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[builtins.str]:
        """
        Country code. Valid values are `US`.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "country_code", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A display name for the hierarchy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DataSetColumnLevelPermissionRuleArgsDict(TypedDict):
        column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        An array of column names.
        """
        principals: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        An array of ARNs for Amazon QuickSight users or groups.
        """
elif False:
    DataSetColumnLevelPermissionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetColumnLevelPermissionRuleArgs:
    def __init__(__self__, *,
                 column_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 principals: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] column_names: An array of column names.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] principals: An array of ARNs for Amazon QuickSight users or groups.
        """
        if column_names is not None:
            pulumi.set(__self__, "column_names", column_names)
        if principals is not None:
            pulumi.set(__self__, "principals", principals)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        An array of column names.
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "column_names", value)

    @property
    @pulumi.getter
    def principals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        An array of ARNs for Amazon QuickSight users or groups.
        """
        return pulumi.get(self, "principals")

    @principals.setter
    def principals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "principals", value)


if not MYPY:
    class DataSetDataSetUsageConfigurationArgsDict(TypedDict):
        disable_use_as_direct_query_source: NotRequired[pulumi.Input[builtins.bool]]
        """
        Controls whether a child dataset of a direct query can use this dataset as a source.
        """
        disable_use_as_imported_source: NotRequired[pulumi.Input[builtins.bool]]
        """
        Controls whether a child dataset that's stored in QuickSight can use this dataset as a source.
        """
elif False:
    DataSetDataSetUsageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetDataSetUsageConfigurationArgs:
    def __init__(__self__, *,
                 disable_use_as_direct_query_source: Optional[pulumi.Input[builtins.bool]] = None,
                 disable_use_as_imported_source: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] disable_use_as_direct_query_source: Controls whether a child dataset of a direct query can use this dataset as a source.
        :param pulumi.Input[builtins.bool] disable_use_as_imported_source: Controls whether a child dataset that's stored in QuickSight can use this dataset as a source.
        """
        if disable_use_as_direct_query_source is not None:
            pulumi.set(__self__, "disable_use_as_direct_query_source", disable_use_as_direct_query_source)
        if disable_use_as_imported_source is not None:
            pulumi.set(__self__, "disable_use_as_imported_source", disable_use_as_imported_source)

    @property
    @pulumi.getter(name="disableUseAsDirectQuerySource")
    def disable_use_as_direct_query_source(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Controls whether a child dataset of a direct query can use this dataset as a source.
        """
        return pulumi.get(self, "disable_use_as_direct_query_source")

    @disable_use_as_direct_query_source.setter
    def disable_use_as_direct_query_source(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_use_as_direct_query_source", value)

    @property
    @pulumi.getter(name="disableUseAsImportedSource")
    def disable_use_as_imported_source(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Controls whether a child dataset that's stored in QuickSight can use this dataset as a source.
        """
        return pulumi.get(self, "disable_use_as_imported_source")

    @disable_use_as_imported_source.setter
    def disable_use_as_imported_source(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_use_as_imported_source", value)


if not MYPY:
    class DataSetFieldFolderArgsDict(TypedDict):
        field_folders_id: pulumi.Input[builtins.str]
        """
        Key of the field folder map.
        """
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        An array of column names to add to the folder. A column can only be in one folder.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Field folder description.
        """
elif False:
    DataSetFieldFolderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetFieldFolderArgs:
    def __init__(__self__, *,
                 field_folders_id: pulumi.Input[builtins.str],
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] field_folders_id: Key of the field folder map.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] columns: An array of column names to add to the folder. A column can only be in one folder.
        :param pulumi.Input[builtins.str] description: Field folder description.
        """
        pulumi.set(__self__, "field_folders_id", field_folders_id)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="fieldFoldersId")
    def field_folders_id(self) -> pulumi.Input[builtins.str]:
        """
        Key of the field folder map.
        """
        return pulumi.get(self, "field_folders_id")

    @field_folders_id.setter
    def field_folders_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "field_folders_id", value)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        An array of column names to add to the folder. A column can only be in one folder.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Field folder description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class DataSetLogicalTableMapArgsDict(TypedDict):
        alias: pulumi.Input[builtins.str]
        """
        A display name for the logical table.
        """
        logical_table_map_id: pulumi.Input[builtins.str]
        """
        Key of the logical table map.
        """
        source: pulumi.Input['DataSetLogicalTableMapSourceArgsDict']
        """
        Source of this logical table. See source.
        """
        data_transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformArgsDict']]]]
        """
        Transform operations that act on this logical table. For this structure to be valid, only one of the attributes can be non-null. See data_transforms.
        """
elif False:
    DataSetLogicalTableMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapArgs:
    def __init__(__self__, *,
                 alias: pulumi.Input[builtins.str],
                 logical_table_map_id: pulumi.Input[builtins.str],
                 source: pulumi.Input['DataSetLogicalTableMapSourceArgs'],
                 data_transforms: Optional[pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] alias: A display name for the logical table.
        :param pulumi.Input[builtins.str] logical_table_map_id: Key of the logical table map.
        :param pulumi.Input['DataSetLogicalTableMapSourceArgs'] source: Source of this logical table. See source.
        :param pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformArgs']]] data_transforms: Transform operations that act on this logical table. For this structure to be valid, only one of the attributes can be non-null. See data_transforms.
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "logical_table_map_id", logical_table_map_id)
        pulumi.set(__self__, "source", source)
        if data_transforms is not None:
            pulumi.set(__self__, "data_transforms", data_transforms)

    @property
    @pulumi.getter
    def alias(self) -> pulumi.Input[builtins.str]:
        """
        A display name for the logical table.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="logicalTableMapId")
    def logical_table_map_id(self) -> pulumi.Input[builtins.str]:
        """
        Key of the logical table map.
        """
        return pulumi.get(self, "logical_table_map_id")

    @logical_table_map_id.setter
    def logical_table_map_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "logical_table_map_id", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input['DataSetLogicalTableMapSourceArgs']:
        """
        Source of this logical table. See source.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input['DataSetLogicalTableMapSourceArgs']):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="dataTransforms")
    def data_transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformArgs']]]]:
        """
        Transform operations that act on this logical table. For this structure to be valid, only one of the attributes can be non-null. See data_transforms.
        """
        return pulumi.get(self, "data_transforms")

    @data_transforms.setter
    def data_transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformArgs']]]]):
        pulumi.set(self, "data_transforms", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformArgsDict(TypedDict):
        cast_column_type_operation: NotRequired[pulumi.Input['DataSetLogicalTableMapDataTransformCastColumnTypeOperationArgsDict']]
        """
        A transform operation that casts a column to a different type. See cast_column_type_operation.
        """
        create_columns_operation: NotRequired[pulumi.Input['DataSetLogicalTableMapDataTransformCreateColumnsOperationArgsDict']]
        """
        An operation that creates calculated columns. Columns created in one such operation form a lexical closure. See create_columns_operation.
        """
        filter_operation: NotRequired[pulumi.Input['DataSetLogicalTableMapDataTransformFilterOperationArgsDict']]
        """
        An operation that filters rows based on some condition. See filter_operation.
        """
        project_operation: NotRequired[pulumi.Input['DataSetLogicalTableMapDataTransformProjectOperationArgsDict']]
        """
        An operation that projects columns. Operations that come after a projection can only refer to projected columns. See project_operation.
        """
        rename_column_operation: NotRequired[pulumi.Input['DataSetLogicalTableMapDataTransformRenameColumnOperationArgsDict']]
        """
        An operation that renames a column. See rename_column_operation.
        """
        tag_column_operation: NotRequired[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationArgsDict']]
        """
        An operation that tags a column with additional information. See tag_column_operation.
        """
        untag_column_operation: NotRequired[pulumi.Input['DataSetLogicalTableMapDataTransformUntagColumnOperationArgsDict']]
        """
        A transform operation that removes tags associated with a column. See untag_column_operation.
        """
elif False:
    DataSetLogicalTableMapDataTransformArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformArgs:
    def __init__(__self__, *,
                 cast_column_type_operation: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformCastColumnTypeOperationArgs']] = None,
                 create_columns_operation: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformCreateColumnsOperationArgs']] = None,
                 filter_operation: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformFilterOperationArgs']] = None,
                 project_operation: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformProjectOperationArgs']] = None,
                 rename_column_operation: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformRenameColumnOperationArgs']] = None,
                 tag_column_operation: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationArgs']] = None,
                 untag_column_operation: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformUntagColumnOperationArgs']] = None):
        """
        :param pulumi.Input['DataSetLogicalTableMapDataTransformCastColumnTypeOperationArgs'] cast_column_type_operation: A transform operation that casts a column to a different type. See cast_column_type_operation.
        :param pulumi.Input['DataSetLogicalTableMapDataTransformCreateColumnsOperationArgs'] create_columns_operation: An operation that creates calculated columns. Columns created in one such operation form a lexical closure. See create_columns_operation.
        :param pulumi.Input['DataSetLogicalTableMapDataTransformFilterOperationArgs'] filter_operation: An operation that filters rows based on some condition. See filter_operation.
        :param pulumi.Input['DataSetLogicalTableMapDataTransformProjectOperationArgs'] project_operation: An operation that projects columns. Operations that come after a projection can only refer to projected columns. See project_operation.
        :param pulumi.Input['DataSetLogicalTableMapDataTransformRenameColumnOperationArgs'] rename_column_operation: An operation that renames a column. See rename_column_operation.
        :param pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationArgs'] tag_column_operation: An operation that tags a column with additional information. See tag_column_operation.
        :param pulumi.Input['DataSetLogicalTableMapDataTransformUntagColumnOperationArgs'] untag_column_operation: A transform operation that removes tags associated with a column. See untag_column_operation.
        """
        if cast_column_type_operation is not None:
            pulumi.set(__self__, "cast_column_type_operation", cast_column_type_operation)
        if create_columns_operation is not None:
            pulumi.set(__self__, "create_columns_operation", create_columns_operation)
        if filter_operation is not None:
            pulumi.set(__self__, "filter_operation", filter_operation)
        if project_operation is not None:
            pulumi.set(__self__, "project_operation", project_operation)
        if rename_column_operation is not None:
            pulumi.set(__self__, "rename_column_operation", rename_column_operation)
        if tag_column_operation is not None:
            pulumi.set(__self__, "tag_column_operation", tag_column_operation)
        if untag_column_operation is not None:
            pulumi.set(__self__, "untag_column_operation", untag_column_operation)

    @property
    @pulumi.getter(name="castColumnTypeOperation")
    def cast_column_type_operation(self) -> Optional[pulumi.Input['DataSetLogicalTableMapDataTransformCastColumnTypeOperationArgs']]:
        """
        A transform operation that casts a column to a different type. See cast_column_type_operation.
        """
        return pulumi.get(self, "cast_column_type_operation")

    @cast_column_type_operation.setter
    def cast_column_type_operation(self, value: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformCastColumnTypeOperationArgs']]):
        pulumi.set(self, "cast_column_type_operation", value)

    @property
    @pulumi.getter(name="createColumnsOperation")
    def create_columns_operation(self) -> Optional[pulumi.Input['DataSetLogicalTableMapDataTransformCreateColumnsOperationArgs']]:
        """
        An operation that creates calculated columns. Columns created in one such operation form a lexical closure. See create_columns_operation.
        """
        return pulumi.get(self, "create_columns_operation")

    @create_columns_operation.setter
    def create_columns_operation(self, value: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformCreateColumnsOperationArgs']]):
        pulumi.set(self, "create_columns_operation", value)

    @property
    @pulumi.getter(name="filterOperation")
    def filter_operation(self) -> Optional[pulumi.Input['DataSetLogicalTableMapDataTransformFilterOperationArgs']]:
        """
        An operation that filters rows based on some condition. See filter_operation.
        """
        return pulumi.get(self, "filter_operation")

    @filter_operation.setter
    def filter_operation(self, value: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformFilterOperationArgs']]):
        pulumi.set(self, "filter_operation", value)

    @property
    @pulumi.getter(name="projectOperation")
    def project_operation(self) -> Optional[pulumi.Input['DataSetLogicalTableMapDataTransformProjectOperationArgs']]:
        """
        An operation that projects columns. Operations that come after a projection can only refer to projected columns. See project_operation.
        """
        return pulumi.get(self, "project_operation")

    @project_operation.setter
    def project_operation(self, value: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformProjectOperationArgs']]):
        pulumi.set(self, "project_operation", value)

    @property
    @pulumi.getter(name="renameColumnOperation")
    def rename_column_operation(self) -> Optional[pulumi.Input['DataSetLogicalTableMapDataTransformRenameColumnOperationArgs']]:
        """
        An operation that renames a column. See rename_column_operation.
        """
        return pulumi.get(self, "rename_column_operation")

    @rename_column_operation.setter
    def rename_column_operation(self, value: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformRenameColumnOperationArgs']]):
        pulumi.set(self, "rename_column_operation", value)

    @property
    @pulumi.getter(name="tagColumnOperation")
    def tag_column_operation(self) -> Optional[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationArgs']]:
        """
        An operation that tags a column with additional information. See tag_column_operation.
        """
        return pulumi.get(self, "tag_column_operation")

    @tag_column_operation.setter
    def tag_column_operation(self, value: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationArgs']]):
        pulumi.set(self, "tag_column_operation", value)

    @property
    @pulumi.getter(name="untagColumnOperation")
    def untag_column_operation(self) -> Optional[pulumi.Input['DataSetLogicalTableMapDataTransformUntagColumnOperationArgs']]:
        """
        A transform operation that removes tags associated with a column. See untag_column_operation.
        """
        return pulumi.get(self, "untag_column_operation")

    @untag_column_operation.setter
    def untag_column_operation(self, value: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformUntagColumnOperationArgs']]):
        pulumi.set(self, "untag_column_operation", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformCastColumnTypeOperationArgsDict(TypedDict):
        column_name: pulumi.Input[builtins.str]
        """
        Column name.
        """
        new_column_type: pulumi.Input[builtins.str]
        """
        New column data type. Valid values are `STRING`, `INTEGER`, `DECIMAL`, `DATETIME`.
        """
        format: NotRequired[pulumi.Input[builtins.str]]
        """
        When casting a column from string to datetime type, you can supply a string in a format supported by Amazon QuickSight to denote the source data format.
        """
elif False:
    DataSetLogicalTableMapDataTransformCastColumnTypeOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformCastColumnTypeOperationArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[builtins.str],
                 new_column_type: pulumi.Input[builtins.str],
                 format: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] column_name: Column name.
        :param pulumi.Input[builtins.str] new_column_type: New column data type. Valid values are `STRING`, `INTEGER`, `DECIMAL`, `DATETIME`.
        :param pulumi.Input[builtins.str] format: When casting a column from string to datetime type, you can supply a string in a format supported by Amazon QuickSight to denote the source data format.
        """
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "new_column_type", new_column_type)
        if format is not None:
            pulumi.set(__self__, "format", format)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[builtins.str]:
        """
        Column name.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter(name="newColumnType")
    def new_column_type(self) -> pulumi.Input[builtins.str]:
        """
        New column data type. Valid values are `STRING`, `INTEGER`, `DECIMAL`, `DATETIME`.
        """
        return pulumi.get(self, "new_column_type")

    @new_column_type.setter
    def new_column_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "new_column_type", value)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        When casting a column from string to datetime type, you can supply a string in a format supported by Amazon QuickSight to denote the source data format.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "format", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformCreateColumnsOperationArgsDict(TypedDict):
        columns: pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformCreateColumnsOperationColumnArgsDict']]]
        """
        Calculated columns to create. See columns.
        """
elif False:
    DataSetLogicalTableMapDataTransformCreateColumnsOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformCreateColumnsOperationArgs:
    def __init__(__self__, *,
                 columns: pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformCreateColumnsOperationColumnArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformCreateColumnsOperationColumnArgs']]] columns: Calculated columns to create. See columns.
        """
        pulumi.set(__self__, "columns", columns)

    @property
    @pulumi.getter
    def columns(self) -> pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformCreateColumnsOperationColumnArgs']]]:
        """
        Calculated columns to create. See columns.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformCreateColumnsOperationColumnArgs']]]):
        pulumi.set(self, "columns", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformCreateColumnsOperationColumnArgsDict(TypedDict):
        column_id: pulumi.Input[builtins.str]
        """
        A unique ID to identify a calculated column. During a dataset update, if the column ID of a calculated column matches that of an existing calculated column, Amazon QuickSight preserves the existing calculated column.
        """
        column_name: pulumi.Input[builtins.str]
        """
        Column name.
        """
        expression: pulumi.Input[builtins.str]
        """
        An expression that defines the calculated column.
        """
elif False:
    DataSetLogicalTableMapDataTransformCreateColumnsOperationColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformCreateColumnsOperationColumnArgs:
    def __init__(__self__, *,
                 column_id: pulumi.Input[builtins.str],
                 column_name: pulumi.Input[builtins.str],
                 expression: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] column_id: A unique ID to identify a calculated column. During a dataset update, if the column ID of a calculated column matches that of an existing calculated column, Amazon QuickSight preserves the existing calculated column.
        :param pulumi.Input[builtins.str] column_name: Column name.
        :param pulumi.Input[builtins.str] expression: An expression that defines the calculated column.
        """
        pulumi.set(__self__, "column_id", column_id)
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="columnId")
    def column_id(self) -> pulumi.Input[builtins.str]:
        """
        A unique ID to identify a calculated column. During a dataset update, if the column ID of a calculated column matches that of an existing calculated column, Amazon QuickSight preserves the existing calculated column.
        """
        return pulumi.get(self, "column_id")

    @column_id.setter
    def column_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "column_id", value)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[builtins.str]:
        """
        Column name.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        """
        An expression that defines the calculated column.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformFilterOperationArgsDict(TypedDict):
        condition_expression: pulumi.Input[builtins.str]
        """
        An expression that must evaluate to a Boolean value. Rows for which the expression evaluates to true are kept in the dataset.
        """
elif False:
    DataSetLogicalTableMapDataTransformFilterOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformFilterOperationArgs:
    def __init__(__self__, *,
                 condition_expression: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] condition_expression: An expression that must evaluate to a Boolean value. Rows for which the expression evaluates to true are kept in the dataset.
        """
        pulumi.set(__self__, "condition_expression", condition_expression)

    @property
    @pulumi.getter(name="conditionExpression")
    def condition_expression(self) -> pulumi.Input[builtins.str]:
        """
        An expression that must evaluate to a Boolean value. Rows for which the expression evaluates to true are kept in the dataset.
        """
        return pulumi.get(self, "condition_expression")

    @condition_expression.setter
    def condition_expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "condition_expression", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformProjectOperationArgsDict(TypedDict):
        projected_columns: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Projected columns.
        """
elif False:
    DataSetLogicalTableMapDataTransformProjectOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformProjectOperationArgs:
    def __init__(__self__, *,
                 projected_columns: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] projected_columns: Projected columns.
        """
        pulumi.set(__self__, "projected_columns", projected_columns)

    @property
    @pulumi.getter(name="projectedColumns")
    def projected_columns(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Projected columns.
        """
        return pulumi.get(self, "projected_columns")

    @projected_columns.setter
    def projected_columns(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "projected_columns", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformRenameColumnOperationArgsDict(TypedDict):
        column_name: pulumi.Input[builtins.str]
        """
        Column to be renamed.
        """
        new_column_name: pulumi.Input[builtins.str]
        """
        New name for the column.
        """
elif False:
    DataSetLogicalTableMapDataTransformRenameColumnOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformRenameColumnOperationArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[builtins.str],
                 new_column_name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] column_name: Column to be renamed.
        :param pulumi.Input[builtins.str] new_column_name: New name for the column.
        """
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "new_column_name", new_column_name)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[builtins.str]:
        """
        Column to be renamed.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter(name="newColumnName")
    def new_column_name(self) -> pulumi.Input[builtins.str]:
        """
        New name for the column.
        """
        return pulumi.get(self, "new_column_name")

    @new_column_name.setter
    def new_column_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "new_column_name", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformTagColumnOperationArgsDict(TypedDict):
        column_name: pulumi.Input[builtins.str]
        """
        Column name.
        """
        tags: pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationTagArgsDict']]]
        """
        The dataset column tag, currently only used for geospatial type tagging. See tags.
        """
elif False:
    DataSetLogicalTableMapDataTransformTagColumnOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformTagColumnOperationArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[builtins.str],
                 tags: pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationTagArgs']]]):
        """
        :param pulumi.Input[builtins.str] column_name: Column name.
        :param pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationTagArgs']]] tags: The dataset column tag, currently only used for geospatial type tagging. See tags.
        """
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[builtins.str]:
        """
        Column name.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter
    def tags(self) -> pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationTagArgs']]]:
        """
        The dataset column tag, currently only used for geospatial type tagging. See tags.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationTagArgs']]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformTagColumnOperationTagArgsDict(TypedDict):
        column_description: NotRequired[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionArgsDict']]
        """
        A description for a column. See column_description.
        """
        column_geographic_role: NotRequired[pulumi.Input[builtins.str]]
        """
        A geospatial role for a column. Valid values are `COUNTRY`, `STATE`, `COUNTY`, `CITY`, `POSTCODE`, `LONGITUDE`, and `LATITUDE`.
        """
elif False:
    DataSetLogicalTableMapDataTransformTagColumnOperationTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformTagColumnOperationTagArgs:
    def __init__(__self__, *,
                 column_description: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionArgs']] = None,
                 column_geographic_role: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionArgs'] column_description: A description for a column. See column_description.
        :param pulumi.Input[builtins.str] column_geographic_role: A geospatial role for a column. Valid values are `COUNTRY`, `STATE`, `COUNTY`, `CITY`, `POSTCODE`, `LONGITUDE`, and `LATITUDE`.
        """
        if column_description is not None:
            pulumi.set(__self__, "column_description", column_description)
        if column_geographic_role is not None:
            pulumi.set(__self__, "column_geographic_role", column_geographic_role)

    @property
    @pulumi.getter(name="columnDescription")
    def column_description(self) -> Optional[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionArgs']]:
        """
        A description for a column. See column_description.
        """
        return pulumi.get(self, "column_description")

    @column_description.setter
    def column_description(self, value: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionArgs']]):
        pulumi.set(self, "column_description", value)

    @property
    @pulumi.getter(name="columnGeographicRole")
    def column_geographic_role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A geospatial role for a column. Valid values are `COUNTRY`, `STATE`, `COUNTY`, `CITY`, `POSTCODE`, `LONGITUDE`, and `LATITUDE`.
        """
        return pulumi.get(self, "column_geographic_role")

    @column_geographic_role.setter
    def column_geographic_role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "column_geographic_role", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionArgsDict(TypedDict):
        text: NotRequired[pulumi.Input[builtins.str]]
        """
        The text of a description for a column.
        """
elif False:
    DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionArgs:
    def __init__(__self__, *,
                 text: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] text: The text of a description for a column.
        """
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The text of a description for a column.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformUntagColumnOperationArgsDict(TypedDict):
        column_name: pulumi.Input[builtins.str]
        """
        Column name.
        """
        tag_names: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The column tags to remove from this column.
        """
elif False:
    DataSetLogicalTableMapDataTransformUntagColumnOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformUntagColumnOperationArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[builtins.str],
                 tag_names: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[builtins.str] column_name: Column name.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tag_names: The column tags to remove from this column.
        """
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "tag_names", tag_names)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[builtins.str]:
        """
        Column name.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter(name="tagNames")
    def tag_names(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The column tags to remove from this column.
        """
        return pulumi.get(self, "tag_names")

    @tag_names.setter
    def tag_names(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "tag_names", value)


if not MYPY:
    class DataSetLogicalTableMapSourceArgsDict(TypedDict):
        data_set_arn: NotRequired[pulumi.Input[builtins.str]]
        """
        ARN of the parent data set.
        """
        join_instruction: NotRequired[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionArgsDict']]
        """
        Specifies the result of a join of two logical tables. See join_instruction.
        """
        physical_table_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Physical table ID.
        """
elif False:
    DataSetLogicalTableMapSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapSourceArgs:
    def __init__(__self__, *,
                 data_set_arn: Optional[pulumi.Input[builtins.str]] = None,
                 join_instruction: Optional[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionArgs']] = None,
                 physical_table_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] data_set_arn: ARN of the parent data set.
        :param pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionArgs'] join_instruction: Specifies the result of a join of two logical tables. See join_instruction.
        :param pulumi.Input[builtins.str] physical_table_id: Physical table ID.
        """
        if data_set_arn is not None:
            pulumi.set(__self__, "data_set_arn", data_set_arn)
        if join_instruction is not None:
            pulumi.set(__self__, "join_instruction", join_instruction)
        if physical_table_id is not None:
            pulumi.set(__self__, "physical_table_id", physical_table_id)

    @property
    @pulumi.getter(name="dataSetArn")
    def data_set_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ARN of the parent data set.
        """
        return pulumi.get(self, "data_set_arn")

    @data_set_arn.setter
    def data_set_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_set_arn", value)

    @property
    @pulumi.getter(name="joinInstruction")
    def join_instruction(self) -> Optional[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionArgs']]:
        """
        Specifies the result of a join of two logical tables. See join_instruction.
        """
        return pulumi.get(self, "join_instruction")

    @join_instruction.setter
    def join_instruction(self, value: Optional[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionArgs']]):
        pulumi.set(self, "join_instruction", value)

    @property
    @pulumi.getter(name="physicalTableId")
    def physical_table_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Physical table ID.
        """
        return pulumi.get(self, "physical_table_id")

    @physical_table_id.setter
    def physical_table_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "physical_table_id", value)


if not MYPY:
    class DataSetLogicalTableMapSourceJoinInstructionArgsDict(TypedDict):
        left_operand: pulumi.Input[builtins.str]
        """
        Operand on the left side of a join.
        """
        on_clause: pulumi.Input[builtins.str]
        """
        Join instructions provided in the ON clause of a join.
        """
        right_operand: pulumi.Input[builtins.str]
        """
        Operand on the right side of a join.
        """
        type: pulumi.Input[builtins.str]
        """
        Type of join. Valid values are `INNER`, `OUTER`, `LEFT`, and `RIGHT`.
        """
        left_join_key_properties: NotRequired[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertiesArgsDict']]
        """
        Join key properties of the left operand. See left_join_key_properties.
        """
        right_join_key_properties: NotRequired[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertiesArgsDict']]
        """
        Join key properties of the right operand. See right_join_key_properties.
        """
elif False:
    DataSetLogicalTableMapSourceJoinInstructionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapSourceJoinInstructionArgs:
    def __init__(__self__, *,
                 left_operand: pulumi.Input[builtins.str],
                 on_clause: pulumi.Input[builtins.str],
                 right_operand: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 left_join_key_properties: Optional[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertiesArgs']] = None,
                 right_join_key_properties: Optional[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertiesArgs']] = None):
        """
        :param pulumi.Input[builtins.str] left_operand: Operand on the left side of a join.
        :param pulumi.Input[builtins.str] on_clause: Join instructions provided in the ON clause of a join.
        :param pulumi.Input[builtins.str] right_operand: Operand on the right side of a join.
        :param pulumi.Input[builtins.str] type: Type of join. Valid values are `INNER`, `OUTER`, `LEFT`, and `RIGHT`.
        :param pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertiesArgs'] left_join_key_properties: Join key properties of the left operand. See left_join_key_properties.
        :param pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertiesArgs'] right_join_key_properties: Join key properties of the right operand. See right_join_key_properties.
        """
        pulumi.set(__self__, "left_operand", left_operand)
        pulumi.set(__self__, "on_clause", on_clause)
        pulumi.set(__self__, "right_operand", right_operand)
        pulumi.set(__self__, "type", type)
        if left_join_key_properties is not None:
            pulumi.set(__self__, "left_join_key_properties", left_join_key_properties)
        if right_join_key_properties is not None:
            pulumi.set(__self__, "right_join_key_properties", right_join_key_properties)

    @property
    @pulumi.getter(name="leftOperand")
    def left_operand(self) -> pulumi.Input[builtins.str]:
        """
        Operand on the left side of a join.
        """
        return pulumi.get(self, "left_operand")

    @left_operand.setter
    def left_operand(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "left_operand", value)

    @property
    @pulumi.getter(name="onClause")
    def on_clause(self) -> pulumi.Input[builtins.str]:
        """
        Join instructions provided in the ON clause of a join.
        """
        return pulumi.get(self, "on_clause")

    @on_clause.setter
    def on_clause(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "on_clause", value)

    @property
    @pulumi.getter(name="rightOperand")
    def right_operand(self) -> pulumi.Input[builtins.str]:
        """
        Operand on the right side of a join.
        """
        return pulumi.get(self, "right_operand")

    @right_operand.setter
    def right_operand(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "right_operand", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of join. Valid values are `INNER`, `OUTER`, `LEFT`, and `RIGHT`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="leftJoinKeyProperties")
    def left_join_key_properties(self) -> Optional[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertiesArgs']]:
        """
        Join key properties of the left operand. See left_join_key_properties.
        """
        return pulumi.get(self, "left_join_key_properties")

    @left_join_key_properties.setter
    def left_join_key_properties(self, value: Optional[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertiesArgs']]):
        pulumi.set(self, "left_join_key_properties", value)

    @property
    @pulumi.getter(name="rightJoinKeyProperties")
    def right_join_key_properties(self) -> Optional[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertiesArgs']]:
        """
        Join key properties of the right operand. See right_join_key_properties.
        """
        return pulumi.get(self, "right_join_key_properties")

    @right_join_key_properties.setter
    def right_join_key_properties(self, value: Optional[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertiesArgs']]):
        pulumi.set(self, "right_join_key_properties", value)


if not MYPY:
    class DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertiesArgsDict(TypedDict):
        unique_key: NotRequired[pulumi.Input[builtins.bool]]
        """
        A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.
        """
elif False:
    DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertiesArgs:
    def __init__(__self__, *,
                 unique_key: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] unique_key: A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.
        """
        if unique_key is not None:
            pulumi.set(__self__, "unique_key", unique_key)

    @property
    @pulumi.getter(name="uniqueKey")
    def unique_key(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.
        """
        return pulumi.get(self, "unique_key")

    @unique_key.setter
    def unique_key(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "unique_key", value)


if not MYPY:
    class DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertiesArgsDict(TypedDict):
        unique_key: NotRequired[pulumi.Input[builtins.bool]]
        """
        A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.
        """
elif False:
    DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertiesArgs:
    def __init__(__self__, *,
                 unique_key: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] unique_key: A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.
        """
        if unique_key is not None:
            pulumi.set(__self__, "unique_key", unique_key)

    @property
    @pulumi.getter(name="uniqueKey")
    def unique_key(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.
        """
        return pulumi.get(self, "unique_key")

    @unique_key.setter
    def unique_key(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "unique_key", value)


if not MYPY:
    class DataSetOutputColumnArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Field folder description.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Display name for the dataset.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DataSetOutputColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetOutputColumnArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] description: Field folder description.
        :param pulumi.Input[builtins.str] name: Display name for the dataset.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Field folder description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Display name for the dataset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DataSetPermissionArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        List of IAM actions to grant or revoke permissions on.
        """
        principal: pulumi.Input[builtins.str]
        """
        ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
elif False:
    DataSetPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetPermissionArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 principal: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: List of IAM actions to grant or revoke permissions on.
        :param pulumi.Input[builtins.str] principal: ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "principal", principal)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        List of IAM actions to grant or revoke permissions on.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def principal(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class DataSetPhysicalTableMapArgsDict(TypedDict):
        physical_table_map_id: pulumi.Input[builtins.str]
        """
        Key of the physical table map.
        """
        custom_sql: NotRequired[pulumi.Input['DataSetPhysicalTableMapCustomSqlArgsDict']]
        """
        A physical table type built from the results of the custom SQL query. See custom_sql.
        """
        relational_table: NotRequired[pulumi.Input['DataSetPhysicalTableMapRelationalTableArgsDict']]
        """
        A physical table type for relational data sources. See relational_table.
        """
        s3_source: NotRequired[pulumi.Input['DataSetPhysicalTableMapS3SourceArgsDict']]
        """
        A physical table type for as S3 data source. See s3_source.
        """
elif False:
    DataSetPhysicalTableMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetPhysicalTableMapArgs:
    def __init__(__self__, *,
                 physical_table_map_id: pulumi.Input[builtins.str],
                 custom_sql: Optional[pulumi.Input['DataSetPhysicalTableMapCustomSqlArgs']] = None,
                 relational_table: Optional[pulumi.Input['DataSetPhysicalTableMapRelationalTableArgs']] = None,
                 s3_source: Optional[pulumi.Input['DataSetPhysicalTableMapS3SourceArgs']] = None):
        """
        :param pulumi.Input[builtins.str] physical_table_map_id: Key of the physical table map.
        :param pulumi.Input['DataSetPhysicalTableMapCustomSqlArgs'] custom_sql: A physical table type built from the results of the custom SQL query. See custom_sql.
        :param pulumi.Input['DataSetPhysicalTableMapRelationalTableArgs'] relational_table: A physical table type for relational data sources. See relational_table.
        :param pulumi.Input['DataSetPhysicalTableMapS3SourceArgs'] s3_source: A physical table type for as S3 data source. See s3_source.
        """
        pulumi.set(__self__, "physical_table_map_id", physical_table_map_id)
        if custom_sql is not None:
            pulumi.set(__self__, "custom_sql", custom_sql)
        if relational_table is not None:
            pulumi.set(__self__, "relational_table", relational_table)
        if s3_source is not None:
            pulumi.set(__self__, "s3_source", s3_source)

    @property
    @pulumi.getter(name="physicalTableMapId")
    def physical_table_map_id(self) -> pulumi.Input[builtins.str]:
        """
        Key of the physical table map.
        """
        return pulumi.get(self, "physical_table_map_id")

    @physical_table_map_id.setter
    def physical_table_map_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "physical_table_map_id", value)

    @property
    @pulumi.getter(name="customSql")
    def custom_sql(self) -> Optional[pulumi.Input['DataSetPhysicalTableMapCustomSqlArgs']]:
        """
        A physical table type built from the results of the custom SQL query. See custom_sql.
        """
        return pulumi.get(self, "custom_sql")

    @custom_sql.setter
    def custom_sql(self, value: Optional[pulumi.Input['DataSetPhysicalTableMapCustomSqlArgs']]):
        pulumi.set(self, "custom_sql", value)

    @property
    @pulumi.getter(name="relationalTable")
    def relational_table(self) -> Optional[pulumi.Input['DataSetPhysicalTableMapRelationalTableArgs']]:
        """
        A physical table type for relational data sources. See relational_table.
        """
        return pulumi.get(self, "relational_table")

    @relational_table.setter
    def relational_table(self, value: Optional[pulumi.Input['DataSetPhysicalTableMapRelationalTableArgs']]):
        pulumi.set(self, "relational_table", value)

    @property
    @pulumi.getter(name="s3Source")
    def s3_source(self) -> Optional[pulumi.Input['DataSetPhysicalTableMapS3SourceArgs']]:
        """
        A physical table type for as S3 data source. See s3_source.
        """
        return pulumi.get(self, "s3_source")

    @s3_source.setter
    def s3_source(self, value: Optional[pulumi.Input['DataSetPhysicalTableMapS3SourceArgs']]):
        pulumi.set(self, "s3_source", value)


if not MYPY:
    class DataSetPhysicalTableMapCustomSqlArgsDict(TypedDict):
        data_source_arn: pulumi.Input[builtins.str]
        """
        ARN of the data source.
        """
        name: pulumi.Input[builtins.str]
        """
        Display name for the SQL query result.
        """
        sql_query: pulumi.Input[builtins.str]
        """
        SQL query.
        """
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapCustomSqlColumnArgsDict']]]]
        """
        Column schema from the SQL query result set. See columns.
        """
elif False:
    DataSetPhysicalTableMapCustomSqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetPhysicalTableMapCustomSqlArgs:
    def __init__(__self__, *,
                 data_source_arn: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 sql_query: pulumi.Input[builtins.str],
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapCustomSqlColumnArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] data_source_arn: ARN of the data source.
        :param pulumi.Input[builtins.str] name: Display name for the SQL query result.
        :param pulumi.Input[builtins.str] sql_query: SQL query.
        :param pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapCustomSqlColumnArgs']]] columns: Column schema from the SQL query result set. See columns.
        """
        pulumi.set(__self__, "data_source_arn", data_source_arn)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sql_query", sql_query)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)

    @property
    @pulumi.getter(name="dataSourceArn")
    def data_source_arn(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the data source.
        """
        return pulumi.get(self, "data_source_arn")

    @data_source_arn.setter
    def data_source_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data_source_arn", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Display name for the SQL query result.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sqlQuery")
    def sql_query(self) -> pulumi.Input[builtins.str]:
        """
        SQL query.
        """
        return pulumi.get(self, "sql_query")

    @sql_query.setter
    def sql_query(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "sql_query", value)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapCustomSqlColumnArgs']]]]:
        """
        Column schema from the SQL query result set. See columns.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapCustomSqlColumnArgs']]]]):
        pulumi.set(self, "columns", value)


if not MYPY:
    class DataSetPhysicalTableMapCustomSqlColumnArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Name of this column in the underlying data source.
        """
        type: pulumi.Input[builtins.str]
        """
        Data type of the column.
        """
elif False:
    DataSetPhysicalTableMapCustomSqlColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetPhysicalTableMapCustomSqlColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] name: Name of this column in the underlying data source.
        :param pulumi.Input[builtins.str] type: Data type of the column.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of this column in the underlying data source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Data type of the column.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DataSetPhysicalTableMapRelationalTableArgsDict(TypedDict):
        data_source_arn: pulumi.Input[builtins.str]
        """
        ARN of the data source.
        """
        input_columns: pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapRelationalTableInputColumnArgsDict']]]
        """
        Column schema of the table. See input_columns.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the relational table.
        """
        catalog: NotRequired[pulumi.Input[builtins.str]]
        """
        Catalog associated with the table.
        """
        schema: NotRequired[pulumi.Input[builtins.str]]
        """
        Schema name. This name applies to certain relational database engines.
        """
elif False:
    DataSetPhysicalTableMapRelationalTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetPhysicalTableMapRelationalTableArgs:
    def __init__(__self__, *,
                 data_source_arn: pulumi.Input[builtins.str],
                 input_columns: pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapRelationalTableInputColumnArgs']]],
                 name: pulumi.Input[builtins.str],
                 catalog: Optional[pulumi.Input[builtins.str]] = None,
                 schema: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] data_source_arn: ARN of the data source.
        :param pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapRelationalTableInputColumnArgs']]] input_columns: Column schema of the table. See input_columns.
        :param pulumi.Input[builtins.str] name: Name of the relational table.
        :param pulumi.Input[builtins.str] catalog: Catalog associated with the table.
        :param pulumi.Input[builtins.str] schema: Schema name. This name applies to certain relational database engines.
        """
        pulumi.set(__self__, "data_source_arn", data_source_arn)
        pulumi.set(__self__, "input_columns", input_columns)
        pulumi.set(__self__, "name", name)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @property
    @pulumi.getter(name="dataSourceArn")
    def data_source_arn(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the data source.
        """
        return pulumi.get(self, "data_source_arn")

    @data_source_arn.setter
    def data_source_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data_source_arn", value)

    @property
    @pulumi.getter(name="inputColumns")
    def input_columns(self) -> pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapRelationalTableInputColumnArgs']]]:
        """
        Column schema of the table. See input_columns.
        """
        return pulumi.get(self, "input_columns")

    @input_columns.setter
    def input_columns(self, value: pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapRelationalTableInputColumnArgs']]]):
        pulumi.set(self, "input_columns", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the relational table.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def catalog(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Catalog associated with the table.
        """
        return pulumi.get(self, "catalog")

    @catalog.setter
    def catalog(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "catalog", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Schema name. This name applies to certain relational database engines.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "schema", value)


if not MYPY:
    class DataSetPhysicalTableMapRelationalTableInputColumnArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Name of this column in the underlying data source.
        """
        type: pulumi.Input[builtins.str]
        """
        Data type of the column.
        """
elif False:
    DataSetPhysicalTableMapRelationalTableInputColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetPhysicalTableMapRelationalTableInputColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] name: Name of this column in the underlying data source.
        :param pulumi.Input[builtins.str] type: Data type of the column.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of this column in the underlying data source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Data type of the column.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DataSetPhysicalTableMapS3SourceArgsDict(TypedDict):
        data_source_arn: pulumi.Input[builtins.str]
        """
        ARN of the data source.
        """
        input_columns: pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapS3SourceInputColumnArgsDict']]]
        """
        Column schema of the table. See input_columns.
        """
        upload_settings: pulumi.Input['DataSetPhysicalTableMapS3SourceUploadSettingsArgsDict']
        """
        Information about the format for the S3 source file or files. See upload_settings.
        """
elif False:
    DataSetPhysicalTableMapS3SourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetPhysicalTableMapS3SourceArgs:
    def __init__(__self__, *,
                 data_source_arn: pulumi.Input[builtins.str],
                 input_columns: pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapS3SourceInputColumnArgs']]],
                 upload_settings: pulumi.Input['DataSetPhysicalTableMapS3SourceUploadSettingsArgs']):
        """
        :param pulumi.Input[builtins.str] data_source_arn: ARN of the data source.
        :param pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapS3SourceInputColumnArgs']]] input_columns: Column schema of the table. See input_columns.
        :param pulumi.Input['DataSetPhysicalTableMapS3SourceUploadSettingsArgs'] upload_settings: Information about the format for the S3 source file or files. See upload_settings.
        """
        pulumi.set(__self__, "data_source_arn", data_source_arn)
        pulumi.set(__self__, "input_columns", input_columns)
        pulumi.set(__self__, "upload_settings", upload_settings)

    @property
    @pulumi.getter(name="dataSourceArn")
    def data_source_arn(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the data source.
        """
        return pulumi.get(self, "data_source_arn")

    @data_source_arn.setter
    def data_source_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data_source_arn", value)

    @property
    @pulumi.getter(name="inputColumns")
    def input_columns(self) -> pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapS3SourceInputColumnArgs']]]:
        """
        Column schema of the table. See input_columns.
        """
        return pulumi.get(self, "input_columns")

    @input_columns.setter
    def input_columns(self, value: pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapS3SourceInputColumnArgs']]]):
        pulumi.set(self, "input_columns", value)

    @property
    @pulumi.getter(name="uploadSettings")
    def upload_settings(self) -> pulumi.Input['DataSetPhysicalTableMapS3SourceUploadSettingsArgs']:
        """
        Information about the format for the S3 source file or files. See upload_settings.
        """
        return pulumi.get(self, "upload_settings")

    @upload_settings.setter
    def upload_settings(self, value: pulumi.Input['DataSetPhysicalTableMapS3SourceUploadSettingsArgs']):
        pulumi.set(self, "upload_settings", value)


if not MYPY:
    class DataSetPhysicalTableMapS3SourceInputColumnArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Name of this column in the underlying data source.
        """
        type: pulumi.Input[builtins.str]
        """
        Data type of the column.
        """
elif False:
    DataSetPhysicalTableMapS3SourceInputColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetPhysicalTableMapS3SourceInputColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] name: Name of this column in the underlying data source.
        :param pulumi.Input[builtins.str] type: Data type of the column.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of this column in the underlying data source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Data type of the column.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DataSetPhysicalTableMapS3SourceUploadSettingsArgsDict(TypedDict):
        contains_header: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the file has a header row, or the files each have a header row.
        """
        delimiter: NotRequired[pulumi.Input[builtins.str]]
        """
        Delimiter between values in the file.
        """
        format: NotRequired[pulumi.Input[builtins.str]]
        """
        File format. Valid values are `CSV`, `TSV`, `CLF`, `ELF`, `XLSX`, and `JSON`.
        """
        start_from_row: NotRequired[pulumi.Input[builtins.int]]
        """
        A row number to start reading data from.
        """
        text_qualifier: NotRequired[pulumi.Input[builtins.str]]
        """
        Text qualifier. Valid values are `DOUBLE_QUOTE` and `SINGLE_QUOTE`.
        """
elif False:
    DataSetPhysicalTableMapS3SourceUploadSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetPhysicalTableMapS3SourceUploadSettingsArgs:
    def __init__(__self__, *,
                 contains_header: Optional[pulumi.Input[builtins.bool]] = None,
                 delimiter: Optional[pulumi.Input[builtins.str]] = None,
                 format: Optional[pulumi.Input[builtins.str]] = None,
                 start_from_row: Optional[pulumi.Input[builtins.int]] = None,
                 text_qualifier: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] contains_header: Whether the file has a header row, or the files each have a header row.
        :param pulumi.Input[builtins.str] delimiter: Delimiter between values in the file.
        :param pulumi.Input[builtins.str] format: File format. Valid values are `CSV`, `TSV`, `CLF`, `ELF`, `XLSX`, and `JSON`.
        :param pulumi.Input[builtins.int] start_from_row: A row number to start reading data from.
        :param pulumi.Input[builtins.str] text_qualifier: Text qualifier. Valid values are `DOUBLE_QUOTE` and `SINGLE_QUOTE`.
        """
        if contains_header is not None:
            pulumi.set(__self__, "contains_header", contains_header)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if start_from_row is not None:
            pulumi.set(__self__, "start_from_row", start_from_row)
        if text_qualifier is not None:
            pulumi.set(__self__, "text_qualifier", text_qualifier)

    @property
    @pulumi.getter(name="containsHeader")
    def contains_header(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the file has a header row, or the files each have a header row.
        """
        return pulumi.get(self, "contains_header")

    @contains_header.setter
    def contains_header(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "contains_header", value)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Delimiter between values in the file.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        File format. Valid values are `CSV`, `TSV`, `CLF`, `ELF`, `XLSX`, and `JSON`.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="startFromRow")
    def start_from_row(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        A row number to start reading data from.
        """
        return pulumi.get(self, "start_from_row")

    @start_from_row.setter
    def start_from_row(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "start_from_row", value)

    @property
    @pulumi.getter(name="textQualifier")
    def text_qualifier(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Text qualifier. Valid values are `DOUBLE_QUOTE` and `SINGLE_QUOTE`.
        """
        return pulumi.get(self, "text_qualifier")

    @text_qualifier.setter
    def text_qualifier(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "text_qualifier", value)


if not MYPY:
    class DataSetRefreshPropertiesArgsDict(TypedDict):
        refresh_configuration: pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationArgsDict']
        """
        The refresh configuration for the data set. See refresh_configuration.
        """
elif False:
    DataSetRefreshPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetRefreshPropertiesArgs:
    def __init__(__self__, *,
                 refresh_configuration: pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationArgs']):
        """
        :param pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationArgs'] refresh_configuration: The refresh configuration for the data set. See refresh_configuration.
        """
        pulumi.set(__self__, "refresh_configuration", refresh_configuration)

    @property
    @pulumi.getter(name="refreshConfiguration")
    def refresh_configuration(self) -> pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationArgs']:
        """
        The refresh configuration for the data set. See refresh_configuration.
        """
        return pulumi.get(self, "refresh_configuration")

    @refresh_configuration.setter
    def refresh_configuration(self, value: pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationArgs']):
        pulumi.set(self, "refresh_configuration", value)


if not MYPY:
    class DataSetRefreshPropertiesRefreshConfigurationArgsDict(TypedDict):
        incremental_refresh: pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshArgsDict']
        """
        The incremental refresh for the data set. See incremental_refresh.
        """
elif False:
    DataSetRefreshPropertiesRefreshConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetRefreshPropertiesRefreshConfigurationArgs:
    def __init__(__self__, *,
                 incremental_refresh: pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshArgs']):
        """
        :param pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshArgs'] incremental_refresh: The incremental refresh for the data set. See incremental_refresh.
        """
        pulumi.set(__self__, "incremental_refresh", incremental_refresh)

    @property
    @pulumi.getter(name="incrementalRefresh")
    def incremental_refresh(self) -> pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshArgs']:
        """
        The incremental refresh for the data set. See incremental_refresh.
        """
        return pulumi.get(self, "incremental_refresh")

    @incremental_refresh.setter
    def incremental_refresh(self, value: pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshArgs']):
        pulumi.set(self, "incremental_refresh", value)


if not MYPY:
    class DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshArgsDict(TypedDict):
        lookback_window: pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindowArgsDict']
        """
        The lookback window setup for an incremental refresh configuration. See lookback_window.
        """
elif False:
    DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshArgs:
    def __init__(__self__, *,
                 lookback_window: pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindowArgs']):
        """
        :param pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindowArgs'] lookback_window: The lookback window setup for an incremental refresh configuration. See lookback_window.
        """
        pulumi.set(__self__, "lookback_window", lookback_window)

    @property
    @pulumi.getter(name="lookbackWindow")
    def lookback_window(self) -> pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindowArgs']:
        """
        The lookback window setup for an incremental refresh configuration. See lookback_window.
        """
        return pulumi.get(self, "lookback_window")

    @lookback_window.setter
    def lookback_window(self, value: pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindowArgs']):
        pulumi.set(self, "lookback_window", value)


if not MYPY:
    class DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindowArgsDict(TypedDict):
        column_name: pulumi.Input[builtins.str]
        """
        The name of the lookback window column.
        """
        size: pulumi.Input[builtins.int]
        """
        The lookback window column size.
        """
        size_unit: pulumi.Input[builtins.str]
        """
        The size unit that is used for the lookback window column. Valid values for this structure are `HOUR`, `DAY`, and `WEEK`.
        """
elif False:
    DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindowArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[builtins.str],
                 size: pulumi.Input[builtins.int],
                 size_unit: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] column_name: The name of the lookback window column.
        :param pulumi.Input[builtins.int] size: The lookback window column size.
        :param pulumi.Input[builtins.str] size_unit: The size unit that is used for the lookback window column. Valid values for this structure are `HOUR`, `DAY`, and `WEEK`.
        """
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "size_unit", size_unit)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the lookback window column.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[builtins.int]:
        """
        The lookback window column size.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="sizeUnit")
    def size_unit(self) -> pulumi.Input[builtins.str]:
        """
        The size unit that is used for the lookback window column. Valid values for this structure are `HOUR`, `DAY`, and `WEEK`.
        """
        return pulumi.get(self, "size_unit")

    @size_unit.setter
    def size_unit(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "size_unit", value)


if not MYPY:
    class DataSetRowLevelPermissionDataSetArgsDict(TypedDict):
        arn: pulumi.Input[builtins.str]
        """
        ARN of the dataset that contains permissions for RLS.
        """
        permission_policy: pulumi.Input[builtins.str]
        """
        Type of permissions to use when interpreting the permissions for RLS. Valid values are `GRANT_ACCESS` and `DENY_ACCESS`.
        """
        format_version: NotRequired[pulumi.Input[builtins.str]]
        """
        User or group rules associated with the dataset that contains permissions for RLS.
        """
        namespace: NotRequired[pulumi.Input[builtins.str]]
        """
        Namespace associated with the dataset that contains permissions for RLS.
        """
        status: NotRequired[pulumi.Input[builtins.str]]
        """
        Status of the row-level security permission dataset. If enabled, the status is `ENABLED`. If disabled, the status is `DISABLED`.
        """
elif False:
    DataSetRowLevelPermissionDataSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetRowLevelPermissionDataSetArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[builtins.str],
                 permission_policy: pulumi.Input[builtins.str],
                 format_version: Optional[pulumi.Input[builtins.str]] = None,
                 namespace: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] arn: ARN of the dataset that contains permissions for RLS.
        :param pulumi.Input[builtins.str] permission_policy: Type of permissions to use when interpreting the permissions for RLS. Valid values are `GRANT_ACCESS` and `DENY_ACCESS`.
        :param pulumi.Input[builtins.str] format_version: User or group rules associated with the dataset that contains permissions for RLS.
        :param pulumi.Input[builtins.str] namespace: Namespace associated with the dataset that contains permissions for RLS.
        :param pulumi.Input[builtins.str] status: Status of the row-level security permission dataset. If enabled, the status is `ENABLED`. If disabled, the status is `DISABLED`.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "permission_policy", permission_policy)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the dataset that contains permissions for RLS.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="permissionPolicy")
    def permission_policy(self) -> pulumi.Input[builtins.str]:
        """
        Type of permissions to use when interpreting the permissions for RLS. Valid values are `GRANT_ACCESS` and `DENY_ACCESS`.
        """
        return pulumi.get(self, "permission_policy")

    @permission_policy.setter
    def permission_policy(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "permission_policy", value)

    @property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        User or group rules associated with the dataset that contains permissions for RLS.
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "format_version", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Namespace associated with the dataset that contains permissions for RLS.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Status of the row-level security permission dataset. If enabled, the status is `ENABLED`. If disabled, the status is `DISABLED`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class DataSetRowLevelPermissionTagConfigurationArgsDict(TypedDict):
        tag_rules: pulumi.Input[Sequence[pulumi.Input['DataSetRowLevelPermissionTagConfigurationTagRuleArgsDict']]]
        """
        A set of rules associated with row-level security, such as the tag names and columns that they are assigned to. See tag_rules.
        """
        status: NotRequired[pulumi.Input[builtins.str]]
        """
        The status of row-level security tags. If enabled, the status is `ENABLED`. If disabled, the status is `DISABLED`.
        """
elif False:
    DataSetRowLevelPermissionTagConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetRowLevelPermissionTagConfigurationArgs:
    def __init__(__self__, *,
                 tag_rules: pulumi.Input[Sequence[pulumi.Input['DataSetRowLevelPermissionTagConfigurationTagRuleArgs']]],
                 status: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DataSetRowLevelPermissionTagConfigurationTagRuleArgs']]] tag_rules: A set of rules associated with row-level security, such as the tag names and columns that they are assigned to. See tag_rules.
        :param pulumi.Input[builtins.str] status: The status of row-level security tags. If enabled, the status is `ENABLED`. If disabled, the status is `DISABLED`.
        """
        pulumi.set(__self__, "tag_rules", tag_rules)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="tagRules")
    def tag_rules(self) -> pulumi.Input[Sequence[pulumi.Input['DataSetRowLevelPermissionTagConfigurationTagRuleArgs']]]:
        """
        A set of rules associated with row-level security, such as the tag names and columns that they are assigned to. See tag_rules.
        """
        return pulumi.get(self, "tag_rules")

    @tag_rules.setter
    def tag_rules(self, value: pulumi.Input[Sequence[pulumi.Input['DataSetRowLevelPermissionTagConfigurationTagRuleArgs']]]):
        pulumi.set(self, "tag_rules", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The status of row-level security tags. If enabled, the status is `ENABLED`. If disabled, the status is `DISABLED`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class DataSetRowLevelPermissionTagConfigurationTagRuleArgsDict(TypedDict):
        column_name: pulumi.Input[builtins.str]
        """
        Column name that a tag key is assigned to.
        """
        tag_key: pulumi.Input[builtins.str]
        """
        Unique key for a tag.
        """
        match_all_value: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that you want to use to filter by all the values in a column in the dataset and dont want to list the values one by one.
        """
        tag_multi_value_delimiter: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that you want to use to delimit the values when you pass the values at run time.
        """
elif False:
    DataSetRowLevelPermissionTagConfigurationTagRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetRowLevelPermissionTagConfigurationTagRuleArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[builtins.str],
                 tag_key: pulumi.Input[builtins.str],
                 match_all_value: Optional[pulumi.Input[builtins.str]] = None,
                 tag_multi_value_delimiter: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] column_name: Column name that a tag key is assigned to.
        :param pulumi.Input[builtins.str] tag_key: Unique key for a tag.
        :param pulumi.Input[builtins.str] match_all_value: A string that you want to use to filter by all the values in a column in the dataset and dont want to list the values one by one.
        :param pulumi.Input[builtins.str] tag_multi_value_delimiter: A string that you want to use to delimit the values when you pass the values at run time.
        """
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "tag_key", tag_key)
        if match_all_value is not None:
            pulumi.set(__self__, "match_all_value", match_all_value)
        if tag_multi_value_delimiter is not None:
            pulumi.set(__self__, "tag_multi_value_delimiter", tag_multi_value_delimiter)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[builtins.str]:
        """
        Column name that a tag key is assigned to.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> pulumi.Input[builtins.str]:
        """
        Unique key for a tag.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="matchAllValue")
    def match_all_value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that you want to use to filter by all the values in a column in the dataset and dont want to list the values one by one.
        """
        return pulumi.get(self, "match_all_value")

    @match_all_value.setter
    def match_all_value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_all_value", value)

    @property
    @pulumi.getter(name="tagMultiValueDelimiter")
    def tag_multi_value_delimiter(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that you want to use to delimit the values when you pass the values at run time.
        """
        return pulumi.get(self, "tag_multi_value_delimiter")

    @tag_multi_value_delimiter.setter
    def tag_multi_value_delimiter(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tag_multi_value_delimiter", value)


if not MYPY:
    class DataSourceCredentialsArgsDict(TypedDict):
        copy_source_arn: NotRequired[pulumi.Input[builtins.str]]
        """
        The Amazon Resource Name (ARN) of a data source that has the credential pair that you want to use.
        When the value is not null, the `credential_pair` from the data source in the ARN is used.
        """
        credential_pair: NotRequired[pulumi.Input['DataSourceCredentialsCredentialPairArgsDict']]
        """
        Credential pair. See Credential Pair below for more details.
        """
        secret_arn: NotRequired[pulumi.Input[builtins.str]]
        """
        The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.
        """
elif False:
    DataSourceCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceCredentialsArgs:
    def __init__(__self__, *,
                 copy_source_arn: Optional[pulumi.Input[builtins.str]] = None,
                 credential_pair: Optional[pulumi.Input['DataSourceCredentialsCredentialPairArgs']] = None,
                 secret_arn: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] copy_source_arn: The Amazon Resource Name (ARN) of a data source that has the credential pair that you want to use.
               When the value is not null, the `credential_pair` from the data source in the ARN is used.
        :param pulumi.Input['DataSourceCredentialsCredentialPairArgs'] credential_pair: Credential pair. See Credential Pair below for more details.
        :param pulumi.Input[builtins.str] secret_arn: The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.
        """
        if copy_source_arn is not None:
            pulumi.set(__self__, "copy_source_arn", copy_source_arn)
        if credential_pair is not None:
            pulumi.set(__self__, "credential_pair", credential_pair)
        if secret_arn is not None:
            pulumi.set(__self__, "secret_arn", secret_arn)

    @property
    @pulumi.getter(name="copySourceArn")
    def copy_source_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Amazon Resource Name (ARN) of a data source that has the credential pair that you want to use.
        When the value is not null, the `credential_pair` from the data source in the ARN is used.
        """
        return pulumi.get(self, "copy_source_arn")

    @copy_source_arn.setter
    def copy_source_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "copy_source_arn", value)

    @property
    @pulumi.getter(name="credentialPair")
    def credential_pair(self) -> Optional[pulumi.Input['DataSourceCredentialsCredentialPairArgs']]:
        """
        Credential pair. See Credential Pair below for more details.
        """
        return pulumi.get(self, "credential_pair")

    @credential_pair.setter
    def credential_pair(self, value: Optional[pulumi.Input['DataSourceCredentialsCredentialPairArgs']]):
        pulumi.set(self, "credential_pair", value)

    @property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.
        """
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret_arn", value)


if not MYPY:
    class DataSourceCredentialsCredentialPairArgsDict(TypedDict):
        password: pulumi.Input[builtins.str]
        """
        Password, maximum length of 1024 characters.
        """
        username: pulumi.Input[builtins.str]
        """
        User name, maximum length of 64 characters.
        """
elif False:
    DataSourceCredentialsCredentialPairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceCredentialsCredentialPairArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[builtins.str],
                 username: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] password: Password, maximum length of 1024 characters.
        :param pulumi.Input[builtins.str] username: User name, maximum length of 64 characters.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[builtins.str]:
        """
        Password, maximum length of 1024 characters.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[builtins.str]:
        """
        User name, maximum length of 64 characters.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class DataSourceParametersArgsDict(TypedDict):
        amazon_elasticsearch: NotRequired[pulumi.Input['DataSourceParametersAmazonElasticsearchArgsDict']]
        """
        Parameters for connecting to Amazon Elasticsearch.
        """
        athena: NotRequired[pulumi.Input['DataSourceParametersAthenaArgsDict']]
        """
        Parameters for connecting to Athena.
        """
        aurora: NotRequired[pulumi.Input['DataSourceParametersAuroraArgsDict']]
        """
        Parameters for connecting to Aurora MySQL.
        """
        aurora_postgresql: NotRequired[pulumi.Input['DataSourceParametersAuroraPostgresqlArgsDict']]
        """
        Parameters for connecting to Aurora Postgresql.
        """
        aws_iot_analytics: NotRequired[pulumi.Input['DataSourceParametersAwsIotAnalyticsArgsDict']]
        """
        Parameters for connecting to AWS IOT Analytics.
        """
        databricks: NotRequired[pulumi.Input['DataSourceParametersDatabricksArgsDict']]
        """
        Parameters for connecting to Databricks.
        """
        jira: NotRequired[pulumi.Input['DataSourceParametersJiraArgsDict']]
        """
        Parameters for connecting to Jira.
        """
        maria_db: NotRequired[pulumi.Input['DataSourceParametersMariaDbArgsDict']]
        """
        Parameters for connecting to MariaDB.
        """
        mysql: NotRequired[pulumi.Input['DataSourceParametersMysqlArgsDict']]
        """
        Parameters for connecting to MySQL.
        """
        oracle: NotRequired[pulumi.Input['DataSourceParametersOracleArgsDict']]
        """
        Parameters for connecting to Oracle.
        """
        postgresql: NotRequired[pulumi.Input['DataSourceParametersPostgresqlArgsDict']]
        """
        Parameters for connecting to Postgresql.
        """
        presto: NotRequired[pulumi.Input['DataSourceParametersPrestoArgsDict']]
        """
        Parameters for connecting to Presto.
        """
        rds: NotRequired[pulumi.Input['DataSourceParametersRdsArgsDict']]
        """
        Parameters for connecting to RDS.
        """
        redshift: NotRequired[pulumi.Input['DataSourceParametersRedshiftArgsDict']]
        """
        Parameters for connecting to Redshift.
        """
        s3: NotRequired[pulumi.Input['DataSourceParametersS3ArgsDict']]
        """
        Parameters for connecting to S3.
        """
        service_now: NotRequired[pulumi.Input['DataSourceParametersServiceNowArgsDict']]
        """
        Parameters for connecting to ServiceNow.
        """
        snowflake: NotRequired[pulumi.Input['DataSourceParametersSnowflakeArgsDict']]
        """
        Parameters for connecting to Snowflake.
        """
        spark: NotRequired[pulumi.Input['DataSourceParametersSparkArgsDict']]
        """
        Parameters for connecting to Spark.
        """
        sql_server: NotRequired[pulumi.Input['DataSourceParametersSqlServerArgsDict']]
        """
        Parameters for connecting to SQL Server.
        """
        teradata: NotRequired[pulumi.Input['DataSourceParametersTeradataArgsDict']]
        """
        Parameters for connecting to Teradata.
        """
        twitter: NotRequired[pulumi.Input['DataSourceParametersTwitterArgsDict']]
        """
        Parameters for connecting to Twitter.
        """
elif False:
    DataSourceParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersArgs:
    def __init__(__self__, *,
                 amazon_elasticsearch: Optional[pulumi.Input['DataSourceParametersAmazonElasticsearchArgs']] = None,
                 athena: Optional[pulumi.Input['DataSourceParametersAthenaArgs']] = None,
                 aurora: Optional[pulumi.Input['DataSourceParametersAuroraArgs']] = None,
                 aurora_postgresql: Optional[pulumi.Input['DataSourceParametersAuroraPostgresqlArgs']] = None,
                 aws_iot_analytics: Optional[pulumi.Input['DataSourceParametersAwsIotAnalyticsArgs']] = None,
                 databricks: Optional[pulumi.Input['DataSourceParametersDatabricksArgs']] = None,
                 jira: Optional[pulumi.Input['DataSourceParametersJiraArgs']] = None,
                 maria_db: Optional[pulumi.Input['DataSourceParametersMariaDbArgs']] = None,
                 mysql: Optional[pulumi.Input['DataSourceParametersMysqlArgs']] = None,
                 oracle: Optional[pulumi.Input['DataSourceParametersOracleArgs']] = None,
                 postgresql: Optional[pulumi.Input['DataSourceParametersPostgresqlArgs']] = None,
                 presto: Optional[pulumi.Input['DataSourceParametersPrestoArgs']] = None,
                 rds: Optional[pulumi.Input['DataSourceParametersRdsArgs']] = None,
                 redshift: Optional[pulumi.Input['DataSourceParametersRedshiftArgs']] = None,
                 s3: Optional[pulumi.Input['DataSourceParametersS3Args']] = None,
                 service_now: Optional[pulumi.Input['DataSourceParametersServiceNowArgs']] = None,
                 snowflake: Optional[pulumi.Input['DataSourceParametersSnowflakeArgs']] = None,
                 spark: Optional[pulumi.Input['DataSourceParametersSparkArgs']] = None,
                 sql_server: Optional[pulumi.Input['DataSourceParametersSqlServerArgs']] = None,
                 teradata: Optional[pulumi.Input['DataSourceParametersTeradataArgs']] = None,
                 twitter: Optional[pulumi.Input['DataSourceParametersTwitterArgs']] = None):
        """
        :param pulumi.Input['DataSourceParametersAmazonElasticsearchArgs'] amazon_elasticsearch: Parameters for connecting to Amazon Elasticsearch.
        :param pulumi.Input['DataSourceParametersAthenaArgs'] athena: Parameters for connecting to Athena.
        :param pulumi.Input['DataSourceParametersAuroraArgs'] aurora: Parameters for connecting to Aurora MySQL.
        :param pulumi.Input['DataSourceParametersAuroraPostgresqlArgs'] aurora_postgresql: Parameters for connecting to Aurora Postgresql.
        :param pulumi.Input['DataSourceParametersAwsIotAnalyticsArgs'] aws_iot_analytics: Parameters for connecting to AWS IOT Analytics.
        :param pulumi.Input['DataSourceParametersDatabricksArgs'] databricks: Parameters for connecting to Databricks.
        :param pulumi.Input['DataSourceParametersJiraArgs'] jira: Parameters for connecting to Jira.
        :param pulumi.Input['DataSourceParametersMariaDbArgs'] maria_db: Parameters for connecting to MariaDB.
        :param pulumi.Input['DataSourceParametersMysqlArgs'] mysql: Parameters for connecting to MySQL.
        :param pulumi.Input['DataSourceParametersOracleArgs'] oracle: Parameters for connecting to Oracle.
        :param pulumi.Input['DataSourceParametersPostgresqlArgs'] postgresql: Parameters for connecting to Postgresql.
        :param pulumi.Input['DataSourceParametersPrestoArgs'] presto: Parameters for connecting to Presto.
        :param pulumi.Input['DataSourceParametersRdsArgs'] rds: Parameters for connecting to RDS.
        :param pulumi.Input['DataSourceParametersRedshiftArgs'] redshift: Parameters for connecting to Redshift.
        :param pulumi.Input['DataSourceParametersS3Args'] s3: Parameters for connecting to S3.
        :param pulumi.Input['DataSourceParametersServiceNowArgs'] service_now: Parameters for connecting to ServiceNow.
        :param pulumi.Input['DataSourceParametersSnowflakeArgs'] snowflake: Parameters for connecting to Snowflake.
        :param pulumi.Input['DataSourceParametersSparkArgs'] spark: Parameters for connecting to Spark.
        :param pulumi.Input['DataSourceParametersSqlServerArgs'] sql_server: Parameters for connecting to SQL Server.
        :param pulumi.Input['DataSourceParametersTeradataArgs'] teradata: Parameters for connecting to Teradata.
        :param pulumi.Input['DataSourceParametersTwitterArgs'] twitter: Parameters for connecting to Twitter.
        """
        if amazon_elasticsearch is not None:
            pulumi.set(__self__, "amazon_elasticsearch", amazon_elasticsearch)
        if athena is not None:
            pulumi.set(__self__, "athena", athena)
        if aurora is not None:
            pulumi.set(__self__, "aurora", aurora)
        if aurora_postgresql is not None:
            pulumi.set(__self__, "aurora_postgresql", aurora_postgresql)
        if aws_iot_analytics is not None:
            pulumi.set(__self__, "aws_iot_analytics", aws_iot_analytics)
        if databricks is not None:
            pulumi.set(__self__, "databricks", databricks)
        if jira is not None:
            pulumi.set(__self__, "jira", jira)
        if maria_db is not None:
            pulumi.set(__self__, "maria_db", maria_db)
        if mysql is not None:
            pulumi.set(__self__, "mysql", mysql)
        if oracle is not None:
            pulumi.set(__self__, "oracle", oracle)
        if postgresql is not None:
            pulumi.set(__self__, "postgresql", postgresql)
        if presto is not None:
            pulumi.set(__self__, "presto", presto)
        if rds is not None:
            pulumi.set(__self__, "rds", rds)
        if redshift is not None:
            pulumi.set(__self__, "redshift", redshift)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if service_now is not None:
            pulumi.set(__self__, "service_now", service_now)
        if snowflake is not None:
            pulumi.set(__self__, "snowflake", snowflake)
        if spark is not None:
            pulumi.set(__self__, "spark", spark)
        if sql_server is not None:
            pulumi.set(__self__, "sql_server", sql_server)
        if teradata is not None:
            pulumi.set(__self__, "teradata", teradata)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)

    @property
    @pulumi.getter(name="amazonElasticsearch")
    def amazon_elasticsearch(self) -> Optional[pulumi.Input['DataSourceParametersAmazonElasticsearchArgs']]:
        """
        Parameters for connecting to Amazon Elasticsearch.
        """
        return pulumi.get(self, "amazon_elasticsearch")

    @amazon_elasticsearch.setter
    def amazon_elasticsearch(self, value: Optional[pulumi.Input['DataSourceParametersAmazonElasticsearchArgs']]):
        pulumi.set(self, "amazon_elasticsearch", value)

    @property
    @pulumi.getter
    def athena(self) -> Optional[pulumi.Input['DataSourceParametersAthenaArgs']]:
        """
        Parameters for connecting to Athena.
        """
        return pulumi.get(self, "athena")

    @athena.setter
    def athena(self, value: Optional[pulumi.Input['DataSourceParametersAthenaArgs']]):
        pulumi.set(self, "athena", value)

    @property
    @pulumi.getter
    def aurora(self) -> Optional[pulumi.Input['DataSourceParametersAuroraArgs']]:
        """
        Parameters for connecting to Aurora MySQL.
        """
        return pulumi.get(self, "aurora")

    @aurora.setter
    def aurora(self, value: Optional[pulumi.Input['DataSourceParametersAuroraArgs']]):
        pulumi.set(self, "aurora", value)

    @property
    @pulumi.getter(name="auroraPostgresql")
    def aurora_postgresql(self) -> Optional[pulumi.Input['DataSourceParametersAuroraPostgresqlArgs']]:
        """
        Parameters for connecting to Aurora Postgresql.
        """
        return pulumi.get(self, "aurora_postgresql")

    @aurora_postgresql.setter
    def aurora_postgresql(self, value: Optional[pulumi.Input['DataSourceParametersAuroraPostgresqlArgs']]):
        pulumi.set(self, "aurora_postgresql", value)

    @property
    @pulumi.getter(name="awsIotAnalytics")
    def aws_iot_analytics(self) -> Optional[pulumi.Input['DataSourceParametersAwsIotAnalyticsArgs']]:
        """
        Parameters for connecting to AWS IOT Analytics.
        """
        return pulumi.get(self, "aws_iot_analytics")

    @aws_iot_analytics.setter
    def aws_iot_analytics(self, value: Optional[pulumi.Input['DataSourceParametersAwsIotAnalyticsArgs']]):
        pulumi.set(self, "aws_iot_analytics", value)

    @property
    @pulumi.getter
    def databricks(self) -> Optional[pulumi.Input['DataSourceParametersDatabricksArgs']]:
        """
        Parameters for connecting to Databricks.
        """
        return pulumi.get(self, "databricks")

    @databricks.setter
    def databricks(self, value: Optional[pulumi.Input['DataSourceParametersDatabricksArgs']]):
        pulumi.set(self, "databricks", value)

    @property
    @pulumi.getter
    def jira(self) -> Optional[pulumi.Input['DataSourceParametersJiraArgs']]:
        """
        Parameters for connecting to Jira.
        """
        return pulumi.get(self, "jira")

    @jira.setter
    def jira(self, value: Optional[pulumi.Input['DataSourceParametersJiraArgs']]):
        pulumi.set(self, "jira", value)

    @property
    @pulumi.getter(name="mariaDb")
    def maria_db(self) -> Optional[pulumi.Input['DataSourceParametersMariaDbArgs']]:
        """
        Parameters for connecting to MariaDB.
        """
        return pulumi.get(self, "maria_db")

    @maria_db.setter
    def maria_db(self, value: Optional[pulumi.Input['DataSourceParametersMariaDbArgs']]):
        pulumi.set(self, "maria_db", value)

    @property
    @pulumi.getter
    def mysql(self) -> Optional[pulumi.Input['DataSourceParametersMysqlArgs']]:
        """
        Parameters for connecting to MySQL.
        """
        return pulumi.get(self, "mysql")

    @mysql.setter
    def mysql(self, value: Optional[pulumi.Input['DataSourceParametersMysqlArgs']]):
        pulumi.set(self, "mysql", value)

    @property
    @pulumi.getter
    def oracle(self) -> Optional[pulumi.Input['DataSourceParametersOracleArgs']]:
        """
        Parameters for connecting to Oracle.
        """
        return pulumi.get(self, "oracle")

    @oracle.setter
    def oracle(self, value: Optional[pulumi.Input['DataSourceParametersOracleArgs']]):
        pulumi.set(self, "oracle", value)

    @property
    @pulumi.getter
    def postgresql(self) -> Optional[pulumi.Input['DataSourceParametersPostgresqlArgs']]:
        """
        Parameters for connecting to Postgresql.
        """
        return pulumi.get(self, "postgresql")

    @postgresql.setter
    def postgresql(self, value: Optional[pulumi.Input['DataSourceParametersPostgresqlArgs']]):
        pulumi.set(self, "postgresql", value)

    @property
    @pulumi.getter
    def presto(self) -> Optional[pulumi.Input['DataSourceParametersPrestoArgs']]:
        """
        Parameters for connecting to Presto.
        """
        return pulumi.get(self, "presto")

    @presto.setter
    def presto(self, value: Optional[pulumi.Input['DataSourceParametersPrestoArgs']]):
        pulumi.set(self, "presto", value)

    @property
    @pulumi.getter
    def rds(self) -> Optional[pulumi.Input['DataSourceParametersRdsArgs']]:
        """
        Parameters for connecting to RDS.
        """
        return pulumi.get(self, "rds")

    @rds.setter
    def rds(self, value: Optional[pulumi.Input['DataSourceParametersRdsArgs']]):
        pulumi.set(self, "rds", value)

    @property
    @pulumi.getter
    def redshift(self) -> Optional[pulumi.Input['DataSourceParametersRedshiftArgs']]:
        """
        Parameters for connecting to Redshift.
        """
        return pulumi.get(self, "redshift")

    @redshift.setter
    def redshift(self, value: Optional[pulumi.Input['DataSourceParametersRedshiftArgs']]):
        pulumi.set(self, "redshift", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['DataSourceParametersS3Args']]:
        """
        Parameters for connecting to S3.
        """
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['DataSourceParametersS3Args']]):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter(name="serviceNow")
    def service_now(self) -> Optional[pulumi.Input['DataSourceParametersServiceNowArgs']]:
        """
        Parameters for connecting to ServiceNow.
        """
        return pulumi.get(self, "service_now")

    @service_now.setter
    def service_now(self, value: Optional[pulumi.Input['DataSourceParametersServiceNowArgs']]):
        pulumi.set(self, "service_now", value)

    @property
    @pulumi.getter
    def snowflake(self) -> Optional[pulumi.Input['DataSourceParametersSnowflakeArgs']]:
        """
        Parameters for connecting to Snowflake.
        """
        return pulumi.get(self, "snowflake")

    @snowflake.setter
    def snowflake(self, value: Optional[pulumi.Input['DataSourceParametersSnowflakeArgs']]):
        pulumi.set(self, "snowflake", value)

    @property
    @pulumi.getter
    def spark(self) -> Optional[pulumi.Input['DataSourceParametersSparkArgs']]:
        """
        Parameters for connecting to Spark.
        """
        return pulumi.get(self, "spark")

    @spark.setter
    def spark(self, value: Optional[pulumi.Input['DataSourceParametersSparkArgs']]):
        pulumi.set(self, "spark", value)

    @property
    @pulumi.getter(name="sqlServer")
    def sql_server(self) -> Optional[pulumi.Input['DataSourceParametersSqlServerArgs']]:
        """
        Parameters for connecting to SQL Server.
        """
        return pulumi.get(self, "sql_server")

    @sql_server.setter
    def sql_server(self, value: Optional[pulumi.Input['DataSourceParametersSqlServerArgs']]):
        pulumi.set(self, "sql_server", value)

    @property
    @pulumi.getter
    def teradata(self) -> Optional[pulumi.Input['DataSourceParametersTeradataArgs']]:
        """
        Parameters for connecting to Teradata.
        """
        return pulumi.get(self, "teradata")

    @teradata.setter
    def teradata(self, value: Optional[pulumi.Input['DataSourceParametersTeradataArgs']]):
        pulumi.set(self, "teradata", value)

    @property
    @pulumi.getter
    def twitter(self) -> Optional[pulumi.Input['DataSourceParametersTwitterArgs']]:
        """
        Parameters for connecting to Twitter.
        """
        return pulumi.get(self, "twitter")

    @twitter.setter
    def twitter(self, value: Optional[pulumi.Input['DataSourceParametersTwitterArgs']]):
        pulumi.set(self, "twitter", value)


if not MYPY:
    class DataSourceParametersAmazonElasticsearchArgsDict(TypedDict):
        domain: pulumi.Input[builtins.str]
        """
        The OpenSearch domain.
        """
elif False:
    DataSourceParametersAmazonElasticsearchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersAmazonElasticsearchArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] domain: The OpenSearch domain.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[builtins.str]:
        """
        The OpenSearch domain.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class DataSourceParametersAthenaArgsDict(TypedDict):
        work_group: NotRequired[pulumi.Input[builtins.str]]
        """
        The work-group to which to connect.
        """
elif False:
    DataSourceParametersAthenaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersAthenaArgs:
    def __init__(__self__, *,
                 work_group: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] work_group: The work-group to which to connect.
        """
        if work_group is not None:
            pulumi.set(__self__, "work_group", work_group)

    @property
    @pulumi.getter(name="workGroup")
    def work_group(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The work-group to which to connect.
        """
        return pulumi.get(self, "work_group")

    @work_group.setter
    def work_group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "work_group", value)


if not MYPY:
    class DataSourceParametersAuroraArgsDict(TypedDict):
        database: pulumi.Input[builtins.str]
        """
        The database to which to connect.
        """
        host: pulumi.Input[builtins.str]
        """
        The host to which to connect.
        """
        port: pulumi.Input[builtins.int]
        """
        The port to which to connect.
        """
elif False:
    DataSourceParametersAuroraArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersAuroraArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[builtins.str],
                 host: pulumi.Input[builtins.str],
                 port: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.str] database: The database to which to connect.
        :param pulumi.Input[builtins.str] host: The host to which to connect.
        :param pulumi.Input[builtins.int] port: The port to which to connect.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[builtins.str]:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[builtins.str]:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.int]:
        """
        The port to which to connect.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersAuroraPostgresqlArgsDict(TypedDict):
        database: pulumi.Input[builtins.str]
        """
        The database to which to connect.
        """
        host: pulumi.Input[builtins.str]
        """
        The host to which to connect.
        """
        port: pulumi.Input[builtins.int]
        """
        The port to which to connect.
        """
elif False:
    DataSourceParametersAuroraPostgresqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersAuroraPostgresqlArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[builtins.str],
                 host: pulumi.Input[builtins.str],
                 port: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.str] database: The database to which to connect.
        :param pulumi.Input[builtins.str] host: The host to which to connect.
        :param pulumi.Input[builtins.int] port: The port to which to connect.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[builtins.str]:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[builtins.str]:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.int]:
        """
        The port to which to connect.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersAwsIotAnalyticsArgsDict(TypedDict):
        data_set_name: pulumi.Input[builtins.str]
        """
        The name of the data set to which to connect.
        """
elif False:
    DataSourceParametersAwsIotAnalyticsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersAwsIotAnalyticsArgs:
    def __init__(__self__, *,
                 data_set_name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] data_set_name: The name of the data set to which to connect.
        """
        pulumi.set(__self__, "data_set_name", data_set_name)

    @property
    @pulumi.getter(name="dataSetName")
    def data_set_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the data set to which to connect.
        """
        return pulumi.get(self, "data_set_name")

    @data_set_name.setter
    def data_set_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data_set_name", value)


if not MYPY:
    class DataSourceParametersDatabricksArgsDict(TypedDict):
        host: pulumi.Input[builtins.str]
        """
        The host name of the Databricks data source.
        """
        port: pulumi.Input[builtins.int]
        """
        The port for the Databricks data source.
        """
        sql_endpoint_path: pulumi.Input[builtins.str]
        """
        The HTTP path of the Databricks data source.
        """
elif False:
    DataSourceParametersDatabricksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersDatabricksArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[builtins.str],
                 port: pulumi.Input[builtins.int],
                 sql_endpoint_path: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] host: The host name of the Databricks data source.
        :param pulumi.Input[builtins.int] port: The port for the Databricks data source.
        :param pulumi.Input[builtins.str] sql_endpoint_path: The HTTP path of the Databricks data source.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "sql_endpoint_path", sql_endpoint_path)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[builtins.str]:
        """
        The host name of the Databricks data source.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.int]:
        """
        The port for the Databricks data source.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sqlEndpointPath")
    def sql_endpoint_path(self) -> pulumi.Input[builtins.str]:
        """
        The HTTP path of the Databricks data source.
        """
        return pulumi.get(self, "sql_endpoint_path")

    @sql_endpoint_path.setter
    def sql_endpoint_path(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "sql_endpoint_path", value)


if not MYPY:
    class DataSourceParametersJiraArgsDict(TypedDict):
        site_base_url: pulumi.Input[builtins.str]
        """
        The base URL of the Jira instance's site to which to connect.
        """
elif False:
    DataSourceParametersJiraArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersJiraArgs:
    def __init__(__self__, *,
                 site_base_url: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] site_base_url: The base URL of the Jira instance's site to which to connect.
        """
        pulumi.set(__self__, "site_base_url", site_base_url)

    @property
    @pulumi.getter(name="siteBaseUrl")
    def site_base_url(self) -> pulumi.Input[builtins.str]:
        """
        The base URL of the Jira instance's site to which to connect.
        """
        return pulumi.get(self, "site_base_url")

    @site_base_url.setter
    def site_base_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "site_base_url", value)


if not MYPY:
    class DataSourceParametersMariaDbArgsDict(TypedDict):
        database: pulumi.Input[builtins.str]
        """
        The database to which to connect.
        """
        host: pulumi.Input[builtins.str]
        """
        The host to which to connect.
        """
        port: pulumi.Input[builtins.int]
        """
        The port to which to connect.
        """
elif False:
    DataSourceParametersMariaDbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersMariaDbArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[builtins.str],
                 host: pulumi.Input[builtins.str],
                 port: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.str] database: The database to which to connect.
        :param pulumi.Input[builtins.str] host: The host to which to connect.
        :param pulumi.Input[builtins.int] port: The port to which to connect.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[builtins.str]:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[builtins.str]:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.int]:
        """
        The port to which to connect.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersMysqlArgsDict(TypedDict):
        database: pulumi.Input[builtins.str]
        """
        The database to which to connect.
        """
        host: pulumi.Input[builtins.str]
        """
        The host to which to connect.
        """
        port: pulumi.Input[builtins.int]
        """
        The port to which to connect.
        """
elif False:
    DataSourceParametersMysqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersMysqlArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[builtins.str],
                 host: pulumi.Input[builtins.str],
                 port: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.str] database: The database to which to connect.
        :param pulumi.Input[builtins.str] host: The host to which to connect.
        :param pulumi.Input[builtins.int] port: The port to which to connect.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[builtins.str]:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[builtins.str]:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.int]:
        """
        The port to which to connect.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersOracleArgsDict(TypedDict):
        database: pulumi.Input[builtins.str]
        """
        The database to which to connect.
        """
        host: pulumi.Input[builtins.str]
        """
        The host to which to connect.
        """
        port: pulumi.Input[builtins.int]
        """
        The port to which to connect.
        """
elif False:
    DataSourceParametersOracleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersOracleArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[builtins.str],
                 host: pulumi.Input[builtins.str],
                 port: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.str] database: The database to which to connect.
        :param pulumi.Input[builtins.str] host: The host to which to connect.
        :param pulumi.Input[builtins.int] port: The port to which to connect.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[builtins.str]:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[builtins.str]:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.int]:
        """
        The port to which to connect.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersPostgresqlArgsDict(TypedDict):
        database: pulumi.Input[builtins.str]
        """
        The database to which to connect.
        """
        host: pulumi.Input[builtins.str]
        """
        The host to which to connect.
        """
        port: pulumi.Input[builtins.int]
        """
        The port to which to connect.
        """
elif False:
    DataSourceParametersPostgresqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersPostgresqlArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[builtins.str],
                 host: pulumi.Input[builtins.str],
                 port: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.str] database: The database to which to connect.
        :param pulumi.Input[builtins.str] host: The host to which to connect.
        :param pulumi.Input[builtins.int] port: The port to which to connect.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[builtins.str]:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[builtins.str]:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.int]:
        """
        The port to which to connect.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersPrestoArgsDict(TypedDict):
        catalog: pulumi.Input[builtins.str]
        """
        The catalog to which to connect.
        """
        host: pulumi.Input[builtins.str]
        """
        The host to which to connect.
        """
        port: pulumi.Input[builtins.int]
        """
        The port to which to connect.
        """
elif False:
    DataSourceParametersPrestoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersPrestoArgs:
    def __init__(__self__, *,
                 catalog: pulumi.Input[builtins.str],
                 host: pulumi.Input[builtins.str],
                 port: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.str] catalog: The catalog to which to connect.
        :param pulumi.Input[builtins.str] host: The host to which to connect.
        :param pulumi.Input[builtins.int] port: The port to which to connect.
        """
        pulumi.set(__self__, "catalog", catalog)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def catalog(self) -> pulumi.Input[builtins.str]:
        """
        The catalog to which to connect.
        """
        return pulumi.get(self, "catalog")

    @catalog.setter
    def catalog(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "catalog", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[builtins.str]:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.int]:
        """
        The port to which to connect.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersRdsArgsDict(TypedDict):
        database: pulumi.Input[builtins.str]
        """
        The database to which to connect.
        """
        instance_id: pulumi.Input[builtins.str]
        """
        The instance ID to which to connect.
        """
elif False:
    DataSourceParametersRdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersRdsArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[builtins.str],
                 instance_id: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] database: The database to which to connect.
        :param pulumi.Input[builtins.str] instance_id: The instance ID to which to connect.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "instance_id", instance_id)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[builtins.str]:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[builtins.str]:
        """
        The instance ID to which to connect.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "instance_id", value)


if not MYPY:
    class DataSourceParametersRedshiftArgsDict(TypedDict):
        database: pulumi.Input[builtins.str]
        """
        The database to which to connect.
        """
        cluster_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the cluster to which to connect.
        """
        host: NotRequired[pulumi.Input[builtins.str]]
        """
        The host to which to connect.
        """
        port: NotRequired[pulumi.Input[builtins.int]]
        """
        The port to which to connect.
        """
elif False:
    DataSourceParametersRedshiftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersRedshiftArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[builtins.str],
                 cluster_id: Optional[pulumi.Input[builtins.str]] = None,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] database: The database to which to connect.
        :param pulumi.Input[builtins.str] cluster_id: The ID of the cluster to which to connect.
        :param pulumi.Input[builtins.str] host: The host to which to connect.
        :param pulumi.Input[builtins.int] port: The port to which to connect.
        """
        pulumi.set(__self__, "database", database)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[builtins.str]:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the cluster to which to connect.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The port to which to connect.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersS3ArgsDict(TypedDict):
        manifest_file_location: pulumi.Input['DataSourceParametersS3ManifestFileLocationArgsDict']
        """
        An object containing the S3 location of the S3 manifest file.
        """
        role_arn: NotRequired[pulumi.Input[builtins.str]]
        """
        Use the `role_arn` to override an account-wide role for a specific S3 data source. For example, say an account administrator has turned off all S3 access with an account-wide role. The administrator can then use `role_arn` to bypass the account-wide role and allow S3 access for the single S3 data source that is specified in the structure, even if the account-wide role forbidding S3 access is still active.
        """
elif False:
    DataSourceParametersS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersS3Args:
    def __init__(__self__, *,
                 manifest_file_location: pulumi.Input['DataSourceParametersS3ManifestFileLocationArgs'],
                 role_arn: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input['DataSourceParametersS3ManifestFileLocationArgs'] manifest_file_location: An object containing the S3 location of the S3 manifest file.
        :param pulumi.Input[builtins.str] role_arn: Use the `role_arn` to override an account-wide role for a specific S3 data source. For example, say an account administrator has turned off all S3 access with an account-wide role. The administrator can then use `role_arn` to bypass the account-wide role and allow S3 access for the single S3 data source that is specified in the structure, even if the account-wide role forbidding S3 access is still active.
        """
        pulumi.set(__self__, "manifest_file_location", manifest_file_location)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="manifestFileLocation")
    def manifest_file_location(self) -> pulumi.Input['DataSourceParametersS3ManifestFileLocationArgs']:
        """
        An object containing the S3 location of the S3 manifest file.
        """
        return pulumi.get(self, "manifest_file_location")

    @manifest_file_location.setter
    def manifest_file_location(self, value: pulumi.Input['DataSourceParametersS3ManifestFileLocationArgs']):
        pulumi.set(self, "manifest_file_location", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Use the `role_arn` to override an account-wide role for a specific S3 data source. For example, say an account administrator has turned off all S3 access with an account-wide role. The administrator can then use `role_arn` to bypass the account-wide role and allow S3 access for the single S3 data source that is specified in the structure, even if the account-wide role forbidding S3 access is still active.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class DataSourceParametersS3ManifestFileLocationArgsDict(TypedDict):
        bucket: pulumi.Input[builtins.str]
        """
        The name of the bucket that contains the manifest file.
        """
        key: pulumi.Input[builtins.str]
        """
        The key of the manifest file within the bucket.
        """
elif False:
    DataSourceParametersS3ManifestFileLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersS3ManifestFileLocationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[builtins.str],
                 key: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] bucket: The name of the bucket that contains the manifest file.
        :param pulumi.Input[builtins.str] key: The key of the manifest file within the bucket.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[builtins.str]:
        """
        The name of the bucket that contains the manifest file.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        The key of the manifest file within the bucket.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class DataSourceParametersServiceNowArgsDict(TypedDict):
        site_base_url: pulumi.Input[builtins.str]
        """
        The base URL of the Jira instance's site to which to connect.
        """
elif False:
    DataSourceParametersServiceNowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersServiceNowArgs:
    def __init__(__self__, *,
                 site_base_url: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] site_base_url: The base URL of the Jira instance's site to which to connect.
        """
        pulumi.set(__self__, "site_base_url", site_base_url)

    @property
    @pulumi.getter(name="siteBaseUrl")
    def site_base_url(self) -> pulumi.Input[builtins.str]:
        """
        The base URL of the Jira instance's site to which to connect.
        """
        return pulumi.get(self, "site_base_url")

    @site_base_url.setter
    def site_base_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "site_base_url", value)


if not MYPY:
    class DataSourceParametersSnowflakeArgsDict(TypedDict):
        database: pulumi.Input[builtins.str]
        """
        The database to which to connect.
        """
        host: pulumi.Input[builtins.str]
        """
        The host to which to connect.
        """
        warehouse: pulumi.Input[builtins.str]
        """
        The warehouse to which to connect.
        """
elif False:
    DataSourceParametersSnowflakeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersSnowflakeArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[builtins.str],
                 host: pulumi.Input[builtins.str],
                 warehouse: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] database: The database to which to connect.
        :param pulumi.Input[builtins.str] host: The host to which to connect.
        :param pulumi.Input[builtins.str] warehouse: The warehouse to which to connect.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "warehouse", warehouse)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[builtins.str]:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[builtins.str]:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def warehouse(self) -> pulumi.Input[builtins.str]:
        """
        The warehouse to which to connect.
        """
        return pulumi.get(self, "warehouse")

    @warehouse.setter
    def warehouse(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "warehouse", value)


if not MYPY:
    class DataSourceParametersSparkArgsDict(TypedDict):
        host: pulumi.Input[builtins.str]
        """
        The host to which to connect.
        """
        port: pulumi.Input[builtins.int]
        """
        The warehouse to which to connect.
        """
elif False:
    DataSourceParametersSparkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersSparkArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[builtins.str],
                 port: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.str] host: The host to which to connect.
        :param pulumi.Input[builtins.int] port: The warehouse to which to connect.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[builtins.str]:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.int]:
        """
        The warehouse to which to connect.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersSqlServerArgsDict(TypedDict):
        database: pulumi.Input[builtins.str]
        """
        The database to which to connect.
        """
        host: pulumi.Input[builtins.str]
        """
        The host to which to connect.
        """
        port: pulumi.Input[builtins.int]
        """
        The warehouse to which to connect.
        """
elif False:
    DataSourceParametersSqlServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersSqlServerArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[builtins.str],
                 host: pulumi.Input[builtins.str],
                 port: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.str] database: The database to which to connect.
        :param pulumi.Input[builtins.str] host: The host to which to connect.
        :param pulumi.Input[builtins.int] port: The warehouse to which to connect.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[builtins.str]:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[builtins.str]:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.int]:
        """
        The warehouse to which to connect.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersTeradataArgsDict(TypedDict):
        database: pulumi.Input[builtins.str]
        """
        The database to which to connect.
        """
        host: pulumi.Input[builtins.str]
        """
        The host to which to connect.
        """
        port: pulumi.Input[builtins.int]
        """
        The warehouse to which to connect.
        """
elif False:
    DataSourceParametersTeradataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersTeradataArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[builtins.str],
                 host: pulumi.Input[builtins.str],
                 port: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.str] database: The database to which to connect.
        :param pulumi.Input[builtins.str] host: The host to which to connect.
        :param pulumi.Input[builtins.int] port: The warehouse to which to connect.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[builtins.str]:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[builtins.str]:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.int]:
        """
        The warehouse to which to connect.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersTwitterArgsDict(TypedDict):
        max_rows: pulumi.Input[builtins.int]
        """
        The maximum number of rows to query.
        """
        query: pulumi.Input[builtins.str]
        """
        The Twitter query to retrieve the data.
        """
elif False:
    DataSourceParametersTwitterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersTwitterArgs:
    def __init__(__self__, *,
                 max_rows: pulumi.Input[builtins.int],
                 query: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.int] max_rows: The maximum number of rows to query.
        :param pulumi.Input[builtins.str] query: The Twitter query to retrieve the data.
        """
        pulumi.set(__self__, "max_rows", max_rows)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter(name="maxRows")
    def max_rows(self) -> pulumi.Input[builtins.int]:
        """
        The maximum number of rows to query.
        """
        return pulumi.get(self, "max_rows")

    @max_rows.setter
    def max_rows(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "max_rows", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[builtins.str]:
        """
        The Twitter query to retrieve the data.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "query", value)


if not MYPY:
    class DataSourcePermissionArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Set of IAM actions to grant or revoke permissions on. Max of 16 items.
        """
        principal: pulumi.Input[builtins.str]
        """
        The Amazon Resource Name (ARN) of the principal.
        """
elif False:
    DataSourcePermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourcePermissionArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 principal: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: Set of IAM actions to grant or revoke permissions on. Max of 16 items.
        :param pulumi.Input[builtins.str] principal: The Amazon Resource Name (ARN) of the principal.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "principal", principal)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Set of IAM actions to grant or revoke permissions on. Max of 16 items.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def principal(self) -> pulumi.Input[builtins.str]:
        """
        The Amazon Resource Name (ARN) of the principal.
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class DataSourceSslPropertiesArgsDict(TypedDict):
        disable_ssl: pulumi.Input[builtins.bool]
        """
        A Boolean option to control whether SSL should be disabled.
        """
elif False:
    DataSourceSslPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceSslPropertiesArgs:
    def __init__(__self__, *,
                 disable_ssl: pulumi.Input[builtins.bool]):
        """
        :param pulumi.Input[builtins.bool] disable_ssl: A Boolean option to control whether SSL should be disabled.
        """
        pulumi.set(__self__, "disable_ssl", disable_ssl)

    @property
    @pulumi.getter(name="disableSsl")
    def disable_ssl(self) -> pulumi.Input[builtins.bool]:
        """
        A Boolean option to control whether SSL should be disabled.
        """
        return pulumi.get(self, "disable_ssl")

    @disable_ssl.setter
    def disable_ssl(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "disable_ssl", value)


if not MYPY:
    class DataSourceVpcConnectionPropertiesArgsDict(TypedDict):
        vpc_connection_arn: pulumi.Input[builtins.str]
        """
        The Amazon Resource Name (ARN) for the VPC connection.
        """
elif False:
    DataSourceVpcConnectionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceVpcConnectionPropertiesArgs:
    def __init__(__self__, *,
                 vpc_connection_arn: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] vpc_connection_arn: The Amazon Resource Name (ARN) for the VPC connection.
        """
        pulumi.set(__self__, "vpc_connection_arn", vpc_connection_arn)

    @property
    @pulumi.getter(name="vpcConnectionArn")
    def vpc_connection_arn(self) -> pulumi.Input[builtins.str]:
        """
        The Amazon Resource Name (ARN) for the VPC connection.
        """
        return pulumi.get(self, "vpc_connection_arn")

    @vpc_connection_arn.setter
    def vpc_connection_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "vpc_connection_arn", value)


if not MYPY:
    class FolderPermissionArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        List of IAM actions to grant or revoke permissions on.
        """
        principal: pulumi.Input[builtins.str]
        """
        ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
elif False:
    FolderPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FolderPermissionArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 principal: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: List of IAM actions to grant or revoke permissions on.
        :param pulumi.Input[builtins.str] principal: ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "principal", principal)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        List of IAM actions to grant or revoke permissions on.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def principal(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class IamPolicyAssignmentIdentitiesArgsDict(TypedDict):
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Array of Quicksight group names to assign the policy to.
        """
        users: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Array of Quicksight user names to assign the policy to.
        """
elif False:
    IamPolicyAssignmentIdentitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamPolicyAssignmentIdentitiesArgs:
    def __init__(__self__, *,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] groups: Array of Quicksight group names to assign the policy to.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] users: Array of Quicksight user names to assign the policy to.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Array of Quicksight group names to assign the policy to.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Array of Quicksight user names to assign the policy to.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "users", value)


if not MYPY:
    class NamespaceTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    NamespaceTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class RefreshScheduleScheduleArgsDict(TypedDict):
        refresh_type: pulumi.Input[builtins.str]
        """
        The type of refresh that the dataset undergoes. Valid values are `INCREMENTAL_REFRESH` and `FULL_REFRESH`.
        """
        schedule_frequency: NotRequired[pulumi.Input['RefreshScheduleScheduleScheduleFrequencyArgsDict']]
        """
        The configuration of the [schedule frequency](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_RefreshFrequency.html). See schedule_frequency.
        """
        start_after_date_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Time after which the refresh schedule can be started, expressed in `YYYY-MM-DDTHH:MM:SS` format.
        """
elif False:
    RefreshScheduleScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RefreshScheduleScheduleArgs:
    def __init__(__self__, *,
                 refresh_type: pulumi.Input[builtins.str],
                 schedule_frequency: Optional[pulumi.Input['RefreshScheduleScheduleScheduleFrequencyArgs']] = None,
                 start_after_date_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] refresh_type: The type of refresh that the dataset undergoes. Valid values are `INCREMENTAL_REFRESH` and `FULL_REFRESH`.
        :param pulumi.Input['RefreshScheduleScheduleScheduleFrequencyArgs'] schedule_frequency: The configuration of the [schedule frequency](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_RefreshFrequency.html). See schedule_frequency.
        :param pulumi.Input[builtins.str] start_after_date_time: Time after which the refresh schedule can be started, expressed in `YYYY-MM-DDTHH:MM:SS` format.
        """
        pulumi.set(__self__, "refresh_type", refresh_type)
        if schedule_frequency is not None:
            pulumi.set(__self__, "schedule_frequency", schedule_frequency)
        if start_after_date_time is not None:
            pulumi.set(__self__, "start_after_date_time", start_after_date_time)

    @property
    @pulumi.getter(name="refreshType")
    def refresh_type(self) -> pulumi.Input[builtins.str]:
        """
        The type of refresh that the dataset undergoes. Valid values are `INCREMENTAL_REFRESH` and `FULL_REFRESH`.
        """
        return pulumi.get(self, "refresh_type")

    @refresh_type.setter
    def refresh_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "refresh_type", value)

    @property
    @pulumi.getter(name="scheduleFrequency")
    def schedule_frequency(self) -> Optional[pulumi.Input['RefreshScheduleScheduleScheduleFrequencyArgs']]:
        """
        The configuration of the [schedule frequency](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_RefreshFrequency.html). See schedule_frequency.
        """
        return pulumi.get(self, "schedule_frequency")

    @schedule_frequency.setter
    def schedule_frequency(self, value: Optional[pulumi.Input['RefreshScheduleScheduleScheduleFrequencyArgs']]):
        pulumi.set(self, "schedule_frequency", value)

    @property
    @pulumi.getter(name="startAfterDateTime")
    def start_after_date_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time after which the refresh schedule can be started, expressed in `YYYY-MM-DDTHH:MM:SS` format.
        """
        return pulumi.get(self, "start_after_date_time")

    @start_after_date_time.setter
    def start_after_date_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_after_date_time", value)


if not MYPY:
    class RefreshScheduleScheduleScheduleFrequencyArgsDict(TypedDict):
        interval: pulumi.Input[builtins.str]
        """
        The interval between scheduled refreshes. Valid values are `MINUTE15`, `MINUTE30`, `HOURLY`, `DAILY`, `WEEKLY` and `MONTHLY`.
        """
        refresh_on_day: NotRequired[pulumi.Input['RefreshScheduleScheduleScheduleFrequencyRefreshOnDayArgsDict']]
        """
        The [refresh on entity](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ScheduleRefreshOnEntity.html) configuration for weekly or monthly schedules. See refresh_on_day.
        """
        time_of_the_day: NotRequired[pulumi.Input[builtins.str]]
        """
        The time of day that you want the dataset to refresh. This value is expressed in `HH:MM` format. This field is not required for schedules that refresh hourly.
        """
        timezone: NotRequired[pulumi.Input[builtins.str]]
        """
        The timezone that you want the refresh schedule to use.
        """
elif False:
    RefreshScheduleScheduleScheduleFrequencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RefreshScheduleScheduleScheduleFrequencyArgs:
    def __init__(__self__, *,
                 interval: pulumi.Input[builtins.str],
                 refresh_on_day: Optional[pulumi.Input['RefreshScheduleScheduleScheduleFrequencyRefreshOnDayArgs']] = None,
                 time_of_the_day: Optional[pulumi.Input[builtins.str]] = None,
                 timezone: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] interval: The interval between scheduled refreshes. Valid values are `MINUTE15`, `MINUTE30`, `HOURLY`, `DAILY`, `WEEKLY` and `MONTHLY`.
        :param pulumi.Input['RefreshScheduleScheduleScheduleFrequencyRefreshOnDayArgs'] refresh_on_day: The [refresh on entity](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ScheduleRefreshOnEntity.html) configuration for weekly or monthly schedules. See refresh_on_day.
        :param pulumi.Input[builtins.str] time_of_the_day: The time of day that you want the dataset to refresh. This value is expressed in `HH:MM` format. This field is not required for schedules that refresh hourly.
        :param pulumi.Input[builtins.str] timezone: The timezone that you want the refresh schedule to use.
        """
        pulumi.set(__self__, "interval", interval)
        if refresh_on_day is not None:
            pulumi.set(__self__, "refresh_on_day", refresh_on_day)
        if time_of_the_day is not None:
            pulumi.set(__self__, "time_of_the_day", time_of_the_day)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[builtins.str]:
        """
        The interval between scheduled refreshes. Valid values are `MINUTE15`, `MINUTE30`, `HOURLY`, `DAILY`, `WEEKLY` and `MONTHLY`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="refreshOnDay")
    def refresh_on_day(self) -> Optional[pulumi.Input['RefreshScheduleScheduleScheduleFrequencyRefreshOnDayArgs']]:
        """
        The [refresh on entity](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ScheduleRefreshOnEntity.html) configuration for weekly or monthly schedules. See refresh_on_day.
        """
        return pulumi.get(self, "refresh_on_day")

    @refresh_on_day.setter
    def refresh_on_day(self, value: Optional[pulumi.Input['RefreshScheduleScheduleScheduleFrequencyRefreshOnDayArgs']]):
        pulumi.set(self, "refresh_on_day", value)

    @property
    @pulumi.getter(name="timeOfTheDay")
    def time_of_the_day(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The time of day that you want the dataset to refresh. This value is expressed in `HH:MM` format. This field is not required for schedules that refresh hourly.
        """
        return pulumi.get(self, "time_of_the_day")

    @time_of_the_day.setter
    def time_of_the_day(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_of_the_day", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The timezone that you want the refresh schedule to use.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class RefreshScheduleScheduleScheduleFrequencyRefreshOnDayArgsDict(TypedDict):
        day_of_month: NotRequired[pulumi.Input[builtins.str]]
        """
        The day of the month that you want to schedule refresh on.
        """
        day_of_week: NotRequired[pulumi.Input[builtins.str]]
        """
        The day of the week that you want to schedule a refresh on. Valid values are `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY` and `SATURDAY`.
        """
elif False:
    RefreshScheduleScheduleScheduleFrequencyRefreshOnDayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RefreshScheduleScheduleScheduleFrequencyRefreshOnDayArgs:
    def __init__(__self__, *,
                 day_of_month: Optional[pulumi.Input[builtins.str]] = None,
                 day_of_week: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] day_of_month: The day of the month that you want to schedule refresh on.
        :param pulumi.Input[builtins.str] day_of_week: The day of the week that you want to schedule a refresh on. Valid values are `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY` and `SATURDAY`.
        """
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The day of the month that you want to schedule refresh on.
        """
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The day of the week that you want to schedule a refresh on. Valid values are `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY` and `SATURDAY`.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "day_of_week", value)


if not MYPY:
    class TemplatePermissionArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        List of IAM actions to grant or revoke permissions on.
        """
        principal: pulumi.Input[builtins.str]
        """
        ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
elif False:
    TemplatePermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplatePermissionArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 principal: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: List of IAM actions to grant or revoke permissions on.
        :param pulumi.Input[builtins.str] principal: ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "principal", principal)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        List of IAM actions to grant or revoke permissions on.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def principal(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class TemplateSourceEntityArgsDict(TypedDict):
        source_analysis: NotRequired[pulumi.Input['TemplateSourceEntitySourceAnalysisArgsDict']]
        """
        The source analysis, if it is based on an analysis.. Only one of `source_analysis` or `source_template` should be configured. See source_analysis.
        """
        source_template: NotRequired[pulumi.Input['TemplateSourceEntitySourceTemplateArgsDict']]
        """
        The source template, if it is based on an template.. Only one of `source_analysis` or `source_template` should be configured. See source_template.
        """
elif False:
    TemplateSourceEntityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateSourceEntityArgs:
    def __init__(__self__, *,
                 source_analysis: Optional[pulumi.Input['TemplateSourceEntitySourceAnalysisArgs']] = None,
                 source_template: Optional[pulumi.Input['TemplateSourceEntitySourceTemplateArgs']] = None):
        """
        :param pulumi.Input['TemplateSourceEntitySourceAnalysisArgs'] source_analysis: The source analysis, if it is based on an analysis.. Only one of `source_analysis` or `source_template` should be configured. See source_analysis.
        :param pulumi.Input['TemplateSourceEntitySourceTemplateArgs'] source_template: The source template, if it is based on an template.. Only one of `source_analysis` or `source_template` should be configured. See source_template.
        """
        if source_analysis is not None:
            pulumi.set(__self__, "source_analysis", source_analysis)
        if source_template is not None:
            pulumi.set(__self__, "source_template", source_template)

    @property
    @pulumi.getter(name="sourceAnalysis")
    def source_analysis(self) -> Optional[pulumi.Input['TemplateSourceEntitySourceAnalysisArgs']]:
        """
        The source analysis, if it is based on an analysis.. Only one of `source_analysis` or `source_template` should be configured. See source_analysis.
        """
        return pulumi.get(self, "source_analysis")

    @source_analysis.setter
    def source_analysis(self, value: Optional[pulumi.Input['TemplateSourceEntitySourceAnalysisArgs']]):
        pulumi.set(self, "source_analysis", value)

    @property
    @pulumi.getter(name="sourceTemplate")
    def source_template(self) -> Optional[pulumi.Input['TemplateSourceEntitySourceTemplateArgs']]:
        """
        The source template, if it is based on an template.. Only one of `source_analysis` or `source_template` should be configured. See source_template.
        """
        return pulumi.get(self, "source_template")

    @source_template.setter
    def source_template(self, value: Optional[pulumi.Input['TemplateSourceEntitySourceTemplateArgs']]):
        pulumi.set(self, "source_template", value)


if not MYPY:
    class TemplateSourceEntitySourceAnalysisArgsDict(TypedDict):
        arn: pulumi.Input[builtins.str]
        """
        The Amazon Resource Name (ARN) of the resource.
        """
        data_set_references: pulumi.Input[Sequence[pulumi.Input['TemplateSourceEntitySourceAnalysisDataSetReferenceArgsDict']]]
        """
        A list of dataset references used as placeholders in the template. See data_set_references.
        """
elif False:
    TemplateSourceEntitySourceAnalysisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateSourceEntitySourceAnalysisArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[builtins.str],
                 data_set_references: pulumi.Input[Sequence[pulumi.Input['TemplateSourceEntitySourceAnalysisDataSetReferenceArgs']]]):
        """
        :param pulumi.Input[builtins.str] arn: The Amazon Resource Name (ARN) of the resource.
        :param pulumi.Input[Sequence[pulumi.Input['TemplateSourceEntitySourceAnalysisDataSetReferenceArgs']]] data_set_references: A list of dataset references used as placeholders in the template. See data_set_references.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "data_set_references", data_set_references)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[builtins.str]:
        """
        The Amazon Resource Name (ARN) of the resource.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="dataSetReferences")
    def data_set_references(self) -> pulumi.Input[Sequence[pulumi.Input['TemplateSourceEntitySourceAnalysisDataSetReferenceArgs']]]:
        """
        A list of dataset references used as placeholders in the template. See data_set_references.
        """
        return pulumi.get(self, "data_set_references")

    @data_set_references.setter
    def data_set_references(self, value: pulumi.Input[Sequence[pulumi.Input['TemplateSourceEntitySourceAnalysisDataSetReferenceArgs']]]):
        pulumi.set(self, "data_set_references", value)


if not MYPY:
    class TemplateSourceEntitySourceAnalysisDataSetReferenceArgsDict(TypedDict):
        data_set_arn: pulumi.Input[builtins.str]
        """
        Dataset Amazon Resource Name (ARN).
        """
        data_set_placeholder: pulumi.Input[builtins.str]
        """
        Dataset placeholder.
        """
elif False:
    TemplateSourceEntitySourceAnalysisDataSetReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateSourceEntitySourceAnalysisDataSetReferenceArgs:
    def __init__(__self__, *,
                 data_set_arn: pulumi.Input[builtins.str],
                 data_set_placeholder: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] data_set_arn: Dataset Amazon Resource Name (ARN).
        :param pulumi.Input[builtins.str] data_set_placeholder: Dataset placeholder.
        """
        pulumi.set(__self__, "data_set_arn", data_set_arn)
        pulumi.set(__self__, "data_set_placeholder", data_set_placeholder)

    @property
    @pulumi.getter(name="dataSetArn")
    def data_set_arn(self) -> pulumi.Input[builtins.str]:
        """
        Dataset Amazon Resource Name (ARN).
        """
        return pulumi.get(self, "data_set_arn")

    @data_set_arn.setter
    def data_set_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data_set_arn", value)

    @property
    @pulumi.getter(name="dataSetPlaceholder")
    def data_set_placeholder(self) -> pulumi.Input[builtins.str]:
        """
        Dataset placeholder.
        """
        return pulumi.get(self, "data_set_placeholder")

    @data_set_placeholder.setter
    def data_set_placeholder(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data_set_placeholder", value)


if not MYPY:
    class TemplateSourceEntitySourceTemplateArgsDict(TypedDict):
        arn: pulumi.Input[builtins.str]
        """
        The Amazon Resource Name (ARN) of the resource.
        """
elif False:
    TemplateSourceEntitySourceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateSourceEntitySourceTemplateArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] arn: The Amazon Resource Name (ARN) of the resource.
        """
        pulumi.set(__self__, "arn", arn)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[builtins.str]:
        """
        The Amazon Resource Name (ARN) of the resource.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class ThemeConfigurationArgsDict(TypedDict):
        data_color_palette: NotRequired[pulumi.Input['ThemeConfigurationDataColorPaletteArgsDict']]
        """
        Color properties that apply to chart data colors. See data_color_palette.
        """
        sheet: NotRequired[pulumi.Input['ThemeConfigurationSheetArgsDict']]
        """
        Display options related to sheets. See sheet.
        """
        typography: NotRequired[pulumi.Input['ThemeConfigurationTypographyArgsDict']]
        """
        Determines the typography options. See typography.
        """
        ui_color_palette: NotRequired[pulumi.Input['ThemeConfigurationUiColorPaletteArgsDict']]
        """
        Color properties that apply to the UI and to charts, excluding the colors that apply to data. See ui_color_palette.
        """
elif False:
    ThemeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationArgs:
    def __init__(__self__, *,
                 data_color_palette: Optional[pulumi.Input['ThemeConfigurationDataColorPaletteArgs']] = None,
                 sheet: Optional[pulumi.Input['ThemeConfigurationSheetArgs']] = None,
                 typography: Optional[pulumi.Input['ThemeConfigurationTypographyArgs']] = None,
                 ui_color_palette: Optional[pulumi.Input['ThemeConfigurationUiColorPaletteArgs']] = None):
        """
        :param pulumi.Input['ThemeConfigurationDataColorPaletteArgs'] data_color_palette: Color properties that apply to chart data colors. See data_color_palette.
        :param pulumi.Input['ThemeConfigurationSheetArgs'] sheet: Display options related to sheets. See sheet.
        :param pulumi.Input['ThemeConfigurationTypographyArgs'] typography: Determines the typography options. See typography.
        :param pulumi.Input['ThemeConfigurationUiColorPaletteArgs'] ui_color_palette: Color properties that apply to the UI and to charts, excluding the colors that apply to data. See ui_color_palette.
        """
        if data_color_palette is not None:
            pulumi.set(__self__, "data_color_palette", data_color_palette)
        if sheet is not None:
            pulumi.set(__self__, "sheet", sheet)
        if typography is not None:
            pulumi.set(__self__, "typography", typography)
        if ui_color_palette is not None:
            pulumi.set(__self__, "ui_color_palette", ui_color_palette)

    @property
    @pulumi.getter(name="dataColorPalette")
    def data_color_palette(self) -> Optional[pulumi.Input['ThemeConfigurationDataColorPaletteArgs']]:
        """
        Color properties that apply to chart data colors. See data_color_palette.
        """
        return pulumi.get(self, "data_color_palette")

    @data_color_palette.setter
    def data_color_palette(self, value: Optional[pulumi.Input['ThemeConfigurationDataColorPaletteArgs']]):
        pulumi.set(self, "data_color_palette", value)

    @property
    @pulumi.getter
    def sheet(self) -> Optional[pulumi.Input['ThemeConfigurationSheetArgs']]:
        """
        Display options related to sheets. See sheet.
        """
        return pulumi.get(self, "sheet")

    @sheet.setter
    def sheet(self, value: Optional[pulumi.Input['ThemeConfigurationSheetArgs']]):
        pulumi.set(self, "sheet", value)

    @property
    @pulumi.getter
    def typography(self) -> Optional[pulumi.Input['ThemeConfigurationTypographyArgs']]:
        """
        Determines the typography options. See typography.
        """
        return pulumi.get(self, "typography")

    @typography.setter
    def typography(self, value: Optional[pulumi.Input['ThemeConfigurationTypographyArgs']]):
        pulumi.set(self, "typography", value)

    @property
    @pulumi.getter(name="uiColorPalette")
    def ui_color_palette(self) -> Optional[pulumi.Input['ThemeConfigurationUiColorPaletteArgs']]:
        """
        Color properties that apply to the UI and to charts, excluding the colors that apply to data. See ui_color_palette.
        """
        return pulumi.get(self, "ui_color_palette")

    @ui_color_palette.setter
    def ui_color_palette(self, value: Optional[pulumi.Input['ThemeConfigurationUiColorPaletteArgs']]):
        pulumi.set(self, "ui_color_palette", value)


if not MYPY:
    class ThemeConfigurationDataColorPaletteArgsDict(TypedDict):
        colors: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of hexadecimal codes for the colors. Minimum of 8 items and maximum of 20 items.
        """
        empty_fill_color: NotRequired[pulumi.Input[builtins.str]]
        """
        The hexadecimal code of a color that applies to charts where a lack of data is highlighted.
        """
        min_max_gradients: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The minimum and maximum hexadecimal codes that describe a color gradient. List of exactly 2 items.
        """
elif False:
    ThemeConfigurationDataColorPaletteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationDataColorPaletteArgs:
    def __init__(__self__, *,
                 colors: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 empty_fill_color: Optional[pulumi.Input[builtins.str]] = None,
                 min_max_gradients: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] colors: List of hexadecimal codes for the colors. Minimum of 8 items and maximum of 20 items.
        :param pulumi.Input[builtins.str] empty_fill_color: The hexadecimal code of a color that applies to charts where a lack of data is highlighted.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] min_max_gradients: The minimum and maximum hexadecimal codes that describe a color gradient. List of exactly 2 items.
        """
        if colors is not None:
            pulumi.set(__self__, "colors", colors)
        if empty_fill_color is not None:
            pulumi.set(__self__, "empty_fill_color", empty_fill_color)
        if min_max_gradients is not None:
            pulumi.set(__self__, "min_max_gradients", min_max_gradients)

    @property
    @pulumi.getter
    def colors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of hexadecimal codes for the colors. Minimum of 8 items and maximum of 20 items.
        """
        return pulumi.get(self, "colors")

    @colors.setter
    def colors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "colors", value)

    @property
    @pulumi.getter(name="emptyFillColor")
    def empty_fill_color(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The hexadecimal code of a color that applies to charts where a lack of data is highlighted.
        """
        return pulumi.get(self, "empty_fill_color")

    @empty_fill_color.setter
    def empty_fill_color(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "empty_fill_color", value)

    @property
    @pulumi.getter(name="minMaxGradients")
    def min_max_gradients(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The minimum and maximum hexadecimal codes that describe a color gradient. List of exactly 2 items.
        """
        return pulumi.get(self, "min_max_gradients")

    @min_max_gradients.setter
    def min_max_gradients(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "min_max_gradients", value)


if not MYPY:
    class ThemeConfigurationSheetArgsDict(TypedDict):
        tile: NotRequired[pulumi.Input['ThemeConfigurationSheetTileArgsDict']]
        """
        The display options for tiles. See tile.
        """
        tile_layout: NotRequired[pulumi.Input['ThemeConfigurationSheetTileLayoutArgsDict']]
        """
        The layout options for tiles. See tile_layout.
        """
elif False:
    ThemeConfigurationSheetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationSheetArgs:
    def __init__(__self__, *,
                 tile: Optional[pulumi.Input['ThemeConfigurationSheetTileArgs']] = None,
                 tile_layout: Optional[pulumi.Input['ThemeConfigurationSheetTileLayoutArgs']] = None):
        """
        :param pulumi.Input['ThemeConfigurationSheetTileArgs'] tile: The display options for tiles. See tile.
        :param pulumi.Input['ThemeConfigurationSheetTileLayoutArgs'] tile_layout: The layout options for tiles. See tile_layout.
        """
        if tile is not None:
            pulumi.set(__self__, "tile", tile)
        if tile_layout is not None:
            pulumi.set(__self__, "tile_layout", tile_layout)

    @property
    @pulumi.getter
    def tile(self) -> Optional[pulumi.Input['ThemeConfigurationSheetTileArgs']]:
        """
        The display options for tiles. See tile.
        """
        return pulumi.get(self, "tile")

    @tile.setter
    def tile(self, value: Optional[pulumi.Input['ThemeConfigurationSheetTileArgs']]):
        pulumi.set(self, "tile", value)

    @property
    @pulumi.getter(name="tileLayout")
    def tile_layout(self) -> Optional[pulumi.Input['ThemeConfigurationSheetTileLayoutArgs']]:
        """
        The layout options for tiles. See tile_layout.
        """
        return pulumi.get(self, "tile_layout")

    @tile_layout.setter
    def tile_layout(self, value: Optional[pulumi.Input['ThemeConfigurationSheetTileLayoutArgs']]):
        pulumi.set(self, "tile_layout", value)


if not MYPY:
    class ThemeConfigurationSheetTileArgsDict(TypedDict):
        border: NotRequired[pulumi.Input['ThemeConfigurationSheetTileBorderArgsDict']]
        """
        The border around a tile. See border.
        """
elif False:
    ThemeConfigurationSheetTileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationSheetTileArgs:
    def __init__(__self__, *,
                 border: Optional[pulumi.Input['ThemeConfigurationSheetTileBorderArgs']] = None):
        """
        :param pulumi.Input['ThemeConfigurationSheetTileBorderArgs'] border: The border around a tile. See border.
        """
        if border is not None:
            pulumi.set(__self__, "border", border)

    @property
    @pulumi.getter
    def border(self) -> Optional[pulumi.Input['ThemeConfigurationSheetTileBorderArgs']]:
        """
        The border around a tile. See border.
        """
        return pulumi.get(self, "border")

    @border.setter
    def border(self, value: Optional[pulumi.Input['ThemeConfigurationSheetTileBorderArgs']]):
        pulumi.set(self, "border", value)


if not MYPY:
    class ThemeConfigurationSheetTileBorderArgsDict(TypedDict):
        show: NotRequired[pulumi.Input[builtins.bool]]
        """
        The option to enable display of borders for visuals.
        """
elif False:
    ThemeConfigurationSheetTileBorderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationSheetTileBorderArgs:
    def __init__(__self__, *,
                 show: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] show: The option to enable display of borders for visuals.
        """
        if show is not None:
            pulumi.set(__self__, "show", show)

    @property
    @pulumi.getter
    def show(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        The option to enable display of borders for visuals.
        """
        return pulumi.get(self, "show")

    @show.setter
    def show(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "show", value)


if not MYPY:
    class ThemeConfigurationSheetTileLayoutArgsDict(TypedDict):
        gutter: NotRequired[pulumi.Input['ThemeConfigurationSheetTileLayoutGutterArgsDict']]
        """
        The gutter settings that apply between tiles. See gutter.
        """
        margin: NotRequired[pulumi.Input['ThemeConfigurationSheetTileLayoutMarginArgsDict']]
        """
        The margin settings that apply around the outside edge of sheets. See margin.
        """
elif False:
    ThemeConfigurationSheetTileLayoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationSheetTileLayoutArgs:
    def __init__(__self__, *,
                 gutter: Optional[pulumi.Input['ThemeConfigurationSheetTileLayoutGutterArgs']] = None,
                 margin: Optional[pulumi.Input['ThemeConfigurationSheetTileLayoutMarginArgs']] = None):
        """
        :param pulumi.Input['ThemeConfigurationSheetTileLayoutGutterArgs'] gutter: The gutter settings that apply between tiles. See gutter.
        :param pulumi.Input['ThemeConfigurationSheetTileLayoutMarginArgs'] margin: The margin settings that apply around the outside edge of sheets. See margin.
        """
        if gutter is not None:
            pulumi.set(__self__, "gutter", gutter)
        if margin is not None:
            pulumi.set(__self__, "margin", margin)

    @property
    @pulumi.getter
    def gutter(self) -> Optional[pulumi.Input['ThemeConfigurationSheetTileLayoutGutterArgs']]:
        """
        The gutter settings that apply between tiles. See gutter.
        """
        return pulumi.get(self, "gutter")

    @gutter.setter
    def gutter(self, value: Optional[pulumi.Input['ThemeConfigurationSheetTileLayoutGutterArgs']]):
        pulumi.set(self, "gutter", value)

    @property
    @pulumi.getter
    def margin(self) -> Optional[pulumi.Input['ThemeConfigurationSheetTileLayoutMarginArgs']]:
        """
        The margin settings that apply around the outside edge of sheets. See margin.
        """
        return pulumi.get(self, "margin")

    @margin.setter
    def margin(self, value: Optional[pulumi.Input['ThemeConfigurationSheetTileLayoutMarginArgs']]):
        pulumi.set(self, "margin", value)


if not MYPY:
    class ThemeConfigurationSheetTileLayoutGutterArgsDict(TypedDict):
        show: NotRequired[pulumi.Input[builtins.bool]]
        """
        This Boolean value controls whether to display a gutter space between sheet tiles.
        """
elif False:
    ThemeConfigurationSheetTileLayoutGutterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationSheetTileLayoutGutterArgs:
    def __init__(__self__, *,
                 show: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] show: This Boolean value controls whether to display a gutter space between sheet tiles.
        """
        if show is not None:
            pulumi.set(__self__, "show", show)

    @property
    @pulumi.getter
    def show(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        This Boolean value controls whether to display a gutter space between sheet tiles.
        """
        return pulumi.get(self, "show")

    @show.setter
    def show(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "show", value)


if not MYPY:
    class ThemeConfigurationSheetTileLayoutMarginArgsDict(TypedDict):
        show: NotRequired[pulumi.Input[builtins.bool]]
        """
        This Boolean value controls whether to display sheet margins.
        """
elif False:
    ThemeConfigurationSheetTileLayoutMarginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationSheetTileLayoutMarginArgs:
    def __init__(__self__, *,
                 show: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] show: This Boolean value controls whether to display sheet margins.
        """
        if show is not None:
            pulumi.set(__self__, "show", show)

    @property
    @pulumi.getter
    def show(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        This Boolean value controls whether to display sheet margins.
        """
        return pulumi.get(self, "show")

    @show.setter
    def show(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "show", value)


if not MYPY:
    class ThemeConfigurationTypographyArgsDict(TypedDict):
        font_families: NotRequired[pulumi.Input[Sequence[pulumi.Input['ThemeConfigurationTypographyFontFamilyArgsDict']]]]
        """
        Determines the list of font families. Maximum number of 5 items. See font_families.
        """
elif False:
    ThemeConfigurationTypographyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationTypographyArgs:
    def __init__(__self__, *,
                 font_families: Optional[pulumi.Input[Sequence[pulumi.Input['ThemeConfigurationTypographyFontFamilyArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ThemeConfigurationTypographyFontFamilyArgs']]] font_families: Determines the list of font families. Maximum number of 5 items. See font_families.
        """
        if font_families is not None:
            pulumi.set(__self__, "font_families", font_families)

    @property
    @pulumi.getter(name="fontFamilies")
    def font_families(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ThemeConfigurationTypographyFontFamilyArgs']]]]:
        """
        Determines the list of font families. Maximum number of 5 items. See font_families.
        """
        return pulumi.get(self, "font_families")

    @font_families.setter
    def font_families(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ThemeConfigurationTypographyFontFamilyArgs']]]]):
        pulumi.set(self, "font_families", value)


if not MYPY:
    class ThemeConfigurationTypographyFontFamilyArgsDict(TypedDict):
        font_family: NotRequired[pulumi.Input[builtins.str]]
        """
        Font family name.
        """
elif False:
    ThemeConfigurationTypographyFontFamilyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationTypographyFontFamilyArgs:
    def __init__(__self__, *,
                 font_family: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] font_family: Font family name.
        """
        if font_family is not None:
            pulumi.set(__self__, "font_family", font_family)

    @property
    @pulumi.getter(name="fontFamily")
    def font_family(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Font family name.
        """
        return pulumi.get(self, "font_family")

    @font_family.setter
    def font_family(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "font_family", value)


if not MYPY:
    class ThemeConfigurationUiColorPaletteArgsDict(TypedDict):
        accent: NotRequired[pulumi.Input[builtins.str]]
        """
        Color (hexadecimal) that applies to selected states and buttons.
        """
        accent_foreground: NotRequired[pulumi.Input[builtins.str]]
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the accent color.
        """
        danger: NotRequired[pulumi.Input[builtins.str]]
        """
        Color (hexadecimal) that applies to error messages.
        """
        danger_foreground: NotRequired[pulumi.Input[builtins.str]]
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the error color.
        """
        dimension: NotRequired[pulumi.Input[builtins.str]]
        """
        Color (hexadecimal) that applies to the names of fields that are identified as dimensions.
        """
        dimension_foreground: NotRequired[pulumi.Input[builtins.str]]
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the dimension color.
        """
        measure: NotRequired[pulumi.Input[builtins.str]]
        """
        Color (hexadecimal) that applies to the names of fields that are identified as measures.
        """
        measure_foreground: NotRequired[pulumi.Input[builtins.str]]
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the measure color.
        """
        primary_background: NotRequired[pulumi.Input[builtins.str]]
        """
        Color (hexadecimal) that applies to visuals and other high emphasis UI.
        """
        primary_foreground: NotRequired[pulumi.Input[builtins.str]]
        """
        Color (hexadecimal) of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.
        """
        secondary_background: NotRequired[pulumi.Input[builtins.str]]
        """
        Color (hexadecimal) that applies to the sheet background and sheet controls.
        """
        secondary_foreground: NotRequired[pulumi.Input[builtins.str]]
        """
        Color (hexadecimal) that applies to any sheet title, sheet control text, or UI that appears over the secondary background.
        """
        success: NotRequired[pulumi.Input[builtins.str]]
        """
        Color (hexadecimal) that applies to success messages, for example the check mark for a successful download.
        """
        success_foreground: NotRequired[pulumi.Input[builtins.str]]
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the success color.
        """
        warning: NotRequired[pulumi.Input[builtins.str]]
        """
        Color (hexadecimal) that applies to warning and informational messages.
        """
        warning_foreground: NotRequired[pulumi.Input[builtins.str]]
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the warning color.
        """
elif False:
    ThemeConfigurationUiColorPaletteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationUiColorPaletteArgs:
    def __init__(__self__, *,
                 accent: Optional[pulumi.Input[builtins.str]] = None,
                 accent_foreground: Optional[pulumi.Input[builtins.str]] = None,
                 danger: Optional[pulumi.Input[builtins.str]] = None,
                 danger_foreground: Optional[pulumi.Input[builtins.str]] = None,
                 dimension: Optional[pulumi.Input[builtins.str]] = None,
                 dimension_foreground: Optional[pulumi.Input[builtins.str]] = None,
                 measure: Optional[pulumi.Input[builtins.str]] = None,
                 measure_foreground: Optional[pulumi.Input[builtins.str]] = None,
                 primary_background: Optional[pulumi.Input[builtins.str]] = None,
                 primary_foreground: Optional[pulumi.Input[builtins.str]] = None,
                 secondary_background: Optional[pulumi.Input[builtins.str]] = None,
                 secondary_foreground: Optional[pulumi.Input[builtins.str]] = None,
                 success: Optional[pulumi.Input[builtins.str]] = None,
                 success_foreground: Optional[pulumi.Input[builtins.str]] = None,
                 warning: Optional[pulumi.Input[builtins.str]] = None,
                 warning_foreground: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] accent: Color (hexadecimal) that applies to selected states and buttons.
        :param pulumi.Input[builtins.str] accent_foreground: Color (hexadecimal) that applies to any text or other elements that appear over the accent color.
        :param pulumi.Input[builtins.str] danger: Color (hexadecimal) that applies to error messages.
        :param pulumi.Input[builtins.str] danger_foreground: Color (hexadecimal) that applies to any text or other elements that appear over the error color.
        :param pulumi.Input[builtins.str] dimension: Color (hexadecimal) that applies to the names of fields that are identified as dimensions.
        :param pulumi.Input[builtins.str] dimension_foreground: Color (hexadecimal) that applies to any text or other elements that appear over the dimension color.
        :param pulumi.Input[builtins.str] measure: Color (hexadecimal) that applies to the names of fields that are identified as measures.
        :param pulumi.Input[builtins.str] measure_foreground: Color (hexadecimal) that applies to any text or other elements that appear over the measure color.
        :param pulumi.Input[builtins.str] primary_background: Color (hexadecimal) that applies to visuals and other high emphasis UI.
        :param pulumi.Input[builtins.str] primary_foreground: Color (hexadecimal) of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.
        :param pulumi.Input[builtins.str] secondary_background: Color (hexadecimal) that applies to the sheet background and sheet controls.
        :param pulumi.Input[builtins.str] secondary_foreground: Color (hexadecimal) that applies to any sheet title, sheet control text, or UI that appears over the secondary background.
        :param pulumi.Input[builtins.str] success: Color (hexadecimal) that applies to success messages, for example the check mark for a successful download.
        :param pulumi.Input[builtins.str] success_foreground: Color (hexadecimal) that applies to any text or other elements that appear over the success color.
        :param pulumi.Input[builtins.str] warning: Color (hexadecimal) that applies to warning and informational messages.
        :param pulumi.Input[builtins.str] warning_foreground: Color (hexadecimal) that applies to any text or other elements that appear over the warning color.
        """
        if accent is not None:
            pulumi.set(__self__, "accent", accent)
        if accent_foreground is not None:
            pulumi.set(__self__, "accent_foreground", accent_foreground)
        if danger is not None:
            pulumi.set(__self__, "danger", danger)
        if danger_foreground is not None:
            pulumi.set(__self__, "danger_foreground", danger_foreground)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if dimension_foreground is not None:
            pulumi.set(__self__, "dimension_foreground", dimension_foreground)
        if measure is not None:
            pulumi.set(__self__, "measure", measure)
        if measure_foreground is not None:
            pulumi.set(__self__, "measure_foreground", measure_foreground)
        if primary_background is not None:
            pulumi.set(__self__, "primary_background", primary_background)
        if primary_foreground is not None:
            pulumi.set(__self__, "primary_foreground", primary_foreground)
        if secondary_background is not None:
            pulumi.set(__self__, "secondary_background", secondary_background)
        if secondary_foreground is not None:
            pulumi.set(__self__, "secondary_foreground", secondary_foreground)
        if success is not None:
            pulumi.set(__self__, "success", success)
        if success_foreground is not None:
            pulumi.set(__self__, "success_foreground", success_foreground)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)
        if warning_foreground is not None:
            pulumi.set(__self__, "warning_foreground", warning_foreground)

    @property
    @pulumi.getter
    def accent(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Color (hexadecimal) that applies to selected states and buttons.
        """
        return pulumi.get(self, "accent")

    @accent.setter
    def accent(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "accent", value)

    @property
    @pulumi.getter(name="accentForeground")
    def accent_foreground(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the accent color.
        """
        return pulumi.get(self, "accent_foreground")

    @accent_foreground.setter
    def accent_foreground(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "accent_foreground", value)

    @property
    @pulumi.getter
    def danger(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Color (hexadecimal) that applies to error messages.
        """
        return pulumi.get(self, "danger")

    @danger.setter
    def danger(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "danger", value)

    @property
    @pulumi.getter(name="dangerForeground")
    def danger_foreground(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the error color.
        """
        return pulumi.get(self, "danger_foreground")

    @danger_foreground.setter
    def danger_foreground(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "danger_foreground", value)

    @property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Color (hexadecimal) that applies to the names of fields that are identified as dimensions.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter(name="dimensionForeground")
    def dimension_foreground(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the dimension color.
        """
        return pulumi.get(self, "dimension_foreground")

    @dimension_foreground.setter
    def dimension_foreground(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dimension_foreground", value)

    @property
    @pulumi.getter
    def measure(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Color (hexadecimal) that applies to the names of fields that are identified as measures.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="measureForeground")
    def measure_foreground(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the measure color.
        """
        return pulumi.get(self, "measure_foreground")

    @measure_foreground.setter
    def measure_foreground(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "measure_foreground", value)

    @property
    @pulumi.getter(name="primaryBackground")
    def primary_background(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Color (hexadecimal) that applies to visuals and other high emphasis UI.
        """
        return pulumi.get(self, "primary_background")

    @primary_background.setter
    def primary_background(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "primary_background", value)

    @property
    @pulumi.getter(name="primaryForeground")
    def primary_foreground(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Color (hexadecimal) of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.
        """
        return pulumi.get(self, "primary_foreground")

    @primary_foreground.setter
    def primary_foreground(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "primary_foreground", value)

    @property
    @pulumi.getter(name="secondaryBackground")
    def secondary_background(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Color (hexadecimal) that applies to the sheet background and sheet controls.
        """
        return pulumi.get(self, "secondary_background")

    @secondary_background.setter
    def secondary_background(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secondary_background", value)

    @property
    @pulumi.getter(name="secondaryForeground")
    def secondary_foreground(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Color (hexadecimal) that applies to any sheet title, sheet control text, or UI that appears over the secondary background.
        """
        return pulumi.get(self, "secondary_foreground")

    @secondary_foreground.setter
    def secondary_foreground(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secondary_foreground", value)

    @property
    @pulumi.getter
    def success(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Color (hexadecimal) that applies to success messages, for example the check mark for a successful download.
        """
        return pulumi.get(self, "success")

    @success.setter
    def success(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "success", value)

    @property
    @pulumi.getter(name="successForeground")
    def success_foreground(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the success color.
        """
        return pulumi.get(self, "success_foreground")

    @success_foreground.setter
    def success_foreground(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "success_foreground", value)

    @property
    @pulumi.getter
    def warning(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Color (hexadecimal) that applies to warning and informational messages.
        """
        return pulumi.get(self, "warning")

    @warning.setter
    def warning(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "warning", value)

    @property
    @pulumi.getter(name="warningForeground")
    def warning_foreground(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the warning color.
        """
        return pulumi.get(self, "warning_foreground")

    @warning_foreground.setter
    def warning_foreground(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "warning_foreground", value)


if not MYPY:
    class ThemePermissionArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        List of IAM actions to grant or revoke permissions on.
        """
        principal: pulumi.Input[builtins.str]
        """
        ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
elif False:
    ThemePermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemePermissionArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 principal: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: List of IAM actions to grant or revoke permissions on.
        :param pulumi.Input[builtins.str] principal: ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "principal", principal)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        List of IAM actions to grant or revoke permissions on.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def principal(self) -> pulumi.Input[builtins.str]:
        """
        ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class VpcConnectionTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    VpcConnectionTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcConnectionTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[builtins.str]] = None,
                 delete: Optional[pulumi.Input[builtins.str]] = None,
                 update: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update", value)


