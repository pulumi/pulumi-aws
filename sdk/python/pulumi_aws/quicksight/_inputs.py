# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AccountSettingsTimeoutsArgs',
    'AccountSettingsTimeoutsArgsDict',
    'AnalysisParametersArgs',
    'AnalysisParametersArgsDict',
    'AnalysisParametersDateTimeParameterArgs',
    'AnalysisParametersDateTimeParameterArgsDict',
    'AnalysisParametersDecimalParameterArgs',
    'AnalysisParametersDecimalParameterArgsDict',
    'AnalysisParametersIntegerParameterArgs',
    'AnalysisParametersIntegerParameterArgsDict',
    'AnalysisParametersStringParameterArgs',
    'AnalysisParametersStringParameterArgsDict',
    'AnalysisPermissionArgs',
    'AnalysisPermissionArgsDict',
    'AnalysisSourceEntityArgs',
    'AnalysisSourceEntityArgsDict',
    'AnalysisSourceEntitySourceTemplateArgs',
    'AnalysisSourceEntitySourceTemplateArgsDict',
    'AnalysisSourceEntitySourceTemplateDataSetReferenceArgs',
    'AnalysisSourceEntitySourceTemplateDataSetReferenceArgsDict',
    'CustomPermissionsCapabilitiesArgs',
    'CustomPermissionsCapabilitiesArgsDict',
    'DashboardDashboardPublishOptionsArgs',
    'DashboardDashboardPublishOptionsArgsDict',
    'DashboardDashboardPublishOptionsAdHocFilteringOptionArgs',
    'DashboardDashboardPublishOptionsAdHocFilteringOptionArgsDict',
    'DashboardDashboardPublishOptionsDataPointDrillUpDownOptionArgs',
    'DashboardDashboardPublishOptionsDataPointDrillUpDownOptionArgsDict',
    'DashboardDashboardPublishOptionsDataPointMenuLabelOptionArgs',
    'DashboardDashboardPublishOptionsDataPointMenuLabelOptionArgsDict',
    'DashboardDashboardPublishOptionsDataPointTooltipOptionArgs',
    'DashboardDashboardPublishOptionsDataPointTooltipOptionArgsDict',
    'DashboardDashboardPublishOptionsExportToCsvOptionArgs',
    'DashboardDashboardPublishOptionsExportToCsvOptionArgsDict',
    'DashboardDashboardPublishOptionsExportWithHiddenFieldsOptionArgs',
    'DashboardDashboardPublishOptionsExportWithHiddenFieldsOptionArgsDict',
    'DashboardDashboardPublishOptionsSheetControlsOptionArgs',
    'DashboardDashboardPublishOptionsSheetControlsOptionArgsDict',
    'DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOptionArgs',
    'DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOptionArgsDict',
    'DashboardDashboardPublishOptionsVisualAxisSortOptionArgs',
    'DashboardDashboardPublishOptionsVisualAxisSortOptionArgsDict',
    'DashboardDashboardPublishOptionsVisualMenuOptionArgs',
    'DashboardDashboardPublishOptionsVisualMenuOptionArgsDict',
    'DashboardParametersArgs',
    'DashboardParametersArgsDict',
    'DashboardParametersDateTimeParameterArgs',
    'DashboardParametersDateTimeParameterArgsDict',
    'DashboardParametersDecimalParameterArgs',
    'DashboardParametersDecimalParameterArgsDict',
    'DashboardParametersIntegerParameterArgs',
    'DashboardParametersIntegerParameterArgsDict',
    'DashboardParametersStringParameterArgs',
    'DashboardParametersStringParameterArgsDict',
    'DashboardPermissionArgs',
    'DashboardPermissionArgsDict',
    'DashboardSourceEntityArgs',
    'DashboardSourceEntityArgsDict',
    'DashboardSourceEntitySourceTemplateArgs',
    'DashboardSourceEntitySourceTemplateArgsDict',
    'DashboardSourceEntitySourceTemplateDataSetReferenceArgs',
    'DashboardSourceEntitySourceTemplateDataSetReferenceArgsDict',
    'DataSetColumnGroupArgs',
    'DataSetColumnGroupArgsDict',
    'DataSetColumnGroupGeoSpatialColumnGroupArgs',
    'DataSetColumnGroupGeoSpatialColumnGroupArgsDict',
    'DataSetColumnLevelPermissionRuleArgs',
    'DataSetColumnLevelPermissionRuleArgsDict',
    'DataSetDataSetUsageConfigurationArgs',
    'DataSetDataSetUsageConfigurationArgsDict',
    'DataSetFieldFolderArgs',
    'DataSetFieldFolderArgsDict',
    'DataSetLogicalTableMapArgs',
    'DataSetLogicalTableMapArgsDict',
    'DataSetLogicalTableMapDataTransformArgs',
    'DataSetLogicalTableMapDataTransformArgsDict',
    'DataSetLogicalTableMapDataTransformCastColumnTypeOperationArgs',
    'DataSetLogicalTableMapDataTransformCastColumnTypeOperationArgsDict',
    'DataSetLogicalTableMapDataTransformCreateColumnsOperationArgs',
    'DataSetLogicalTableMapDataTransformCreateColumnsOperationArgsDict',
    'DataSetLogicalTableMapDataTransformCreateColumnsOperationColumnArgs',
    'DataSetLogicalTableMapDataTransformCreateColumnsOperationColumnArgsDict',
    'DataSetLogicalTableMapDataTransformFilterOperationArgs',
    'DataSetLogicalTableMapDataTransformFilterOperationArgsDict',
    'DataSetLogicalTableMapDataTransformProjectOperationArgs',
    'DataSetLogicalTableMapDataTransformProjectOperationArgsDict',
    'DataSetLogicalTableMapDataTransformRenameColumnOperationArgs',
    'DataSetLogicalTableMapDataTransformRenameColumnOperationArgsDict',
    'DataSetLogicalTableMapDataTransformTagColumnOperationArgs',
    'DataSetLogicalTableMapDataTransformTagColumnOperationArgsDict',
    'DataSetLogicalTableMapDataTransformTagColumnOperationTagArgs',
    'DataSetLogicalTableMapDataTransformTagColumnOperationTagArgsDict',
    'DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionArgs',
    'DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionArgsDict',
    'DataSetLogicalTableMapDataTransformUntagColumnOperationArgs',
    'DataSetLogicalTableMapDataTransformUntagColumnOperationArgsDict',
    'DataSetLogicalTableMapSourceArgs',
    'DataSetLogicalTableMapSourceArgsDict',
    'DataSetLogicalTableMapSourceJoinInstructionArgs',
    'DataSetLogicalTableMapSourceJoinInstructionArgsDict',
    'DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertiesArgs',
    'DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertiesArgsDict',
    'DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertiesArgs',
    'DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertiesArgsDict',
    'DataSetOutputColumnArgs',
    'DataSetOutputColumnArgsDict',
    'DataSetPermissionArgs',
    'DataSetPermissionArgsDict',
    'DataSetPhysicalTableMapArgs',
    'DataSetPhysicalTableMapArgsDict',
    'DataSetPhysicalTableMapCustomSqlArgs',
    'DataSetPhysicalTableMapCustomSqlArgsDict',
    'DataSetPhysicalTableMapCustomSqlColumnArgs',
    'DataSetPhysicalTableMapCustomSqlColumnArgsDict',
    'DataSetPhysicalTableMapRelationalTableArgs',
    'DataSetPhysicalTableMapRelationalTableArgsDict',
    'DataSetPhysicalTableMapRelationalTableInputColumnArgs',
    'DataSetPhysicalTableMapRelationalTableInputColumnArgsDict',
    'DataSetPhysicalTableMapS3SourceArgs',
    'DataSetPhysicalTableMapS3SourceArgsDict',
    'DataSetPhysicalTableMapS3SourceInputColumnArgs',
    'DataSetPhysicalTableMapS3SourceInputColumnArgsDict',
    'DataSetPhysicalTableMapS3SourceUploadSettingsArgs',
    'DataSetPhysicalTableMapS3SourceUploadSettingsArgsDict',
    'DataSetRefreshPropertiesArgs',
    'DataSetRefreshPropertiesArgsDict',
    'DataSetRefreshPropertiesRefreshConfigurationArgs',
    'DataSetRefreshPropertiesRefreshConfigurationArgsDict',
    'DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshArgs',
    'DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshArgsDict',
    'DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindowArgs',
    'DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindowArgsDict',
    'DataSetRowLevelPermissionDataSetArgs',
    'DataSetRowLevelPermissionDataSetArgsDict',
    'DataSetRowLevelPermissionTagConfigurationArgs',
    'DataSetRowLevelPermissionTagConfigurationArgsDict',
    'DataSetRowLevelPermissionTagConfigurationTagRuleArgs',
    'DataSetRowLevelPermissionTagConfigurationTagRuleArgsDict',
    'DataSourceCredentialsArgs',
    'DataSourceCredentialsArgsDict',
    'DataSourceCredentialsCredentialPairArgs',
    'DataSourceCredentialsCredentialPairArgsDict',
    'DataSourceParametersArgs',
    'DataSourceParametersArgsDict',
    'DataSourceParametersAmazonElasticsearchArgs',
    'DataSourceParametersAmazonElasticsearchArgsDict',
    'DataSourceParametersAthenaArgs',
    'DataSourceParametersAthenaArgsDict',
    'DataSourceParametersAuroraArgs',
    'DataSourceParametersAuroraArgsDict',
    'DataSourceParametersAuroraPostgresqlArgs',
    'DataSourceParametersAuroraPostgresqlArgsDict',
    'DataSourceParametersAwsIotAnalyticsArgs',
    'DataSourceParametersAwsIotAnalyticsArgsDict',
    'DataSourceParametersDatabricksArgs',
    'DataSourceParametersDatabricksArgsDict',
    'DataSourceParametersJiraArgs',
    'DataSourceParametersJiraArgsDict',
    'DataSourceParametersMariaDbArgs',
    'DataSourceParametersMariaDbArgsDict',
    'DataSourceParametersMysqlArgs',
    'DataSourceParametersMysqlArgsDict',
    'DataSourceParametersOracleArgs',
    'DataSourceParametersOracleArgsDict',
    'DataSourceParametersPostgresqlArgs',
    'DataSourceParametersPostgresqlArgsDict',
    'DataSourceParametersPrestoArgs',
    'DataSourceParametersPrestoArgsDict',
    'DataSourceParametersRdsArgs',
    'DataSourceParametersRdsArgsDict',
    'DataSourceParametersRedshiftArgs',
    'DataSourceParametersRedshiftArgsDict',
    'DataSourceParametersS3Args',
    'DataSourceParametersS3ArgsDict',
    'DataSourceParametersS3ManifestFileLocationArgs',
    'DataSourceParametersS3ManifestFileLocationArgsDict',
    'DataSourceParametersServiceNowArgs',
    'DataSourceParametersServiceNowArgsDict',
    'DataSourceParametersSnowflakeArgs',
    'DataSourceParametersSnowflakeArgsDict',
    'DataSourceParametersSparkArgs',
    'DataSourceParametersSparkArgsDict',
    'DataSourceParametersSqlServerArgs',
    'DataSourceParametersSqlServerArgsDict',
    'DataSourceParametersTeradataArgs',
    'DataSourceParametersTeradataArgsDict',
    'DataSourceParametersTwitterArgs',
    'DataSourceParametersTwitterArgsDict',
    'DataSourcePermissionArgs',
    'DataSourcePermissionArgsDict',
    'DataSourceSslPropertiesArgs',
    'DataSourceSslPropertiesArgsDict',
    'DataSourceVpcConnectionPropertiesArgs',
    'DataSourceVpcConnectionPropertiesArgsDict',
    'FolderPermissionArgs',
    'FolderPermissionArgsDict',
    'IamPolicyAssignmentIdentitiesArgs',
    'IamPolicyAssignmentIdentitiesArgsDict',
    'KeyRegistrationKeyRegistrationArgs',
    'KeyRegistrationKeyRegistrationArgsDict',
    'NamespaceTimeoutsArgs',
    'NamespaceTimeoutsArgsDict',
    'RefreshScheduleScheduleArgs',
    'RefreshScheduleScheduleArgsDict',
    'RefreshScheduleScheduleScheduleFrequencyArgs',
    'RefreshScheduleScheduleScheduleFrequencyArgsDict',
    'RefreshScheduleScheduleScheduleFrequencyRefreshOnDayArgs',
    'RefreshScheduleScheduleScheduleFrequencyRefreshOnDayArgsDict',
    'TemplatePermissionArgs',
    'TemplatePermissionArgsDict',
    'TemplateSourceEntityArgs',
    'TemplateSourceEntityArgsDict',
    'TemplateSourceEntitySourceAnalysisArgs',
    'TemplateSourceEntitySourceAnalysisArgsDict',
    'TemplateSourceEntitySourceAnalysisDataSetReferenceArgs',
    'TemplateSourceEntitySourceAnalysisDataSetReferenceArgsDict',
    'TemplateSourceEntitySourceTemplateArgs',
    'TemplateSourceEntitySourceTemplateArgsDict',
    'ThemeConfigurationArgs',
    'ThemeConfigurationArgsDict',
    'ThemeConfigurationDataColorPaletteArgs',
    'ThemeConfigurationDataColorPaletteArgsDict',
    'ThemeConfigurationSheetArgs',
    'ThemeConfigurationSheetArgsDict',
    'ThemeConfigurationSheetTileArgs',
    'ThemeConfigurationSheetTileArgsDict',
    'ThemeConfigurationSheetTileBorderArgs',
    'ThemeConfigurationSheetTileBorderArgsDict',
    'ThemeConfigurationSheetTileLayoutArgs',
    'ThemeConfigurationSheetTileLayoutArgsDict',
    'ThemeConfigurationSheetTileLayoutGutterArgs',
    'ThemeConfigurationSheetTileLayoutGutterArgsDict',
    'ThemeConfigurationSheetTileLayoutMarginArgs',
    'ThemeConfigurationSheetTileLayoutMarginArgsDict',
    'ThemeConfigurationTypographyArgs',
    'ThemeConfigurationTypographyArgsDict',
    'ThemeConfigurationTypographyFontFamilyArgs',
    'ThemeConfigurationTypographyFontFamilyArgsDict',
    'ThemeConfigurationUiColorPaletteArgs',
    'ThemeConfigurationUiColorPaletteArgsDict',
    'ThemePermissionArgs',
    'ThemePermissionArgsDict',
    'VpcConnectionTimeoutsArgs',
    'VpcConnectionTimeoutsArgsDict',
]

MYPY = False

if not MYPY:
    class AccountSettingsTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    AccountSettingsTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountSettingsTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AnalysisParametersArgsDict(TypedDict):
        date_time_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersDateTimeParameterArgsDict']]]]
        decimal_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersDecimalParameterArgsDict']]]]
        integer_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersIntegerParameterArgsDict']]]]
        string_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersStringParameterArgsDict']]]]
elif False:
    AnalysisParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisParametersArgs:
    def __init__(__self__, *,
                 date_time_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersDateTimeParameterArgs']]]] = None,
                 decimal_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersDecimalParameterArgs']]]] = None,
                 integer_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersIntegerParameterArgs']]]] = None,
                 string_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersStringParameterArgs']]]] = None):
        if date_time_parameters is not None:
            pulumi.set(__self__, "date_time_parameters", date_time_parameters)
        if decimal_parameters is not None:
            pulumi.set(__self__, "decimal_parameters", decimal_parameters)
        if integer_parameters is not None:
            pulumi.set(__self__, "integer_parameters", integer_parameters)
        if string_parameters is not None:
            pulumi.set(__self__, "string_parameters", string_parameters)

    @_builtins.property
    @pulumi.getter(name="dateTimeParameters")
    def date_time_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersDateTimeParameterArgs']]]]:
        return pulumi.get(self, "date_time_parameters")

    @date_time_parameters.setter
    def date_time_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersDateTimeParameterArgs']]]]):
        pulumi.set(self, "date_time_parameters", value)

    @_builtins.property
    @pulumi.getter(name="decimalParameters")
    def decimal_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersDecimalParameterArgs']]]]:
        return pulumi.get(self, "decimal_parameters")

    @decimal_parameters.setter
    def decimal_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersDecimalParameterArgs']]]]):
        pulumi.set(self, "decimal_parameters", value)

    @_builtins.property
    @pulumi.getter(name="integerParameters")
    def integer_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersIntegerParameterArgs']]]]:
        return pulumi.get(self, "integer_parameters")

    @integer_parameters.setter
    def integer_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersIntegerParameterArgs']]]]):
        pulumi.set(self, "integer_parameters", value)

    @_builtins.property
    @pulumi.getter(name="stringParameters")
    def string_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersStringParameterArgs']]]]:
        return pulumi.get(self, "string_parameters")

    @string_parameters.setter
    def string_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AnalysisParametersStringParameterArgs']]]]):
        pulumi.set(self, "string_parameters", value)


if not MYPY:
    class AnalysisParametersDateTimeParameterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    AnalysisParametersDateTimeParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisParametersDateTimeParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnalysisParametersDecimalParameterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.float]]]
elif False:
    AnalysisParametersDecimalParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisParametersDecimalParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.float]]]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.float]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.float]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnalysisParametersIntegerParameterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
elif False:
    AnalysisParametersIntegerParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisParametersIntegerParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnalysisParametersStringParameterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    AnalysisParametersStringParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisParametersStringParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AnalysisPermissionArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        principal: pulumi.Input[_builtins.str]
elif False:
    AnalysisPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisPermissionArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 principal: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "principal", principal)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter
    def principal(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class AnalysisSourceEntityArgsDict(TypedDict):
        source_template: NotRequired[pulumi.Input['AnalysisSourceEntitySourceTemplateArgsDict']]
elif False:
    AnalysisSourceEntityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisSourceEntityArgs:
    def __init__(__self__, *,
                 source_template: Optional[pulumi.Input['AnalysisSourceEntitySourceTemplateArgs']] = None):
        if source_template is not None:
            pulumi.set(__self__, "source_template", source_template)

    @_builtins.property
    @pulumi.getter(name="sourceTemplate")
    def source_template(self) -> Optional[pulumi.Input['AnalysisSourceEntitySourceTemplateArgs']]:
        return pulumi.get(self, "source_template")

    @source_template.setter
    def source_template(self, value: Optional[pulumi.Input['AnalysisSourceEntitySourceTemplateArgs']]):
        pulumi.set(self, "source_template", value)


if not MYPY:
    class AnalysisSourceEntitySourceTemplateArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        data_set_references: pulumi.Input[Sequence[pulumi.Input['AnalysisSourceEntitySourceTemplateDataSetReferenceArgsDict']]]
elif False:
    AnalysisSourceEntitySourceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisSourceEntitySourceTemplateArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 data_set_references: pulumi.Input[Sequence[pulumi.Input['AnalysisSourceEntitySourceTemplateDataSetReferenceArgs']]]):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "data_set_references", data_set_references)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="dataSetReferences")
    def data_set_references(self) -> pulumi.Input[Sequence[pulumi.Input['AnalysisSourceEntitySourceTemplateDataSetReferenceArgs']]]:
        return pulumi.get(self, "data_set_references")

    @data_set_references.setter
    def data_set_references(self, value: pulumi.Input[Sequence[pulumi.Input['AnalysisSourceEntitySourceTemplateDataSetReferenceArgs']]]):
        pulumi.set(self, "data_set_references", value)


if not MYPY:
    class AnalysisSourceEntitySourceTemplateDataSetReferenceArgsDict(TypedDict):
        data_set_arn: pulumi.Input[_builtins.str]
        data_set_placeholder: pulumi.Input[_builtins.str]
elif False:
    AnalysisSourceEntitySourceTemplateDataSetReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisSourceEntitySourceTemplateDataSetReferenceArgs:
    def __init__(__self__, *,
                 data_set_arn: pulumi.Input[_builtins.str],
                 data_set_placeholder: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "data_set_arn", data_set_arn)
        pulumi.set(__self__, "data_set_placeholder", data_set_placeholder)

    @_builtins.property
    @pulumi.getter(name="dataSetArn")
    def data_set_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "data_set_arn")

    @data_set_arn.setter
    def data_set_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_set_arn", value)

    @_builtins.property
    @pulumi.getter(name="dataSetPlaceholder")
    def data_set_placeholder(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "data_set_placeholder")

    @data_set_placeholder.setter
    def data_set_placeholder(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_set_placeholder", value)


if not MYPY:
    class CustomPermissionsCapabilitiesArgsDict(TypedDict):
        add_or_run_anomaly_detection_for_analyses: NotRequired[pulumi.Input[_builtins.str]]
        create_and_update_dashboard_email_reports: NotRequired[pulumi.Input[_builtins.str]]
        create_and_update_data_sources: NotRequired[pulumi.Input[_builtins.str]]
        create_and_update_datasets: NotRequired[pulumi.Input[_builtins.str]]
        create_and_update_themes: NotRequired[pulumi.Input[_builtins.str]]
        create_and_update_threshold_alerts: NotRequired[pulumi.Input[_builtins.str]]
        create_shared_folders: NotRequired[pulumi.Input[_builtins.str]]
        create_spice_dataset: NotRequired[pulumi.Input[_builtins.str]]
        export_to_csv: NotRequired[pulumi.Input[_builtins.str]]
        export_to_csv_in_scheduled_reports: NotRequired[pulumi.Input[_builtins.str]]
        export_to_excel: NotRequired[pulumi.Input[_builtins.str]]
        export_to_excel_in_scheduled_reports: NotRequired[pulumi.Input[_builtins.str]]
        export_to_pdf: NotRequired[pulumi.Input[_builtins.str]]
        export_to_pdf_in_scheduled_reports: NotRequired[pulumi.Input[_builtins.str]]
        include_content_in_scheduled_reports_email: NotRequired[pulumi.Input[_builtins.str]]
        print_reports: NotRequired[pulumi.Input[_builtins.str]]
        rename_shared_folders: NotRequired[pulumi.Input[_builtins.str]]
        share_analyses: NotRequired[pulumi.Input[_builtins.str]]
        share_dashboards: NotRequired[pulumi.Input[_builtins.str]]
        share_data_sources: NotRequired[pulumi.Input[_builtins.str]]
        share_datasets: NotRequired[pulumi.Input[_builtins.str]]
        subscribe_dashboard_email_reports: NotRequired[pulumi.Input[_builtins.str]]
        view_account_spice_capacity: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CustomPermissionsCapabilitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomPermissionsCapabilitiesArgs:
    def __init__(__self__, *,
                 add_or_run_anomaly_detection_for_analyses: Optional[pulumi.Input[_builtins.str]] = None,
                 create_and_update_dashboard_email_reports: Optional[pulumi.Input[_builtins.str]] = None,
                 create_and_update_data_sources: Optional[pulumi.Input[_builtins.str]] = None,
                 create_and_update_datasets: Optional[pulumi.Input[_builtins.str]] = None,
                 create_and_update_themes: Optional[pulumi.Input[_builtins.str]] = None,
                 create_and_update_threshold_alerts: Optional[pulumi.Input[_builtins.str]] = None,
                 create_shared_folders: Optional[pulumi.Input[_builtins.str]] = None,
                 create_spice_dataset: Optional[pulumi.Input[_builtins.str]] = None,
                 export_to_csv: Optional[pulumi.Input[_builtins.str]] = None,
                 export_to_csv_in_scheduled_reports: Optional[pulumi.Input[_builtins.str]] = None,
                 export_to_excel: Optional[pulumi.Input[_builtins.str]] = None,
                 export_to_excel_in_scheduled_reports: Optional[pulumi.Input[_builtins.str]] = None,
                 export_to_pdf: Optional[pulumi.Input[_builtins.str]] = None,
                 export_to_pdf_in_scheduled_reports: Optional[pulumi.Input[_builtins.str]] = None,
                 include_content_in_scheduled_reports_email: Optional[pulumi.Input[_builtins.str]] = None,
                 print_reports: Optional[pulumi.Input[_builtins.str]] = None,
                 rename_shared_folders: Optional[pulumi.Input[_builtins.str]] = None,
                 share_analyses: Optional[pulumi.Input[_builtins.str]] = None,
                 share_dashboards: Optional[pulumi.Input[_builtins.str]] = None,
                 share_data_sources: Optional[pulumi.Input[_builtins.str]] = None,
                 share_datasets: Optional[pulumi.Input[_builtins.str]] = None,
                 subscribe_dashboard_email_reports: Optional[pulumi.Input[_builtins.str]] = None,
                 view_account_spice_capacity: Optional[pulumi.Input[_builtins.str]] = None):
        if add_or_run_anomaly_detection_for_analyses is not None:
            pulumi.set(__self__, "add_or_run_anomaly_detection_for_analyses", add_or_run_anomaly_detection_for_analyses)
        if create_and_update_dashboard_email_reports is not None:
            pulumi.set(__self__, "create_and_update_dashboard_email_reports", create_and_update_dashboard_email_reports)
        if create_and_update_data_sources is not None:
            pulumi.set(__self__, "create_and_update_data_sources", create_and_update_data_sources)
        if create_and_update_datasets is not None:
            pulumi.set(__self__, "create_and_update_datasets", create_and_update_datasets)
        if create_and_update_themes is not None:
            pulumi.set(__self__, "create_and_update_themes", create_and_update_themes)
        if create_and_update_threshold_alerts is not None:
            pulumi.set(__self__, "create_and_update_threshold_alerts", create_and_update_threshold_alerts)
        if create_shared_folders is not None:
            pulumi.set(__self__, "create_shared_folders", create_shared_folders)
        if create_spice_dataset is not None:
            pulumi.set(__self__, "create_spice_dataset", create_spice_dataset)
        if export_to_csv is not None:
            pulumi.set(__self__, "export_to_csv", export_to_csv)
        if export_to_csv_in_scheduled_reports is not None:
            pulumi.set(__self__, "export_to_csv_in_scheduled_reports", export_to_csv_in_scheduled_reports)
        if export_to_excel is not None:
            pulumi.set(__self__, "export_to_excel", export_to_excel)
        if export_to_excel_in_scheduled_reports is not None:
            pulumi.set(__self__, "export_to_excel_in_scheduled_reports", export_to_excel_in_scheduled_reports)
        if export_to_pdf is not None:
            pulumi.set(__self__, "export_to_pdf", export_to_pdf)
        if export_to_pdf_in_scheduled_reports is not None:
            pulumi.set(__self__, "export_to_pdf_in_scheduled_reports", export_to_pdf_in_scheduled_reports)
        if include_content_in_scheduled_reports_email is not None:
            pulumi.set(__self__, "include_content_in_scheduled_reports_email", include_content_in_scheduled_reports_email)
        if print_reports is not None:
            pulumi.set(__self__, "print_reports", print_reports)
        if rename_shared_folders is not None:
            pulumi.set(__self__, "rename_shared_folders", rename_shared_folders)
        if share_analyses is not None:
            pulumi.set(__self__, "share_analyses", share_analyses)
        if share_dashboards is not None:
            pulumi.set(__self__, "share_dashboards", share_dashboards)
        if share_data_sources is not None:
            pulumi.set(__self__, "share_data_sources", share_data_sources)
        if share_datasets is not None:
            pulumi.set(__self__, "share_datasets", share_datasets)
        if subscribe_dashboard_email_reports is not None:
            pulumi.set(__self__, "subscribe_dashboard_email_reports", subscribe_dashboard_email_reports)
        if view_account_spice_capacity is not None:
            pulumi.set(__self__, "view_account_spice_capacity", view_account_spice_capacity)

    @_builtins.property
    @pulumi.getter(name="addOrRunAnomalyDetectionForAnalyses")
    def add_or_run_anomaly_detection_for_analyses(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "add_or_run_anomaly_detection_for_analyses")

    @add_or_run_anomaly_detection_for_analyses.setter
    def add_or_run_anomaly_detection_for_analyses(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "add_or_run_anomaly_detection_for_analyses", value)

    @_builtins.property
    @pulumi.getter(name="createAndUpdateDashboardEmailReports")
    def create_and_update_dashboard_email_reports(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "create_and_update_dashboard_email_reports")

    @create_and_update_dashboard_email_reports.setter
    def create_and_update_dashboard_email_reports(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_and_update_dashboard_email_reports", value)

    @_builtins.property
    @pulumi.getter(name="createAndUpdateDataSources")
    def create_and_update_data_sources(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "create_and_update_data_sources")

    @create_and_update_data_sources.setter
    def create_and_update_data_sources(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_and_update_data_sources", value)

    @_builtins.property
    @pulumi.getter(name="createAndUpdateDatasets")
    def create_and_update_datasets(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "create_and_update_datasets")

    @create_and_update_datasets.setter
    def create_and_update_datasets(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_and_update_datasets", value)

    @_builtins.property
    @pulumi.getter(name="createAndUpdateThemes")
    def create_and_update_themes(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "create_and_update_themes")

    @create_and_update_themes.setter
    def create_and_update_themes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_and_update_themes", value)

    @_builtins.property
    @pulumi.getter(name="createAndUpdateThresholdAlerts")
    def create_and_update_threshold_alerts(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "create_and_update_threshold_alerts")

    @create_and_update_threshold_alerts.setter
    def create_and_update_threshold_alerts(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_and_update_threshold_alerts", value)

    @_builtins.property
    @pulumi.getter(name="createSharedFolders")
    def create_shared_folders(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "create_shared_folders")

    @create_shared_folders.setter
    def create_shared_folders(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_shared_folders", value)

    @_builtins.property
    @pulumi.getter(name="createSpiceDataset")
    def create_spice_dataset(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "create_spice_dataset")

    @create_spice_dataset.setter
    def create_spice_dataset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_spice_dataset", value)

    @_builtins.property
    @pulumi.getter(name="exportToCsv")
    def export_to_csv(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "export_to_csv")

    @export_to_csv.setter
    def export_to_csv(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_to_csv", value)

    @_builtins.property
    @pulumi.getter(name="exportToCsvInScheduledReports")
    def export_to_csv_in_scheduled_reports(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "export_to_csv_in_scheduled_reports")

    @export_to_csv_in_scheduled_reports.setter
    def export_to_csv_in_scheduled_reports(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_to_csv_in_scheduled_reports", value)

    @_builtins.property
    @pulumi.getter(name="exportToExcel")
    def export_to_excel(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "export_to_excel")

    @export_to_excel.setter
    def export_to_excel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_to_excel", value)

    @_builtins.property
    @pulumi.getter(name="exportToExcelInScheduledReports")
    def export_to_excel_in_scheduled_reports(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "export_to_excel_in_scheduled_reports")

    @export_to_excel_in_scheduled_reports.setter
    def export_to_excel_in_scheduled_reports(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_to_excel_in_scheduled_reports", value)

    @_builtins.property
    @pulumi.getter(name="exportToPdf")
    def export_to_pdf(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "export_to_pdf")

    @export_to_pdf.setter
    def export_to_pdf(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_to_pdf", value)

    @_builtins.property
    @pulumi.getter(name="exportToPdfInScheduledReports")
    def export_to_pdf_in_scheduled_reports(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "export_to_pdf_in_scheduled_reports")

    @export_to_pdf_in_scheduled_reports.setter
    def export_to_pdf_in_scheduled_reports(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_to_pdf_in_scheduled_reports", value)

    @_builtins.property
    @pulumi.getter(name="includeContentInScheduledReportsEmail")
    def include_content_in_scheduled_reports_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "include_content_in_scheduled_reports_email")

    @include_content_in_scheduled_reports_email.setter
    def include_content_in_scheduled_reports_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "include_content_in_scheduled_reports_email", value)

    @_builtins.property
    @pulumi.getter(name="printReports")
    def print_reports(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "print_reports")

    @print_reports.setter
    def print_reports(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "print_reports", value)

    @_builtins.property
    @pulumi.getter(name="renameSharedFolders")
    def rename_shared_folders(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "rename_shared_folders")

    @rename_shared_folders.setter
    def rename_shared_folders(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rename_shared_folders", value)

    @_builtins.property
    @pulumi.getter(name="shareAnalyses")
    def share_analyses(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "share_analyses")

    @share_analyses.setter
    def share_analyses(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "share_analyses", value)

    @_builtins.property
    @pulumi.getter(name="shareDashboards")
    def share_dashboards(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "share_dashboards")

    @share_dashboards.setter
    def share_dashboards(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "share_dashboards", value)

    @_builtins.property
    @pulumi.getter(name="shareDataSources")
    def share_data_sources(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "share_data_sources")

    @share_data_sources.setter
    def share_data_sources(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "share_data_sources", value)

    @_builtins.property
    @pulumi.getter(name="shareDatasets")
    def share_datasets(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "share_datasets")

    @share_datasets.setter
    def share_datasets(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "share_datasets", value)

    @_builtins.property
    @pulumi.getter(name="subscribeDashboardEmailReports")
    def subscribe_dashboard_email_reports(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "subscribe_dashboard_email_reports")

    @subscribe_dashboard_email_reports.setter
    def subscribe_dashboard_email_reports(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subscribe_dashboard_email_reports", value)

    @_builtins.property
    @pulumi.getter(name="viewAccountSpiceCapacity")
    def view_account_spice_capacity(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "view_account_spice_capacity")

    @view_account_spice_capacity.setter
    def view_account_spice_capacity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "view_account_spice_capacity", value)


if not MYPY:
    class DashboardDashboardPublishOptionsArgsDict(TypedDict):
        ad_hoc_filtering_option: NotRequired[pulumi.Input['DashboardDashboardPublishOptionsAdHocFilteringOptionArgsDict']]
        data_point_drill_up_down_option: NotRequired[pulumi.Input['DashboardDashboardPublishOptionsDataPointDrillUpDownOptionArgsDict']]
        data_point_menu_label_option: NotRequired[pulumi.Input['DashboardDashboardPublishOptionsDataPointMenuLabelOptionArgsDict']]
        data_point_tooltip_option: NotRequired[pulumi.Input['DashboardDashboardPublishOptionsDataPointTooltipOptionArgsDict']]
        export_to_csv_option: NotRequired[pulumi.Input['DashboardDashboardPublishOptionsExportToCsvOptionArgsDict']]
        export_with_hidden_fields_option: NotRequired[pulumi.Input['DashboardDashboardPublishOptionsExportWithHiddenFieldsOptionArgsDict']]
        sheet_controls_option: NotRequired[pulumi.Input['DashboardDashboardPublishOptionsSheetControlsOptionArgsDict']]
        sheet_layout_element_maximization_option: NotRequired[pulumi.Input['DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOptionArgsDict']]
        visual_axis_sort_option: NotRequired[pulumi.Input['DashboardDashboardPublishOptionsVisualAxisSortOptionArgsDict']]
        visual_menu_option: NotRequired[pulumi.Input['DashboardDashboardPublishOptionsVisualMenuOptionArgsDict']]
elif False:
    DashboardDashboardPublishOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsArgs:
    def __init__(__self__, *,
                 ad_hoc_filtering_option: Optional[pulumi.Input['DashboardDashboardPublishOptionsAdHocFilteringOptionArgs']] = None,
                 data_point_drill_up_down_option: Optional[pulumi.Input['DashboardDashboardPublishOptionsDataPointDrillUpDownOptionArgs']] = None,
                 data_point_menu_label_option: Optional[pulumi.Input['DashboardDashboardPublishOptionsDataPointMenuLabelOptionArgs']] = None,
                 data_point_tooltip_option: Optional[pulumi.Input['DashboardDashboardPublishOptionsDataPointTooltipOptionArgs']] = None,
                 export_to_csv_option: Optional[pulumi.Input['DashboardDashboardPublishOptionsExportToCsvOptionArgs']] = None,
                 export_with_hidden_fields_option: Optional[pulumi.Input['DashboardDashboardPublishOptionsExportWithHiddenFieldsOptionArgs']] = None,
                 sheet_controls_option: Optional[pulumi.Input['DashboardDashboardPublishOptionsSheetControlsOptionArgs']] = None,
                 sheet_layout_element_maximization_option: Optional[pulumi.Input['DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOptionArgs']] = None,
                 visual_axis_sort_option: Optional[pulumi.Input['DashboardDashboardPublishOptionsVisualAxisSortOptionArgs']] = None,
                 visual_menu_option: Optional[pulumi.Input['DashboardDashboardPublishOptionsVisualMenuOptionArgs']] = None):
        if ad_hoc_filtering_option is not None:
            pulumi.set(__self__, "ad_hoc_filtering_option", ad_hoc_filtering_option)
        if data_point_drill_up_down_option is not None:
            pulumi.set(__self__, "data_point_drill_up_down_option", data_point_drill_up_down_option)
        if data_point_menu_label_option is not None:
            pulumi.set(__self__, "data_point_menu_label_option", data_point_menu_label_option)
        if data_point_tooltip_option is not None:
            pulumi.set(__self__, "data_point_tooltip_option", data_point_tooltip_option)
        if export_to_csv_option is not None:
            pulumi.set(__self__, "export_to_csv_option", export_to_csv_option)
        if export_with_hidden_fields_option is not None:
            pulumi.set(__self__, "export_with_hidden_fields_option", export_with_hidden_fields_option)
        if sheet_controls_option is not None:
            pulumi.set(__self__, "sheet_controls_option", sheet_controls_option)
        if sheet_layout_element_maximization_option is not None:
            pulumi.set(__self__, "sheet_layout_element_maximization_option", sheet_layout_element_maximization_option)
        if visual_axis_sort_option is not None:
            pulumi.set(__self__, "visual_axis_sort_option", visual_axis_sort_option)
        if visual_menu_option is not None:
            pulumi.set(__self__, "visual_menu_option", visual_menu_option)

    @_builtins.property
    @pulumi.getter(name="adHocFilteringOption")
    def ad_hoc_filtering_option(self) -> Optional[pulumi.Input['DashboardDashboardPublishOptionsAdHocFilteringOptionArgs']]:
        return pulumi.get(self, "ad_hoc_filtering_option")

    @ad_hoc_filtering_option.setter
    def ad_hoc_filtering_option(self, value: Optional[pulumi.Input['DashboardDashboardPublishOptionsAdHocFilteringOptionArgs']]):
        pulumi.set(self, "ad_hoc_filtering_option", value)

    @_builtins.property
    @pulumi.getter(name="dataPointDrillUpDownOption")
    def data_point_drill_up_down_option(self) -> Optional[pulumi.Input['DashboardDashboardPublishOptionsDataPointDrillUpDownOptionArgs']]:
        return pulumi.get(self, "data_point_drill_up_down_option")

    @data_point_drill_up_down_option.setter
    def data_point_drill_up_down_option(self, value: Optional[pulumi.Input['DashboardDashboardPublishOptionsDataPointDrillUpDownOptionArgs']]):
        pulumi.set(self, "data_point_drill_up_down_option", value)

    @_builtins.property
    @pulumi.getter(name="dataPointMenuLabelOption")
    def data_point_menu_label_option(self) -> Optional[pulumi.Input['DashboardDashboardPublishOptionsDataPointMenuLabelOptionArgs']]:
        return pulumi.get(self, "data_point_menu_label_option")

    @data_point_menu_label_option.setter
    def data_point_menu_label_option(self, value: Optional[pulumi.Input['DashboardDashboardPublishOptionsDataPointMenuLabelOptionArgs']]):
        pulumi.set(self, "data_point_menu_label_option", value)

    @_builtins.property
    @pulumi.getter(name="dataPointTooltipOption")
    def data_point_tooltip_option(self) -> Optional[pulumi.Input['DashboardDashboardPublishOptionsDataPointTooltipOptionArgs']]:
        return pulumi.get(self, "data_point_tooltip_option")

    @data_point_tooltip_option.setter
    def data_point_tooltip_option(self, value: Optional[pulumi.Input['DashboardDashboardPublishOptionsDataPointTooltipOptionArgs']]):
        pulumi.set(self, "data_point_tooltip_option", value)

    @_builtins.property
    @pulumi.getter(name="exportToCsvOption")
    def export_to_csv_option(self) -> Optional[pulumi.Input['DashboardDashboardPublishOptionsExportToCsvOptionArgs']]:
        return pulumi.get(self, "export_to_csv_option")

    @export_to_csv_option.setter
    def export_to_csv_option(self, value: Optional[pulumi.Input['DashboardDashboardPublishOptionsExportToCsvOptionArgs']]):
        pulumi.set(self, "export_to_csv_option", value)

    @_builtins.property
    @pulumi.getter(name="exportWithHiddenFieldsOption")
    def export_with_hidden_fields_option(self) -> Optional[pulumi.Input['DashboardDashboardPublishOptionsExportWithHiddenFieldsOptionArgs']]:
        return pulumi.get(self, "export_with_hidden_fields_option")

    @export_with_hidden_fields_option.setter
    def export_with_hidden_fields_option(self, value: Optional[pulumi.Input['DashboardDashboardPublishOptionsExportWithHiddenFieldsOptionArgs']]):
        pulumi.set(self, "export_with_hidden_fields_option", value)

    @_builtins.property
    @pulumi.getter(name="sheetControlsOption")
    def sheet_controls_option(self) -> Optional[pulumi.Input['DashboardDashboardPublishOptionsSheetControlsOptionArgs']]:
        return pulumi.get(self, "sheet_controls_option")

    @sheet_controls_option.setter
    def sheet_controls_option(self, value: Optional[pulumi.Input['DashboardDashboardPublishOptionsSheetControlsOptionArgs']]):
        pulumi.set(self, "sheet_controls_option", value)

    @_builtins.property
    @pulumi.getter(name="sheetLayoutElementMaximizationOption")
    def sheet_layout_element_maximization_option(self) -> Optional[pulumi.Input['DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOptionArgs']]:
        return pulumi.get(self, "sheet_layout_element_maximization_option")

    @sheet_layout_element_maximization_option.setter
    def sheet_layout_element_maximization_option(self, value: Optional[pulumi.Input['DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOptionArgs']]):
        pulumi.set(self, "sheet_layout_element_maximization_option", value)

    @_builtins.property
    @pulumi.getter(name="visualAxisSortOption")
    def visual_axis_sort_option(self) -> Optional[pulumi.Input['DashboardDashboardPublishOptionsVisualAxisSortOptionArgs']]:
        return pulumi.get(self, "visual_axis_sort_option")

    @visual_axis_sort_option.setter
    def visual_axis_sort_option(self, value: Optional[pulumi.Input['DashboardDashboardPublishOptionsVisualAxisSortOptionArgs']]):
        pulumi.set(self, "visual_axis_sort_option", value)

    @_builtins.property
    @pulumi.getter(name="visualMenuOption")
    def visual_menu_option(self) -> Optional[pulumi.Input['DashboardDashboardPublishOptionsVisualMenuOptionArgs']]:
        return pulumi.get(self, "visual_menu_option")

    @visual_menu_option.setter
    def visual_menu_option(self, value: Optional[pulumi.Input['DashboardDashboardPublishOptionsVisualMenuOptionArgs']]):
        pulumi.set(self, "visual_menu_option", value)


if not MYPY:
    class DashboardDashboardPublishOptionsAdHocFilteringOptionArgsDict(TypedDict):
        availability_status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DashboardDashboardPublishOptionsAdHocFilteringOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsAdHocFilteringOptionArgs:
    def __init__(__self__, *,
                 availability_status: Optional[pulumi.Input[_builtins.str]] = None):
        if availability_status is not None:
            pulumi.set(__self__, "availability_status", availability_status)

    @_builtins.property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "availability_status")

    @availability_status.setter
    def availability_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_status", value)


if not MYPY:
    class DashboardDashboardPublishOptionsDataPointDrillUpDownOptionArgsDict(TypedDict):
        availability_status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DashboardDashboardPublishOptionsDataPointDrillUpDownOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsDataPointDrillUpDownOptionArgs:
    def __init__(__self__, *,
                 availability_status: Optional[pulumi.Input[_builtins.str]] = None):
        if availability_status is not None:
            pulumi.set(__self__, "availability_status", availability_status)

    @_builtins.property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "availability_status")

    @availability_status.setter
    def availability_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_status", value)


if not MYPY:
    class DashboardDashboardPublishOptionsDataPointMenuLabelOptionArgsDict(TypedDict):
        availability_status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DashboardDashboardPublishOptionsDataPointMenuLabelOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsDataPointMenuLabelOptionArgs:
    def __init__(__self__, *,
                 availability_status: Optional[pulumi.Input[_builtins.str]] = None):
        if availability_status is not None:
            pulumi.set(__self__, "availability_status", availability_status)

    @_builtins.property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "availability_status")

    @availability_status.setter
    def availability_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_status", value)


if not MYPY:
    class DashboardDashboardPublishOptionsDataPointTooltipOptionArgsDict(TypedDict):
        availability_status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DashboardDashboardPublishOptionsDataPointTooltipOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsDataPointTooltipOptionArgs:
    def __init__(__self__, *,
                 availability_status: Optional[pulumi.Input[_builtins.str]] = None):
        if availability_status is not None:
            pulumi.set(__self__, "availability_status", availability_status)

    @_builtins.property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "availability_status")

    @availability_status.setter
    def availability_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_status", value)


if not MYPY:
    class DashboardDashboardPublishOptionsExportToCsvOptionArgsDict(TypedDict):
        availability_status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DashboardDashboardPublishOptionsExportToCsvOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsExportToCsvOptionArgs:
    def __init__(__self__, *,
                 availability_status: Optional[pulumi.Input[_builtins.str]] = None):
        if availability_status is not None:
            pulumi.set(__self__, "availability_status", availability_status)

    @_builtins.property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "availability_status")

    @availability_status.setter
    def availability_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_status", value)


if not MYPY:
    class DashboardDashboardPublishOptionsExportWithHiddenFieldsOptionArgsDict(TypedDict):
        availability_status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DashboardDashboardPublishOptionsExportWithHiddenFieldsOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsExportWithHiddenFieldsOptionArgs:
    def __init__(__self__, *,
                 availability_status: Optional[pulumi.Input[_builtins.str]] = None):
        if availability_status is not None:
            pulumi.set(__self__, "availability_status", availability_status)

    @_builtins.property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "availability_status")

    @availability_status.setter
    def availability_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_status", value)


if not MYPY:
    class DashboardDashboardPublishOptionsSheetControlsOptionArgsDict(TypedDict):
        visibility_state: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DashboardDashboardPublishOptionsSheetControlsOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsSheetControlsOptionArgs:
    def __init__(__self__, *,
                 visibility_state: Optional[pulumi.Input[_builtins.str]] = None):
        if visibility_state is not None:
            pulumi.set(__self__, "visibility_state", visibility_state)

    @_builtins.property
    @pulumi.getter(name="visibilityState")
    def visibility_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "visibility_state")

    @visibility_state.setter
    def visibility_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "visibility_state", value)


if not MYPY:
    class DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOptionArgsDict(TypedDict):
        availability_status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOptionArgs:
    def __init__(__self__, *,
                 availability_status: Optional[pulumi.Input[_builtins.str]] = None):
        if availability_status is not None:
            pulumi.set(__self__, "availability_status", availability_status)

    @_builtins.property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "availability_status")

    @availability_status.setter
    def availability_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_status", value)


if not MYPY:
    class DashboardDashboardPublishOptionsVisualAxisSortOptionArgsDict(TypedDict):
        availability_status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DashboardDashboardPublishOptionsVisualAxisSortOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsVisualAxisSortOptionArgs:
    def __init__(__self__, *,
                 availability_status: Optional[pulumi.Input[_builtins.str]] = None):
        if availability_status is not None:
            pulumi.set(__self__, "availability_status", availability_status)

    @_builtins.property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "availability_status")

    @availability_status.setter
    def availability_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_status", value)


if not MYPY:
    class DashboardDashboardPublishOptionsVisualMenuOptionArgsDict(TypedDict):
        availability_status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DashboardDashboardPublishOptionsVisualMenuOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardDashboardPublishOptionsVisualMenuOptionArgs:
    def __init__(__self__, *,
                 availability_status: Optional[pulumi.Input[_builtins.str]] = None):
        if availability_status is not None:
            pulumi.set(__self__, "availability_status", availability_status)

    @_builtins.property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "availability_status")

    @availability_status.setter
    def availability_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_status", value)


if not MYPY:
    class DashboardParametersArgsDict(TypedDict):
        date_time_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['DashboardParametersDateTimeParameterArgsDict']]]]
        decimal_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['DashboardParametersDecimalParameterArgsDict']]]]
        integer_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['DashboardParametersIntegerParameterArgsDict']]]]
        string_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['DashboardParametersStringParameterArgsDict']]]]
elif False:
    DashboardParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardParametersArgs:
    def __init__(__self__, *,
                 date_time_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersDateTimeParameterArgs']]]] = None,
                 decimal_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersDecimalParameterArgs']]]] = None,
                 integer_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersIntegerParameterArgs']]]] = None,
                 string_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersStringParameterArgs']]]] = None):
        if date_time_parameters is not None:
            pulumi.set(__self__, "date_time_parameters", date_time_parameters)
        if decimal_parameters is not None:
            pulumi.set(__self__, "decimal_parameters", decimal_parameters)
        if integer_parameters is not None:
            pulumi.set(__self__, "integer_parameters", integer_parameters)
        if string_parameters is not None:
            pulumi.set(__self__, "string_parameters", string_parameters)

    @_builtins.property
    @pulumi.getter(name="dateTimeParameters")
    def date_time_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersDateTimeParameterArgs']]]]:
        return pulumi.get(self, "date_time_parameters")

    @date_time_parameters.setter
    def date_time_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersDateTimeParameterArgs']]]]):
        pulumi.set(self, "date_time_parameters", value)

    @_builtins.property
    @pulumi.getter(name="decimalParameters")
    def decimal_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersDecimalParameterArgs']]]]:
        return pulumi.get(self, "decimal_parameters")

    @decimal_parameters.setter
    def decimal_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersDecimalParameterArgs']]]]):
        pulumi.set(self, "decimal_parameters", value)

    @_builtins.property
    @pulumi.getter(name="integerParameters")
    def integer_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersIntegerParameterArgs']]]]:
        return pulumi.get(self, "integer_parameters")

    @integer_parameters.setter
    def integer_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersIntegerParameterArgs']]]]):
        pulumi.set(self, "integer_parameters", value)

    @_builtins.property
    @pulumi.getter(name="stringParameters")
    def string_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersStringParameterArgs']]]]:
        return pulumi.get(self, "string_parameters")

    @string_parameters.setter
    def string_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardParametersStringParameterArgs']]]]):
        pulumi.set(self, "string_parameters", value)


if not MYPY:
    class DashboardParametersDateTimeParameterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    DashboardParametersDateTimeParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardParametersDateTimeParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DashboardParametersDecimalParameterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.float]]]
elif False:
    DashboardParametersDecimalParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardParametersDecimalParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.float]]]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.float]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.float]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DashboardParametersIntegerParameterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
elif False:
    DashboardParametersIntegerParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardParametersIntegerParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DashboardParametersStringParameterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    DashboardParametersStringParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardParametersStringParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DashboardPermissionArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        principal: pulumi.Input[_builtins.str]
elif False:
    DashboardPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPermissionArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 principal: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "principal", principal)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter
    def principal(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class DashboardSourceEntityArgsDict(TypedDict):
        source_template: NotRequired[pulumi.Input['DashboardSourceEntitySourceTemplateArgsDict']]
elif False:
    DashboardSourceEntityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardSourceEntityArgs:
    def __init__(__self__, *,
                 source_template: Optional[pulumi.Input['DashboardSourceEntitySourceTemplateArgs']] = None):
        if source_template is not None:
            pulumi.set(__self__, "source_template", source_template)

    @_builtins.property
    @pulumi.getter(name="sourceTemplate")
    def source_template(self) -> Optional[pulumi.Input['DashboardSourceEntitySourceTemplateArgs']]:
        return pulumi.get(self, "source_template")

    @source_template.setter
    def source_template(self, value: Optional[pulumi.Input['DashboardSourceEntitySourceTemplateArgs']]):
        pulumi.set(self, "source_template", value)


if not MYPY:
    class DashboardSourceEntitySourceTemplateArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        data_set_references: pulumi.Input[Sequence[pulumi.Input['DashboardSourceEntitySourceTemplateDataSetReferenceArgsDict']]]
elif False:
    DashboardSourceEntitySourceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardSourceEntitySourceTemplateArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 data_set_references: pulumi.Input[Sequence[pulumi.Input['DashboardSourceEntitySourceTemplateDataSetReferenceArgs']]]):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "data_set_references", data_set_references)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="dataSetReferences")
    def data_set_references(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardSourceEntitySourceTemplateDataSetReferenceArgs']]]:
        return pulumi.get(self, "data_set_references")

    @data_set_references.setter
    def data_set_references(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardSourceEntitySourceTemplateDataSetReferenceArgs']]]):
        pulumi.set(self, "data_set_references", value)


if not MYPY:
    class DashboardSourceEntitySourceTemplateDataSetReferenceArgsDict(TypedDict):
        data_set_arn: pulumi.Input[_builtins.str]
        data_set_placeholder: pulumi.Input[_builtins.str]
elif False:
    DashboardSourceEntitySourceTemplateDataSetReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardSourceEntitySourceTemplateDataSetReferenceArgs:
    def __init__(__self__, *,
                 data_set_arn: pulumi.Input[_builtins.str],
                 data_set_placeholder: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "data_set_arn", data_set_arn)
        pulumi.set(__self__, "data_set_placeholder", data_set_placeholder)

    @_builtins.property
    @pulumi.getter(name="dataSetArn")
    def data_set_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "data_set_arn")

    @data_set_arn.setter
    def data_set_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_set_arn", value)

    @_builtins.property
    @pulumi.getter(name="dataSetPlaceholder")
    def data_set_placeholder(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "data_set_placeholder")

    @data_set_placeholder.setter
    def data_set_placeholder(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_set_placeholder", value)


if not MYPY:
    class DataSetColumnGroupArgsDict(TypedDict):
        geo_spatial_column_group: NotRequired[pulumi.Input['DataSetColumnGroupGeoSpatialColumnGroupArgsDict']]
elif False:
    DataSetColumnGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetColumnGroupArgs:
    def __init__(__self__, *,
                 geo_spatial_column_group: Optional[pulumi.Input['DataSetColumnGroupGeoSpatialColumnGroupArgs']] = None):
        if geo_spatial_column_group is not None:
            pulumi.set(__self__, "geo_spatial_column_group", geo_spatial_column_group)

    @_builtins.property
    @pulumi.getter(name="geoSpatialColumnGroup")
    def geo_spatial_column_group(self) -> Optional[pulumi.Input['DataSetColumnGroupGeoSpatialColumnGroupArgs']]:
        return pulumi.get(self, "geo_spatial_column_group")

    @geo_spatial_column_group.setter
    def geo_spatial_column_group(self, value: Optional[pulumi.Input['DataSetColumnGroupGeoSpatialColumnGroupArgs']]):
        pulumi.set(self, "geo_spatial_column_group", value)


if not MYPY:
    class DataSetColumnGroupGeoSpatialColumnGroupArgsDict(TypedDict):
        columns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        country_code: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
elif False:
    DataSetColumnGroupGeoSpatialColumnGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetColumnGroupGeoSpatialColumnGroupArgs:
    def __init__(__self__, *,
                 columns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 country_code: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "country_code", country_code)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "columns", value)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DataSetColumnLevelPermissionRuleArgsDict(TypedDict):
        column_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        principals: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DataSetColumnLevelPermissionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetColumnLevelPermissionRuleArgs:
    def __init__(__self__, *,
                 column_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 principals: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if column_names is not None:
            pulumi.set(__self__, "column_names", column_names)
        if principals is not None:
            pulumi.set(__self__, "principals", principals)

    @_builtins.property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "column_names", value)

    @_builtins.property
    @pulumi.getter
    def principals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "principals")

    @principals.setter
    def principals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "principals", value)


if not MYPY:
    class DataSetDataSetUsageConfigurationArgsDict(TypedDict):
        disable_use_as_direct_query_source: NotRequired[pulumi.Input[_builtins.bool]]
        disable_use_as_imported_source: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    DataSetDataSetUsageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetDataSetUsageConfigurationArgs:
    def __init__(__self__, *,
                 disable_use_as_direct_query_source: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_use_as_imported_source: Optional[pulumi.Input[_builtins.bool]] = None):
        if disable_use_as_direct_query_source is not None:
            pulumi.set(__self__, "disable_use_as_direct_query_source", disable_use_as_direct_query_source)
        if disable_use_as_imported_source is not None:
            pulumi.set(__self__, "disable_use_as_imported_source", disable_use_as_imported_source)

    @_builtins.property
    @pulumi.getter(name="disableUseAsDirectQuerySource")
    def disable_use_as_direct_query_source(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "disable_use_as_direct_query_source")

    @disable_use_as_direct_query_source.setter
    def disable_use_as_direct_query_source(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_use_as_direct_query_source", value)

    @_builtins.property
    @pulumi.getter(name="disableUseAsImportedSource")
    def disable_use_as_imported_source(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "disable_use_as_imported_source")

    @disable_use_as_imported_source.setter
    def disable_use_as_imported_source(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_use_as_imported_source", value)


if not MYPY:
    class DataSetFieldFolderArgsDict(TypedDict):
        field_folders_id: pulumi.Input[_builtins.str]
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        description: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DataSetFieldFolderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetFieldFolderArgs:
    def __init__(__self__, *,
                 field_folders_id: pulumi.Input[_builtins.str],
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "field_folders_id", field_folders_id)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="fieldFoldersId")
    def field_folders_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "field_folders_id")

    @field_folders_id.setter
    def field_folders_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_folders_id", value)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "columns", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class DataSetLogicalTableMapArgsDict(TypedDict):
        alias: pulumi.Input[_builtins.str]
        logical_table_map_id: pulumi.Input[_builtins.str]
        source: pulumi.Input['DataSetLogicalTableMapSourceArgsDict']
        data_transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformArgsDict']]]]
elif False:
    DataSetLogicalTableMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapArgs:
    def __init__(__self__, *,
                 alias: pulumi.Input[_builtins.str],
                 logical_table_map_id: pulumi.Input[_builtins.str],
                 source: pulumi.Input['DataSetLogicalTableMapSourceArgs'],
                 data_transforms: Optional[pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformArgs']]]] = None):
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "logical_table_map_id", logical_table_map_id)
        pulumi.set(__self__, "source", source)
        if data_transforms is not None:
            pulumi.set(__self__, "data_transforms", data_transforms)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "alias", value)

    @_builtins.property
    @pulumi.getter(name="logicalTableMapId")
    def logical_table_map_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "logical_table_map_id")

    @logical_table_map_id.setter
    def logical_table_map_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "logical_table_map_id", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input['DataSetLogicalTableMapSourceArgs']:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input['DataSetLogicalTableMapSourceArgs']):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter(name="dataTransforms")
    def data_transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformArgs']]]]:
        return pulumi.get(self, "data_transforms")

    @data_transforms.setter
    def data_transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformArgs']]]]):
        pulumi.set(self, "data_transforms", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformArgsDict(TypedDict):
        cast_column_type_operation: NotRequired[pulumi.Input['DataSetLogicalTableMapDataTransformCastColumnTypeOperationArgsDict']]
        create_columns_operation: NotRequired[pulumi.Input['DataSetLogicalTableMapDataTransformCreateColumnsOperationArgsDict']]
        filter_operation: NotRequired[pulumi.Input['DataSetLogicalTableMapDataTransformFilterOperationArgsDict']]
        project_operation: NotRequired[pulumi.Input['DataSetLogicalTableMapDataTransformProjectOperationArgsDict']]
        rename_column_operation: NotRequired[pulumi.Input['DataSetLogicalTableMapDataTransformRenameColumnOperationArgsDict']]
        tag_column_operation: NotRequired[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationArgsDict']]
        untag_column_operation: NotRequired[pulumi.Input['DataSetLogicalTableMapDataTransformUntagColumnOperationArgsDict']]
elif False:
    DataSetLogicalTableMapDataTransformArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformArgs:
    def __init__(__self__, *,
                 cast_column_type_operation: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformCastColumnTypeOperationArgs']] = None,
                 create_columns_operation: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformCreateColumnsOperationArgs']] = None,
                 filter_operation: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformFilterOperationArgs']] = None,
                 project_operation: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformProjectOperationArgs']] = None,
                 rename_column_operation: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformRenameColumnOperationArgs']] = None,
                 tag_column_operation: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationArgs']] = None,
                 untag_column_operation: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformUntagColumnOperationArgs']] = None):
        if cast_column_type_operation is not None:
            pulumi.set(__self__, "cast_column_type_operation", cast_column_type_operation)
        if create_columns_operation is not None:
            pulumi.set(__self__, "create_columns_operation", create_columns_operation)
        if filter_operation is not None:
            pulumi.set(__self__, "filter_operation", filter_operation)
        if project_operation is not None:
            pulumi.set(__self__, "project_operation", project_operation)
        if rename_column_operation is not None:
            pulumi.set(__self__, "rename_column_operation", rename_column_operation)
        if tag_column_operation is not None:
            pulumi.set(__self__, "tag_column_operation", tag_column_operation)
        if untag_column_operation is not None:
            pulumi.set(__self__, "untag_column_operation", untag_column_operation)

    @_builtins.property
    @pulumi.getter(name="castColumnTypeOperation")
    def cast_column_type_operation(self) -> Optional[pulumi.Input['DataSetLogicalTableMapDataTransformCastColumnTypeOperationArgs']]:
        return pulumi.get(self, "cast_column_type_operation")

    @cast_column_type_operation.setter
    def cast_column_type_operation(self, value: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformCastColumnTypeOperationArgs']]):
        pulumi.set(self, "cast_column_type_operation", value)

    @_builtins.property
    @pulumi.getter(name="createColumnsOperation")
    def create_columns_operation(self) -> Optional[pulumi.Input['DataSetLogicalTableMapDataTransformCreateColumnsOperationArgs']]:
        return pulumi.get(self, "create_columns_operation")

    @create_columns_operation.setter
    def create_columns_operation(self, value: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformCreateColumnsOperationArgs']]):
        pulumi.set(self, "create_columns_operation", value)

    @_builtins.property
    @pulumi.getter(name="filterOperation")
    def filter_operation(self) -> Optional[pulumi.Input['DataSetLogicalTableMapDataTransformFilterOperationArgs']]:
        return pulumi.get(self, "filter_operation")

    @filter_operation.setter
    def filter_operation(self, value: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformFilterOperationArgs']]):
        pulumi.set(self, "filter_operation", value)

    @_builtins.property
    @pulumi.getter(name="projectOperation")
    def project_operation(self) -> Optional[pulumi.Input['DataSetLogicalTableMapDataTransformProjectOperationArgs']]:
        return pulumi.get(self, "project_operation")

    @project_operation.setter
    def project_operation(self, value: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformProjectOperationArgs']]):
        pulumi.set(self, "project_operation", value)

    @_builtins.property
    @pulumi.getter(name="renameColumnOperation")
    def rename_column_operation(self) -> Optional[pulumi.Input['DataSetLogicalTableMapDataTransformRenameColumnOperationArgs']]:
        return pulumi.get(self, "rename_column_operation")

    @rename_column_operation.setter
    def rename_column_operation(self, value: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformRenameColumnOperationArgs']]):
        pulumi.set(self, "rename_column_operation", value)

    @_builtins.property
    @pulumi.getter(name="tagColumnOperation")
    def tag_column_operation(self) -> Optional[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationArgs']]:
        return pulumi.get(self, "tag_column_operation")

    @tag_column_operation.setter
    def tag_column_operation(self, value: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationArgs']]):
        pulumi.set(self, "tag_column_operation", value)

    @_builtins.property
    @pulumi.getter(name="untagColumnOperation")
    def untag_column_operation(self) -> Optional[pulumi.Input['DataSetLogicalTableMapDataTransformUntagColumnOperationArgs']]:
        return pulumi.get(self, "untag_column_operation")

    @untag_column_operation.setter
    def untag_column_operation(self, value: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformUntagColumnOperationArgs']]):
        pulumi.set(self, "untag_column_operation", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformCastColumnTypeOperationArgsDict(TypedDict):
        column_name: pulumi.Input[_builtins.str]
        new_column_type: pulumi.Input[_builtins.str]
        format: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DataSetLogicalTableMapDataTransformCastColumnTypeOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformCastColumnTypeOperationArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[_builtins.str],
                 new_column_type: pulumi.Input[_builtins.str],
                 format: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "new_column_type", new_column_type)
        if format is not None:
            pulumi.set(__self__, "format", format)

    @_builtins.property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "column_name", value)

    @_builtins.property
    @pulumi.getter(name="newColumnType")
    def new_column_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "new_column_type")

    @new_column_type.setter
    def new_column_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "new_column_type", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformCreateColumnsOperationArgsDict(TypedDict):
        columns: pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformCreateColumnsOperationColumnArgsDict']]]
elif False:
    DataSetLogicalTableMapDataTransformCreateColumnsOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformCreateColumnsOperationArgs:
    def __init__(__self__, *,
                 columns: pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformCreateColumnsOperationColumnArgs']]]):
        pulumi.set(__self__, "columns", columns)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformCreateColumnsOperationColumnArgs']]]:
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformCreateColumnsOperationColumnArgs']]]):
        pulumi.set(self, "columns", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformCreateColumnsOperationColumnArgsDict(TypedDict):
        column_id: pulumi.Input[_builtins.str]
        column_name: pulumi.Input[_builtins.str]
        expression: pulumi.Input[_builtins.str]
elif False:
    DataSetLogicalTableMapDataTransformCreateColumnsOperationColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformCreateColumnsOperationColumnArgs:
    def __init__(__self__, *,
                 column_id: pulumi.Input[_builtins.str],
                 column_name: pulumi.Input[_builtins.str],
                 expression: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "column_id", column_id)
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter(name="columnId")
    def column_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "column_id")

    @column_id.setter
    def column_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "column_id", value)

    @_builtins.property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "column_name", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformFilterOperationArgsDict(TypedDict):
        condition_expression: pulumi.Input[_builtins.str]
elif False:
    DataSetLogicalTableMapDataTransformFilterOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformFilterOperationArgs:
    def __init__(__self__, *,
                 condition_expression: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "condition_expression", condition_expression)

    @_builtins.property
    @pulumi.getter(name="conditionExpression")
    def condition_expression(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "condition_expression")

    @condition_expression.setter
    def condition_expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition_expression", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformProjectOperationArgsDict(TypedDict):
        projected_columns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    DataSetLogicalTableMapDataTransformProjectOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformProjectOperationArgs:
    def __init__(__self__, *,
                 projected_columns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "projected_columns", projected_columns)

    @_builtins.property
    @pulumi.getter(name="projectedColumns")
    def projected_columns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "projected_columns")

    @projected_columns.setter
    def projected_columns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "projected_columns", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformRenameColumnOperationArgsDict(TypedDict):
        column_name: pulumi.Input[_builtins.str]
        new_column_name: pulumi.Input[_builtins.str]
elif False:
    DataSetLogicalTableMapDataTransformRenameColumnOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformRenameColumnOperationArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[_builtins.str],
                 new_column_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "new_column_name", new_column_name)

    @_builtins.property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "column_name", value)

    @_builtins.property
    @pulumi.getter(name="newColumnName")
    def new_column_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "new_column_name")

    @new_column_name.setter
    def new_column_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "new_column_name", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformTagColumnOperationArgsDict(TypedDict):
        column_name: pulumi.Input[_builtins.str]
        tags: pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationTagArgsDict']]]
elif False:
    DataSetLogicalTableMapDataTransformTagColumnOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformTagColumnOperationArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[_builtins.str],
                 tags: pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationTagArgs']]]):
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "column_name", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationTagArgs']]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: pulumi.Input[Sequence[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationTagArgs']]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformTagColumnOperationTagArgsDict(TypedDict):
        column_description: NotRequired[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionArgsDict']]
        column_geographic_role: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DataSetLogicalTableMapDataTransformTagColumnOperationTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformTagColumnOperationTagArgs:
    def __init__(__self__, *,
                 column_description: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionArgs']] = None,
                 column_geographic_role: Optional[pulumi.Input[_builtins.str]] = None):
        if column_description is not None:
            pulumi.set(__self__, "column_description", column_description)
        if column_geographic_role is not None:
            pulumi.set(__self__, "column_geographic_role", column_geographic_role)

    @_builtins.property
    @pulumi.getter(name="columnDescription")
    def column_description(self) -> Optional[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionArgs']]:
        return pulumi.get(self, "column_description")

    @column_description.setter
    def column_description(self, value: Optional[pulumi.Input['DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionArgs']]):
        pulumi.set(self, "column_description", value)

    @_builtins.property
    @pulumi.getter(name="columnGeographicRole")
    def column_geographic_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "column_geographic_role")

    @column_geographic_role.setter
    def column_geographic_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "column_geographic_role", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionArgsDict(TypedDict):
        text: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionArgs:
    def __init__(__self__, *,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class DataSetLogicalTableMapDataTransformUntagColumnOperationArgsDict(TypedDict):
        column_name: pulumi.Input[_builtins.str]
        tag_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    DataSetLogicalTableMapDataTransformUntagColumnOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapDataTransformUntagColumnOperationArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[_builtins.str],
                 tag_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "tag_names", tag_names)

    @_builtins.property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "column_name", value)

    @_builtins.property
    @pulumi.getter(name="tagNames")
    def tag_names(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "tag_names")

    @tag_names.setter
    def tag_names(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "tag_names", value)


if not MYPY:
    class DataSetLogicalTableMapSourceArgsDict(TypedDict):
        data_set_arn: NotRequired[pulumi.Input[_builtins.str]]
        join_instruction: NotRequired[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionArgsDict']]
        physical_table_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DataSetLogicalTableMapSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapSourceArgs:
    def __init__(__self__, *,
                 data_set_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 join_instruction: Optional[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionArgs']] = None,
                 physical_table_id: Optional[pulumi.Input[_builtins.str]] = None):
        if data_set_arn is not None:
            pulumi.set(__self__, "data_set_arn", data_set_arn)
        if join_instruction is not None:
            pulumi.set(__self__, "join_instruction", join_instruction)
        if physical_table_id is not None:
            pulumi.set(__self__, "physical_table_id", physical_table_id)

    @_builtins.property
    @pulumi.getter(name="dataSetArn")
    def data_set_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "data_set_arn")

    @data_set_arn.setter
    def data_set_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_set_arn", value)

    @_builtins.property
    @pulumi.getter(name="joinInstruction")
    def join_instruction(self) -> Optional[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionArgs']]:
        return pulumi.get(self, "join_instruction")

    @join_instruction.setter
    def join_instruction(self, value: Optional[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionArgs']]):
        pulumi.set(self, "join_instruction", value)

    @_builtins.property
    @pulumi.getter(name="physicalTableId")
    def physical_table_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "physical_table_id")

    @physical_table_id.setter
    def physical_table_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "physical_table_id", value)


if not MYPY:
    class DataSetLogicalTableMapSourceJoinInstructionArgsDict(TypedDict):
        left_operand: pulumi.Input[_builtins.str]
        on_clause: pulumi.Input[_builtins.str]
        right_operand: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
        left_join_key_properties: NotRequired[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertiesArgsDict']]
        right_join_key_properties: NotRequired[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertiesArgsDict']]
elif False:
    DataSetLogicalTableMapSourceJoinInstructionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapSourceJoinInstructionArgs:
    def __init__(__self__, *,
                 left_operand: pulumi.Input[_builtins.str],
                 on_clause: pulumi.Input[_builtins.str],
                 right_operand: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 left_join_key_properties: Optional[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertiesArgs']] = None,
                 right_join_key_properties: Optional[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertiesArgs']] = None):
        pulumi.set(__self__, "left_operand", left_operand)
        pulumi.set(__self__, "on_clause", on_clause)
        pulumi.set(__self__, "right_operand", right_operand)
        pulumi.set(__self__, "type", type)
        if left_join_key_properties is not None:
            pulumi.set(__self__, "left_join_key_properties", left_join_key_properties)
        if right_join_key_properties is not None:
            pulumi.set(__self__, "right_join_key_properties", right_join_key_properties)

    @_builtins.property
    @pulumi.getter(name="leftOperand")
    def left_operand(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "left_operand")

    @left_operand.setter
    def left_operand(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "left_operand", value)

    @_builtins.property
    @pulumi.getter(name="onClause")
    def on_clause(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "on_clause")

    @on_clause.setter
    def on_clause(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "on_clause", value)

    @_builtins.property
    @pulumi.getter(name="rightOperand")
    def right_operand(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "right_operand")

    @right_operand.setter
    def right_operand(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "right_operand", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="leftJoinKeyProperties")
    def left_join_key_properties(self) -> Optional[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertiesArgs']]:
        return pulumi.get(self, "left_join_key_properties")

    @left_join_key_properties.setter
    def left_join_key_properties(self, value: Optional[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertiesArgs']]):
        pulumi.set(self, "left_join_key_properties", value)

    @_builtins.property
    @pulumi.getter(name="rightJoinKeyProperties")
    def right_join_key_properties(self) -> Optional[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertiesArgs']]:
        return pulumi.get(self, "right_join_key_properties")

    @right_join_key_properties.setter
    def right_join_key_properties(self, value: Optional[pulumi.Input['DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertiesArgs']]):
        pulumi.set(self, "right_join_key_properties", value)


if not MYPY:
    class DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertiesArgsDict(TypedDict):
        unique_key: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertiesArgs:
    def __init__(__self__, *,
                 unique_key: Optional[pulumi.Input[_builtins.bool]] = None):
        if unique_key is not None:
            pulumi.set(__self__, "unique_key", unique_key)

    @_builtins.property
    @pulumi.getter(name="uniqueKey")
    def unique_key(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "unique_key")

    @unique_key.setter
    def unique_key(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "unique_key", value)


if not MYPY:
    class DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertiesArgsDict(TypedDict):
        unique_key: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertiesArgs:
    def __init__(__self__, *,
                 unique_key: Optional[pulumi.Input[_builtins.bool]] = None):
        if unique_key is not None:
            pulumi.set(__self__, "unique_key", unique_key)

    @_builtins.property
    @pulumi.getter(name="uniqueKey")
    def unique_key(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "unique_key")

    @unique_key.setter
    def unique_key(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "unique_key", value)


if not MYPY:
    class DataSetOutputColumnArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DataSetOutputColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetOutputColumnArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DataSetPermissionArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        principal: pulumi.Input[_builtins.str]
elif False:
    DataSetPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetPermissionArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 principal: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "principal", principal)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter
    def principal(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class DataSetPhysicalTableMapArgsDict(TypedDict):
        physical_table_map_id: pulumi.Input[_builtins.str]
        custom_sql: NotRequired[pulumi.Input['DataSetPhysicalTableMapCustomSqlArgsDict']]
        relational_table: NotRequired[pulumi.Input['DataSetPhysicalTableMapRelationalTableArgsDict']]
        s3_source: NotRequired[pulumi.Input['DataSetPhysicalTableMapS3SourceArgsDict']]
elif False:
    DataSetPhysicalTableMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetPhysicalTableMapArgs:
    def __init__(__self__, *,
                 physical_table_map_id: pulumi.Input[_builtins.str],
                 custom_sql: Optional[pulumi.Input['DataSetPhysicalTableMapCustomSqlArgs']] = None,
                 relational_table: Optional[pulumi.Input['DataSetPhysicalTableMapRelationalTableArgs']] = None,
                 s3_source: Optional[pulumi.Input['DataSetPhysicalTableMapS3SourceArgs']] = None):
        pulumi.set(__self__, "physical_table_map_id", physical_table_map_id)
        if custom_sql is not None:
            pulumi.set(__self__, "custom_sql", custom_sql)
        if relational_table is not None:
            pulumi.set(__self__, "relational_table", relational_table)
        if s3_source is not None:
            pulumi.set(__self__, "s3_source", s3_source)

    @_builtins.property
    @pulumi.getter(name="physicalTableMapId")
    def physical_table_map_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "physical_table_map_id")

    @physical_table_map_id.setter
    def physical_table_map_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "physical_table_map_id", value)

    @_builtins.property
    @pulumi.getter(name="customSql")
    def custom_sql(self) -> Optional[pulumi.Input['DataSetPhysicalTableMapCustomSqlArgs']]:
        return pulumi.get(self, "custom_sql")

    @custom_sql.setter
    def custom_sql(self, value: Optional[pulumi.Input['DataSetPhysicalTableMapCustomSqlArgs']]):
        pulumi.set(self, "custom_sql", value)

    @_builtins.property
    @pulumi.getter(name="relationalTable")
    def relational_table(self) -> Optional[pulumi.Input['DataSetPhysicalTableMapRelationalTableArgs']]:
        return pulumi.get(self, "relational_table")

    @relational_table.setter
    def relational_table(self, value: Optional[pulumi.Input['DataSetPhysicalTableMapRelationalTableArgs']]):
        pulumi.set(self, "relational_table", value)

    @_builtins.property
    @pulumi.getter(name="s3Source")
    def s3_source(self) -> Optional[pulumi.Input['DataSetPhysicalTableMapS3SourceArgs']]:
        return pulumi.get(self, "s3_source")

    @s3_source.setter
    def s3_source(self, value: Optional[pulumi.Input['DataSetPhysicalTableMapS3SourceArgs']]):
        pulumi.set(self, "s3_source", value)


if not MYPY:
    class DataSetPhysicalTableMapCustomSqlArgsDict(TypedDict):
        data_source_arn: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        sql_query: pulumi.Input[_builtins.str]
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapCustomSqlColumnArgsDict']]]]
elif False:
    DataSetPhysicalTableMapCustomSqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetPhysicalTableMapCustomSqlArgs:
    def __init__(__self__, *,
                 data_source_arn: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 sql_query: pulumi.Input[_builtins.str],
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapCustomSqlColumnArgs']]]] = None):
        pulumi.set(__self__, "data_source_arn", data_source_arn)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sql_query", sql_query)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)

    @_builtins.property
    @pulumi.getter(name="dataSourceArn")
    def data_source_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "data_source_arn")

    @data_source_arn.setter
    def data_source_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_source_arn", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="sqlQuery")
    def sql_query(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "sql_query")

    @sql_query.setter
    def sql_query(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sql_query", value)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapCustomSqlColumnArgs']]]]:
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapCustomSqlColumnArgs']]]]):
        pulumi.set(self, "columns", value)


if not MYPY:
    class DataSetPhysicalTableMapCustomSqlColumnArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
elif False:
    DataSetPhysicalTableMapCustomSqlColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetPhysicalTableMapCustomSqlColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DataSetPhysicalTableMapRelationalTableArgsDict(TypedDict):
        data_source_arn: pulumi.Input[_builtins.str]
        input_columns: pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapRelationalTableInputColumnArgsDict']]]
        name: pulumi.Input[_builtins.str]
        catalog: NotRequired[pulumi.Input[_builtins.str]]
        schema: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DataSetPhysicalTableMapRelationalTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetPhysicalTableMapRelationalTableArgs:
    def __init__(__self__, *,
                 data_source_arn: pulumi.Input[_builtins.str],
                 input_columns: pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapRelationalTableInputColumnArgs']]],
                 name: pulumi.Input[_builtins.str],
                 catalog: Optional[pulumi.Input[_builtins.str]] = None,
                 schema: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "data_source_arn", data_source_arn)
        pulumi.set(__self__, "input_columns", input_columns)
        pulumi.set(__self__, "name", name)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @_builtins.property
    @pulumi.getter(name="dataSourceArn")
    def data_source_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "data_source_arn")

    @data_source_arn.setter
    def data_source_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_source_arn", value)

    @_builtins.property
    @pulumi.getter(name="inputColumns")
    def input_columns(self) -> pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapRelationalTableInputColumnArgs']]]:
        return pulumi.get(self, "input_columns")

    @input_columns.setter
    def input_columns(self, value: pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapRelationalTableInputColumnArgs']]]):
        pulumi.set(self, "input_columns", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def catalog(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "catalog")

    @catalog.setter
    def catalog(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "catalog", value)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema", value)


if not MYPY:
    class DataSetPhysicalTableMapRelationalTableInputColumnArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
elif False:
    DataSetPhysicalTableMapRelationalTableInputColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetPhysicalTableMapRelationalTableInputColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DataSetPhysicalTableMapS3SourceArgsDict(TypedDict):
        data_source_arn: pulumi.Input[_builtins.str]
        input_columns: pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapS3SourceInputColumnArgsDict']]]
        upload_settings: pulumi.Input['DataSetPhysicalTableMapS3SourceUploadSettingsArgsDict']
elif False:
    DataSetPhysicalTableMapS3SourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetPhysicalTableMapS3SourceArgs:
    def __init__(__self__, *,
                 data_source_arn: pulumi.Input[_builtins.str],
                 input_columns: pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapS3SourceInputColumnArgs']]],
                 upload_settings: pulumi.Input['DataSetPhysicalTableMapS3SourceUploadSettingsArgs']):
        pulumi.set(__self__, "data_source_arn", data_source_arn)
        pulumi.set(__self__, "input_columns", input_columns)
        pulumi.set(__self__, "upload_settings", upload_settings)

    @_builtins.property
    @pulumi.getter(name="dataSourceArn")
    def data_source_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "data_source_arn")

    @data_source_arn.setter
    def data_source_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_source_arn", value)

    @_builtins.property
    @pulumi.getter(name="inputColumns")
    def input_columns(self) -> pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapS3SourceInputColumnArgs']]]:
        return pulumi.get(self, "input_columns")

    @input_columns.setter
    def input_columns(self, value: pulumi.Input[Sequence[pulumi.Input['DataSetPhysicalTableMapS3SourceInputColumnArgs']]]):
        pulumi.set(self, "input_columns", value)

    @_builtins.property
    @pulumi.getter(name="uploadSettings")
    def upload_settings(self) -> pulumi.Input['DataSetPhysicalTableMapS3SourceUploadSettingsArgs']:
        return pulumi.get(self, "upload_settings")

    @upload_settings.setter
    def upload_settings(self, value: pulumi.Input['DataSetPhysicalTableMapS3SourceUploadSettingsArgs']):
        pulumi.set(self, "upload_settings", value)


if not MYPY:
    class DataSetPhysicalTableMapS3SourceInputColumnArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
elif False:
    DataSetPhysicalTableMapS3SourceInputColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetPhysicalTableMapS3SourceInputColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DataSetPhysicalTableMapS3SourceUploadSettingsArgsDict(TypedDict):
        contains_header: NotRequired[pulumi.Input[_builtins.bool]]
        delimiter: NotRequired[pulumi.Input[_builtins.str]]
        format: NotRequired[pulumi.Input[_builtins.str]]
        start_from_row: NotRequired[pulumi.Input[_builtins.int]]
        text_qualifier: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DataSetPhysicalTableMapS3SourceUploadSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetPhysicalTableMapS3SourceUploadSettingsArgs:
    def __init__(__self__, *,
                 contains_header: Optional[pulumi.Input[_builtins.bool]] = None,
                 delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 start_from_row: Optional[pulumi.Input[_builtins.int]] = None,
                 text_qualifier: Optional[pulumi.Input[_builtins.str]] = None):
        if contains_header is not None:
            pulumi.set(__self__, "contains_header", contains_header)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if start_from_row is not None:
            pulumi.set(__self__, "start_from_row", start_from_row)
        if text_qualifier is not None:
            pulumi.set(__self__, "text_qualifier", text_qualifier)

    @_builtins.property
    @pulumi.getter(name="containsHeader")
    def contains_header(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "contains_header")

    @contains_header.setter
    def contains_header(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "contains_header", value)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delimiter", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="startFromRow")
    def start_from_row(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "start_from_row")

    @start_from_row.setter
    def start_from_row(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "start_from_row", value)

    @_builtins.property
    @pulumi.getter(name="textQualifier")
    def text_qualifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "text_qualifier")

    @text_qualifier.setter
    def text_qualifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text_qualifier", value)


if not MYPY:
    class DataSetRefreshPropertiesArgsDict(TypedDict):
        refresh_configuration: pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationArgsDict']
elif False:
    DataSetRefreshPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetRefreshPropertiesArgs:
    def __init__(__self__, *,
                 refresh_configuration: pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationArgs']):
        pulumi.set(__self__, "refresh_configuration", refresh_configuration)

    @_builtins.property
    @pulumi.getter(name="refreshConfiguration")
    def refresh_configuration(self) -> pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationArgs']:
        return pulumi.get(self, "refresh_configuration")

    @refresh_configuration.setter
    def refresh_configuration(self, value: pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationArgs']):
        pulumi.set(self, "refresh_configuration", value)


if not MYPY:
    class DataSetRefreshPropertiesRefreshConfigurationArgsDict(TypedDict):
        incremental_refresh: pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshArgsDict']
elif False:
    DataSetRefreshPropertiesRefreshConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetRefreshPropertiesRefreshConfigurationArgs:
    def __init__(__self__, *,
                 incremental_refresh: pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshArgs']):
        pulumi.set(__self__, "incremental_refresh", incremental_refresh)

    @_builtins.property
    @pulumi.getter(name="incrementalRefresh")
    def incremental_refresh(self) -> pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshArgs']:
        return pulumi.get(self, "incremental_refresh")

    @incremental_refresh.setter
    def incremental_refresh(self, value: pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshArgs']):
        pulumi.set(self, "incremental_refresh", value)


if not MYPY:
    class DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshArgsDict(TypedDict):
        lookback_window: pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindowArgsDict']
elif False:
    DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshArgs:
    def __init__(__self__, *,
                 lookback_window: pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindowArgs']):
        pulumi.set(__self__, "lookback_window", lookback_window)

    @_builtins.property
    @pulumi.getter(name="lookbackWindow")
    def lookback_window(self) -> pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindowArgs']:
        return pulumi.get(self, "lookback_window")

    @lookback_window.setter
    def lookback_window(self, value: pulumi.Input['DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindowArgs']):
        pulumi.set(self, "lookback_window", value)


if not MYPY:
    class DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindowArgsDict(TypedDict):
        column_name: pulumi.Input[_builtins.str]
        size: pulumi.Input[_builtins.int]
        size_unit: pulumi.Input[_builtins.str]
elif False:
    DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindowArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[_builtins.str],
                 size: pulumi.Input[_builtins.int],
                 size_unit: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "size_unit", size_unit)

    @_builtins.property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "column_name", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="sizeUnit")
    def size_unit(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "size_unit")

    @size_unit.setter
    def size_unit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "size_unit", value)


if not MYPY:
    class DataSetRowLevelPermissionDataSetArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        permission_policy: pulumi.Input[_builtins.str]
        format_version: NotRequired[pulumi.Input[_builtins.str]]
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DataSetRowLevelPermissionDataSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetRowLevelPermissionDataSetArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 permission_policy: pulumi.Input[_builtins.str],
                 format_version: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "permission_policy", permission_policy)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="permissionPolicy")
    def permission_policy(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "permission_policy")

    @permission_policy.setter
    def permission_policy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "permission_policy", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class DataSetRowLevelPermissionTagConfigurationArgsDict(TypedDict):
        tag_rules: pulumi.Input[Sequence[pulumi.Input['DataSetRowLevelPermissionTagConfigurationTagRuleArgsDict']]]
        status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DataSetRowLevelPermissionTagConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetRowLevelPermissionTagConfigurationArgs:
    def __init__(__self__, *,
                 tag_rules: pulumi.Input[Sequence[pulumi.Input['DataSetRowLevelPermissionTagConfigurationTagRuleArgs']]],
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "tag_rules", tag_rules)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="tagRules")
    def tag_rules(self) -> pulumi.Input[Sequence[pulumi.Input['DataSetRowLevelPermissionTagConfigurationTagRuleArgs']]]:
        return pulumi.get(self, "tag_rules")

    @tag_rules.setter
    def tag_rules(self, value: pulumi.Input[Sequence[pulumi.Input['DataSetRowLevelPermissionTagConfigurationTagRuleArgs']]]):
        pulumi.set(self, "tag_rules", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class DataSetRowLevelPermissionTagConfigurationTagRuleArgsDict(TypedDict):
        column_name: pulumi.Input[_builtins.str]
        tag_key: pulumi.Input[_builtins.str]
        match_all_value: NotRequired[pulumi.Input[_builtins.str]]
        tag_multi_value_delimiter: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DataSetRowLevelPermissionTagConfigurationTagRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSetRowLevelPermissionTagConfigurationTagRuleArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[_builtins.str],
                 tag_key: pulumi.Input[_builtins.str],
                 match_all_value: Optional[pulumi.Input[_builtins.str]] = None,
                 tag_multi_value_delimiter: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "tag_key", tag_key)
        if match_all_value is not None:
            pulumi.set(__self__, "match_all_value", match_all_value)
        if tag_multi_value_delimiter is not None:
            pulumi.set(__self__, "tag_multi_value_delimiter", tag_multi_value_delimiter)

    @_builtins.property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "column_name", value)

    @_builtins.property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tag_key", value)

    @_builtins.property
    @pulumi.getter(name="matchAllValue")
    def match_all_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_all_value")

    @match_all_value.setter
    def match_all_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_all_value", value)

    @_builtins.property
    @pulumi.getter(name="tagMultiValueDelimiter")
    def tag_multi_value_delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "tag_multi_value_delimiter")

    @tag_multi_value_delimiter.setter
    def tag_multi_value_delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag_multi_value_delimiter", value)


if not MYPY:
    class DataSourceCredentialsArgsDict(TypedDict):
        copy_source_arn: NotRequired[pulumi.Input[_builtins.str]]
        credential_pair: NotRequired[pulumi.Input['DataSourceCredentialsCredentialPairArgsDict']]
        secret_arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DataSourceCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceCredentialsArgs:
    def __init__(__self__, *,
                 copy_source_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 credential_pair: Optional[pulumi.Input['DataSourceCredentialsCredentialPairArgs']] = None,
                 secret_arn: Optional[pulumi.Input[_builtins.str]] = None):
        if copy_source_arn is not None:
            pulumi.set(__self__, "copy_source_arn", copy_source_arn)
        if credential_pair is not None:
            pulumi.set(__self__, "credential_pair", credential_pair)
        if secret_arn is not None:
            pulumi.set(__self__, "secret_arn", secret_arn)

    @_builtins.property
    @pulumi.getter(name="copySourceArn")
    def copy_source_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "copy_source_arn")

    @copy_source_arn.setter
    def copy_source_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "copy_source_arn", value)

    @_builtins.property
    @pulumi.getter(name="credentialPair")
    def credential_pair(self) -> Optional[pulumi.Input['DataSourceCredentialsCredentialPairArgs']]:
        return pulumi.get(self, "credential_pair")

    @credential_pair.setter
    def credential_pair(self, value: Optional[pulumi.Input['DataSourceCredentialsCredentialPairArgs']]):
        pulumi.set(self, "credential_pair", value)

    @_builtins.property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_arn", value)


if not MYPY:
    class DataSourceCredentialsCredentialPairArgsDict(TypedDict):
        password: pulumi.Input[_builtins.str]
        username: pulumi.Input[_builtins.str]
elif False:
    DataSourceCredentialsCredentialPairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceCredentialsCredentialPairArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class DataSourceParametersArgsDict(TypedDict):
        amazon_elasticsearch: NotRequired[pulumi.Input['DataSourceParametersAmazonElasticsearchArgsDict']]
        athena: NotRequired[pulumi.Input['DataSourceParametersAthenaArgsDict']]
        aurora: NotRequired[pulumi.Input['DataSourceParametersAuroraArgsDict']]
        aurora_postgresql: NotRequired[pulumi.Input['DataSourceParametersAuroraPostgresqlArgsDict']]
        aws_iot_analytics: NotRequired[pulumi.Input['DataSourceParametersAwsIotAnalyticsArgsDict']]
        databricks: NotRequired[pulumi.Input['DataSourceParametersDatabricksArgsDict']]
        jira: NotRequired[pulumi.Input['DataSourceParametersJiraArgsDict']]
        maria_db: NotRequired[pulumi.Input['DataSourceParametersMariaDbArgsDict']]
        mysql: NotRequired[pulumi.Input['DataSourceParametersMysqlArgsDict']]
        oracle: NotRequired[pulumi.Input['DataSourceParametersOracleArgsDict']]
        postgresql: NotRequired[pulumi.Input['DataSourceParametersPostgresqlArgsDict']]
        presto: NotRequired[pulumi.Input['DataSourceParametersPrestoArgsDict']]
        rds: NotRequired[pulumi.Input['DataSourceParametersRdsArgsDict']]
        redshift: NotRequired[pulumi.Input['DataSourceParametersRedshiftArgsDict']]
        s3: NotRequired[pulumi.Input['DataSourceParametersS3ArgsDict']]
        service_now: NotRequired[pulumi.Input['DataSourceParametersServiceNowArgsDict']]
        snowflake: NotRequired[pulumi.Input['DataSourceParametersSnowflakeArgsDict']]
        spark: NotRequired[pulumi.Input['DataSourceParametersSparkArgsDict']]
        sql_server: NotRequired[pulumi.Input['DataSourceParametersSqlServerArgsDict']]
        teradata: NotRequired[pulumi.Input['DataSourceParametersTeradataArgsDict']]
        twitter: NotRequired[pulumi.Input['DataSourceParametersTwitterArgsDict']]
elif False:
    DataSourceParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersArgs:
    def __init__(__self__, *,
                 amazon_elasticsearch: Optional[pulumi.Input['DataSourceParametersAmazonElasticsearchArgs']] = None,
                 athena: Optional[pulumi.Input['DataSourceParametersAthenaArgs']] = None,
                 aurora: Optional[pulumi.Input['DataSourceParametersAuroraArgs']] = None,
                 aurora_postgresql: Optional[pulumi.Input['DataSourceParametersAuroraPostgresqlArgs']] = None,
                 aws_iot_analytics: Optional[pulumi.Input['DataSourceParametersAwsIotAnalyticsArgs']] = None,
                 databricks: Optional[pulumi.Input['DataSourceParametersDatabricksArgs']] = None,
                 jira: Optional[pulumi.Input['DataSourceParametersJiraArgs']] = None,
                 maria_db: Optional[pulumi.Input['DataSourceParametersMariaDbArgs']] = None,
                 mysql: Optional[pulumi.Input['DataSourceParametersMysqlArgs']] = None,
                 oracle: Optional[pulumi.Input['DataSourceParametersOracleArgs']] = None,
                 postgresql: Optional[pulumi.Input['DataSourceParametersPostgresqlArgs']] = None,
                 presto: Optional[pulumi.Input['DataSourceParametersPrestoArgs']] = None,
                 rds: Optional[pulumi.Input['DataSourceParametersRdsArgs']] = None,
                 redshift: Optional[pulumi.Input['DataSourceParametersRedshiftArgs']] = None,
                 s3: Optional[pulumi.Input['DataSourceParametersS3Args']] = None,
                 service_now: Optional[pulumi.Input['DataSourceParametersServiceNowArgs']] = None,
                 snowflake: Optional[pulumi.Input['DataSourceParametersSnowflakeArgs']] = None,
                 spark: Optional[pulumi.Input['DataSourceParametersSparkArgs']] = None,
                 sql_server: Optional[pulumi.Input['DataSourceParametersSqlServerArgs']] = None,
                 teradata: Optional[pulumi.Input['DataSourceParametersTeradataArgs']] = None,
                 twitter: Optional[pulumi.Input['DataSourceParametersTwitterArgs']] = None):
        if amazon_elasticsearch is not None:
            pulumi.set(__self__, "amazon_elasticsearch", amazon_elasticsearch)
        if athena is not None:
            pulumi.set(__self__, "athena", athena)
        if aurora is not None:
            pulumi.set(__self__, "aurora", aurora)
        if aurora_postgresql is not None:
            pulumi.set(__self__, "aurora_postgresql", aurora_postgresql)
        if aws_iot_analytics is not None:
            pulumi.set(__self__, "aws_iot_analytics", aws_iot_analytics)
        if databricks is not None:
            pulumi.set(__self__, "databricks", databricks)
        if jira is not None:
            pulumi.set(__self__, "jira", jira)
        if maria_db is not None:
            pulumi.set(__self__, "maria_db", maria_db)
        if mysql is not None:
            pulumi.set(__self__, "mysql", mysql)
        if oracle is not None:
            pulumi.set(__self__, "oracle", oracle)
        if postgresql is not None:
            pulumi.set(__self__, "postgresql", postgresql)
        if presto is not None:
            pulumi.set(__self__, "presto", presto)
        if rds is not None:
            pulumi.set(__self__, "rds", rds)
        if redshift is not None:
            pulumi.set(__self__, "redshift", redshift)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if service_now is not None:
            pulumi.set(__self__, "service_now", service_now)
        if snowflake is not None:
            pulumi.set(__self__, "snowflake", snowflake)
        if spark is not None:
            pulumi.set(__self__, "spark", spark)
        if sql_server is not None:
            pulumi.set(__self__, "sql_server", sql_server)
        if teradata is not None:
            pulumi.set(__self__, "teradata", teradata)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)

    @_builtins.property
    @pulumi.getter(name="amazonElasticsearch")
    def amazon_elasticsearch(self) -> Optional[pulumi.Input['DataSourceParametersAmazonElasticsearchArgs']]:
        return pulumi.get(self, "amazon_elasticsearch")

    @amazon_elasticsearch.setter
    def amazon_elasticsearch(self, value: Optional[pulumi.Input['DataSourceParametersAmazonElasticsearchArgs']]):
        pulumi.set(self, "amazon_elasticsearch", value)

    @_builtins.property
    @pulumi.getter
    def athena(self) -> Optional[pulumi.Input['DataSourceParametersAthenaArgs']]:
        return pulumi.get(self, "athena")

    @athena.setter
    def athena(self, value: Optional[pulumi.Input['DataSourceParametersAthenaArgs']]):
        pulumi.set(self, "athena", value)

    @_builtins.property
    @pulumi.getter
    def aurora(self) -> Optional[pulumi.Input['DataSourceParametersAuroraArgs']]:
        return pulumi.get(self, "aurora")

    @aurora.setter
    def aurora(self, value: Optional[pulumi.Input['DataSourceParametersAuroraArgs']]):
        pulumi.set(self, "aurora", value)

    @_builtins.property
    @pulumi.getter(name="auroraPostgresql")
    def aurora_postgresql(self) -> Optional[pulumi.Input['DataSourceParametersAuroraPostgresqlArgs']]:
        return pulumi.get(self, "aurora_postgresql")

    @aurora_postgresql.setter
    def aurora_postgresql(self, value: Optional[pulumi.Input['DataSourceParametersAuroraPostgresqlArgs']]):
        pulumi.set(self, "aurora_postgresql", value)

    @_builtins.property
    @pulumi.getter(name="awsIotAnalytics")
    def aws_iot_analytics(self) -> Optional[pulumi.Input['DataSourceParametersAwsIotAnalyticsArgs']]:
        return pulumi.get(self, "aws_iot_analytics")

    @aws_iot_analytics.setter
    def aws_iot_analytics(self, value: Optional[pulumi.Input['DataSourceParametersAwsIotAnalyticsArgs']]):
        pulumi.set(self, "aws_iot_analytics", value)

    @_builtins.property
    @pulumi.getter
    def databricks(self) -> Optional[pulumi.Input['DataSourceParametersDatabricksArgs']]:
        return pulumi.get(self, "databricks")

    @databricks.setter
    def databricks(self, value: Optional[pulumi.Input['DataSourceParametersDatabricksArgs']]):
        pulumi.set(self, "databricks", value)

    @_builtins.property
    @pulumi.getter
    def jira(self) -> Optional[pulumi.Input['DataSourceParametersJiraArgs']]:
        return pulumi.get(self, "jira")

    @jira.setter
    def jira(self, value: Optional[pulumi.Input['DataSourceParametersJiraArgs']]):
        pulumi.set(self, "jira", value)

    @_builtins.property
    @pulumi.getter(name="mariaDb")
    def maria_db(self) -> Optional[pulumi.Input['DataSourceParametersMariaDbArgs']]:
        return pulumi.get(self, "maria_db")

    @maria_db.setter
    def maria_db(self, value: Optional[pulumi.Input['DataSourceParametersMariaDbArgs']]):
        pulumi.set(self, "maria_db", value)

    @_builtins.property
    @pulumi.getter
    def mysql(self) -> Optional[pulumi.Input['DataSourceParametersMysqlArgs']]:
        return pulumi.get(self, "mysql")

    @mysql.setter
    def mysql(self, value: Optional[pulumi.Input['DataSourceParametersMysqlArgs']]):
        pulumi.set(self, "mysql", value)

    @_builtins.property
    @pulumi.getter
    def oracle(self) -> Optional[pulumi.Input['DataSourceParametersOracleArgs']]:
        return pulumi.get(self, "oracle")

    @oracle.setter
    def oracle(self, value: Optional[pulumi.Input['DataSourceParametersOracleArgs']]):
        pulumi.set(self, "oracle", value)

    @_builtins.property
    @pulumi.getter
    def postgresql(self) -> Optional[pulumi.Input['DataSourceParametersPostgresqlArgs']]:
        return pulumi.get(self, "postgresql")

    @postgresql.setter
    def postgresql(self, value: Optional[pulumi.Input['DataSourceParametersPostgresqlArgs']]):
        pulumi.set(self, "postgresql", value)

    @_builtins.property
    @pulumi.getter
    def presto(self) -> Optional[pulumi.Input['DataSourceParametersPrestoArgs']]:
        return pulumi.get(self, "presto")

    @presto.setter
    def presto(self, value: Optional[pulumi.Input['DataSourceParametersPrestoArgs']]):
        pulumi.set(self, "presto", value)

    @_builtins.property
    @pulumi.getter
    def rds(self) -> Optional[pulumi.Input['DataSourceParametersRdsArgs']]:
        return pulumi.get(self, "rds")

    @rds.setter
    def rds(self, value: Optional[pulumi.Input['DataSourceParametersRdsArgs']]):
        pulumi.set(self, "rds", value)

    @_builtins.property
    @pulumi.getter
    def redshift(self) -> Optional[pulumi.Input['DataSourceParametersRedshiftArgs']]:
        return pulumi.get(self, "redshift")

    @redshift.setter
    def redshift(self, value: Optional[pulumi.Input['DataSourceParametersRedshiftArgs']]):
        pulumi.set(self, "redshift", value)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['DataSourceParametersS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['DataSourceParametersS3Args']]):
        pulumi.set(self, "s3", value)

    @_builtins.property
    @pulumi.getter(name="serviceNow")
    def service_now(self) -> Optional[pulumi.Input['DataSourceParametersServiceNowArgs']]:
        return pulumi.get(self, "service_now")

    @service_now.setter
    def service_now(self, value: Optional[pulumi.Input['DataSourceParametersServiceNowArgs']]):
        pulumi.set(self, "service_now", value)

    @_builtins.property
    @pulumi.getter
    def snowflake(self) -> Optional[pulumi.Input['DataSourceParametersSnowflakeArgs']]:
        return pulumi.get(self, "snowflake")

    @snowflake.setter
    def snowflake(self, value: Optional[pulumi.Input['DataSourceParametersSnowflakeArgs']]):
        pulumi.set(self, "snowflake", value)

    @_builtins.property
    @pulumi.getter
    def spark(self) -> Optional[pulumi.Input['DataSourceParametersSparkArgs']]:
        return pulumi.get(self, "spark")

    @spark.setter
    def spark(self, value: Optional[pulumi.Input['DataSourceParametersSparkArgs']]):
        pulumi.set(self, "spark", value)

    @_builtins.property
    @pulumi.getter(name="sqlServer")
    def sql_server(self) -> Optional[pulumi.Input['DataSourceParametersSqlServerArgs']]:
        return pulumi.get(self, "sql_server")

    @sql_server.setter
    def sql_server(self, value: Optional[pulumi.Input['DataSourceParametersSqlServerArgs']]):
        pulumi.set(self, "sql_server", value)

    @_builtins.property
    @pulumi.getter
    def teradata(self) -> Optional[pulumi.Input['DataSourceParametersTeradataArgs']]:
        return pulumi.get(self, "teradata")

    @teradata.setter
    def teradata(self, value: Optional[pulumi.Input['DataSourceParametersTeradataArgs']]):
        pulumi.set(self, "teradata", value)

    @_builtins.property
    @pulumi.getter
    def twitter(self) -> Optional[pulumi.Input['DataSourceParametersTwitterArgs']]:
        return pulumi.get(self, "twitter")

    @twitter.setter
    def twitter(self, value: Optional[pulumi.Input['DataSourceParametersTwitterArgs']]):
        pulumi.set(self, "twitter", value)


if not MYPY:
    class DataSourceParametersAmazonElasticsearchArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
elif False:
    DataSourceParametersAmazonElasticsearchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersAmazonElasticsearchArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class DataSourceParametersAthenaArgsDict(TypedDict):
        work_group: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DataSourceParametersAthenaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersAthenaArgs:
    def __init__(__self__, *,
                 work_group: Optional[pulumi.Input[_builtins.str]] = None):
        if work_group is not None:
            pulumi.set(__self__, "work_group", work_group)

    @_builtins.property
    @pulumi.getter(name="workGroup")
    def work_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "work_group")

    @work_group.setter
    def work_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "work_group", value)


if not MYPY:
    class DataSourceParametersAuroraArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        host: pulumi.Input[_builtins.str]
        port: pulumi.Input[_builtins.int]
elif False:
    DataSourceParametersAuroraArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersAuroraArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 host: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersAuroraPostgresqlArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        host: pulumi.Input[_builtins.str]
        port: pulumi.Input[_builtins.int]
elif False:
    DataSourceParametersAuroraPostgresqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersAuroraPostgresqlArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 host: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersAwsIotAnalyticsArgsDict(TypedDict):
        data_set_name: pulumi.Input[_builtins.str]
elif False:
    DataSourceParametersAwsIotAnalyticsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersAwsIotAnalyticsArgs:
    def __init__(__self__, *,
                 data_set_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "data_set_name", data_set_name)

    @_builtins.property
    @pulumi.getter(name="dataSetName")
    def data_set_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "data_set_name")

    @data_set_name.setter
    def data_set_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_set_name", value)


if not MYPY:
    class DataSourceParametersDatabricksArgsDict(TypedDict):
        host: pulumi.Input[_builtins.str]
        port: pulumi.Input[_builtins.int]
        sql_endpoint_path: pulumi.Input[_builtins.str]
elif False:
    DataSourceParametersDatabricksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersDatabricksArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 sql_endpoint_path: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "sql_endpoint_path", sql_endpoint_path)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="sqlEndpointPath")
    def sql_endpoint_path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "sql_endpoint_path")

    @sql_endpoint_path.setter
    def sql_endpoint_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sql_endpoint_path", value)


if not MYPY:
    class DataSourceParametersJiraArgsDict(TypedDict):
        site_base_url: pulumi.Input[_builtins.str]
elif False:
    DataSourceParametersJiraArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersJiraArgs:
    def __init__(__self__, *,
                 site_base_url: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "site_base_url", site_base_url)

    @_builtins.property
    @pulumi.getter(name="siteBaseUrl")
    def site_base_url(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "site_base_url")

    @site_base_url.setter
    def site_base_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "site_base_url", value)


if not MYPY:
    class DataSourceParametersMariaDbArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        host: pulumi.Input[_builtins.str]
        port: pulumi.Input[_builtins.int]
elif False:
    DataSourceParametersMariaDbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersMariaDbArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 host: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersMysqlArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        host: pulumi.Input[_builtins.str]
        port: pulumi.Input[_builtins.int]
elif False:
    DataSourceParametersMysqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersMysqlArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 host: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersOracleArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        host: pulumi.Input[_builtins.str]
        port: pulumi.Input[_builtins.int]
elif False:
    DataSourceParametersOracleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersOracleArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 host: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersPostgresqlArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        host: pulumi.Input[_builtins.str]
        port: pulumi.Input[_builtins.int]
elif False:
    DataSourceParametersPostgresqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersPostgresqlArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 host: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersPrestoArgsDict(TypedDict):
        catalog: pulumi.Input[_builtins.str]
        host: pulumi.Input[_builtins.str]
        port: pulumi.Input[_builtins.int]
elif False:
    DataSourceParametersPrestoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersPrestoArgs:
    def __init__(__self__, *,
                 catalog: pulumi.Input[_builtins.str],
                 host: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "catalog", catalog)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def catalog(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "catalog")

    @catalog.setter
    def catalog(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "catalog", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersRdsArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        instance_id: pulumi.Input[_builtins.str]
elif False:
    DataSourceParametersRdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersRdsArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 instance_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "instance_id", instance_id)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_id", value)


if not MYPY:
    class DataSourceParametersRedshiftArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        host: NotRequired[pulumi.Input[_builtins.str]]
        port: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    DataSourceParametersRedshiftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersRedshiftArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "database", database)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_id", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersS3ArgsDict(TypedDict):
        manifest_file_location: pulumi.Input['DataSourceParametersS3ManifestFileLocationArgsDict']
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DataSourceParametersS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersS3Args:
    def __init__(__self__, *,
                 manifest_file_location: pulumi.Input['DataSourceParametersS3ManifestFileLocationArgs'],
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "manifest_file_location", manifest_file_location)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter(name="manifestFileLocation")
    def manifest_file_location(self) -> pulumi.Input['DataSourceParametersS3ManifestFileLocationArgs']:
        return pulumi.get(self, "manifest_file_location")

    @manifest_file_location.setter
    def manifest_file_location(self, value: pulumi.Input['DataSourceParametersS3ManifestFileLocationArgs']):
        pulumi.set(self, "manifest_file_location", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class DataSourceParametersS3ManifestFileLocationArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        key: pulumi.Input[_builtins.str]
elif False:
    DataSourceParametersS3ManifestFileLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersS3ManifestFileLocationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class DataSourceParametersServiceNowArgsDict(TypedDict):
        site_base_url: pulumi.Input[_builtins.str]
elif False:
    DataSourceParametersServiceNowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersServiceNowArgs:
    def __init__(__self__, *,
                 site_base_url: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "site_base_url", site_base_url)

    @_builtins.property
    @pulumi.getter(name="siteBaseUrl")
    def site_base_url(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "site_base_url")

    @site_base_url.setter
    def site_base_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "site_base_url", value)


if not MYPY:
    class DataSourceParametersSnowflakeArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        host: pulumi.Input[_builtins.str]
        warehouse: pulumi.Input[_builtins.str]
elif False:
    DataSourceParametersSnowflakeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersSnowflakeArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 host: pulumi.Input[_builtins.str],
                 warehouse: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "warehouse", warehouse)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def warehouse(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "warehouse")

    @warehouse.setter
    def warehouse(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "warehouse", value)


if not MYPY:
    class DataSourceParametersSparkArgsDict(TypedDict):
        host: pulumi.Input[_builtins.str]
        port: pulumi.Input[_builtins.int]
elif False:
    DataSourceParametersSparkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersSparkArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersSqlServerArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        host: pulumi.Input[_builtins.str]
        port: pulumi.Input[_builtins.int]
elif False:
    DataSourceParametersSqlServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersSqlServerArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 host: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersTeradataArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        host: pulumi.Input[_builtins.str]
        port: pulumi.Input[_builtins.int]
elif False:
    DataSourceParametersTeradataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersTeradataArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 host: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class DataSourceParametersTwitterArgsDict(TypedDict):
        max_rows: pulumi.Input[_builtins.int]
        query: pulumi.Input[_builtins.str]
elif False:
    DataSourceParametersTwitterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParametersTwitterArgs:
    def __init__(__self__, *,
                 max_rows: pulumi.Input[_builtins.int],
                 query: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "max_rows", max_rows)
        pulumi.set(__self__, "query", query)

    @_builtins.property
    @pulumi.getter(name="maxRows")
    def max_rows(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "max_rows")

    @max_rows.setter
    def max_rows(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_rows", value)

    @_builtins.property
    @pulumi.getter
    def query(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "query", value)


if not MYPY:
    class DataSourcePermissionArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        principal: pulumi.Input[_builtins.str]
elif False:
    DataSourcePermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourcePermissionArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 principal: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "principal", principal)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter
    def principal(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class DataSourceSslPropertiesArgsDict(TypedDict):
        disable_ssl: pulumi.Input[_builtins.bool]
elif False:
    DataSourceSslPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceSslPropertiesArgs:
    def __init__(__self__, *,
                 disable_ssl: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "disable_ssl", disable_ssl)

    @_builtins.property
    @pulumi.getter(name="disableSsl")
    def disable_ssl(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "disable_ssl")

    @disable_ssl.setter
    def disable_ssl(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "disable_ssl", value)


if not MYPY:
    class DataSourceVpcConnectionPropertiesArgsDict(TypedDict):
        vpc_connection_arn: pulumi.Input[_builtins.str]
elif False:
    DataSourceVpcConnectionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceVpcConnectionPropertiesArgs:
    def __init__(__self__, *,
                 vpc_connection_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "vpc_connection_arn", vpc_connection_arn)

    @_builtins.property
    @pulumi.getter(name="vpcConnectionArn")
    def vpc_connection_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "vpc_connection_arn")

    @vpc_connection_arn.setter
    def vpc_connection_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_connection_arn", value)


if not MYPY:
    class FolderPermissionArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        principal: pulumi.Input[_builtins.str]
elif False:
    FolderPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FolderPermissionArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 principal: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "principal", principal)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter
    def principal(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class IamPolicyAssignmentIdentitiesArgsDict(TypedDict):
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        users: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    IamPolicyAssignmentIdentitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamPolicyAssignmentIdentitiesArgs:
    def __init__(__self__, *,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "groups", value)

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "users", value)


if not MYPY:
    class KeyRegistrationKeyRegistrationArgsDict(TypedDict):
        key_arn: pulumi.Input[_builtins.str]
        default_key: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    KeyRegistrationKeyRegistrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeyRegistrationKeyRegistrationArgs:
    def __init__(__self__, *,
                 key_arn: pulumi.Input[_builtins.str],
                 default_key: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "key_arn", key_arn)
        if default_key is not None:
            pulumi.set(__self__, "default_key", default_key)

    @_builtins.property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key_arn")

    @key_arn.setter
    def key_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_arn", value)

    @_builtins.property
    @pulumi.getter(name="defaultKey")
    def default_key(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "default_key")

    @default_key.setter
    def default_key(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "default_key", value)


if not MYPY:
    class NamespaceTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    NamespaceTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class RefreshScheduleScheduleArgsDict(TypedDict):
        refresh_type: pulumi.Input[_builtins.str]
        schedule_frequency: NotRequired[pulumi.Input['RefreshScheduleScheduleScheduleFrequencyArgsDict']]
        start_after_date_time: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RefreshScheduleScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RefreshScheduleScheduleArgs:
    def __init__(__self__, *,
                 refresh_type: pulumi.Input[_builtins.str],
                 schedule_frequency: Optional[pulumi.Input['RefreshScheduleScheduleScheduleFrequencyArgs']] = None,
                 start_after_date_time: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "refresh_type", refresh_type)
        if schedule_frequency is not None:
            pulumi.set(__self__, "schedule_frequency", schedule_frequency)
        if start_after_date_time is not None:
            pulumi.set(__self__, "start_after_date_time", start_after_date_time)

    @_builtins.property
    @pulumi.getter(name="refreshType")
    def refresh_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "refresh_type")

    @refresh_type.setter
    def refresh_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "refresh_type", value)

    @_builtins.property
    @pulumi.getter(name="scheduleFrequency")
    def schedule_frequency(self) -> Optional[pulumi.Input['RefreshScheduleScheduleScheduleFrequencyArgs']]:
        return pulumi.get(self, "schedule_frequency")

    @schedule_frequency.setter
    def schedule_frequency(self, value: Optional[pulumi.Input['RefreshScheduleScheduleScheduleFrequencyArgs']]):
        pulumi.set(self, "schedule_frequency", value)

    @_builtins.property
    @pulumi.getter(name="startAfterDateTime")
    def start_after_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "start_after_date_time")

    @start_after_date_time.setter
    def start_after_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_after_date_time", value)


if not MYPY:
    class RefreshScheduleScheduleScheduleFrequencyArgsDict(TypedDict):
        interval: pulumi.Input[_builtins.str]
        refresh_on_day: NotRequired[pulumi.Input['RefreshScheduleScheduleScheduleFrequencyRefreshOnDayArgsDict']]
        time_of_the_day: NotRequired[pulumi.Input[_builtins.str]]
        timezone: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RefreshScheduleScheduleScheduleFrequencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RefreshScheduleScheduleScheduleFrequencyArgs:
    def __init__(__self__, *,
                 interval: pulumi.Input[_builtins.str],
                 refresh_on_day: Optional[pulumi.Input['RefreshScheduleScheduleScheduleFrequencyRefreshOnDayArgs']] = None,
                 time_of_the_day: Optional[pulumi.Input[_builtins.str]] = None,
                 timezone: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "interval", interval)
        if refresh_on_day is not None:
            pulumi.set(__self__, "refresh_on_day", refresh_on_day)
        if time_of_the_day is not None:
            pulumi.set(__self__, "time_of_the_day", time_of_the_day)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter(name="refreshOnDay")
    def refresh_on_day(self) -> Optional[pulumi.Input['RefreshScheduleScheduleScheduleFrequencyRefreshOnDayArgs']]:
        return pulumi.get(self, "refresh_on_day")

    @refresh_on_day.setter
    def refresh_on_day(self, value: Optional[pulumi.Input['RefreshScheduleScheduleScheduleFrequencyRefreshOnDayArgs']]):
        pulumi.set(self, "refresh_on_day", value)

    @_builtins.property
    @pulumi.getter(name="timeOfTheDay")
    def time_of_the_day(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "time_of_the_day")

    @time_of_the_day.setter
    def time_of_the_day(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_of_the_day", value)

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class RefreshScheduleScheduleScheduleFrequencyRefreshOnDayArgsDict(TypedDict):
        day_of_month: NotRequired[pulumi.Input[_builtins.str]]
        day_of_week: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RefreshScheduleScheduleScheduleFrequencyRefreshOnDayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RefreshScheduleScheduleScheduleFrequencyRefreshOnDayArgs:
    def __init__(__self__, *,
                 day_of_month: Optional[pulumi.Input[_builtins.str]] = None,
                 day_of_week: Optional[pulumi.Input[_builtins.str]] = None):
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)

    @_builtins.property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "day_of_month", value)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "day_of_week", value)


if not MYPY:
    class TemplatePermissionArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        principal: pulumi.Input[_builtins.str]
elif False:
    TemplatePermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplatePermissionArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 principal: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "principal", principal)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter
    def principal(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class TemplateSourceEntityArgsDict(TypedDict):
        source_analysis: NotRequired[pulumi.Input['TemplateSourceEntitySourceAnalysisArgsDict']]
        source_template: NotRequired[pulumi.Input['TemplateSourceEntitySourceTemplateArgsDict']]
elif False:
    TemplateSourceEntityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateSourceEntityArgs:
    def __init__(__self__, *,
                 source_analysis: Optional[pulumi.Input['TemplateSourceEntitySourceAnalysisArgs']] = None,
                 source_template: Optional[pulumi.Input['TemplateSourceEntitySourceTemplateArgs']] = None):
        if source_analysis is not None:
            pulumi.set(__self__, "source_analysis", source_analysis)
        if source_template is not None:
            pulumi.set(__self__, "source_template", source_template)

    @_builtins.property
    @pulumi.getter(name="sourceAnalysis")
    def source_analysis(self) -> Optional[pulumi.Input['TemplateSourceEntitySourceAnalysisArgs']]:
        return pulumi.get(self, "source_analysis")

    @source_analysis.setter
    def source_analysis(self, value: Optional[pulumi.Input['TemplateSourceEntitySourceAnalysisArgs']]):
        pulumi.set(self, "source_analysis", value)

    @_builtins.property
    @pulumi.getter(name="sourceTemplate")
    def source_template(self) -> Optional[pulumi.Input['TemplateSourceEntitySourceTemplateArgs']]:
        return pulumi.get(self, "source_template")

    @source_template.setter
    def source_template(self, value: Optional[pulumi.Input['TemplateSourceEntitySourceTemplateArgs']]):
        pulumi.set(self, "source_template", value)


if not MYPY:
    class TemplateSourceEntitySourceAnalysisArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        data_set_references: pulumi.Input[Sequence[pulumi.Input['TemplateSourceEntitySourceAnalysisDataSetReferenceArgsDict']]]
elif False:
    TemplateSourceEntitySourceAnalysisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateSourceEntitySourceAnalysisArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 data_set_references: pulumi.Input[Sequence[pulumi.Input['TemplateSourceEntitySourceAnalysisDataSetReferenceArgs']]]):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "data_set_references", data_set_references)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="dataSetReferences")
    def data_set_references(self) -> pulumi.Input[Sequence[pulumi.Input['TemplateSourceEntitySourceAnalysisDataSetReferenceArgs']]]:
        return pulumi.get(self, "data_set_references")

    @data_set_references.setter
    def data_set_references(self, value: pulumi.Input[Sequence[pulumi.Input['TemplateSourceEntitySourceAnalysisDataSetReferenceArgs']]]):
        pulumi.set(self, "data_set_references", value)


if not MYPY:
    class TemplateSourceEntitySourceAnalysisDataSetReferenceArgsDict(TypedDict):
        data_set_arn: pulumi.Input[_builtins.str]
        data_set_placeholder: pulumi.Input[_builtins.str]
elif False:
    TemplateSourceEntitySourceAnalysisDataSetReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateSourceEntitySourceAnalysisDataSetReferenceArgs:
    def __init__(__self__, *,
                 data_set_arn: pulumi.Input[_builtins.str],
                 data_set_placeholder: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "data_set_arn", data_set_arn)
        pulumi.set(__self__, "data_set_placeholder", data_set_placeholder)

    @_builtins.property
    @pulumi.getter(name="dataSetArn")
    def data_set_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "data_set_arn")

    @data_set_arn.setter
    def data_set_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_set_arn", value)

    @_builtins.property
    @pulumi.getter(name="dataSetPlaceholder")
    def data_set_placeholder(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "data_set_placeholder")

    @data_set_placeholder.setter
    def data_set_placeholder(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_set_placeholder", value)


if not MYPY:
    class TemplateSourceEntitySourceTemplateArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
elif False:
    TemplateSourceEntitySourceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateSourceEntitySourceTemplateArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class ThemeConfigurationArgsDict(TypedDict):
        data_color_palette: NotRequired[pulumi.Input['ThemeConfigurationDataColorPaletteArgsDict']]
        sheet: NotRequired[pulumi.Input['ThemeConfigurationSheetArgsDict']]
        typography: NotRequired[pulumi.Input['ThemeConfigurationTypographyArgsDict']]
        ui_color_palette: NotRequired[pulumi.Input['ThemeConfigurationUiColorPaletteArgsDict']]
elif False:
    ThemeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationArgs:
    def __init__(__self__, *,
                 data_color_palette: Optional[pulumi.Input['ThemeConfigurationDataColorPaletteArgs']] = None,
                 sheet: Optional[pulumi.Input['ThemeConfigurationSheetArgs']] = None,
                 typography: Optional[pulumi.Input['ThemeConfigurationTypographyArgs']] = None,
                 ui_color_palette: Optional[pulumi.Input['ThemeConfigurationUiColorPaletteArgs']] = None):
        if data_color_palette is not None:
            pulumi.set(__self__, "data_color_palette", data_color_palette)
        if sheet is not None:
            pulumi.set(__self__, "sheet", sheet)
        if typography is not None:
            pulumi.set(__self__, "typography", typography)
        if ui_color_palette is not None:
            pulumi.set(__self__, "ui_color_palette", ui_color_palette)

    @_builtins.property
    @pulumi.getter(name="dataColorPalette")
    def data_color_palette(self) -> Optional[pulumi.Input['ThemeConfigurationDataColorPaletteArgs']]:
        return pulumi.get(self, "data_color_palette")

    @data_color_palette.setter
    def data_color_palette(self, value: Optional[pulumi.Input['ThemeConfigurationDataColorPaletteArgs']]):
        pulumi.set(self, "data_color_palette", value)

    @_builtins.property
    @pulumi.getter
    def sheet(self) -> Optional[pulumi.Input['ThemeConfigurationSheetArgs']]:
        return pulumi.get(self, "sheet")

    @sheet.setter
    def sheet(self, value: Optional[pulumi.Input['ThemeConfigurationSheetArgs']]):
        pulumi.set(self, "sheet", value)

    @_builtins.property
    @pulumi.getter
    def typography(self) -> Optional[pulumi.Input['ThemeConfigurationTypographyArgs']]:
        return pulumi.get(self, "typography")

    @typography.setter
    def typography(self, value: Optional[pulumi.Input['ThemeConfigurationTypographyArgs']]):
        pulumi.set(self, "typography", value)

    @_builtins.property
    @pulumi.getter(name="uiColorPalette")
    def ui_color_palette(self) -> Optional[pulumi.Input['ThemeConfigurationUiColorPaletteArgs']]:
        return pulumi.get(self, "ui_color_palette")

    @ui_color_palette.setter
    def ui_color_palette(self, value: Optional[pulumi.Input['ThemeConfigurationUiColorPaletteArgs']]):
        pulumi.set(self, "ui_color_palette", value)


if not MYPY:
    class ThemeConfigurationDataColorPaletteArgsDict(TypedDict):
        colors: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        empty_fill_color: NotRequired[pulumi.Input[_builtins.str]]
        min_max_gradients: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ThemeConfigurationDataColorPaletteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationDataColorPaletteArgs:
    def __init__(__self__, *,
                 colors: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 empty_fill_color: Optional[pulumi.Input[_builtins.str]] = None,
                 min_max_gradients: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if colors is not None:
            pulumi.set(__self__, "colors", colors)
        if empty_fill_color is not None:
            pulumi.set(__self__, "empty_fill_color", empty_fill_color)
        if min_max_gradients is not None:
            pulumi.set(__self__, "min_max_gradients", min_max_gradients)

    @_builtins.property
    @pulumi.getter
    def colors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "colors")

    @colors.setter
    def colors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "colors", value)

    @_builtins.property
    @pulumi.getter(name="emptyFillColor")
    def empty_fill_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "empty_fill_color")

    @empty_fill_color.setter
    def empty_fill_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "empty_fill_color", value)

    @_builtins.property
    @pulumi.getter(name="minMaxGradients")
    def min_max_gradients(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "min_max_gradients")

    @min_max_gradients.setter
    def min_max_gradients(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "min_max_gradients", value)


if not MYPY:
    class ThemeConfigurationSheetArgsDict(TypedDict):
        tile: NotRequired[pulumi.Input['ThemeConfigurationSheetTileArgsDict']]
        tile_layout: NotRequired[pulumi.Input['ThemeConfigurationSheetTileLayoutArgsDict']]
elif False:
    ThemeConfigurationSheetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationSheetArgs:
    def __init__(__self__, *,
                 tile: Optional[pulumi.Input['ThemeConfigurationSheetTileArgs']] = None,
                 tile_layout: Optional[pulumi.Input['ThemeConfigurationSheetTileLayoutArgs']] = None):
        if tile is not None:
            pulumi.set(__self__, "tile", tile)
        if tile_layout is not None:
            pulumi.set(__self__, "tile_layout", tile_layout)

    @_builtins.property
    @pulumi.getter
    def tile(self) -> Optional[pulumi.Input['ThemeConfigurationSheetTileArgs']]:
        return pulumi.get(self, "tile")

    @tile.setter
    def tile(self, value: Optional[pulumi.Input['ThemeConfigurationSheetTileArgs']]):
        pulumi.set(self, "tile", value)

    @_builtins.property
    @pulumi.getter(name="tileLayout")
    def tile_layout(self) -> Optional[pulumi.Input['ThemeConfigurationSheetTileLayoutArgs']]:
        return pulumi.get(self, "tile_layout")

    @tile_layout.setter
    def tile_layout(self, value: Optional[pulumi.Input['ThemeConfigurationSheetTileLayoutArgs']]):
        pulumi.set(self, "tile_layout", value)


if not MYPY:
    class ThemeConfigurationSheetTileArgsDict(TypedDict):
        border: NotRequired[pulumi.Input['ThemeConfigurationSheetTileBorderArgsDict']]
elif False:
    ThemeConfigurationSheetTileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationSheetTileArgs:
    def __init__(__self__, *,
                 border: Optional[pulumi.Input['ThemeConfigurationSheetTileBorderArgs']] = None):
        if border is not None:
            pulumi.set(__self__, "border", border)

    @_builtins.property
    @pulumi.getter
    def border(self) -> Optional[pulumi.Input['ThemeConfigurationSheetTileBorderArgs']]:
        return pulumi.get(self, "border")

    @border.setter
    def border(self, value: Optional[pulumi.Input['ThemeConfigurationSheetTileBorderArgs']]):
        pulumi.set(self, "border", value)


if not MYPY:
    class ThemeConfigurationSheetTileBorderArgsDict(TypedDict):
        show: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ThemeConfigurationSheetTileBorderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationSheetTileBorderArgs:
    def __init__(__self__, *,
                 show: Optional[pulumi.Input[_builtins.bool]] = None):
        if show is not None:
            pulumi.set(__self__, "show", show)

    @_builtins.property
    @pulumi.getter
    def show(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "show")

    @show.setter
    def show(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "show", value)


if not MYPY:
    class ThemeConfigurationSheetTileLayoutArgsDict(TypedDict):
        gutter: NotRequired[pulumi.Input['ThemeConfigurationSheetTileLayoutGutterArgsDict']]
        margin: NotRequired[pulumi.Input['ThemeConfigurationSheetTileLayoutMarginArgsDict']]
elif False:
    ThemeConfigurationSheetTileLayoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationSheetTileLayoutArgs:
    def __init__(__self__, *,
                 gutter: Optional[pulumi.Input['ThemeConfigurationSheetTileLayoutGutterArgs']] = None,
                 margin: Optional[pulumi.Input['ThemeConfigurationSheetTileLayoutMarginArgs']] = None):
        if gutter is not None:
            pulumi.set(__self__, "gutter", gutter)
        if margin is not None:
            pulumi.set(__self__, "margin", margin)

    @_builtins.property
    @pulumi.getter
    def gutter(self) -> Optional[pulumi.Input['ThemeConfigurationSheetTileLayoutGutterArgs']]:
        return pulumi.get(self, "gutter")

    @gutter.setter
    def gutter(self, value: Optional[pulumi.Input['ThemeConfigurationSheetTileLayoutGutterArgs']]):
        pulumi.set(self, "gutter", value)

    @_builtins.property
    @pulumi.getter
    def margin(self) -> Optional[pulumi.Input['ThemeConfigurationSheetTileLayoutMarginArgs']]:
        return pulumi.get(self, "margin")

    @margin.setter
    def margin(self, value: Optional[pulumi.Input['ThemeConfigurationSheetTileLayoutMarginArgs']]):
        pulumi.set(self, "margin", value)


if not MYPY:
    class ThemeConfigurationSheetTileLayoutGutterArgsDict(TypedDict):
        show: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ThemeConfigurationSheetTileLayoutGutterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationSheetTileLayoutGutterArgs:
    def __init__(__self__, *,
                 show: Optional[pulumi.Input[_builtins.bool]] = None):
        if show is not None:
            pulumi.set(__self__, "show", show)

    @_builtins.property
    @pulumi.getter
    def show(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "show")

    @show.setter
    def show(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "show", value)


if not MYPY:
    class ThemeConfigurationSheetTileLayoutMarginArgsDict(TypedDict):
        show: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ThemeConfigurationSheetTileLayoutMarginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationSheetTileLayoutMarginArgs:
    def __init__(__self__, *,
                 show: Optional[pulumi.Input[_builtins.bool]] = None):
        if show is not None:
            pulumi.set(__self__, "show", show)

    @_builtins.property
    @pulumi.getter
    def show(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "show")

    @show.setter
    def show(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "show", value)


if not MYPY:
    class ThemeConfigurationTypographyArgsDict(TypedDict):
        font_families: NotRequired[pulumi.Input[Sequence[pulumi.Input['ThemeConfigurationTypographyFontFamilyArgsDict']]]]
elif False:
    ThemeConfigurationTypographyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationTypographyArgs:
    def __init__(__self__, *,
                 font_families: Optional[pulumi.Input[Sequence[pulumi.Input['ThemeConfigurationTypographyFontFamilyArgs']]]] = None):
        if font_families is not None:
            pulumi.set(__self__, "font_families", font_families)

    @_builtins.property
    @pulumi.getter(name="fontFamilies")
    def font_families(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ThemeConfigurationTypographyFontFamilyArgs']]]]:
        return pulumi.get(self, "font_families")

    @font_families.setter
    def font_families(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ThemeConfigurationTypographyFontFamilyArgs']]]]):
        pulumi.set(self, "font_families", value)


if not MYPY:
    class ThemeConfigurationTypographyFontFamilyArgsDict(TypedDict):
        font_family: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ThemeConfigurationTypographyFontFamilyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationTypographyFontFamilyArgs:
    def __init__(__self__, *,
                 font_family: Optional[pulumi.Input[_builtins.str]] = None):
        if font_family is not None:
            pulumi.set(__self__, "font_family", font_family)

    @_builtins.property
    @pulumi.getter(name="fontFamily")
    def font_family(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "font_family")

    @font_family.setter
    def font_family(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "font_family", value)


if not MYPY:
    class ThemeConfigurationUiColorPaletteArgsDict(TypedDict):
        accent: NotRequired[pulumi.Input[_builtins.str]]
        accent_foreground: NotRequired[pulumi.Input[_builtins.str]]
        danger: NotRequired[pulumi.Input[_builtins.str]]
        danger_foreground: NotRequired[pulumi.Input[_builtins.str]]
        dimension: NotRequired[pulumi.Input[_builtins.str]]
        dimension_foreground: NotRequired[pulumi.Input[_builtins.str]]
        measure: NotRequired[pulumi.Input[_builtins.str]]
        measure_foreground: NotRequired[pulumi.Input[_builtins.str]]
        primary_background: NotRequired[pulumi.Input[_builtins.str]]
        primary_foreground: NotRequired[pulumi.Input[_builtins.str]]
        secondary_background: NotRequired[pulumi.Input[_builtins.str]]
        secondary_foreground: NotRequired[pulumi.Input[_builtins.str]]
        success: NotRequired[pulumi.Input[_builtins.str]]
        success_foreground: NotRequired[pulumi.Input[_builtins.str]]
        warning: NotRequired[pulumi.Input[_builtins.str]]
        warning_foreground: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ThemeConfigurationUiColorPaletteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemeConfigurationUiColorPaletteArgs:
    def __init__(__self__, *,
                 accent: Optional[pulumi.Input[_builtins.str]] = None,
                 accent_foreground: Optional[pulumi.Input[_builtins.str]] = None,
                 danger: Optional[pulumi.Input[_builtins.str]] = None,
                 danger_foreground: Optional[pulumi.Input[_builtins.str]] = None,
                 dimension: Optional[pulumi.Input[_builtins.str]] = None,
                 dimension_foreground: Optional[pulumi.Input[_builtins.str]] = None,
                 measure: Optional[pulumi.Input[_builtins.str]] = None,
                 measure_foreground: Optional[pulumi.Input[_builtins.str]] = None,
                 primary_background: Optional[pulumi.Input[_builtins.str]] = None,
                 primary_foreground: Optional[pulumi.Input[_builtins.str]] = None,
                 secondary_background: Optional[pulumi.Input[_builtins.str]] = None,
                 secondary_foreground: Optional[pulumi.Input[_builtins.str]] = None,
                 success: Optional[pulumi.Input[_builtins.str]] = None,
                 success_foreground: Optional[pulumi.Input[_builtins.str]] = None,
                 warning: Optional[pulumi.Input[_builtins.str]] = None,
                 warning_foreground: Optional[pulumi.Input[_builtins.str]] = None):
        if accent is not None:
            pulumi.set(__self__, "accent", accent)
        if accent_foreground is not None:
            pulumi.set(__self__, "accent_foreground", accent_foreground)
        if danger is not None:
            pulumi.set(__self__, "danger", danger)
        if danger_foreground is not None:
            pulumi.set(__self__, "danger_foreground", danger_foreground)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)
        if dimension_foreground is not None:
            pulumi.set(__self__, "dimension_foreground", dimension_foreground)
        if measure is not None:
            pulumi.set(__self__, "measure", measure)
        if measure_foreground is not None:
            pulumi.set(__self__, "measure_foreground", measure_foreground)
        if primary_background is not None:
            pulumi.set(__self__, "primary_background", primary_background)
        if primary_foreground is not None:
            pulumi.set(__self__, "primary_foreground", primary_foreground)
        if secondary_background is not None:
            pulumi.set(__self__, "secondary_background", secondary_background)
        if secondary_foreground is not None:
            pulumi.set(__self__, "secondary_foreground", secondary_foreground)
        if success is not None:
            pulumi.set(__self__, "success", success)
        if success_foreground is not None:
            pulumi.set(__self__, "success_foreground", success_foreground)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)
        if warning_foreground is not None:
            pulumi.set(__self__, "warning_foreground", warning_foreground)

    @_builtins.property
    @pulumi.getter
    def accent(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "accent")

    @accent.setter
    def accent(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "accent", value)

    @_builtins.property
    @pulumi.getter(name="accentForeground")
    def accent_foreground(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "accent_foreground")

    @accent_foreground.setter
    def accent_foreground(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "accent_foreground", value)

    @_builtins.property
    @pulumi.getter
    def danger(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "danger")

    @danger.setter
    def danger(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "danger", value)

    @_builtins.property
    @pulumi.getter(name="dangerForeground")
    def danger_foreground(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "danger_foreground")

    @danger_foreground.setter
    def danger_foreground(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "danger_foreground", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dimension", value)

    @_builtins.property
    @pulumi.getter(name="dimensionForeground")
    def dimension_foreground(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dimension_foreground")

    @dimension_foreground.setter
    def dimension_foreground(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dimension_foreground", value)

    @_builtins.property
    @pulumi.getter
    def measure(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "measure", value)

    @_builtins.property
    @pulumi.getter(name="measureForeground")
    def measure_foreground(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "measure_foreground")

    @measure_foreground.setter
    def measure_foreground(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "measure_foreground", value)

    @_builtins.property
    @pulumi.getter(name="primaryBackground")
    def primary_background(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "primary_background")

    @primary_background.setter
    def primary_background(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "primary_background", value)

    @_builtins.property
    @pulumi.getter(name="primaryForeground")
    def primary_foreground(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "primary_foreground")

    @primary_foreground.setter
    def primary_foreground(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "primary_foreground", value)

    @_builtins.property
    @pulumi.getter(name="secondaryBackground")
    def secondary_background(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "secondary_background")

    @secondary_background.setter
    def secondary_background(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secondary_background", value)

    @_builtins.property
    @pulumi.getter(name="secondaryForeground")
    def secondary_foreground(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "secondary_foreground")

    @secondary_foreground.setter
    def secondary_foreground(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secondary_foreground", value)

    @_builtins.property
    @pulumi.getter
    def success(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "success")

    @success.setter
    def success(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "success", value)

    @_builtins.property
    @pulumi.getter(name="successForeground")
    def success_foreground(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "success_foreground")

    @success_foreground.setter
    def success_foreground(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "success_foreground", value)

    @_builtins.property
    @pulumi.getter
    def warning(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "warning")

    @warning.setter
    def warning(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "warning", value)

    @_builtins.property
    @pulumi.getter(name="warningForeground")
    def warning_foreground(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "warning_foreground")

    @warning_foreground.setter
    def warning_foreground(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "warning_foreground", value)


if not MYPY:
    class ThemePermissionArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        principal: pulumi.Input[_builtins.str]
elif False:
    ThemePermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThemePermissionArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 principal: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "principal", principal)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter
    def principal(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "principal", value)


if not MYPY:
    class VpcConnectionTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    VpcConnectionTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcConnectionTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


