# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AnalysisParameters',
    'AnalysisParametersDateTimeParameter',
    'AnalysisParametersDecimalParameter',
    'AnalysisParametersIntegerParameter',
    'AnalysisParametersStringParameter',
    'AnalysisPermission',
    'AnalysisSourceEntity',
    'AnalysisSourceEntitySourceTemplate',
    'AnalysisSourceEntitySourceTemplateDataSetReference',
    'DashboardDashboardPublishOptions',
    'DashboardDashboardPublishOptionsAdHocFilteringOption',
    'DashboardDashboardPublishOptionsDataPointDrillUpDownOption',
    'DashboardDashboardPublishOptionsDataPointMenuLabelOption',
    'DashboardDashboardPublishOptionsDataPointTooltipOption',
    'DashboardDashboardPublishOptionsExportToCsvOption',
    'DashboardDashboardPublishOptionsExportWithHiddenFieldsOption',
    'DashboardDashboardPublishOptionsSheetControlsOption',
    'DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOption',
    'DashboardDashboardPublishOptionsVisualAxisSortOption',
    'DashboardDashboardPublishOptionsVisualMenuOption',
    'DashboardParameters',
    'DashboardParametersDateTimeParameter',
    'DashboardParametersDecimalParameter',
    'DashboardParametersIntegerParameter',
    'DashboardParametersStringParameter',
    'DashboardPermission',
    'DashboardSourceEntity',
    'DashboardSourceEntitySourceTemplate',
    'DashboardSourceEntitySourceTemplateDataSetReference',
    'DataSetColumnGroup',
    'DataSetColumnGroupGeoSpatialColumnGroup',
    'DataSetColumnLevelPermissionRule',
    'DataSetDataSetUsageConfiguration',
    'DataSetFieldFolder',
    'DataSetLogicalTableMap',
    'DataSetLogicalTableMapDataTransform',
    'DataSetLogicalTableMapDataTransformCastColumnTypeOperation',
    'DataSetLogicalTableMapDataTransformCreateColumnsOperation',
    'DataSetLogicalTableMapDataTransformCreateColumnsOperationColumn',
    'DataSetLogicalTableMapDataTransformFilterOperation',
    'DataSetLogicalTableMapDataTransformProjectOperation',
    'DataSetLogicalTableMapDataTransformRenameColumnOperation',
    'DataSetLogicalTableMapDataTransformTagColumnOperation',
    'DataSetLogicalTableMapDataTransformTagColumnOperationTag',
    'DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescription',
    'DataSetLogicalTableMapDataTransformUntagColumnOperation',
    'DataSetLogicalTableMapSource',
    'DataSetLogicalTableMapSourceJoinInstruction',
    'DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyProperties',
    'DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyProperties',
    'DataSetOutputColumn',
    'DataSetPermission',
    'DataSetPhysicalTableMap',
    'DataSetPhysicalTableMapCustomSql',
    'DataSetPhysicalTableMapCustomSqlColumn',
    'DataSetPhysicalTableMapRelationalTable',
    'DataSetPhysicalTableMapRelationalTableInputColumn',
    'DataSetPhysicalTableMapS3Source',
    'DataSetPhysicalTableMapS3SourceInputColumn',
    'DataSetPhysicalTableMapS3SourceUploadSettings',
    'DataSetRefreshProperties',
    'DataSetRefreshPropertiesRefreshConfiguration',
    'DataSetRefreshPropertiesRefreshConfigurationIncrementalRefresh',
    'DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindow',
    'DataSetRowLevelPermissionDataSet',
    'DataSetRowLevelPermissionTagConfiguration',
    'DataSetRowLevelPermissionTagConfigurationTagRule',
    'DataSourceCredentials',
    'DataSourceCredentialsCredentialPair',
    'DataSourceParameters',
    'DataSourceParametersAmazonElasticsearch',
    'DataSourceParametersAthena',
    'DataSourceParametersAurora',
    'DataSourceParametersAuroraPostgresql',
    'DataSourceParametersAwsIotAnalytics',
    'DataSourceParametersJira',
    'DataSourceParametersMariaDb',
    'DataSourceParametersMysql',
    'DataSourceParametersOracle',
    'DataSourceParametersPostgresql',
    'DataSourceParametersPresto',
    'DataSourceParametersRds',
    'DataSourceParametersRedshift',
    'DataSourceParametersS3',
    'DataSourceParametersS3ManifestFileLocation',
    'DataSourceParametersServiceNow',
    'DataSourceParametersSnowflake',
    'DataSourceParametersSpark',
    'DataSourceParametersSqlServer',
    'DataSourceParametersTeradata',
    'DataSourceParametersTwitter',
    'DataSourcePermission',
    'DataSourceSslProperties',
    'DataSourceVpcConnectionProperties',
    'FolderPermission',
    'IamPolicyAssignmentIdentities',
    'NamespaceTimeouts',
    'RefreshScheduleSchedule',
    'RefreshScheduleScheduleScheduleFrequency',
    'RefreshScheduleScheduleScheduleFrequencyRefreshOnDay',
    'TemplatePermission',
    'TemplateSourceEntity',
    'TemplateSourceEntitySourceAnalysis',
    'TemplateSourceEntitySourceAnalysisDataSetReference',
    'TemplateSourceEntitySourceTemplate',
    'ThemeConfiguration',
    'ThemeConfigurationDataColorPalette',
    'ThemeConfigurationSheet',
    'ThemeConfigurationSheetTile',
    'ThemeConfigurationSheetTileBorder',
    'ThemeConfigurationSheetTileLayout',
    'ThemeConfigurationSheetTileLayoutGutter',
    'ThemeConfigurationSheetTileLayoutMargin',
    'ThemeConfigurationTypography',
    'ThemeConfigurationTypographyFontFamily',
    'ThemeConfigurationUiColorPalette',
    'ThemePermission',
    'VpcConnectionTimeouts',
    'GetDataSetColumnGroupResult',
    'GetDataSetColumnGroupGeoSpatialColumnGroupResult',
    'GetDataSetColumnLevelPermissionRuleResult',
    'GetDataSetDataSetUsageConfigurationResult',
    'GetDataSetFieldFolderResult',
    'GetDataSetLogicalTableMapResult',
    'GetDataSetLogicalTableMapDataTransformResult',
    'GetDataSetLogicalTableMapDataTransformCastColumnTypeOperationResult',
    'GetDataSetLogicalTableMapDataTransformCreateColumnsOperationResult',
    'GetDataSetLogicalTableMapDataTransformCreateColumnsOperationColumnResult',
    'GetDataSetLogicalTableMapDataTransformFilterOperationResult',
    'GetDataSetLogicalTableMapDataTransformProjectOperationResult',
    'GetDataSetLogicalTableMapDataTransformRenameColumnOperationResult',
    'GetDataSetLogicalTableMapDataTransformTagColumnOperationResult',
    'GetDataSetLogicalTableMapDataTransformTagColumnOperationTagResult',
    'GetDataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionResult',
    'GetDataSetLogicalTableMapDataTransformUntagColumnOperationResult',
    'GetDataSetLogicalTableMapSourceResult',
    'GetDataSetLogicalTableMapSourceJoinInstructionResult',
    'GetDataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertyResult',
    'GetDataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertyResult',
    'GetDataSetPermissionResult',
    'GetDataSetPhysicalTableMapResult',
    'GetDataSetPhysicalTableMapCustomSqlResult',
    'GetDataSetPhysicalTableMapCustomSqlColumnResult',
    'GetDataSetPhysicalTableMapRelationalTableResult',
    'GetDataSetPhysicalTableMapRelationalTableInputColumnResult',
    'GetDataSetPhysicalTableMapS3SourceResult',
    'GetDataSetPhysicalTableMapS3SourceInputColumnResult',
    'GetDataSetPhysicalTableMapS3SourceUploadSettingResult',
    'GetDataSetRowLevelPermissionDataSetResult',
    'GetDataSetRowLevelPermissionTagConfigurationResult',
    'GetDataSetRowLevelPermissionTagConfigurationTagRuleResult',
    'GetThemeConfigurationResult',
    'GetThemeConfigurationDataColorPaletteResult',
    'GetThemeConfigurationSheetResult',
    'GetThemeConfigurationSheetTileResult',
    'GetThemeConfigurationSheetTileBorderResult',
    'GetThemeConfigurationSheetTileLayoutResult',
    'GetThemeConfigurationSheetTileLayoutGutterResult',
    'GetThemeConfigurationSheetTileLayoutMarginResult',
    'GetThemeConfigurationTypographyResult',
    'GetThemeConfigurationTypographyFontFamilyResult',
    'GetThemeConfigurationUiColorPaletteResult',
    'GetThemePermissionResult',
]

@pulumi.output_type
class AnalysisParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeParameters":
            suggest = "date_time_parameters"
        elif key == "decimalParameters":
            suggest = "decimal_parameters"
        elif key == "integerParameters":
            suggest = "integer_parameters"
        elif key == "stringParameters":
            suggest = "string_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_parameters: Optional[Sequence['outputs.AnalysisParametersDateTimeParameter']] = None,
                 decimal_parameters: Optional[Sequence['outputs.AnalysisParametersDecimalParameter']] = None,
                 integer_parameters: Optional[Sequence['outputs.AnalysisParametersIntegerParameter']] = None,
                 string_parameters: Optional[Sequence['outputs.AnalysisParametersStringParameter']] = None):
        """
        :param Sequence['AnalysisParametersDateTimeParameterArgs'] date_time_parameters: A list of parameters that have a data type of date-time. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DateTimeParameter.html).
        :param Sequence['AnalysisParametersDecimalParameterArgs'] decimal_parameters: A list of parameters that have a data type of decimal. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DecimalParameter.html).
        :param Sequence['AnalysisParametersIntegerParameterArgs'] integer_parameters: A list of parameters that have a data type of integer. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_IntegerParameter.html).
        :param Sequence['AnalysisParametersStringParameterArgs'] string_parameters: A list of parameters that have a data type of string. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_StringParameter.html).
        """
        AnalysisParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_parameters=date_time_parameters,
            decimal_parameters=decimal_parameters,
            integer_parameters=integer_parameters,
            string_parameters=string_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_parameters: Optional[Sequence['outputs.AnalysisParametersDateTimeParameter']] = None,
             decimal_parameters: Optional[Sequence['outputs.AnalysisParametersDecimalParameter']] = None,
             integer_parameters: Optional[Sequence['outputs.AnalysisParametersIntegerParameter']] = None,
             string_parameters: Optional[Sequence['outputs.AnalysisParametersStringParameter']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if date_time_parameters is None and 'dateTimeParameters' in kwargs:
            date_time_parameters = kwargs['dateTimeParameters']
        if decimal_parameters is None and 'decimalParameters' in kwargs:
            decimal_parameters = kwargs['decimalParameters']
        if integer_parameters is None and 'integerParameters' in kwargs:
            integer_parameters = kwargs['integerParameters']
        if string_parameters is None and 'stringParameters' in kwargs:
            string_parameters = kwargs['stringParameters']

        if date_time_parameters is not None:
            _setter("date_time_parameters", date_time_parameters)
        if decimal_parameters is not None:
            _setter("decimal_parameters", decimal_parameters)
        if integer_parameters is not None:
            _setter("integer_parameters", integer_parameters)
        if string_parameters is not None:
            _setter("string_parameters", string_parameters)

    @property
    @pulumi.getter(name="dateTimeParameters")
    def date_time_parameters(self) -> Optional[Sequence['outputs.AnalysisParametersDateTimeParameter']]:
        """
        A list of parameters that have a data type of date-time. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DateTimeParameter.html).
        """
        return pulumi.get(self, "date_time_parameters")

    @property
    @pulumi.getter(name="decimalParameters")
    def decimal_parameters(self) -> Optional[Sequence['outputs.AnalysisParametersDecimalParameter']]:
        """
        A list of parameters that have a data type of decimal. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DecimalParameter.html).
        """
        return pulumi.get(self, "decimal_parameters")

    @property
    @pulumi.getter(name="integerParameters")
    def integer_parameters(self) -> Optional[Sequence['outputs.AnalysisParametersIntegerParameter']]:
        """
        A list of parameters that have a data type of integer. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_IntegerParameter.html).
        """
        return pulumi.get(self, "integer_parameters")

    @property
    @pulumi.getter(name="stringParameters")
    def string_parameters(self) -> Optional[Sequence['outputs.AnalysisParametersStringParameter']]:
        """
        A list of parameters that have a data type of string. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_StringParameter.html).
        """
        return pulumi.get(self, "string_parameters")


@pulumi.output_type
class AnalysisParametersDateTimeParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Display name for the analysis.
               
               The following arguments are optional:
        """
        AnalysisParametersDateTimeParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Display name for the analysis.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisParametersDecimalParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[float]):
        """
        :param str name: Display name for the analysis.
               
               The following arguments are optional:
        """
        AnalysisParametersDecimalParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[float]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Display name for the analysis.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[float]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisParametersIntegerParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[int]):
        """
        :param str name: Display name for the analysis.
               
               The following arguments are optional:
        """
        AnalysisParametersIntegerParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Display name for the analysis.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[int]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisParametersStringParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Display name for the analysis.
               
               The following arguments are optional:
        """
        AnalysisParametersStringParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Display name for the analysis.

        The following arguments are optional:
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AnalysisPermission(dict):
    def __init__(__self__, *,
                 actions: Sequence[str],
                 principal: str):
        """
        :param Sequence[str] actions: List of IAM actions to grant or revoke permissions on.
        :param str principal: ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        AnalysisPermission._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            principal=principal,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[Sequence[str]] = None,
             principal: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions is None:
            raise TypeError("Missing 'actions' argument")
        if principal is None:
            raise TypeError("Missing 'principal' argument")

        _setter("actions", actions)
        _setter("principal", principal)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        List of IAM actions to grant or revoke permissions on.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def principal(self) -> str:
        """
        ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        return pulumi.get(self, "principal")


@pulumi.output_type
class AnalysisSourceEntity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceTemplate":
            suggest = "source_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSourceEntity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSourceEntity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSourceEntity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_template: Optional['outputs.AnalysisSourceEntitySourceTemplate'] = None):
        """
        :param 'AnalysisSourceEntitySourceTemplateArgs' source_template: The source template. See source_template.
        """
        AnalysisSourceEntity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_template=source_template,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_template: Optional['outputs.AnalysisSourceEntitySourceTemplate'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source_template is None and 'sourceTemplate' in kwargs:
            source_template = kwargs['sourceTemplate']

        if source_template is not None:
            _setter("source_template", source_template)

    @property
    @pulumi.getter(name="sourceTemplate")
    def source_template(self) -> Optional['outputs.AnalysisSourceEntitySourceTemplate']:
        """
        The source template. See source_template.
        """
        return pulumi.get(self, "source_template")


@pulumi.output_type
class AnalysisSourceEntitySourceTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetReferences":
            suggest = "data_set_references"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSourceEntitySourceTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSourceEntitySourceTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSourceEntitySourceTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 data_set_references: Sequence['outputs.AnalysisSourceEntitySourceTemplateDataSetReference']):
        """
        :param str arn: The Amazon Resource Name (ARN) of the resource.
        :param Sequence['AnalysisSourceEntitySourceTemplateDataSetReferenceArgs'] data_set_references: List of dataset references. See data_set_references.
        """
        AnalysisSourceEntitySourceTemplate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            data_set_references=data_set_references,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             data_set_references: Optional[Sequence['outputs.AnalysisSourceEntitySourceTemplateDataSetReference']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if data_set_references is None and 'dataSetReferences' in kwargs:
            data_set_references = kwargs['dataSetReferences']
        if data_set_references is None:
            raise TypeError("Missing 'data_set_references' argument")

        _setter("arn", arn)
        _setter("data_set_references", data_set_references)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the resource.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="dataSetReferences")
    def data_set_references(self) -> Sequence['outputs.AnalysisSourceEntitySourceTemplateDataSetReference']:
        """
        List of dataset references. See data_set_references.
        """
        return pulumi.get(self, "data_set_references")


@pulumi.output_type
class AnalysisSourceEntitySourceTemplateDataSetReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetArn":
            suggest = "data_set_arn"
        elif key == "dataSetPlaceholder":
            suggest = "data_set_placeholder"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisSourceEntitySourceTemplateDataSetReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisSourceEntitySourceTemplateDataSetReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisSourceEntitySourceTemplateDataSetReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_arn: str,
                 data_set_placeholder: str):
        """
        :param str data_set_arn: Dataset Amazon Resource Name (ARN).
        :param str data_set_placeholder: Dataset placeholder.
        """
        AnalysisSourceEntitySourceTemplateDataSetReference._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_arn=data_set_arn,
            data_set_placeholder=data_set_placeholder,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_arn: Optional[str] = None,
             data_set_placeholder: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_set_arn is None and 'dataSetArn' in kwargs:
            data_set_arn = kwargs['dataSetArn']
        if data_set_arn is None:
            raise TypeError("Missing 'data_set_arn' argument")
        if data_set_placeholder is None and 'dataSetPlaceholder' in kwargs:
            data_set_placeholder = kwargs['dataSetPlaceholder']
        if data_set_placeholder is None:
            raise TypeError("Missing 'data_set_placeholder' argument")

        _setter("data_set_arn", data_set_arn)
        _setter("data_set_placeholder", data_set_placeholder)

    @property
    @pulumi.getter(name="dataSetArn")
    def data_set_arn(self) -> str:
        """
        Dataset Amazon Resource Name (ARN).
        """
        return pulumi.get(self, "data_set_arn")

    @property
    @pulumi.getter(name="dataSetPlaceholder")
    def data_set_placeholder(self) -> str:
        """
        Dataset placeholder.
        """
        return pulumi.get(self, "data_set_placeholder")


@pulumi.output_type
class DashboardDashboardPublishOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adHocFilteringOption":
            suggest = "ad_hoc_filtering_option"
        elif key == "dataPointDrillUpDownOption":
            suggest = "data_point_drill_up_down_option"
        elif key == "dataPointMenuLabelOption":
            suggest = "data_point_menu_label_option"
        elif key == "dataPointTooltipOption":
            suggest = "data_point_tooltip_option"
        elif key == "exportToCsvOption":
            suggest = "export_to_csv_option"
        elif key == "exportWithHiddenFieldsOption":
            suggest = "export_with_hidden_fields_option"
        elif key == "sheetControlsOption":
            suggest = "sheet_controls_option"
        elif key == "sheetLayoutElementMaximizationOption":
            suggest = "sheet_layout_element_maximization_option"
        elif key == "visualAxisSortOption":
            suggest = "visual_axis_sort_option"
        elif key == "visualMenuOption":
            suggest = "visual_menu_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardPublishOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardPublishOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardPublishOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ad_hoc_filtering_option: Optional['outputs.DashboardDashboardPublishOptionsAdHocFilteringOption'] = None,
                 data_point_drill_up_down_option: Optional['outputs.DashboardDashboardPublishOptionsDataPointDrillUpDownOption'] = None,
                 data_point_menu_label_option: Optional['outputs.DashboardDashboardPublishOptionsDataPointMenuLabelOption'] = None,
                 data_point_tooltip_option: Optional['outputs.DashboardDashboardPublishOptionsDataPointTooltipOption'] = None,
                 export_to_csv_option: Optional['outputs.DashboardDashboardPublishOptionsExportToCsvOption'] = None,
                 export_with_hidden_fields_option: Optional['outputs.DashboardDashboardPublishOptionsExportWithHiddenFieldsOption'] = None,
                 sheet_controls_option: Optional['outputs.DashboardDashboardPublishOptionsSheetControlsOption'] = None,
                 sheet_layout_element_maximization_option: Optional['outputs.DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOption'] = None,
                 visual_axis_sort_option: Optional['outputs.DashboardDashboardPublishOptionsVisualAxisSortOption'] = None,
                 visual_menu_option: Optional['outputs.DashboardDashboardPublishOptionsVisualMenuOption'] = None):
        """
        :param 'DashboardDashboardPublishOptionsAdHocFilteringOptionArgs' ad_hoc_filtering_option: Ad hoc (one-time) filtering option. See ad_hoc_filtering_option.
        :param 'DashboardDashboardPublishOptionsDataPointDrillUpDownOptionArgs' data_point_drill_up_down_option: The drill-down options of data points in a dashboard. See data_point_drill_up_down_option.
        :param 'DashboardDashboardPublishOptionsDataPointMenuLabelOptionArgs' data_point_menu_label_option: The data point menu label options of a dashboard. See data_point_menu_label_option.
        :param 'DashboardDashboardPublishOptionsDataPointTooltipOptionArgs' data_point_tooltip_option: The data point tool tip options of a dashboard. See data_point_tooltip_option.
        :param 'DashboardDashboardPublishOptionsExportToCsvOptionArgs' export_to_csv_option: Export to .csv option. See export_to_csv_option.
        :param 'DashboardDashboardPublishOptionsExportWithHiddenFieldsOptionArgs' export_with_hidden_fields_option: Determines if hidden fields are exported with a dashboard. See export_with_hidden_fields_option.
        :param 'DashboardDashboardPublishOptionsSheetControlsOptionArgs' sheet_controls_option: Sheet controls option. See sheet_controls_option.
        :param 'DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOptionArgs' sheet_layout_element_maximization_option: The sheet layout maximization options of a dashboard. See sheet_layout_element_maximization_option.
        :param 'DashboardDashboardPublishOptionsVisualAxisSortOptionArgs' visual_axis_sort_option: The axis sort options of a dashboard. See visual_axis_sort_option.
        :param 'DashboardDashboardPublishOptionsVisualMenuOptionArgs' visual_menu_option: The menu options of a visual in a dashboard. See visual_menu_option.
        """
        DashboardDashboardPublishOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ad_hoc_filtering_option=ad_hoc_filtering_option,
            data_point_drill_up_down_option=data_point_drill_up_down_option,
            data_point_menu_label_option=data_point_menu_label_option,
            data_point_tooltip_option=data_point_tooltip_option,
            export_to_csv_option=export_to_csv_option,
            export_with_hidden_fields_option=export_with_hidden_fields_option,
            sheet_controls_option=sheet_controls_option,
            sheet_layout_element_maximization_option=sheet_layout_element_maximization_option,
            visual_axis_sort_option=visual_axis_sort_option,
            visual_menu_option=visual_menu_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ad_hoc_filtering_option: Optional['outputs.DashboardDashboardPublishOptionsAdHocFilteringOption'] = None,
             data_point_drill_up_down_option: Optional['outputs.DashboardDashboardPublishOptionsDataPointDrillUpDownOption'] = None,
             data_point_menu_label_option: Optional['outputs.DashboardDashboardPublishOptionsDataPointMenuLabelOption'] = None,
             data_point_tooltip_option: Optional['outputs.DashboardDashboardPublishOptionsDataPointTooltipOption'] = None,
             export_to_csv_option: Optional['outputs.DashboardDashboardPublishOptionsExportToCsvOption'] = None,
             export_with_hidden_fields_option: Optional['outputs.DashboardDashboardPublishOptionsExportWithHiddenFieldsOption'] = None,
             sheet_controls_option: Optional['outputs.DashboardDashboardPublishOptionsSheetControlsOption'] = None,
             sheet_layout_element_maximization_option: Optional['outputs.DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOption'] = None,
             visual_axis_sort_option: Optional['outputs.DashboardDashboardPublishOptionsVisualAxisSortOption'] = None,
             visual_menu_option: Optional['outputs.DashboardDashboardPublishOptionsVisualMenuOption'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ad_hoc_filtering_option is None and 'adHocFilteringOption' in kwargs:
            ad_hoc_filtering_option = kwargs['adHocFilteringOption']
        if data_point_drill_up_down_option is None and 'dataPointDrillUpDownOption' in kwargs:
            data_point_drill_up_down_option = kwargs['dataPointDrillUpDownOption']
        if data_point_menu_label_option is None and 'dataPointMenuLabelOption' in kwargs:
            data_point_menu_label_option = kwargs['dataPointMenuLabelOption']
        if data_point_tooltip_option is None and 'dataPointTooltipOption' in kwargs:
            data_point_tooltip_option = kwargs['dataPointTooltipOption']
        if export_to_csv_option is None and 'exportToCsvOption' in kwargs:
            export_to_csv_option = kwargs['exportToCsvOption']
        if export_with_hidden_fields_option is None and 'exportWithHiddenFieldsOption' in kwargs:
            export_with_hidden_fields_option = kwargs['exportWithHiddenFieldsOption']
        if sheet_controls_option is None and 'sheetControlsOption' in kwargs:
            sheet_controls_option = kwargs['sheetControlsOption']
        if sheet_layout_element_maximization_option is None and 'sheetLayoutElementMaximizationOption' in kwargs:
            sheet_layout_element_maximization_option = kwargs['sheetLayoutElementMaximizationOption']
        if visual_axis_sort_option is None and 'visualAxisSortOption' in kwargs:
            visual_axis_sort_option = kwargs['visualAxisSortOption']
        if visual_menu_option is None and 'visualMenuOption' in kwargs:
            visual_menu_option = kwargs['visualMenuOption']

        if ad_hoc_filtering_option is not None:
            _setter("ad_hoc_filtering_option", ad_hoc_filtering_option)
        if data_point_drill_up_down_option is not None:
            _setter("data_point_drill_up_down_option", data_point_drill_up_down_option)
        if data_point_menu_label_option is not None:
            _setter("data_point_menu_label_option", data_point_menu_label_option)
        if data_point_tooltip_option is not None:
            _setter("data_point_tooltip_option", data_point_tooltip_option)
        if export_to_csv_option is not None:
            _setter("export_to_csv_option", export_to_csv_option)
        if export_with_hidden_fields_option is not None:
            _setter("export_with_hidden_fields_option", export_with_hidden_fields_option)
        if sheet_controls_option is not None:
            _setter("sheet_controls_option", sheet_controls_option)
        if sheet_layout_element_maximization_option is not None:
            _setter("sheet_layout_element_maximization_option", sheet_layout_element_maximization_option)
        if visual_axis_sort_option is not None:
            _setter("visual_axis_sort_option", visual_axis_sort_option)
        if visual_menu_option is not None:
            _setter("visual_menu_option", visual_menu_option)

    @property
    @pulumi.getter(name="adHocFilteringOption")
    def ad_hoc_filtering_option(self) -> Optional['outputs.DashboardDashboardPublishOptionsAdHocFilteringOption']:
        """
        Ad hoc (one-time) filtering option. See ad_hoc_filtering_option.
        """
        return pulumi.get(self, "ad_hoc_filtering_option")

    @property
    @pulumi.getter(name="dataPointDrillUpDownOption")
    def data_point_drill_up_down_option(self) -> Optional['outputs.DashboardDashboardPublishOptionsDataPointDrillUpDownOption']:
        """
        The drill-down options of data points in a dashboard. See data_point_drill_up_down_option.
        """
        return pulumi.get(self, "data_point_drill_up_down_option")

    @property
    @pulumi.getter(name="dataPointMenuLabelOption")
    def data_point_menu_label_option(self) -> Optional['outputs.DashboardDashboardPublishOptionsDataPointMenuLabelOption']:
        """
        The data point menu label options of a dashboard. See data_point_menu_label_option.
        """
        return pulumi.get(self, "data_point_menu_label_option")

    @property
    @pulumi.getter(name="dataPointTooltipOption")
    def data_point_tooltip_option(self) -> Optional['outputs.DashboardDashboardPublishOptionsDataPointTooltipOption']:
        """
        The data point tool tip options of a dashboard. See data_point_tooltip_option.
        """
        return pulumi.get(self, "data_point_tooltip_option")

    @property
    @pulumi.getter(name="exportToCsvOption")
    def export_to_csv_option(self) -> Optional['outputs.DashboardDashboardPublishOptionsExportToCsvOption']:
        """
        Export to .csv option. See export_to_csv_option.
        """
        return pulumi.get(self, "export_to_csv_option")

    @property
    @pulumi.getter(name="exportWithHiddenFieldsOption")
    def export_with_hidden_fields_option(self) -> Optional['outputs.DashboardDashboardPublishOptionsExportWithHiddenFieldsOption']:
        """
        Determines if hidden fields are exported with a dashboard. See export_with_hidden_fields_option.
        """
        return pulumi.get(self, "export_with_hidden_fields_option")

    @property
    @pulumi.getter(name="sheetControlsOption")
    def sheet_controls_option(self) -> Optional['outputs.DashboardDashboardPublishOptionsSheetControlsOption']:
        """
        Sheet controls option. See sheet_controls_option.
        """
        return pulumi.get(self, "sheet_controls_option")

    @property
    @pulumi.getter(name="sheetLayoutElementMaximizationOption")
    def sheet_layout_element_maximization_option(self) -> Optional['outputs.DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOption']:
        """
        The sheet layout maximization options of a dashboard. See sheet_layout_element_maximization_option.
        """
        return pulumi.get(self, "sheet_layout_element_maximization_option")

    @property
    @pulumi.getter(name="visualAxisSortOption")
    def visual_axis_sort_option(self) -> Optional['outputs.DashboardDashboardPublishOptionsVisualAxisSortOption']:
        """
        The axis sort options of a dashboard. See visual_axis_sort_option.
        """
        return pulumi.get(self, "visual_axis_sort_option")

    @property
    @pulumi.getter(name="visualMenuOption")
    def visual_menu_option(self) -> Optional['outputs.DashboardDashboardPublishOptionsVisualMenuOption']:
        """
        The menu options of a visual in a dashboard. See visual_menu_option.
        """
        return pulumi.get(self, "visual_menu_option")


@pulumi.output_type
class DashboardDashboardPublishOptionsAdHocFilteringOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityStatus":
            suggest = "availability_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardPublishOptionsAdHocFilteringOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardPublishOptionsAdHocFilteringOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardPublishOptionsAdHocFilteringOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_status: Optional[str] = None):
        """
        :param str availability_status: Availability status. Possibles values: ENABLED, DISABLED.
        """
        DashboardDashboardPublishOptionsAdHocFilteringOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_status=availability_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_status is None and 'availabilityStatus' in kwargs:
            availability_status = kwargs['availabilityStatus']

        if availability_status is not None:
            _setter("availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[str]:
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
        return pulumi.get(self, "availability_status")


@pulumi.output_type
class DashboardDashboardPublishOptionsDataPointDrillUpDownOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityStatus":
            suggest = "availability_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardPublishOptionsDataPointDrillUpDownOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardPublishOptionsDataPointDrillUpDownOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardPublishOptionsDataPointDrillUpDownOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_status: Optional[str] = None):
        """
        :param str availability_status: Availability status. Possibles values: ENABLED, DISABLED.
        """
        DashboardDashboardPublishOptionsDataPointDrillUpDownOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_status=availability_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_status is None and 'availabilityStatus' in kwargs:
            availability_status = kwargs['availabilityStatus']

        if availability_status is not None:
            _setter("availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[str]:
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
        return pulumi.get(self, "availability_status")


@pulumi.output_type
class DashboardDashboardPublishOptionsDataPointMenuLabelOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityStatus":
            suggest = "availability_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardPublishOptionsDataPointMenuLabelOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardPublishOptionsDataPointMenuLabelOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardPublishOptionsDataPointMenuLabelOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_status: Optional[str] = None):
        """
        :param str availability_status: Availability status. Possibles values: ENABLED, DISABLED.
        """
        DashboardDashboardPublishOptionsDataPointMenuLabelOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_status=availability_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_status is None and 'availabilityStatus' in kwargs:
            availability_status = kwargs['availabilityStatus']

        if availability_status is not None:
            _setter("availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[str]:
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
        return pulumi.get(self, "availability_status")


@pulumi.output_type
class DashboardDashboardPublishOptionsDataPointTooltipOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityStatus":
            suggest = "availability_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardPublishOptionsDataPointTooltipOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardPublishOptionsDataPointTooltipOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardPublishOptionsDataPointTooltipOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_status: Optional[str] = None):
        """
        :param str availability_status: Availability status. Possibles values: ENABLED, DISABLED.
        """
        DashboardDashboardPublishOptionsDataPointTooltipOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_status=availability_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_status is None and 'availabilityStatus' in kwargs:
            availability_status = kwargs['availabilityStatus']

        if availability_status is not None:
            _setter("availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[str]:
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
        return pulumi.get(self, "availability_status")


@pulumi.output_type
class DashboardDashboardPublishOptionsExportToCsvOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityStatus":
            suggest = "availability_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardPublishOptionsExportToCsvOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardPublishOptionsExportToCsvOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardPublishOptionsExportToCsvOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_status: Optional[str] = None):
        """
        :param str availability_status: Availability status. Possibles values: ENABLED, DISABLED.
        """
        DashboardDashboardPublishOptionsExportToCsvOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_status=availability_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_status is None and 'availabilityStatus' in kwargs:
            availability_status = kwargs['availabilityStatus']

        if availability_status is not None:
            _setter("availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[str]:
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
        return pulumi.get(self, "availability_status")


@pulumi.output_type
class DashboardDashboardPublishOptionsExportWithHiddenFieldsOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityStatus":
            suggest = "availability_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardPublishOptionsExportWithHiddenFieldsOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardPublishOptionsExportWithHiddenFieldsOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardPublishOptionsExportWithHiddenFieldsOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_status: Optional[str] = None):
        """
        :param str availability_status: Availability status. Possibles values: ENABLED, DISABLED.
        """
        DashboardDashboardPublishOptionsExportWithHiddenFieldsOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_status=availability_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_status is None and 'availabilityStatus' in kwargs:
            availability_status = kwargs['availabilityStatus']

        if availability_status is not None:
            _setter("availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[str]:
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
        return pulumi.get(self, "availability_status")


@pulumi.output_type
class DashboardDashboardPublishOptionsSheetControlsOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visibilityState":
            suggest = "visibility_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardPublishOptionsSheetControlsOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardPublishOptionsSheetControlsOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardPublishOptionsSheetControlsOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 visibility_state: Optional[str] = None):
        """
        :param str visibility_state: Visibility state. Possibles values: EXPANDED, COLLAPSED.
        """
        DashboardDashboardPublishOptionsSheetControlsOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            visibility_state=visibility_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             visibility_state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if visibility_state is None and 'visibilityState' in kwargs:
            visibility_state = kwargs['visibilityState']

        if visibility_state is not None:
            _setter("visibility_state", visibility_state)

    @property
    @pulumi.getter(name="visibilityState")
    def visibility_state(self) -> Optional[str]:
        """
        Visibility state. Possibles values: EXPANDED, COLLAPSED.
        """
        return pulumi.get(self, "visibility_state")


@pulumi.output_type
class DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityStatus":
            suggest = "availability_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_status: Optional[str] = None):
        """
        :param str availability_status: Availability status. Possibles values: ENABLED, DISABLED.
        """
        DashboardDashboardPublishOptionsSheetLayoutElementMaximizationOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_status=availability_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_status is None and 'availabilityStatus' in kwargs:
            availability_status = kwargs['availabilityStatus']

        if availability_status is not None:
            _setter("availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[str]:
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
        return pulumi.get(self, "availability_status")


@pulumi.output_type
class DashboardDashboardPublishOptionsVisualAxisSortOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityStatus":
            suggest = "availability_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardPublishOptionsVisualAxisSortOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardPublishOptionsVisualAxisSortOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardPublishOptionsVisualAxisSortOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_status: Optional[str] = None):
        """
        :param str availability_status: Availability status. Possibles values: ENABLED, DISABLED.
        """
        DashboardDashboardPublishOptionsVisualAxisSortOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_status=availability_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_status is None and 'availabilityStatus' in kwargs:
            availability_status = kwargs['availabilityStatus']

        if availability_status is not None:
            _setter("availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[str]:
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
        return pulumi.get(self, "availability_status")


@pulumi.output_type
class DashboardDashboardPublishOptionsVisualMenuOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityStatus":
            suggest = "availability_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardDashboardPublishOptionsVisualMenuOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardDashboardPublishOptionsVisualMenuOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardDashboardPublishOptionsVisualMenuOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_status: Optional[str] = None):
        """
        :param str availability_status: Availability status. Possibles values: ENABLED, DISABLED.
        """
        DashboardDashboardPublishOptionsVisualMenuOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_status=availability_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability_status is None and 'availabilityStatus' in kwargs:
            availability_status = kwargs['availabilityStatus']

        if availability_status is not None:
            _setter("availability_status", availability_status)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[str]:
        """
        Availability status. Possibles values: ENABLED, DISABLED.
        """
        return pulumi.get(self, "availability_status")


@pulumi.output_type
class DashboardParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateTimeParameters":
            suggest = "date_time_parameters"
        elif key == "decimalParameters":
            suggest = "decimal_parameters"
        elif key == "integerParameters":
            suggest = "integer_parameters"
        elif key == "stringParameters":
            suggest = "string_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_time_parameters: Optional[Sequence['outputs.DashboardParametersDateTimeParameter']] = None,
                 decimal_parameters: Optional[Sequence['outputs.DashboardParametersDecimalParameter']] = None,
                 integer_parameters: Optional[Sequence['outputs.DashboardParametersIntegerParameter']] = None,
                 string_parameters: Optional[Sequence['outputs.DashboardParametersStringParameter']] = None):
        """
        :param Sequence['DashboardParametersDateTimeParameterArgs'] date_time_parameters: A list of parameters that have a data type of date-time. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DateTimeParameter.html).
        :param Sequence['DashboardParametersDecimalParameterArgs'] decimal_parameters: A list of parameters that have a data type of decimal. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DecimalParameter.html).
        :param Sequence['DashboardParametersIntegerParameterArgs'] integer_parameters: A list of parameters that have a data type of integer. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_IntegerParameter.html).
        :param Sequence['DashboardParametersStringParameterArgs'] string_parameters: A list of parameters that have a data type of string. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_StringParameter.html).
        """
        DashboardParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_time_parameters=date_time_parameters,
            decimal_parameters=decimal_parameters,
            integer_parameters=integer_parameters,
            string_parameters=string_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_time_parameters: Optional[Sequence['outputs.DashboardParametersDateTimeParameter']] = None,
             decimal_parameters: Optional[Sequence['outputs.DashboardParametersDecimalParameter']] = None,
             integer_parameters: Optional[Sequence['outputs.DashboardParametersIntegerParameter']] = None,
             string_parameters: Optional[Sequence['outputs.DashboardParametersStringParameter']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if date_time_parameters is None and 'dateTimeParameters' in kwargs:
            date_time_parameters = kwargs['dateTimeParameters']
        if decimal_parameters is None and 'decimalParameters' in kwargs:
            decimal_parameters = kwargs['decimalParameters']
        if integer_parameters is None and 'integerParameters' in kwargs:
            integer_parameters = kwargs['integerParameters']
        if string_parameters is None and 'stringParameters' in kwargs:
            string_parameters = kwargs['stringParameters']

        if date_time_parameters is not None:
            _setter("date_time_parameters", date_time_parameters)
        if decimal_parameters is not None:
            _setter("decimal_parameters", decimal_parameters)
        if integer_parameters is not None:
            _setter("integer_parameters", integer_parameters)
        if string_parameters is not None:
            _setter("string_parameters", string_parameters)

    @property
    @pulumi.getter(name="dateTimeParameters")
    def date_time_parameters(self) -> Optional[Sequence['outputs.DashboardParametersDateTimeParameter']]:
        """
        A list of parameters that have a data type of date-time. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DateTimeParameter.html).
        """
        return pulumi.get(self, "date_time_parameters")

    @property
    @pulumi.getter(name="decimalParameters")
    def decimal_parameters(self) -> Optional[Sequence['outputs.DashboardParametersDecimalParameter']]:
        """
        A list of parameters that have a data type of decimal. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DecimalParameter.html).
        """
        return pulumi.get(self, "decimal_parameters")

    @property
    @pulumi.getter(name="integerParameters")
    def integer_parameters(self) -> Optional[Sequence['outputs.DashboardParametersIntegerParameter']]:
        """
        A list of parameters that have a data type of integer. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_IntegerParameter.html).
        """
        return pulumi.get(self, "integer_parameters")

    @property
    @pulumi.getter(name="stringParameters")
    def string_parameters(self) -> Optional[Sequence['outputs.DashboardParametersStringParameter']]:
        """
        A list of parameters that have a data type of string. See [AWS API Documentation for complete description](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_StringParameter.html).
        """
        return pulumi.get(self, "string_parameters")


@pulumi.output_type
class DashboardParametersDateTimeParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Display name for the dashboard.
        """
        DashboardParametersDateTimeParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Display name for the dashboard.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardParametersDecimalParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[float]):
        """
        :param str name: Display name for the dashboard.
        """
        DashboardParametersDecimalParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[float]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Display name for the dashboard.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[float]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardParametersIntegerParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[int]):
        """
        :param str name: Display name for the dashboard.
        """
        DashboardParametersIntegerParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Display name for the dashboard.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[int]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardParametersStringParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: Display name for the dashboard.
        """
        DashboardParametersStringParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Display name for the dashboard.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardPermission(dict):
    def __init__(__self__, *,
                 actions: Sequence[str],
                 principal: str):
        """
        :param Sequence[str] actions: List of IAM actions to grant or revoke permissions on.
        :param str principal: ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        DashboardPermission._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            principal=principal,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[Sequence[str]] = None,
             principal: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions is None:
            raise TypeError("Missing 'actions' argument")
        if principal is None:
            raise TypeError("Missing 'principal' argument")

        _setter("actions", actions)
        _setter("principal", principal)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        List of IAM actions to grant or revoke permissions on.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def principal(self) -> str:
        """
        ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        return pulumi.get(self, "principal")


@pulumi.output_type
class DashboardSourceEntity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceTemplate":
            suggest = "source_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSourceEntity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSourceEntity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSourceEntity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_template: Optional['outputs.DashboardSourceEntitySourceTemplate'] = None):
        """
        :param 'DashboardSourceEntitySourceTemplateArgs' source_template: The source template. See source_template.
        """
        DashboardSourceEntity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_template=source_template,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_template: Optional['outputs.DashboardSourceEntitySourceTemplate'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source_template is None and 'sourceTemplate' in kwargs:
            source_template = kwargs['sourceTemplate']

        if source_template is not None:
            _setter("source_template", source_template)

    @property
    @pulumi.getter(name="sourceTemplate")
    def source_template(self) -> Optional['outputs.DashboardSourceEntitySourceTemplate']:
        """
        The source template. See source_template.
        """
        return pulumi.get(self, "source_template")


@pulumi.output_type
class DashboardSourceEntitySourceTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetReferences":
            suggest = "data_set_references"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSourceEntitySourceTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSourceEntitySourceTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSourceEntitySourceTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 data_set_references: Sequence['outputs.DashboardSourceEntitySourceTemplateDataSetReference']):
        """
        :param str arn: The Amazon Resource Name (ARN) of the resource.
        :param Sequence['DashboardSourceEntitySourceTemplateDataSetReferenceArgs'] data_set_references: List of dataset references. See data_set_references.
        """
        DashboardSourceEntitySourceTemplate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            data_set_references=data_set_references,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             data_set_references: Optional[Sequence['outputs.DashboardSourceEntitySourceTemplateDataSetReference']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if data_set_references is None and 'dataSetReferences' in kwargs:
            data_set_references = kwargs['dataSetReferences']
        if data_set_references is None:
            raise TypeError("Missing 'data_set_references' argument")

        _setter("arn", arn)
        _setter("data_set_references", data_set_references)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the resource.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="dataSetReferences")
    def data_set_references(self) -> Sequence['outputs.DashboardSourceEntitySourceTemplateDataSetReference']:
        """
        List of dataset references. See data_set_references.
        """
        return pulumi.get(self, "data_set_references")


@pulumi.output_type
class DashboardSourceEntitySourceTemplateDataSetReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetArn":
            suggest = "data_set_arn"
        elif key == "dataSetPlaceholder":
            suggest = "data_set_placeholder"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardSourceEntitySourceTemplateDataSetReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardSourceEntitySourceTemplateDataSetReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardSourceEntitySourceTemplateDataSetReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_arn: str,
                 data_set_placeholder: str):
        """
        :param str data_set_arn: Dataset Amazon Resource Name (ARN).
        :param str data_set_placeholder: Dataset placeholder.
        """
        DashboardSourceEntitySourceTemplateDataSetReference._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_arn=data_set_arn,
            data_set_placeholder=data_set_placeholder,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_arn: Optional[str] = None,
             data_set_placeholder: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_set_arn is None and 'dataSetArn' in kwargs:
            data_set_arn = kwargs['dataSetArn']
        if data_set_arn is None:
            raise TypeError("Missing 'data_set_arn' argument")
        if data_set_placeholder is None and 'dataSetPlaceholder' in kwargs:
            data_set_placeholder = kwargs['dataSetPlaceholder']
        if data_set_placeholder is None:
            raise TypeError("Missing 'data_set_placeholder' argument")

        _setter("data_set_arn", data_set_arn)
        _setter("data_set_placeholder", data_set_placeholder)

    @property
    @pulumi.getter(name="dataSetArn")
    def data_set_arn(self) -> str:
        """
        Dataset Amazon Resource Name (ARN).
        """
        return pulumi.get(self, "data_set_arn")

    @property
    @pulumi.getter(name="dataSetPlaceholder")
    def data_set_placeholder(self) -> str:
        """
        Dataset placeholder.
        """
        return pulumi.get(self, "data_set_placeholder")


@pulumi.output_type
class DataSetColumnGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geoSpatialColumnGroup":
            suggest = "geo_spatial_column_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetColumnGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetColumnGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetColumnGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 geo_spatial_column_group: Optional['outputs.DataSetColumnGroupGeoSpatialColumnGroup'] = None):
        """
        :param 'DataSetColumnGroupGeoSpatialColumnGroupArgs' geo_spatial_column_group: Geospatial column group that denotes a hierarchy. See geo_spatial_column_group.
        """
        DataSetColumnGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            geo_spatial_column_group=geo_spatial_column_group,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             geo_spatial_column_group: Optional['outputs.DataSetColumnGroupGeoSpatialColumnGroup'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if geo_spatial_column_group is None and 'geoSpatialColumnGroup' in kwargs:
            geo_spatial_column_group = kwargs['geoSpatialColumnGroup']

        if geo_spatial_column_group is not None:
            _setter("geo_spatial_column_group", geo_spatial_column_group)

    @property
    @pulumi.getter(name="geoSpatialColumnGroup")
    def geo_spatial_column_group(self) -> Optional['outputs.DataSetColumnGroupGeoSpatialColumnGroup']:
        """
        Geospatial column group that denotes a hierarchy. See geo_spatial_column_group.
        """
        return pulumi.get(self, "geo_spatial_column_group")


@pulumi.output_type
class DataSetColumnGroupGeoSpatialColumnGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCode":
            suggest = "country_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetColumnGroupGeoSpatialColumnGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetColumnGroupGeoSpatialColumnGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetColumnGroupGeoSpatialColumnGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Sequence[str],
                 country_code: str,
                 name: str):
        """
        :param Sequence[str] columns: Columns in this hierarchy.
        :param str country_code: Country code. Valid values are `US`.
        :param str name: A display name for the hierarchy.
        """
        DataSetColumnGroupGeoSpatialColumnGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            country_code=country_code,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Optional[Sequence[str]] = None,
             country_code: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if columns is None:
            raise TypeError("Missing 'columns' argument")
        if country_code is None and 'countryCode' in kwargs:
            country_code = kwargs['countryCode']
        if country_code is None:
            raise TypeError("Missing 'country_code' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("columns", columns)
        _setter("country_code", country_code)
        _setter("name", name)

    @property
    @pulumi.getter
    def columns(self) -> Sequence[str]:
        """
        Columns in this hierarchy.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        """
        Country code. Valid values are `US`.
        """
        return pulumi.get(self, "country_code")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A display name for the hierarchy.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DataSetColumnLevelPermissionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnNames":
            suggest = "column_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetColumnLevelPermissionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetColumnLevelPermissionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetColumnLevelPermissionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_names: Optional[Sequence[str]] = None,
                 principals: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] column_names: An array of column names.
        :param Sequence[str] principals: An array of ARNs for Amazon QuickSight users or groups.
        """
        DataSetColumnLevelPermissionRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_names=column_names,
            principals=principals,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_names: Optional[Sequence[str]] = None,
             principals: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_names is None and 'columnNames' in kwargs:
            column_names = kwargs['columnNames']

        if column_names is not None:
            _setter("column_names", column_names)
        if principals is not None:
            _setter("principals", principals)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[Sequence[str]]:
        """
        An array of column names.
        """
        return pulumi.get(self, "column_names")

    @property
    @pulumi.getter
    def principals(self) -> Optional[Sequence[str]]:
        """
        An array of ARNs for Amazon QuickSight users or groups.
        """
        return pulumi.get(self, "principals")


@pulumi.output_type
class DataSetDataSetUsageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableUseAsDirectQuerySource":
            suggest = "disable_use_as_direct_query_source"
        elif key == "disableUseAsImportedSource":
            suggest = "disable_use_as_imported_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetDataSetUsageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetDataSetUsageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetDataSetUsageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_use_as_direct_query_source: Optional[bool] = None,
                 disable_use_as_imported_source: Optional[bool] = None):
        """
        :param bool disable_use_as_direct_query_source: Controls whether a child dataset of a direct query can use this dataset as a source.
        :param bool disable_use_as_imported_source: Controls whether a child dataset that's stored in QuickSight can use this dataset as a source.
        """
        DataSetDataSetUsageConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disable_use_as_direct_query_source=disable_use_as_direct_query_source,
            disable_use_as_imported_source=disable_use_as_imported_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disable_use_as_direct_query_source: Optional[bool] = None,
             disable_use_as_imported_source: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if disable_use_as_direct_query_source is None and 'disableUseAsDirectQuerySource' in kwargs:
            disable_use_as_direct_query_source = kwargs['disableUseAsDirectQuerySource']
        if disable_use_as_imported_source is None and 'disableUseAsImportedSource' in kwargs:
            disable_use_as_imported_source = kwargs['disableUseAsImportedSource']

        if disable_use_as_direct_query_source is not None:
            _setter("disable_use_as_direct_query_source", disable_use_as_direct_query_source)
        if disable_use_as_imported_source is not None:
            _setter("disable_use_as_imported_source", disable_use_as_imported_source)

    @property
    @pulumi.getter(name="disableUseAsDirectQuerySource")
    def disable_use_as_direct_query_source(self) -> Optional[bool]:
        """
        Controls whether a child dataset of a direct query can use this dataset as a source.
        """
        return pulumi.get(self, "disable_use_as_direct_query_source")

    @property
    @pulumi.getter(name="disableUseAsImportedSource")
    def disable_use_as_imported_source(self) -> Optional[bool]:
        """
        Controls whether a child dataset that's stored in QuickSight can use this dataset as a source.
        """
        return pulumi.get(self, "disable_use_as_imported_source")


@pulumi.output_type
class DataSetFieldFolder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldFoldersId":
            suggest = "field_folders_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetFieldFolder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetFieldFolder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetFieldFolder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_folders_id: str,
                 columns: Optional[Sequence[str]] = None,
                 description: Optional[str] = None):
        """
        :param str field_folders_id: Key of the field folder map.
        :param Sequence[str] columns: An array of column names to add to the folder. A column can only be in one folder.
        :param str description: Field folder description.
        """
        DataSetFieldFolder._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_folders_id=field_folders_id,
            columns=columns,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_folders_id: Optional[str] = None,
             columns: Optional[Sequence[str]] = None,
             description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if field_folders_id is None and 'fieldFoldersId' in kwargs:
            field_folders_id = kwargs['fieldFoldersId']
        if field_folders_id is None:
            raise TypeError("Missing 'field_folders_id' argument")

        _setter("field_folders_id", field_folders_id)
        if columns is not None:
            _setter("columns", columns)
        if description is not None:
            _setter("description", description)

    @property
    @pulumi.getter(name="fieldFoldersId")
    def field_folders_id(self) -> str:
        """
        Key of the field folder map.
        """
        return pulumi.get(self, "field_folders_id")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence[str]]:
        """
        An array of column names to add to the folder. A column can only be in one folder.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Field folder description.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class DataSetLogicalTableMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logicalTableMapId":
            suggest = "logical_table_map_id"
        elif key == "dataTransforms":
            suggest = "data_transforms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetLogicalTableMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetLogicalTableMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetLogicalTableMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias: str,
                 logical_table_map_id: str,
                 source: 'outputs.DataSetLogicalTableMapSource',
                 data_transforms: Optional[Sequence['outputs.DataSetLogicalTableMapDataTransform']] = None):
        """
        :param str alias: A display name for the logical table.
        :param str logical_table_map_id: Key of the logical table map.
        :param 'DataSetLogicalTableMapSourceArgs' source: Source of this logical table. See source.
        :param Sequence['DataSetLogicalTableMapDataTransformArgs'] data_transforms: Transform operations that act on this logical table. For this structure to be valid, only one of the attributes can be non-null. See data_transforms.
        """
        DataSetLogicalTableMap._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alias=alias,
            logical_table_map_id=logical_table_map_id,
            source=source,
            data_transforms=data_transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alias: Optional[str] = None,
             logical_table_map_id: Optional[str] = None,
             source: Optional['outputs.DataSetLogicalTableMapSource'] = None,
             data_transforms: Optional[Sequence['outputs.DataSetLogicalTableMapDataTransform']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alias is None:
            raise TypeError("Missing 'alias' argument")
        if logical_table_map_id is None and 'logicalTableMapId' in kwargs:
            logical_table_map_id = kwargs['logicalTableMapId']
        if logical_table_map_id is None:
            raise TypeError("Missing 'logical_table_map_id' argument")
        if source is None:
            raise TypeError("Missing 'source' argument")
        if data_transforms is None and 'dataTransforms' in kwargs:
            data_transforms = kwargs['dataTransforms']

        _setter("alias", alias)
        _setter("logical_table_map_id", logical_table_map_id)
        _setter("source", source)
        if data_transforms is not None:
            _setter("data_transforms", data_transforms)

    @property
    @pulumi.getter
    def alias(self) -> str:
        """
        A display name for the logical table.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="logicalTableMapId")
    def logical_table_map_id(self) -> str:
        """
        Key of the logical table map.
        """
        return pulumi.get(self, "logical_table_map_id")

    @property
    @pulumi.getter
    def source(self) -> 'outputs.DataSetLogicalTableMapSource':
        """
        Source of this logical table. See source.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="dataTransforms")
    def data_transforms(self) -> Optional[Sequence['outputs.DataSetLogicalTableMapDataTransform']]:
        """
        Transform operations that act on this logical table. For this structure to be valid, only one of the attributes can be non-null. See data_transforms.
        """
        return pulumi.get(self, "data_transforms")


@pulumi.output_type
class DataSetLogicalTableMapDataTransform(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "castColumnTypeOperation":
            suggest = "cast_column_type_operation"
        elif key == "createColumnsOperation":
            suggest = "create_columns_operation"
        elif key == "filterOperation":
            suggest = "filter_operation"
        elif key == "projectOperation":
            suggest = "project_operation"
        elif key == "renameColumnOperation":
            suggest = "rename_column_operation"
        elif key == "tagColumnOperation":
            suggest = "tag_column_operation"
        elif key == "untagColumnOperation":
            suggest = "untag_column_operation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetLogicalTableMapDataTransform. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetLogicalTableMapDataTransform.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetLogicalTableMapDataTransform.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cast_column_type_operation: Optional['outputs.DataSetLogicalTableMapDataTransformCastColumnTypeOperation'] = None,
                 create_columns_operation: Optional['outputs.DataSetLogicalTableMapDataTransformCreateColumnsOperation'] = None,
                 filter_operation: Optional['outputs.DataSetLogicalTableMapDataTransformFilterOperation'] = None,
                 project_operation: Optional['outputs.DataSetLogicalTableMapDataTransformProjectOperation'] = None,
                 rename_column_operation: Optional['outputs.DataSetLogicalTableMapDataTransformRenameColumnOperation'] = None,
                 tag_column_operation: Optional['outputs.DataSetLogicalTableMapDataTransformTagColumnOperation'] = None,
                 untag_column_operation: Optional['outputs.DataSetLogicalTableMapDataTransformUntagColumnOperation'] = None):
        """
        :param 'DataSetLogicalTableMapDataTransformCastColumnTypeOperationArgs' cast_column_type_operation: A transform operation that casts a column to a different type. See cast_column_type_operation.
        :param 'DataSetLogicalTableMapDataTransformCreateColumnsOperationArgs' create_columns_operation: An operation that creates calculated columns. Columns created in one such operation form a lexical closure. See create_columns_operation.
        :param 'DataSetLogicalTableMapDataTransformFilterOperationArgs' filter_operation: An operation that filters rows based on some condition. See filter_operation.
        :param 'DataSetLogicalTableMapDataTransformProjectOperationArgs' project_operation: An operation that projects columns. Operations that come after a projection can only refer to projected columns. See project_operation.
        :param 'DataSetLogicalTableMapDataTransformRenameColumnOperationArgs' rename_column_operation: An operation that renames a column. See rename_column_operation.
        :param 'DataSetLogicalTableMapDataTransformTagColumnOperationArgs' tag_column_operation: An operation that tags a column with additional information. See tag_column_operation.
        :param 'DataSetLogicalTableMapDataTransformUntagColumnOperationArgs' untag_column_operation: A transform operation that removes tags associated with a column. See untag_column_operation.
        """
        DataSetLogicalTableMapDataTransform._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cast_column_type_operation=cast_column_type_operation,
            create_columns_operation=create_columns_operation,
            filter_operation=filter_operation,
            project_operation=project_operation,
            rename_column_operation=rename_column_operation,
            tag_column_operation=tag_column_operation,
            untag_column_operation=untag_column_operation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cast_column_type_operation: Optional['outputs.DataSetLogicalTableMapDataTransformCastColumnTypeOperation'] = None,
             create_columns_operation: Optional['outputs.DataSetLogicalTableMapDataTransformCreateColumnsOperation'] = None,
             filter_operation: Optional['outputs.DataSetLogicalTableMapDataTransformFilterOperation'] = None,
             project_operation: Optional['outputs.DataSetLogicalTableMapDataTransformProjectOperation'] = None,
             rename_column_operation: Optional['outputs.DataSetLogicalTableMapDataTransformRenameColumnOperation'] = None,
             tag_column_operation: Optional['outputs.DataSetLogicalTableMapDataTransformTagColumnOperation'] = None,
             untag_column_operation: Optional['outputs.DataSetLogicalTableMapDataTransformUntagColumnOperation'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cast_column_type_operation is None and 'castColumnTypeOperation' in kwargs:
            cast_column_type_operation = kwargs['castColumnTypeOperation']
        if create_columns_operation is None and 'createColumnsOperation' in kwargs:
            create_columns_operation = kwargs['createColumnsOperation']
        if filter_operation is None and 'filterOperation' in kwargs:
            filter_operation = kwargs['filterOperation']
        if project_operation is None and 'projectOperation' in kwargs:
            project_operation = kwargs['projectOperation']
        if rename_column_operation is None and 'renameColumnOperation' in kwargs:
            rename_column_operation = kwargs['renameColumnOperation']
        if tag_column_operation is None and 'tagColumnOperation' in kwargs:
            tag_column_operation = kwargs['tagColumnOperation']
        if untag_column_operation is None and 'untagColumnOperation' in kwargs:
            untag_column_operation = kwargs['untagColumnOperation']

        if cast_column_type_operation is not None:
            _setter("cast_column_type_operation", cast_column_type_operation)
        if create_columns_operation is not None:
            _setter("create_columns_operation", create_columns_operation)
        if filter_operation is not None:
            _setter("filter_operation", filter_operation)
        if project_operation is not None:
            _setter("project_operation", project_operation)
        if rename_column_operation is not None:
            _setter("rename_column_operation", rename_column_operation)
        if tag_column_operation is not None:
            _setter("tag_column_operation", tag_column_operation)
        if untag_column_operation is not None:
            _setter("untag_column_operation", untag_column_operation)

    @property
    @pulumi.getter(name="castColumnTypeOperation")
    def cast_column_type_operation(self) -> Optional['outputs.DataSetLogicalTableMapDataTransformCastColumnTypeOperation']:
        """
        A transform operation that casts a column to a different type. See cast_column_type_operation.
        """
        return pulumi.get(self, "cast_column_type_operation")

    @property
    @pulumi.getter(name="createColumnsOperation")
    def create_columns_operation(self) -> Optional['outputs.DataSetLogicalTableMapDataTransformCreateColumnsOperation']:
        """
        An operation that creates calculated columns. Columns created in one such operation form a lexical closure. See create_columns_operation.
        """
        return pulumi.get(self, "create_columns_operation")

    @property
    @pulumi.getter(name="filterOperation")
    def filter_operation(self) -> Optional['outputs.DataSetLogicalTableMapDataTransformFilterOperation']:
        """
        An operation that filters rows based on some condition. See filter_operation.
        """
        return pulumi.get(self, "filter_operation")

    @property
    @pulumi.getter(name="projectOperation")
    def project_operation(self) -> Optional['outputs.DataSetLogicalTableMapDataTransformProjectOperation']:
        """
        An operation that projects columns. Operations that come after a projection can only refer to projected columns. See project_operation.
        """
        return pulumi.get(self, "project_operation")

    @property
    @pulumi.getter(name="renameColumnOperation")
    def rename_column_operation(self) -> Optional['outputs.DataSetLogicalTableMapDataTransformRenameColumnOperation']:
        """
        An operation that renames a column. See rename_column_operation.
        """
        return pulumi.get(self, "rename_column_operation")

    @property
    @pulumi.getter(name="tagColumnOperation")
    def tag_column_operation(self) -> Optional['outputs.DataSetLogicalTableMapDataTransformTagColumnOperation']:
        """
        An operation that tags a column with additional information. See tag_column_operation.
        """
        return pulumi.get(self, "tag_column_operation")

    @property
    @pulumi.getter(name="untagColumnOperation")
    def untag_column_operation(self) -> Optional['outputs.DataSetLogicalTableMapDataTransformUntagColumnOperation']:
        """
        A transform operation that removes tags associated with a column. See untag_column_operation.
        """
        return pulumi.get(self, "untag_column_operation")


@pulumi.output_type
class DataSetLogicalTableMapDataTransformCastColumnTypeOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"
        elif key == "newColumnType":
            suggest = "new_column_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetLogicalTableMapDataTransformCastColumnTypeOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetLogicalTableMapDataTransformCastColumnTypeOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetLogicalTableMapDataTransformCastColumnTypeOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: str,
                 new_column_type: str,
                 format: Optional[str] = None):
        """
        :param str column_name: Column name.
        :param str new_column_type: New column data type. Valid values are `STRING`, `INTEGER`, `DECIMAL`, `DATETIME`.
        :param str format: When casting a column from string to datetime type, you can supply a string in a format supported by Amazon QuickSight to denote the source data format.
        """
        DataSetLogicalTableMapDataTransformCastColumnTypeOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            new_column_type=new_column_type,
            format=format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             new_column_type: Optional[str] = None,
             format: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if new_column_type is None and 'newColumnType' in kwargs:
            new_column_type = kwargs['newColumnType']
        if new_column_type is None:
            raise TypeError("Missing 'new_column_type' argument")

        _setter("column_name", column_name)
        _setter("new_column_type", new_column_type)
        if format is not None:
            _setter("format", format)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        Column name.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="newColumnType")
    def new_column_type(self) -> str:
        """
        New column data type. Valid values are `STRING`, `INTEGER`, `DECIMAL`, `DATETIME`.
        """
        return pulumi.get(self, "new_column_type")

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        """
        When casting a column from string to datetime type, you can supply a string in a format supported by Amazon QuickSight to denote the source data format.
        """
        return pulumi.get(self, "format")


@pulumi.output_type
class DataSetLogicalTableMapDataTransformCreateColumnsOperation(dict):
    def __init__(__self__, *,
                 columns: Sequence['outputs.DataSetLogicalTableMapDataTransformCreateColumnsOperationColumn']):
        """
        :param Sequence['DataSetLogicalTableMapDataTransformCreateColumnsOperationColumnArgs'] columns: Calculated columns to create. See columns.
        """
        DataSetLogicalTableMapDataTransformCreateColumnsOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Optional[Sequence['outputs.DataSetLogicalTableMapDataTransformCreateColumnsOperationColumn']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if columns is None:
            raise TypeError("Missing 'columns' argument")

        _setter("columns", columns)

    @property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.DataSetLogicalTableMapDataTransformCreateColumnsOperationColumn']:
        """
        Calculated columns to create. See columns.
        """
        return pulumi.get(self, "columns")


@pulumi.output_type
class DataSetLogicalTableMapDataTransformCreateColumnsOperationColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnId":
            suggest = "column_id"
        elif key == "columnName":
            suggest = "column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetLogicalTableMapDataTransformCreateColumnsOperationColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetLogicalTableMapDataTransformCreateColumnsOperationColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetLogicalTableMapDataTransformCreateColumnsOperationColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_id: str,
                 column_name: str,
                 expression: str):
        """
        :param str column_id: A unique ID to identify a calculated column. During a dataset update, if the column ID of a calculated column matches that of an existing calculated column, Amazon QuickSight preserves the existing calculated column.
        :param str column_name: Column name.
        :param str expression: An expression that defines the calculated column.
        """
        DataSetLogicalTableMapDataTransformCreateColumnsOperationColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_id=column_id,
            column_name=column_name,
            expression=expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_id: Optional[str] = None,
             column_name: Optional[str] = None,
             expression: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_id is None and 'columnId' in kwargs:
            column_id = kwargs['columnId']
        if column_id is None:
            raise TypeError("Missing 'column_id' argument")
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if expression is None:
            raise TypeError("Missing 'expression' argument")

        _setter("column_id", column_id)
        _setter("column_name", column_name)
        _setter("expression", expression)

    @property
    @pulumi.getter(name="columnId")
    def column_id(self) -> str:
        """
        A unique ID to identify a calculated column. During a dataset update, if the column ID of a calculated column matches that of an existing calculated column, Amazon QuickSight preserves the existing calculated column.
        """
        return pulumi.get(self, "column_id")

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        Column name.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        An expression that defines the calculated column.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class DataSetLogicalTableMapDataTransformFilterOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionExpression":
            suggest = "condition_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetLogicalTableMapDataTransformFilterOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetLogicalTableMapDataTransformFilterOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetLogicalTableMapDataTransformFilterOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_expression: str):
        """
        :param str condition_expression: An expression that must evaluate to a Boolean value. Rows for which the expression evaluates to true are kept in the dataset.
        """
        DataSetLogicalTableMapDataTransformFilterOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition_expression=condition_expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition_expression: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if condition_expression is None and 'conditionExpression' in kwargs:
            condition_expression = kwargs['conditionExpression']
        if condition_expression is None:
            raise TypeError("Missing 'condition_expression' argument")

        _setter("condition_expression", condition_expression)

    @property
    @pulumi.getter(name="conditionExpression")
    def condition_expression(self) -> str:
        """
        An expression that must evaluate to a Boolean value. Rows for which the expression evaluates to true are kept in the dataset.
        """
        return pulumi.get(self, "condition_expression")


@pulumi.output_type
class DataSetLogicalTableMapDataTransformProjectOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectedColumns":
            suggest = "projected_columns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetLogicalTableMapDataTransformProjectOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetLogicalTableMapDataTransformProjectOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetLogicalTableMapDataTransformProjectOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 projected_columns: Sequence[str]):
        """
        :param Sequence[str] projected_columns: Projected columns.
        """
        DataSetLogicalTableMapDataTransformProjectOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            projected_columns=projected_columns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             projected_columns: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if projected_columns is None and 'projectedColumns' in kwargs:
            projected_columns = kwargs['projectedColumns']
        if projected_columns is None:
            raise TypeError("Missing 'projected_columns' argument")

        _setter("projected_columns", projected_columns)

    @property
    @pulumi.getter(name="projectedColumns")
    def projected_columns(self) -> Sequence[str]:
        """
        Projected columns.
        """
        return pulumi.get(self, "projected_columns")


@pulumi.output_type
class DataSetLogicalTableMapDataTransformRenameColumnOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"
        elif key == "newColumnName":
            suggest = "new_column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetLogicalTableMapDataTransformRenameColumnOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetLogicalTableMapDataTransformRenameColumnOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetLogicalTableMapDataTransformRenameColumnOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: str,
                 new_column_name: str):
        """
        :param str column_name: Column to be renamed.
        :param str new_column_name: New name for the column.
        """
        DataSetLogicalTableMapDataTransformRenameColumnOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            new_column_name=new_column_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             new_column_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if new_column_name is None and 'newColumnName' in kwargs:
            new_column_name = kwargs['newColumnName']
        if new_column_name is None:
            raise TypeError("Missing 'new_column_name' argument")

        _setter("column_name", column_name)
        _setter("new_column_name", new_column_name)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        Column to be renamed.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="newColumnName")
    def new_column_name(self) -> str:
        """
        New name for the column.
        """
        return pulumi.get(self, "new_column_name")


@pulumi.output_type
class DataSetLogicalTableMapDataTransformTagColumnOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetLogicalTableMapDataTransformTagColumnOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetLogicalTableMapDataTransformTagColumnOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetLogicalTableMapDataTransformTagColumnOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: str,
                 tags: Sequence['outputs.DataSetLogicalTableMapDataTransformTagColumnOperationTag']):
        """
        :param str column_name: Column name.
        :param Sequence['DataSetLogicalTableMapDataTransformTagColumnOperationTagArgs'] tags: The dataset column tag, currently only used for geospatial type tagging. See tags.
        """
        DataSetLogicalTableMapDataTransformTagColumnOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             tags: Optional[Sequence['outputs.DataSetLogicalTableMapDataTransformTagColumnOperationTag']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")

        _setter("column_name", column_name)
        _setter("tags", tags)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        Column name.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.DataSetLogicalTableMapDataTransformTagColumnOperationTag']:
        """
        The dataset column tag, currently only used for geospatial type tagging. See tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class DataSetLogicalTableMapDataTransformTagColumnOperationTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnDescription":
            suggest = "column_description"
        elif key == "columnGeographicRole":
            suggest = "column_geographic_role"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetLogicalTableMapDataTransformTagColumnOperationTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetLogicalTableMapDataTransformTagColumnOperationTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetLogicalTableMapDataTransformTagColumnOperationTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_description: Optional['outputs.DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescription'] = None,
                 column_geographic_role: Optional[str] = None):
        """
        :param 'DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionArgs' column_description: A description for a column. See column_description.
        :param str column_geographic_role: A geospatial role for a column. Valid values are `COUNTRY`, `STATE`, `COUNTY`, `CITY`, `POSTCODE`, `LONGITUDE`, and `LATITUDE`.
        """
        DataSetLogicalTableMapDataTransformTagColumnOperationTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_description=column_description,
            column_geographic_role=column_geographic_role,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_description: Optional['outputs.DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescription'] = None,
             column_geographic_role: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_description is None and 'columnDescription' in kwargs:
            column_description = kwargs['columnDescription']
        if column_geographic_role is None and 'columnGeographicRole' in kwargs:
            column_geographic_role = kwargs['columnGeographicRole']

        if column_description is not None:
            _setter("column_description", column_description)
        if column_geographic_role is not None:
            _setter("column_geographic_role", column_geographic_role)

    @property
    @pulumi.getter(name="columnDescription")
    def column_description(self) -> Optional['outputs.DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescription']:
        """
        A description for a column. See column_description.
        """
        return pulumi.get(self, "column_description")

    @property
    @pulumi.getter(name="columnGeographicRole")
    def column_geographic_role(self) -> Optional[str]:
        """
        A geospatial role for a column. Valid values are `COUNTRY`, `STATE`, `COUNTY`, `CITY`, `POSTCODE`, `LONGITUDE`, and `LATITUDE`.
        """
        return pulumi.get(self, "column_geographic_role")


@pulumi.output_type
class DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescription(dict):
    def __init__(__self__, *,
                 text: Optional[str] = None):
        """
        :param str text: The text of a description for a column.
        """
        DataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescription._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text=text,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if text is not None:
            _setter("text", text)

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The text of a description for a column.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class DataSetLogicalTableMapDataTransformUntagColumnOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"
        elif key == "tagNames":
            suggest = "tag_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetLogicalTableMapDataTransformUntagColumnOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetLogicalTableMapDataTransformUntagColumnOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetLogicalTableMapDataTransformUntagColumnOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: str,
                 tag_names: Sequence[str]):
        """
        :param str column_name: Column name.
        :param Sequence[str] tag_names: The column tags to remove from this column.
        """
        DataSetLogicalTableMapDataTransformUntagColumnOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            tag_names=tag_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             tag_names: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if tag_names is None and 'tagNames' in kwargs:
            tag_names = kwargs['tagNames']
        if tag_names is None:
            raise TypeError("Missing 'tag_names' argument")

        _setter("column_name", column_name)
        _setter("tag_names", tag_names)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        Column name.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="tagNames")
    def tag_names(self) -> Sequence[str]:
        """
        The column tags to remove from this column.
        """
        return pulumi.get(self, "tag_names")


@pulumi.output_type
class DataSetLogicalTableMapSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetArn":
            suggest = "data_set_arn"
        elif key == "joinInstruction":
            suggest = "join_instruction"
        elif key == "physicalTableId":
            suggest = "physical_table_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetLogicalTableMapSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetLogicalTableMapSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetLogicalTableMapSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_arn: Optional[str] = None,
                 join_instruction: Optional['outputs.DataSetLogicalTableMapSourceJoinInstruction'] = None,
                 physical_table_id: Optional[str] = None):
        """
        :param str data_set_arn: ARN of the parent data set.
        :param 'DataSetLogicalTableMapSourceJoinInstructionArgs' join_instruction: Specifies the result of a join of two logical tables. See join_instruction.
        :param str physical_table_id: Physical table ID.
        """
        DataSetLogicalTableMapSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_arn=data_set_arn,
            join_instruction=join_instruction,
            physical_table_id=physical_table_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_arn: Optional[str] = None,
             join_instruction: Optional['outputs.DataSetLogicalTableMapSourceJoinInstruction'] = None,
             physical_table_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_set_arn is None and 'dataSetArn' in kwargs:
            data_set_arn = kwargs['dataSetArn']
        if join_instruction is None and 'joinInstruction' in kwargs:
            join_instruction = kwargs['joinInstruction']
        if physical_table_id is None and 'physicalTableId' in kwargs:
            physical_table_id = kwargs['physicalTableId']

        if data_set_arn is not None:
            _setter("data_set_arn", data_set_arn)
        if join_instruction is not None:
            _setter("join_instruction", join_instruction)
        if physical_table_id is not None:
            _setter("physical_table_id", physical_table_id)

    @property
    @pulumi.getter(name="dataSetArn")
    def data_set_arn(self) -> Optional[str]:
        """
        ARN of the parent data set.
        """
        return pulumi.get(self, "data_set_arn")

    @property
    @pulumi.getter(name="joinInstruction")
    def join_instruction(self) -> Optional['outputs.DataSetLogicalTableMapSourceJoinInstruction']:
        """
        Specifies the result of a join of two logical tables. See join_instruction.
        """
        return pulumi.get(self, "join_instruction")

    @property
    @pulumi.getter(name="physicalTableId")
    def physical_table_id(self) -> Optional[str]:
        """
        Physical table ID.
        """
        return pulumi.get(self, "physical_table_id")


@pulumi.output_type
class DataSetLogicalTableMapSourceJoinInstruction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "leftOperand":
            suggest = "left_operand"
        elif key == "onClause":
            suggest = "on_clause"
        elif key == "rightOperand":
            suggest = "right_operand"
        elif key == "leftJoinKeyProperties":
            suggest = "left_join_key_properties"
        elif key == "rightJoinKeyProperties":
            suggest = "right_join_key_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetLogicalTableMapSourceJoinInstruction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetLogicalTableMapSourceJoinInstruction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetLogicalTableMapSourceJoinInstruction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 left_operand: str,
                 on_clause: str,
                 right_operand: str,
                 type: str,
                 left_join_key_properties: Optional['outputs.DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyProperties'] = None,
                 right_join_key_properties: Optional['outputs.DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyProperties'] = None):
        """
        :param str left_operand: Operand on the left side of a join.
        :param str on_clause: Join instructions provided in the ON clause of a join.
        :param str right_operand: Operand on the right side of a join.
        :param str type: Type of join. Valid values are `INNER`, `OUTER`, `LEFT`, and `RIGHT`.
        :param 'DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertiesArgs' left_join_key_properties: Join key properties of the left operand. See left_join_key_properties.
        :param 'DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertiesArgs' right_join_key_properties: Join key properties of the right operand. See right_join_key_properties.
        """
        DataSetLogicalTableMapSourceJoinInstruction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            left_operand=left_operand,
            on_clause=on_clause,
            right_operand=right_operand,
            type=type,
            left_join_key_properties=left_join_key_properties,
            right_join_key_properties=right_join_key_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             left_operand: Optional[str] = None,
             on_clause: Optional[str] = None,
             right_operand: Optional[str] = None,
             type: Optional[str] = None,
             left_join_key_properties: Optional['outputs.DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyProperties'] = None,
             right_join_key_properties: Optional['outputs.DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyProperties'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if left_operand is None and 'leftOperand' in kwargs:
            left_operand = kwargs['leftOperand']
        if left_operand is None:
            raise TypeError("Missing 'left_operand' argument")
        if on_clause is None and 'onClause' in kwargs:
            on_clause = kwargs['onClause']
        if on_clause is None:
            raise TypeError("Missing 'on_clause' argument")
        if right_operand is None and 'rightOperand' in kwargs:
            right_operand = kwargs['rightOperand']
        if right_operand is None:
            raise TypeError("Missing 'right_operand' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if left_join_key_properties is None and 'leftJoinKeyProperties' in kwargs:
            left_join_key_properties = kwargs['leftJoinKeyProperties']
        if right_join_key_properties is None and 'rightJoinKeyProperties' in kwargs:
            right_join_key_properties = kwargs['rightJoinKeyProperties']

        _setter("left_operand", left_operand)
        _setter("on_clause", on_clause)
        _setter("right_operand", right_operand)
        _setter("type", type)
        if left_join_key_properties is not None:
            _setter("left_join_key_properties", left_join_key_properties)
        if right_join_key_properties is not None:
            _setter("right_join_key_properties", right_join_key_properties)

    @property
    @pulumi.getter(name="leftOperand")
    def left_operand(self) -> str:
        """
        Operand on the left side of a join.
        """
        return pulumi.get(self, "left_operand")

    @property
    @pulumi.getter(name="onClause")
    def on_clause(self) -> str:
        """
        Join instructions provided in the ON clause of a join.
        """
        return pulumi.get(self, "on_clause")

    @property
    @pulumi.getter(name="rightOperand")
    def right_operand(self) -> str:
        """
        Operand on the right side of a join.
        """
        return pulumi.get(self, "right_operand")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of join. Valid values are `INNER`, `OUTER`, `LEFT`, and `RIGHT`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="leftJoinKeyProperties")
    def left_join_key_properties(self) -> Optional['outputs.DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyProperties']:
        """
        Join key properties of the left operand. See left_join_key_properties.
        """
        return pulumi.get(self, "left_join_key_properties")

    @property
    @pulumi.getter(name="rightJoinKeyProperties")
    def right_join_key_properties(self) -> Optional['outputs.DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyProperties']:
        """
        Join key properties of the right operand. See right_join_key_properties.
        """
        return pulumi.get(self, "right_join_key_properties")


@pulumi.output_type
class DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "uniqueKey":
            suggest = "unique_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 unique_key: Optional[bool] = None):
        """
        :param bool unique_key: A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.
        """
        DataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unique_key=unique_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unique_key: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unique_key is None and 'uniqueKey' in kwargs:
            unique_key = kwargs['uniqueKey']

        if unique_key is not None:
            _setter("unique_key", unique_key)

    @property
    @pulumi.getter(name="uniqueKey")
    def unique_key(self) -> Optional[bool]:
        """
        A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.
        """
        return pulumi.get(self, "unique_key")


@pulumi.output_type
class DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "uniqueKey":
            suggest = "unique_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 unique_key: Optional[bool] = None):
        """
        :param bool unique_key: A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.
        """
        DataSetLogicalTableMapSourceJoinInstructionRightJoinKeyProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unique_key=unique_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unique_key: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unique_key is None and 'uniqueKey' in kwargs:
            unique_key = kwargs['uniqueKey']

        if unique_key is not None:
            _setter("unique_key", unique_key)

    @property
    @pulumi.getter(name="uniqueKey")
    def unique_key(self) -> Optional[bool]:
        """
        A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.
        """
        return pulumi.get(self, "unique_key")


@pulumi.output_type
class DataSetOutputColumn(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str description: Field folder description.
        :param str name: Display name for the dataset.
        :param str type: Data type of the column.
        """
        DataSetOutputColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if description is not None:
            _setter("description", description)
        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Field folder description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Display name for the dataset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Data type of the column.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DataSetPermission(dict):
    def __init__(__self__, *,
                 actions: Sequence[str],
                 principal: str):
        """
        :param Sequence[str] actions: List of IAM actions to grant or revoke permissions on.
        :param str principal: ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        DataSetPermission._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            principal=principal,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[Sequence[str]] = None,
             principal: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions is None:
            raise TypeError("Missing 'actions' argument")
        if principal is None:
            raise TypeError("Missing 'principal' argument")

        _setter("actions", actions)
        _setter("principal", principal)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        List of IAM actions to grant or revoke permissions on.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def principal(self) -> str:
        """
        ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        return pulumi.get(self, "principal")


@pulumi.output_type
class DataSetPhysicalTableMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "physicalTableMapId":
            suggest = "physical_table_map_id"
        elif key == "customSql":
            suggest = "custom_sql"
        elif key == "relationalTable":
            suggest = "relational_table"
        elif key == "s3Source":
            suggest = "s3_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetPhysicalTableMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetPhysicalTableMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetPhysicalTableMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 physical_table_map_id: str,
                 custom_sql: Optional['outputs.DataSetPhysicalTableMapCustomSql'] = None,
                 relational_table: Optional['outputs.DataSetPhysicalTableMapRelationalTable'] = None,
                 s3_source: Optional['outputs.DataSetPhysicalTableMapS3Source'] = None):
        """
        :param str physical_table_map_id: Key of the physical table map.
        :param 'DataSetPhysicalTableMapCustomSqlArgs' custom_sql: A physical table type built from the results of the custom SQL query. See custom_sql.
        :param 'DataSetPhysicalTableMapRelationalTableArgs' relational_table: A physical table type for relational data sources. See relational_table.
        :param 'DataSetPhysicalTableMapS3SourceArgs' s3_source: A physical table type for as S3 data source. See s3_source.
        """
        DataSetPhysicalTableMap._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            physical_table_map_id=physical_table_map_id,
            custom_sql=custom_sql,
            relational_table=relational_table,
            s3_source=s3_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             physical_table_map_id: Optional[str] = None,
             custom_sql: Optional['outputs.DataSetPhysicalTableMapCustomSql'] = None,
             relational_table: Optional['outputs.DataSetPhysicalTableMapRelationalTable'] = None,
             s3_source: Optional['outputs.DataSetPhysicalTableMapS3Source'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if physical_table_map_id is None and 'physicalTableMapId' in kwargs:
            physical_table_map_id = kwargs['physicalTableMapId']
        if physical_table_map_id is None:
            raise TypeError("Missing 'physical_table_map_id' argument")
        if custom_sql is None and 'customSql' in kwargs:
            custom_sql = kwargs['customSql']
        if relational_table is None and 'relationalTable' in kwargs:
            relational_table = kwargs['relationalTable']
        if s3_source is None and 's3Source' in kwargs:
            s3_source = kwargs['s3Source']

        _setter("physical_table_map_id", physical_table_map_id)
        if custom_sql is not None:
            _setter("custom_sql", custom_sql)
        if relational_table is not None:
            _setter("relational_table", relational_table)
        if s3_source is not None:
            _setter("s3_source", s3_source)

    @property
    @pulumi.getter(name="physicalTableMapId")
    def physical_table_map_id(self) -> str:
        """
        Key of the physical table map.
        """
        return pulumi.get(self, "physical_table_map_id")

    @property
    @pulumi.getter(name="customSql")
    def custom_sql(self) -> Optional['outputs.DataSetPhysicalTableMapCustomSql']:
        """
        A physical table type built from the results of the custom SQL query. See custom_sql.
        """
        return pulumi.get(self, "custom_sql")

    @property
    @pulumi.getter(name="relationalTable")
    def relational_table(self) -> Optional['outputs.DataSetPhysicalTableMapRelationalTable']:
        """
        A physical table type for relational data sources. See relational_table.
        """
        return pulumi.get(self, "relational_table")

    @property
    @pulumi.getter(name="s3Source")
    def s3_source(self) -> Optional['outputs.DataSetPhysicalTableMapS3Source']:
        """
        A physical table type for as S3 data source. See s3_source.
        """
        return pulumi.get(self, "s3_source")


@pulumi.output_type
class DataSetPhysicalTableMapCustomSql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSourceArn":
            suggest = "data_source_arn"
        elif key == "sqlQuery":
            suggest = "sql_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetPhysicalTableMapCustomSql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetPhysicalTableMapCustomSql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetPhysicalTableMapCustomSql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source_arn: str,
                 name: str,
                 sql_query: str,
                 columns: Optional[Sequence['outputs.DataSetPhysicalTableMapCustomSqlColumn']] = None):
        """
        :param str data_source_arn: ARN of the data source.
        :param str name: Display name for the SQL query result.
        :param str sql_query: SQL query.
        :param Sequence['DataSetPhysicalTableMapCustomSqlColumnArgs'] columns: Column schema from the SQL query result set. See columns.
        """
        DataSetPhysicalTableMapCustomSql._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source_arn=data_source_arn,
            name=name,
            sql_query=sql_query,
            columns=columns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source_arn: Optional[str] = None,
             name: Optional[str] = None,
             sql_query: Optional[str] = None,
             columns: Optional[Sequence['outputs.DataSetPhysicalTableMapCustomSqlColumn']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_source_arn is None and 'dataSourceArn' in kwargs:
            data_source_arn = kwargs['dataSourceArn']
        if data_source_arn is None:
            raise TypeError("Missing 'data_source_arn' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if sql_query is None and 'sqlQuery' in kwargs:
            sql_query = kwargs['sqlQuery']
        if sql_query is None:
            raise TypeError("Missing 'sql_query' argument")

        _setter("data_source_arn", data_source_arn)
        _setter("name", name)
        _setter("sql_query", sql_query)
        if columns is not None:
            _setter("columns", columns)

    @property
    @pulumi.getter(name="dataSourceArn")
    def data_source_arn(self) -> str:
        """
        ARN of the data source.
        """
        return pulumi.get(self, "data_source_arn")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Display name for the SQL query result.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sqlQuery")
    def sql_query(self) -> str:
        """
        SQL query.
        """
        return pulumi.get(self, "sql_query")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.DataSetPhysicalTableMapCustomSqlColumn']]:
        """
        Column schema from the SQL query result set. See columns.
        """
        return pulumi.get(self, "columns")


@pulumi.output_type
class DataSetPhysicalTableMapCustomSqlColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: Name of this column in the underlying data source.
        :param str type: Data type of the column.
        """
        DataSetPhysicalTableMapCustomSqlColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("name", name)
        _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of this column in the underlying data source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Data type of the column.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DataSetPhysicalTableMapRelationalTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSourceArn":
            suggest = "data_source_arn"
        elif key == "inputColumns":
            suggest = "input_columns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetPhysicalTableMapRelationalTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetPhysicalTableMapRelationalTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetPhysicalTableMapRelationalTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source_arn: str,
                 input_columns: Sequence['outputs.DataSetPhysicalTableMapRelationalTableInputColumn'],
                 name: str,
                 catalog: Optional[str] = None,
                 schema: Optional[str] = None):
        """
        :param str data_source_arn: ARN of the data source.
        :param Sequence['DataSetPhysicalTableMapRelationalTableInputColumnArgs'] input_columns: Column schema of the table. See input_columns.
        :param str name: Name of the relational table.
        :param str catalog: Catalog associated with the table.
        :param str schema: Schema name. This name applies to certain relational database engines.
        """
        DataSetPhysicalTableMapRelationalTable._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source_arn=data_source_arn,
            input_columns=input_columns,
            name=name,
            catalog=catalog,
            schema=schema,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source_arn: Optional[str] = None,
             input_columns: Optional[Sequence['outputs.DataSetPhysicalTableMapRelationalTableInputColumn']] = None,
             name: Optional[str] = None,
             catalog: Optional[str] = None,
             schema: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_source_arn is None and 'dataSourceArn' in kwargs:
            data_source_arn = kwargs['dataSourceArn']
        if data_source_arn is None:
            raise TypeError("Missing 'data_source_arn' argument")
        if input_columns is None and 'inputColumns' in kwargs:
            input_columns = kwargs['inputColumns']
        if input_columns is None:
            raise TypeError("Missing 'input_columns' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("data_source_arn", data_source_arn)
        _setter("input_columns", input_columns)
        _setter("name", name)
        if catalog is not None:
            _setter("catalog", catalog)
        if schema is not None:
            _setter("schema", schema)

    @property
    @pulumi.getter(name="dataSourceArn")
    def data_source_arn(self) -> str:
        """
        ARN of the data source.
        """
        return pulumi.get(self, "data_source_arn")

    @property
    @pulumi.getter(name="inputColumns")
    def input_columns(self) -> Sequence['outputs.DataSetPhysicalTableMapRelationalTableInputColumn']:
        """
        Column schema of the table. See input_columns.
        """
        return pulumi.get(self, "input_columns")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the relational table.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def catalog(self) -> Optional[str]:
        """
        Catalog associated with the table.
        """
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        """
        Schema name. This name applies to certain relational database engines.
        """
        return pulumi.get(self, "schema")


@pulumi.output_type
class DataSetPhysicalTableMapRelationalTableInputColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: Name of this column in the underlying data source.
        :param str type: Data type of the column.
        """
        DataSetPhysicalTableMapRelationalTableInputColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("name", name)
        _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of this column in the underlying data source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Data type of the column.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DataSetPhysicalTableMapS3Source(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSourceArn":
            suggest = "data_source_arn"
        elif key == "inputColumns":
            suggest = "input_columns"
        elif key == "uploadSettings":
            suggest = "upload_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetPhysicalTableMapS3Source. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetPhysicalTableMapS3Source.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetPhysicalTableMapS3Source.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source_arn: str,
                 input_columns: Sequence['outputs.DataSetPhysicalTableMapS3SourceInputColumn'],
                 upload_settings: 'outputs.DataSetPhysicalTableMapS3SourceUploadSettings'):
        """
        :param str data_source_arn: ARN of the data source.
        :param Sequence['DataSetPhysicalTableMapS3SourceInputColumnArgs'] input_columns: Column schema of the table. See input_columns.
        :param 'DataSetPhysicalTableMapS3SourceUploadSettingsArgs' upload_settings: Information about the format for the S3 source file or files. See upload_settings.
        """
        DataSetPhysicalTableMapS3Source._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source_arn=data_source_arn,
            input_columns=input_columns,
            upload_settings=upload_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source_arn: Optional[str] = None,
             input_columns: Optional[Sequence['outputs.DataSetPhysicalTableMapS3SourceInputColumn']] = None,
             upload_settings: Optional['outputs.DataSetPhysicalTableMapS3SourceUploadSettings'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_source_arn is None and 'dataSourceArn' in kwargs:
            data_source_arn = kwargs['dataSourceArn']
        if data_source_arn is None:
            raise TypeError("Missing 'data_source_arn' argument")
        if input_columns is None and 'inputColumns' in kwargs:
            input_columns = kwargs['inputColumns']
        if input_columns is None:
            raise TypeError("Missing 'input_columns' argument")
        if upload_settings is None and 'uploadSettings' in kwargs:
            upload_settings = kwargs['uploadSettings']
        if upload_settings is None:
            raise TypeError("Missing 'upload_settings' argument")

        _setter("data_source_arn", data_source_arn)
        _setter("input_columns", input_columns)
        _setter("upload_settings", upload_settings)

    @property
    @pulumi.getter(name="dataSourceArn")
    def data_source_arn(self) -> str:
        """
        ARN of the data source.
        """
        return pulumi.get(self, "data_source_arn")

    @property
    @pulumi.getter(name="inputColumns")
    def input_columns(self) -> Sequence['outputs.DataSetPhysicalTableMapS3SourceInputColumn']:
        """
        Column schema of the table. See input_columns.
        """
        return pulumi.get(self, "input_columns")

    @property
    @pulumi.getter(name="uploadSettings")
    def upload_settings(self) -> 'outputs.DataSetPhysicalTableMapS3SourceUploadSettings':
        """
        Information about the format for the S3 source file or files. See upload_settings.
        """
        return pulumi.get(self, "upload_settings")


@pulumi.output_type
class DataSetPhysicalTableMapS3SourceInputColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: Name of this column in the underlying data source.
        :param str type: Data type of the column.
        """
        DataSetPhysicalTableMapS3SourceInputColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("name", name)
        _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of this column in the underlying data source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Data type of the column.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DataSetPhysicalTableMapS3SourceUploadSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containsHeader":
            suggest = "contains_header"
        elif key == "startFromRow":
            suggest = "start_from_row"
        elif key == "textQualifier":
            suggest = "text_qualifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetPhysicalTableMapS3SourceUploadSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetPhysicalTableMapS3SourceUploadSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetPhysicalTableMapS3SourceUploadSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contains_header: Optional[bool] = None,
                 delimiter: Optional[str] = None,
                 format: Optional[str] = None,
                 start_from_row: Optional[int] = None,
                 text_qualifier: Optional[str] = None):
        """
        :param bool contains_header: Whether the file has a header row, or the files each have a header row.
        :param str delimiter: Delimiter between values in the file.
        :param str format: File format. Valid values are `CSV`, `TSV`, `CLF`, `ELF`, `XLSX`, and `JSON`.
        :param int start_from_row: A row number to start reading data from.
        :param str text_qualifier: Text qualifier. Valid values are `DOUBLE_QUOTE` and `SINGLE_QUOTE`.
        """
        DataSetPhysicalTableMapS3SourceUploadSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contains_header=contains_header,
            delimiter=delimiter,
            format=format,
            start_from_row=start_from_row,
            text_qualifier=text_qualifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contains_header: Optional[bool] = None,
             delimiter: Optional[str] = None,
             format: Optional[str] = None,
             start_from_row: Optional[int] = None,
             text_qualifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if contains_header is None and 'containsHeader' in kwargs:
            contains_header = kwargs['containsHeader']
        if start_from_row is None and 'startFromRow' in kwargs:
            start_from_row = kwargs['startFromRow']
        if text_qualifier is None and 'textQualifier' in kwargs:
            text_qualifier = kwargs['textQualifier']

        if contains_header is not None:
            _setter("contains_header", contains_header)
        if delimiter is not None:
            _setter("delimiter", delimiter)
        if format is not None:
            _setter("format", format)
        if start_from_row is not None:
            _setter("start_from_row", start_from_row)
        if text_qualifier is not None:
            _setter("text_qualifier", text_qualifier)

    @property
    @pulumi.getter(name="containsHeader")
    def contains_header(self) -> Optional[bool]:
        """
        Whether the file has a header row, or the files each have a header row.
        """
        return pulumi.get(self, "contains_header")

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        """
        Delimiter between values in the file.
        """
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        """
        File format. Valid values are `CSV`, `TSV`, `CLF`, `ELF`, `XLSX`, and `JSON`.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="startFromRow")
    def start_from_row(self) -> Optional[int]:
        """
        A row number to start reading data from.
        """
        return pulumi.get(self, "start_from_row")

    @property
    @pulumi.getter(name="textQualifier")
    def text_qualifier(self) -> Optional[str]:
        """
        Text qualifier. Valid values are `DOUBLE_QUOTE` and `SINGLE_QUOTE`.
        """
        return pulumi.get(self, "text_qualifier")


@pulumi.output_type
class DataSetRefreshProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "refreshConfiguration":
            suggest = "refresh_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetRefreshProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetRefreshProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetRefreshProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 refresh_configuration: 'outputs.DataSetRefreshPropertiesRefreshConfiguration'):
        """
        :param 'DataSetRefreshPropertiesRefreshConfigurationArgs' refresh_configuration: The refresh configuration for the data set. See refresh_configuration.
        """
        DataSetRefreshProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            refresh_configuration=refresh_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             refresh_configuration: Optional['outputs.DataSetRefreshPropertiesRefreshConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if refresh_configuration is None and 'refreshConfiguration' in kwargs:
            refresh_configuration = kwargs['refreshConfiguration']
        if refresh_configuration is None:
            raise TypeError("Missing 'refresh_configuration' argument")

        _setter("refresh_configuration", refresh_configuration)

    @property
    @pulumi.getter(name="refreshConfiguration")
    def refresh_configuration(self) -> 'outputs.DataSetRefreshPropertiesRefreshConfiguration':
        """
        The refresh configuration for the data set. See refresh_configuration.
        """
        return pulumi.get(self, "refresh_configuration")


@pulumi.output_type
class DataSetRefreshPropertiesRefreshConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "incrementalRefresh":
            suggest = "incremental_refresh"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetRefreshPropertiesRefreshConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetRefreshPropertiesRefreshConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetRefreshPropertiesRefreshConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incremental_refresh: 'outputs.DataSetRefreshPropertiesRefreshConfigurationIncrementalRefresh'):
        """
        :param 'DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshArgs' incremental_refresh: The incremental refresh for the data set. See incremental_refresh.
        """
        DataSetRefreshPropertiesRefreshConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            incremental_refresh=incremental_refresh,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             incremental_refresh: Optional['outputs.DataSetRefreshPropertiesRefreshConfigurationIncrementalRefresh'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if incremental_refresh is None and 'incrementalRefresh' in kwargs:
            incremental_refresh = kwargs['incrementalRefresh']
        if incremental_refresh is None:
            raise TypeError("Missing 'incremental_refresh' argument")

        _setter("incremental_refresh", incremental_refresh)

    @property
    @pulumi.getter(name="incrementalRefresh")
    def incremental_refresh(self) -> 'outputs.DataSetRefreshPropertiesRefreshConfigurationIncrementalRefresh':
        """
        The incremental refresh for the data set. See incremental_refresh.
        """
        return pulumi.get(self, "incremental_refresh")


@pulumi.output_type
class DataSetRefreshPropertiesRefreshConfigurationIncrementalRefresh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lookbackWindow":
            suggest = "lookback_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetRefreshPropertiesRefreshConfigurationIncrementalRefresh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetRefreshPropertiesRefreshConfigurationIncrementalRefresh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetRefreshPropertiesRefreshConfigurationIncrementalRefresh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lookback_window: 'outputs.DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindow'):
        """
        :param 'DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindowArgs' lookback_window: The lookback window setup for an incremental refresh configuration. See lookback_window.
        """
        DataSetRefreshPropertiesRefreshConfigurationIncrementalRefresh._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lookback_window=lookback_window,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lookback_window: Optional['outputs.DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindow'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if lookback_window is None and 'lookbackWindow' in kwargs:
            lookback_window = kwargs['lookbackWindow']
        if lookback_window is None:
            raise TypeError("Missing 'lookback_window' argument")

        _setter("lookback_window", lookback_window)

    @property
    @pulumi.getter(name="lookbackWindow")
    def lookback_window(self) -> 'outputs.DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindow':
        """
        The lookback window setup for an incremental refresh configuration. See lookback_window.
        """
        return pulumi.get(self, "lookback_window")


@pulumi.output_type
class DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"
        elif key == "sizeUnit":
            suggest = "size_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: str,
                 size: int,
                 size_unit: str):
        """
        :param str column_name: The name of the lookback window column.
        :param int size: The lookback window column size.
        :param str size_unit: The size unit that is used for the lookback window column. Valid values for this structure are `HOUR`, `DAY`, and `WEEK`.
        """
        DataSetRefreshPropertiesRefreshConfigurationIncrementalRefreshLookbackWindow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            size=size,
            size_unit=size_unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             size: Optional[int] = None,
             size_unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if size_unit is None and 'sizeUnit' in kwargs:
            size_unit = kwargs['sizeUnit']
        if size_unit is None:
            raise TypeError("Missing 'size_unit' argument")

        _setter("column_name", column_name)
        _setter("size", size)
        _setter("size_unit", size_unit)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        The name of the lookback window column.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The lookback window column size.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeUnit")
    def size_unit(self) -> str:
        """
        The size unit that is used for the lookback window column. Valid values for this structure are `HOUR`, `DAY`, and `WEEK`.
        """
        return pulumi.get(self, "size_unit")


@pulumi.output_type
class DataSetRowLevelPermissionDataSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "permissionPolicy":
            suggest = "permission_policy"
        elif key == "formatVersion":
            suggest = "format_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetRowLevelPermissionDataSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetRowLevelPermissionDataSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetRowLevelPermissionDataSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 permission_policy: str,
                 format_version: Optional[str] = None,
                 namespace: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str arn: ARN of the dataset that contains permissions for RLS.
        :param str permission_policy: Type of permissions to use when interpreting the permissions for RLS. Valid values are `GRANT_ACCESS` and `DENY_ACCESS`.
        :param str format_version: User or group rules associated with the dataset that contains permissions for RLS.
        :param str namespace: Namespace associated with the dataset that contains permissions for RLS.
        :param str status: Status of the row-level security permission dataset. If enabled, the status is `ENABLED`. If disabled, the status is `DISABLED`.
        """
        DataSetRowLevelPermissionDataSet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            permission_policy=permission_policy,
            format_version=format_version,
            namespace=namespace,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             permission_policy: Optional[str] = None,
             format_version: Optional[str] = None,
             namespace: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if permission_policy is None and 'permissionPolicy' in kwargs:
            permission_policy = kwargs['permissionPolicy']
        if permission_policy is None:
            raise TypeError("Missing 'permission_policy' argument")
        if format_version is None and 'formatVersion' in kwargs:
            format_version = kwargs['formatVersion']

        _setter("arn", arn)
        _setter("permission_policy", permission_policy)
        if format_version is not None:
            _setter("format_version", format_version)
        if namespace is not None:
            _setter("namespace", namespace)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the dataset that contains permissions for RLS.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="permissionPolicy")
    def permission_policy(self) -> str:
        """
        Type of permissions to use when interpreting the permissions for RLS. Valid values are `GRANT_ACCESS` and `DENY_ACCESS`.
        """
        return pulumi.get(self, "permission_policy")

    @property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[str]:
        """
        User or group rules associated with the dataset that contains permissions for RLS.
        """
        return pulumi.get(self, "format_version")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace associated with the dataset that contains permissions for RLS.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the row-level security permission dataset. If enabled, the status is `ENABLED`. If disabled, the status is `DISABLED`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class DataSetRowLevelPermissionTagConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagRules":
            suggest = "tag_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetRowLevelPermissionTagConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetRowLevelPermissionTagConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetRowLevelPermissionTagConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag_rules: Sequence['outputs.DataSetRowLevelPermissionTagConfigurationTagRule'],
                 status: Optional[str] = None):
        """
        :param Sequence['DataSetRowLevelPermissionTagConfigurationTagRuleArgs'] tag_rules: A set of rules associated with row-level security, such as the tag names and columns that they are assigned to. See tag_rules.
        :param str status: The status of row-level security tags. If enabled, the status is `ENABLED`. If disabled, the status is `DISABLED`.
        """
        DataSetRowLevelPermissionTagConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tag_rules=tag_rules,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tag_rules: Optional[Sequence['outputs.DataSetRowLevelPermissionTagConfigurationTagRule']] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if tag_rules is None and 'tagRules' in kwargs:
            tag_rules = kwargs['tagRules']
        if tag_rules is None:
            raise TypeError("Missing 'tag_rules' argument")

        _setter("tag_rules", tag_rules)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="tagRules")
    def tag_rules(self) -> Sequence['outputs.DataSetRowLevelPermissionTagConfigurationTagRule']:
        """
        A set of rules associated with row-level security, such as the tag names and columns that they are assigned to. See tag_rules.
        """
        return pulumi.get(self, "tag_rules")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of row-level security tags. If enabled, the status is `ENABLED`. If disabled, the status is `DISABLED`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class DataSetRowLevelPermissionTagConfigurationTagRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"
        elif key == "tagKey":
            suggest = "tag_key"
        elif key == "matchAllValue":
            suggest = "match_all_value"
        elif key == "tagMultiValueDelimiter":
            suggest = "tag_multi_value_delimiter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSetRowLevelPermissionTagConfigurationTagRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSetRowLevelPermissionTagConfigurationTagRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSetRowLevelPermissionTagConfigurationTagRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: str,
                 tag_key: str,
                 match_all_value: Optional[str] = None,
                 tag_multi_value_delimiter: Optional[str] = None):
        """
        :param str column_name: Column name that a tag key is assigned to.
        :param str tag_key: Unique key for a tag.
        :param str match_all_value: A string that you want to use to filter by all the values in a column in the dataset and dont want to list the values one by one.
        :param str tag_multi_value_delimiter: A string that you want to use to delimit the values when you pass the values at run time.
        """
        DataSetRowLevelPermissionTagConfigurationTagRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            tag_key=tag_key,
            match_all_value=match_all_value,
            tag_multi_value_delimiter=tag_multi_value_delimiter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             tag_key: Optional[str] = None,
             match_all_value: Optional[str] = None,
             tag_multi_value_delimiter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if tag_key is None and 'tagKey' in kwargs:
            tag_key = kwargs['tagKey']
        if tag_key is None:
            raise TypeError("Missing 'tag_key' argument")
        if match_all_value is None and 'matchAllValue' in kwargs:
            match_all_value = kwargs['matchAllValue']
        if tag_multi_value_delimiter is None and 'tagMultiValueDelimiter' in kwargs:
            tag_multi_value_delimiter = kwargs['tagMultiValueDelimiter']

        _setter("column_name", column_name)
        _setter("tag_key", tag_key)
        if match_all_value is not None:
            _setter("match_all_value", match_all_value)
        if tag_multi_value_delimiter is not None:
            _setter("tag_multi_value_delimiter", tag_multi_value_delimiter)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        Column name that a tag key is assigned to.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> str:
        """
        Unique key for a tag.
        """
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter(name="matchAllValue")
    def match_all_value(self) -> Optional[str]:
        """
        A string that you want to use to filter by all the values in a column in the dataset and dont want to list the values one by one.
        """
        return pulumi.get(self, "match_all_value")

    @property
    @pulumi.getter(name="tagMultiValueDelimiter")
    def tag_multi_value_delimiter(self) -> Optional[str]:
        """
        A string that you want to use to delimit the values when you pass the values at run time.
        """
        return pulumi.get(self, "tag_multi_value_delimiter")


@pulumi.output_type
class DataSourceCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copySourceArn":
            suggest = "copy_source_arn"
        elif key == "credentialPair":
            suggest = "credential_pair"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_source_arn: Optional[str] = None,
                 credential_pair: Optional['outputs.DataSourceCredentialsCredentialPair'] = None):
        """
        :param str copy_source_arn: The Amazon Resource Name (ARN) of a data source that has the credential pair that you want to use.
               When the value is not null, the `credential_pair` from the data source in the ARN is used.
        :param 'DataSourceCredentialsCredentialPairArgs' credential_pair: Credential pair. See Credential Pair below for more details.
        """
        DataSourceCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            copy_source_arn=copy_source_arn,
            credential_pair=credential_pair,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             copy_source_arn: Optional[str] = None,
             credential_pair: Optional['outputs.DataSourceCredentialsCredentialPair'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if copy_source_arn is None and 'copySourceArn' in kwargs:
            copy_source_arn = kwargs['copySourceArn']
        if credential_pair is None and 'credentialPair' in kwargs:
            credential_pair = kwargs['credentialPair']

        if copy_source_arn is not None:
            _setter("copy_source_arn", copy_source_arn)
        if credential_pair is not None:
            _setter("credential_pair", credential_pair)

    @property
    @pulumi.getter(name="copySourceArn")
    def copy_source_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of a data source that has the credential pair that you want to use.
        When the value is not null, the `credential_pair` from the data source in the ARN is used.
        """
        return pulumi.get(self, "copy_source_arn")

    @property
    @pulumi.getter(name="credentialPair")
    def credential_pair(self) -> Optional['outputs.DataSourceCredentialsCredentialPair']:
        """
        Credential pair. See Credential Pair below for more details.
        """
        return pulumi.get(self, "credential_pair")


@pulumi.output_type
class DataSourceCredentialsCredentialPair(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: Password, maximum length of 1024 characters.
        :param str username: User name, maximum length of 64 characters.
        """
        DataSourceCredentialsCredentialPair._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password, maximum length of 1024 characters.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        User name, maximum length of 64 characters.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class DataSourceParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amazonElasticsearch":
            suggest = "amazon_elasticsearch"
        elif key == "auroraPostgresql":
            suggest = "aurora_postgresql"
        elif key == "awsIotAnalytics":
            suggest = "aws_iot_analytics"
        elif key == "mariaDb":
            suggest = "maria_db"
        elif key == "serviceNow":
            suggest = "service_now"
        elif key == "sqlServer":
            suggest = "sql_server"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amazon_elasticsearch: Optional['outputs.DataSourceParametersAmazonElasticsearch'] = None,
                 athena: Optional['outputs.DataSourceParametersAthena'] = None,
                 aurora: Optional['outputs.DataSourceParametersAurora'] = None,
                 aurora_postgresql: Optional['outputs.DataSourceParametersAuroraPostgresql'] = None,
                 aws_iot_analytics: Optional['outputs.DataSourceParametersAwsIotAnalytics'] = None,
                 jira: Optional['outputs.DataSourceParametersJira'] = None,
                 maria_db: Optional['outputs.DataSourceParametersMariaDb'] = None,
                 mysql: Optional['outputs.DataSourceParametersMysql'] = None,
                 oracle: Optional['outputs.DataSourceParametersOracle'] = None,
                 postgresql: Optional['outputs.DataSourceParametersPostgresql'] = None,
                 presto: Optional['outputs.DataSourceParametersPresto'] = None,
                 rds: Optional['outputs.DataSourceParametersRds'] = None,
                 redshift: Optional['outputs.DataSourceParametersRedshift'] = None,
                 s3: Optional['outputs.DataSourceParametersS3'] = None,
                 service_now: Optional['outputs.DataSourceParametersServiceNow'] = None,
                 snowflake: Optional['outputs.DataSourceParametersSnowflake'] = None,
                 spark: Optional['outputs.DataSourceParametersSpark'] = None,
                 sql_server: Optional['outputs.DataSourceParametersSqlServer'] = None,
                 teradata: Optional['outputs.DataSourceParametersTeradata'] = None,
                 twitter: Optional['outputs.DataSourceParametersTwitter'] = None):
        """
        :param 'DataSourceParametersAmazonElasticsearchArgs' amazon_elasticsearch: Parameters for connecting to Amazon Elasticsearch.
        :param 'DataSourceParametersAthenaArgs' athena: Parameters for connecting to Athena.
        :param 'DataSourceParametersAuroraArgs' aurora: Parameters for connecting to Aurora MySQL.
        :param 'DataSourceParametersAuroraPostgresqlArgs' aurora_postgresql: Parameters for connecting to Aurora Postgresql.
        :param 'DataSourceParametersAwsIotAnalyticsArgs' aws_iot_analytics: Parameters for connecting to AWS IOT Analytics.
        :param 'DataSourceParametersJiraArgs' jira: Parameters for connecting to Jira.
        :param 'DataSourceParametersMariaDbArgs' maria_db: Parameters for connecting to MariaDB.
        :param 'DataSourceParametersMysqlArgs' mysql: Parameters for connecting to MySQL.
        :param 'DataSourceParametersOracleArgs' oracle: Parameters for connecting to Oracle.
        :param 'DataSourceParametersPostgresqlArgs' postgresql: Parameters for connecting to Postgresql.
        :param 'DataSourceParametersPrestoArgs' presto: Parameters for connecting to Presto.
        :param 'DataSourceParametersRdsArgs' rds: Parameters for connecting to RDS.
        :param 'DataSourceParametersRedshiftArgs' redshift: Parameters for connecting to Redshift.
        :param 'DataSourceParametersS3Args' s3: Parameters for connecting to S3.
        :param 'DataSourceParametersServiceNowArgs' service_now: Parameters for connecting to ServiceNow.
        :param 'DataSourceParametersSnowflakeArgs' snowflake: Parameters for connecting to Snowflake.
        :param 'DataSourceParametersSparkArgs' spark: Parameters for connecting to Spark.
        :param 'DataSourceParametersSqlServerArgs' sql_server: Parameters for connecting to SQL Server.
        :param 'DataSourceParametersTeradataArgs' teradata: Parameters for connecting to Teradata.
        :param 'DataSourceParametersTwitterArgs' twitter: Parameters for connecting to Twitter.
        """
        DataSourceParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            amazon_elasticsearch=amazon_elasticsearch,
            athena=athena,
            aurora=aurora,
            aurora_postgresql=aurora_postgresql,
            aws_iot_analytics=aws_iot_analytics,
            jira=jira,
            maria_db=maria_db,
            mysql=mysql,
            oracle=oracle,
            postgresql=postgresql,
            presto=presto,
            rds=rds,
            redshift=redshift,
            s3=s3,
            service_now=service_now,
            snowflake=snowflake,
            spark=spark,
            sql_server=sql_server,
            teradata=teradata,
            twitter=twitter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             amazon_elasticsearch: Optional['outputs.DataSourceParametersAmazonElasticsearch'] = None,
             athena: Optional['outputs.DataSourceParametersAthena'] = None,
             aurora: Optional['outputs.DataSourceParametersAurora'] = None,
             aurora_postgresql: Optional['outputs.DataSourceParametersAuroraPostgresql'] = None,
             aws_iot_analytics: Optional['outputs.DataSourceParametersAwsIotAnalytics'] = None,
             jira: Optional['outputs.DataSourceParametersJira'] = None,
             maria_db: Optional['outputs.DataSourceParametersMariaDb'] = None,
             mysql: Optional['outputs.DataSourceParametersMysql'] = None,
             oracle: Optional['outputs.DataSourceParametersOracle'] = None,
             postgresql: Optional['outputs.DataSourceParametersPostgresql'] = None,
             presto: Optional['outputs.DataSourceParametersPresto'] = None,
             rds: Optional['outputs.DataSourceParametersRds'] = None,
             redshift: Optional['outputs.DataSourceParametersRedshift'] = None,
             s3: Optional['outputs.DataSourceParametersS3'] = None,
             service_now: Optional['outputs.DataSourceParametersServiceNow'] = None,
             snowflake: Optional['outputs.DataSourceParametersSnowflake'] = None,
             spark: Optional['outputs.DataSourceParametersSpark'] = None,
             sql_server: Optional['outputs.DataSourceParametersSqlServer'] = None,
             teradata: Optional['outputs.DataSourceParametersTeradata'] = None,
             twitter: Optional['outputs.DataSourceParametersTwitter'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if amazon_elasticsearch is None and 'amazonElasticsearch' in kwargs:
            amazon_elasticsearch = kwargs['amazonElasticsearch']
        if aurora_postgresql is None and 'auroraPostgresql' in kwargs:
            aurora_postgresql = kwargs['auroraPostgresql']
        if aws_iot_analytics is None and 'awsIotAnalytics' in kwargs:
            aws_iot_analytics = kwargs['awsIotAnalytics']
        if maria_db is None and 'mariaDb' in kwargs:
            maria_db = kwargs['mariaDb']
        if service_now is None and 'serviceNow' in kwargs:
            service_now = kwargs['serviceNow']
        if sql_server is None and 'sqlServer' in kwargs:
            sql_server = kwargs['sqlServer']

        if amazon_elasticsearch is not None:
            _setter("amazon_elasticsearch", amazon_elasticsearch)
        if athena is not None:
            _setter("athena", athena)
        if aurora is not None:
            _setter("aurora", aurora)
        if aurora_postgresql is not None:
            _setter("aurora_postgresql", aurora_postgresql)
        if aws_iot_analytics is not None:
            _setter("aws_iot_analytics", aws_iot_analytics)
        if jira is not None:
            _setter("jira", jira)
        if maria_db is not None:
            _setter("maria_db", maria_db)
        if mysql is not None:
            _setter("mysql", mysql)
        if oracle is not None:
            _setter("oracle", oracle)
        if postgresql is not None:
            _setter("postgresql", postgresql)
        if presto is not None:
            _setter("presto", presto)
        if rds is not None:
            _setter("rds", rds)
        if redshift is not None:
            _setter("redshift", redshift)
        if s3 is not None:
            _setter("s3", s3)
        if service_now is not None:
            _setter("service_now", service_now)
        if snowflake is not None:
            _setter("snowflake", snowflake)
        if spark is not None:
            _setter("spark", spark)
        if sql_server is not None:
            _setter("sql_server", sql_server)
        if teradata is not None:
            _setter("teradata", teradata)
        if twitter is not None:
            _setter("twitter", twitter)

    @property
    @pulumi.getter(name="amazonElasticsearch")
    def amazon_elasticsearch(self) -> Optional['outputs.DataSourceParametersAmazonElasticsearch']:
        """
        Parameters for connecting to Amazon Elasticsearch.
        """
        return pulumi.get(self, "amazon_elasticsearch")

    @property
    @pulumi.getter
    def athena(self) -> Optional['outputs.DataSourceParametersAthena']:
        """
        Parameters for connecting to Athena.
        """
        return pulumi.get(self, "athena")

    @property
    @pulumi.getter
    def aurora(self) -> Optional['outputs.DataSourceParametersAurora']:
        """
        Parameters for connecting to Aurora MySQL.
        """
        return pulumi.get(self, "aurora")

    @property
    @pulumi.getter(name="auroraPostgresql")
    def aurora_postgresql(self) -> Optional['outputs.DataSourceParametersAuroraPostgresql']:
        """
        Parameters for connecting to Aurora Postgresql.
        """
        return pulumi.get(self, "aurora_postgresql")

    @property
    @pulumi.getter(name="awsIotAnalytics")
    def aws_iot_analytics(self) -> Optional['outputs.DataSourceParametersAwsIotAnalytics']:
        """
        Parameters for connecting to AWS IOT Analytics.
        """
        return pulumi.get(self, "aws_iot_analytics")

    @property
    @pulumi.getter
    def jira(self) -> Optional['outputs.DataSourceParametersJira']:
        """
        Parameters for connecting to Jira.
        """
        return pulumi.get(self, "jira")

    @property
    @pulumi.getter(name="mariaDb")
    def maria_db(self) -> Optional['outputs.DataSourceParametersMariaDb']:
        """
        Parameters for connecting to MariaDB.
        """
        return pulumi.get(self, "maria_db")

    @property
    @pulumi.getter
    def mysql(self) -> Optional['outputs.DataSourceParametersMysql']:
        """
        Parameters for connecting to MySQL.
        """
        return pulumi.get(self, "mysql")

    @property
    @pulumi.getter
    def oracle(self) -> Optional['outputs.DataSourceParametersOracle']:
        """
        Parameters for connecting to Oracle.
        """
        return pulumi.get(self, "oracle")

    @property
    @pulumi.getter
    def postgresql(self) -> Optional['outputs.DataSourceParametersPostgresql']:
        """
        Parameters for connecting to Postgresql.
        """
        return pulumi.get(self, "postgresql")

    @property
    @pulumi.getter
    def presto(self) -> Optional['outputs.DataSourceParametersPresto']:
        """
        Parameters for connecting to Presto.
        """
        return pulumi.get(self, "presto")

    @property
    @pulumi.getter
    def rds(self) -> Optional['outputs.DataSourceParametersRds']:
        """
        Parameters for connecting to RDS.
        """
        return pulumi.get(self, "rds")

    @property
    @pulumi.getter
    def redshift(self) -> Optional['outputs.DataSourceParametersRedshift']:
        """
        Parameters for connecting to Redshift.
        """
        return pulumi.get(self, "redshift")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.DataSourceParametersS3']:
        """
        Parameters for connecting to S3.
        """
        return pulumi.get(self, "s3")

    @property
    @pulumi.getter(name="serviceNow")
    def service_now(self) -> Optional['outputs.DataSourceParametersServiceNow']:
        """
        Parameters for connecting to ServiceNow.
        """
        return pulumi.get(self, "service_now")

    @property
    @pulumi.getter
    def snowflake(self) -> Optional['outputs.DataSourceParametersSnowflake']:
        """
        Parameters for connecting to Snowflake.
        """
        return pulumi.get(self, "snowflake")

    @property
    @pulumi.getter
    def spark(self) -> Optional['outputs.DataSourceParametersSpark']:
        """
        Parameters for connecting to Spark.
        """
        return pulumi.get(self, "spark")

    @property
    @pulumi.getter(name="sqlServer")
    def sql_server(self) -> Optional['outputs.DataSourceParametersSqlServer']:
        """
        Parameters for connecting to SQL Server.
        """
        return pulumi.get(self, "sql_server")

    @property
    @pulumi.getter
    def teradata(self) -> Optional['outputs.DataSourceParametersTeradata']:
        """
        Parameters for connecting to Teradata.
        """
        return pulumi.get(self, "teradata")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.DataSourceParametersTwitter']:
        """
        Parameters for connecting to Twitter.
        """
        return pulumi.get(self, "twitter")


@pulumi.output_type
class DataSourceParametersAmazonElasticsearch(dict):
    def __init__(__self__, *,
                 domain: str):
        """
        :param str domain: The OpenSearch domain.
        """
        DataSourceParametersAmazonElasticsearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if domain is None:
            raise TypeError("Missing 'domain' argument")

        _setter("domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The OpenSearch domain.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class DataSourceParametersAthena(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workGroup":
            suggest = "work_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceParametersAthena. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceParametersAthena.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceParametersAthena.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 work_group: Optional[str] = None):
        """
        :param str work_group: The work-group to which to connect.
        """
        DataSourceParametersAthena._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            work_group=work_group,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             work_group: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if work_group is None and 'workGroup' in kwargs:
            work_group = kwargs['workGroup']

        if work_group is not None:
            _setter("work_group", work_group)

    @property
    @pulumi.getter(name="workGroup")
    def work_group(self) -> Optional[str]:
        """
        The work-group to which to connect.
        """
        return pulumi.get(self, "work_group")


@pulumi.output_type
class DataSourceParametersAurora(dict):
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 port: int):
        """
        :param str database: The database to which to connect.
        :param str host: The host to which to connect.
        :param int port: The port to which to connect.
        """
        DataSourceParametersAurora._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: Optional[str] = None,
             host: Optional[str] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database is None:
            raise TypeError("Missing 'database' argument")
        if host is None:
            raise TypeError("Missing 'host' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")

        _setter("database", database)
        _setter("host", host)
        _setter("port", port)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to which to connect.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceParametersAuroraPostgresql(dict):
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 port: int):
        """
        :param str database: The database to which to connect.
        :param str host: The host to which to connect.
        :param int port: The port to which to connect.
        """
        DataSourceParametersAuroraPostgresql._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: Optional[str] = None,
             host: Optional[str] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database is None:
            raise TypeError("Missing 'database' argument")
        if host is None:
            raise TypeError("Missing 'host' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")

        _setter("database", database)
        _setter("host", host)
        _setter("port", port)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to which to connect.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceParametersAwsIotAnalytics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetName":
            suggest = "data_set_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceParametersAwsIotAnalytics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceParametersAwsIotAnalytics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceParametersAwsIotAnalytics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_name: str):
        """
        :param str data_set_name: The name of the data set to which to connect.
        """
        DataSourceParametersAwsIotAnalytics._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_name=data_set_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_set_name is None and 'dataSetName' in kwargs:
            data_set_name = kwargs['dataSetName']
        if data_set_name is None:
            raise TypeError("Missing 'data_set_name' argument")

        _setter("data_set_name", data_set_name)

    @property
    @pulumi.getter(name="dataSetName")
    def data_set_name(self) -> str:
        """
        The name of the data set to which to connect.
        """
        return pulumi.get(self, "data_set_name")


@pulumi.output_type
class DataSourceParametersJira(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "siteBaseUrl":
            suggest = "site_base_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceParametersJira. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceParametersJira.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceParametersJira.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 site_base_url: str):
        """
        :param str site_base_url: The base URL of the Jira instance's site to which to connect.
        """
        DataSourceParametersJira._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            site_base_url=site_base_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             site_base_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if site_base_url is None and 'siteBaseUrl' in kwargs:
            site_base_url = kwargs['siteBaseUrl']
        if site_base_url is None:
            raise TypeError("Missing 'site_base_url' argument")

        _setter("site_base_url", site_base_url)

    @property
    @pulumi.getter(name="siteBaseUrl")
    def site_base_url(self) -> str:
        """
        The base URL of the Jira instance's site to which to connect.
        """
        return pulumi.get(self, "site_base_url")


@pulumi.output_type
class DataSourceParametersMariaDb(dict):
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 port: int):
        """
        :param str database: The database to which to connect.
        :param str host: The host to which to connect.
        :param int port: The port to which to connect.
        """
        DataSourceParametersMariaDb._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: Optional[str] = None,
             host: Optional[str] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database is None:
            raise TypeError("Missing 'database' argument")
        if host is None:
            raise TypeError("Missing 'host' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")

        _setter("database", database)
        _setter("host", host)
        _setter("port", port)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to which to connect.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceParametersMysql(dict):
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 port: int):
        """
        :param str database: The database to which to connect.
        :param str host: The host to which to connect.
        :param int port: The port to which to connect.
        """
        DataSourceParametersMysql._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: Optional[str] = None,
             host: Optional[str] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database is None:
            raise TypeError("Missing 'database' argument")
        if host is None:
            raise TypeError("Missing 'host' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")

        _setter("database", database)
        _setter("host", host)
        _setter("port", port)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to which to connect.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceParametersOracle(dict):
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 port: int):
        """
        :param str database: The database to which to connect.
        :param str host: The host to which to connect.
        :param int port: The port to which to connect.
        """
        DataSourceParametersOracle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: Optional[str] = None,
             host: Optional[str] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database is None:
            raise TypeError("Missing 'database' argument")
        if host is None:
            raise TypeError("Missing 'host' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")

        _setter("database", database)
        _setter("host", host)
        _setter("port", port)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to which to connect.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceParametersPostgresql(dict):
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 port: int):
        """
        :param str database: The database to which to connect.
        :param str host: The host to which to connect.
        :param int port: The port to which to connect.
        """
        DataSourceParametersPostgresql._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: Optional[str] = None,
             host: Optional[str] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database is None:
            raise TypeError("Missing 'database' argument")
        if host is None:
            raise TypeError("Missing 'host' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")

        _setter("database", database)
        _setter("host", host)
        _setter("port", port)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to which to connect.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceParametersPresto(dict):
    def __init__(__self__, *,
                 catalog: str,
                 host: str,
                 port: int):
        """
        :param str catalog: The catalog to which to connect.
        :param str host: The host to which to connect.
        :param int port: The port to which to connect.
        """
        DataSourceParametersPresto._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            catalog=catalog,
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             catalog: Optional[str] = None,
             host: Optional[str] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if catalog is None:
            raise TypeError("Missing 'catalog' argument")
        if host is None:
            raise TypeError("Missing 'host' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")

        _setter("catalog", catalog)
        _setter("host", host)
        _setter("port", port)

    @property
    @pulumi.getter
    def catalog(self) -> str:
        """
        The catalog to which to connect.
        """
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to which to connect.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceParametersRds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceParametersRds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceParametersRds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceParametersRds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 instance_id: str):
        """
        :param str database: The database to which to connect.
        :param str instance_id: The instance ID to which to connect.
        """
        DataSourceParametersRds._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            instance_id=instance_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: Optional[str] = None,
             instance_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database is None:
            raise TypeError("Missing 'database' argument")
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if instance_id is None:
            raise TypeError("Missing 'instance_id' argument")

        _setter("database", database)
        _setter("instance_id", instance_id)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The instance ID to which to connect.
        """
        return pulumi.get(self, "instance_id")


@pulumi.output_type
class DataSourceParametersRedshift(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceParametersRedshift. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceParametersRedshift.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceParametersRedshift.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 cluster_id: Optional[str] = None,
                 host: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str database: The database to which to connect.
        :param str cluster_id: The ID of the cluster to which to connect.
        :param str host: The host to which to connect.
        :param int port: The port to which to connect.
        """
        DataSourceParametersRedshift._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            cluster_id=cluster_id,
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: Optional[str] = None,
             cluster_id: Optional[str] = None,
             host: Optional[str] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database is None:
            raise TypeError("Missing 'database' argument")
        if cluster_id is None and 'clusterId' in kwargs:
            cluster_id = kwargs['clusterId']

        _setter("database", database)
        if cluster_id is not None:
            _setter("cluster_id", cluster_id)
        if host is not None:
            _setter("host", host)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        """
        The ID of the cluster to which to connect.
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to which to connect.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceParametersS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "manifestFileLocation":
            suggest = "manifest_file_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceParametersS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceParametersS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceParametersS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 manifest_file_location: 'outputs.DataSourceParametersS3ManifestFileLocation'):
        """
        :param 'DataSourceParametersS3ManifestFileLocationArgs' manifest_file_location: An object containing the S3 location of the S3 manifest file.
        """
        DataSourceParametersS3._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            manifest_file_location=manifest_file_location,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             manifest_file_location: Optional['outputs.DataSourceParametersS3ManifestFileLocation'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if manifest_file_location is None and 'manifestFileLocation' in kwargs:
            manifest_file_location = kwargs['manifestFileLocation']
        if manifest_file_location is None:
            raise TypeError("Missing 'manifest_file_location' argument")

        _setter("manifest_file_location", manifest_file_location)

    @property
    @pulumi.getter(name="manifestFileLocation")
    def manifest_file_location(self) -> 'outputs.DataSourceParametersS3ManifestFileLocation':
        """
        An object containing the S3 location of the S3 manifest file.
        """
        return pulumi.get(self, "manifest_file_location")


@pulumi.output_type
class DataSourceParametersS3ManifestFileLocation(dict):
    def __init__(__self__, *,
                 bucket: str,
                 key: str):
        """
        :param str bucket: The name of the bucket that contains the manifest file.
        :param str key: The key of the manifest file within the bucket.
        """
        DataSourceParametersS3ManifestFileLocation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket=bucket,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket: Optional[str] = None,
             key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket is None:
            raise TypeError("Missing 'bucket' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")

        _setter("bucket", bucket)
        _setter("key", key)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        The name of the bucket that contains the manifest file.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the manifest file within the bucket.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class DataSourceParametersServiceNow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "siteBaseUrl":
            suggest = "site_base_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceParametersServiceNow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceParametersServiceNow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceParametersServiceNow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 site_base_url: str):
        """
        :param str site_base_url: The base URL of the Jira instance's site to which to connect.
        """
        DataSourceParametersServiceNow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            site_base_url=site_base_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             site_base_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if site_base_url is None and 'siteBaseUrl' in kwargs:
            site_base_url = kwargs['siteBaseUrl']
        if site_base_url is None:
            raise TypeError("Missing 'site_base_url' argument")

        _setter("site_base_url", site_base_url)

    @property
    @pulumi.getter(name="siteBaseUrl")
    def site_base_url(self) -> str:
        """
        The base URL of the Jira instance's site to which to connect.
        """
        return pulumi.get(self, "site_base_url")


@pulumi.output_type
class DataSourceParametersSnowflake(dict):
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 warehouse: str):
        """
        :param str database: The database to which to connect.
        :param str host: The host to which to connect.
        :param str warehouse: The warehouse to which to connect.
        """
        DataSourceParametersSnowflake._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            host=host,
            warehouse=warehouse,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: Optional[str] = None,
             host: Optional[str] = None,
             warehouse: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database is None:
            raise TypeError("Missing 'database' argument")
        if host is None:
            raise TypeError("Missing 'host' argument")
        if warehouse is None:
            raise TypeError("Missing 'warehouse' argument")

        _setter("database", database)
        _setter("host", host)
        _setter("warehouse", warehouse)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def warehouse(self) -> str:
        """
        The warehouse to which to connect.
        """
        return pulumi.get(self, "warehouse")


@pulumi.output_type
class DataSourceParametersSpark(dict):
    def __init__(__self__, *,
                 host: str,
                 port: int):
        """
        :param str host: The host to which to connect.
        :param int port: The warehouse to which to connect.
        """
        DataSourceParametersSpark._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host: Optional[str] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if host is None:
            raise TypeError("Missing 'host' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")

        _setter("host", host)
        _setter("port", port)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The warehouse to which to connect.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceParametersSqlServer(dict):
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 port: int):
        """
        :param str database: The database to which to connect.
        :param str host: The host to which to connect.
        :param int port: The warehouse to which to connect.
        """
        DataSourceParametersSqlServer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: Optional[str] = None,
             host: Optional[str] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database is None:
            raise TypeError("Missing 'database' argument")
        if host is None:
            raise TypeError("Missing 'host' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")

        _setter("database", database)
        _setter("host", host)
        _setter("port", port)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The warehouse to which to connect.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceParametersTeradata(dict):
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 port: int):
        """
        :param str database: The database to which to connect.
        :param str host: The host to which to connect.
        :param int port: The warehouse to which to connect.
        """
        DataSourceParametersTeradata._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: Optional[str] = None,
             host: Optional[str] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database is None:
            raise TypeError("Missing 'database' argument")
        if host is None:
            raise TypeError("Missing 'host' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")

        _setter("database", database)
        _setter("host", host)
        _setter("port", port)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The database to which to connect.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host to which to connect.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The warehouse to which to connect.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DataSourceParametersTwitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxRows":
            suggest = "max_rows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceParametersTwitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceParametersTwitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceParametersTwitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_rows: int,
                 query: str):
        """
        :param int max_rows: The maximum number of rows to query.
        :param str query: The Twitter query to retrieve the data.
        """
        DataSourceParametersTwitter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_rows=max_rows,
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_rows: Optional[int] = None,
             query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_rows is None and 'maxRows' in kwargs:
            max_rows = kwargs['maxRows']
        if max_rows is None:
            raise TypeError("Missing 'max_rows' argument")
        if query is None:
            raise TypeError("Missing 'query' argument")

        _setter("max_rows", max_rows)
        _setter("query", query)

    @property
    @pulumi.getter(name="maxRows")
    def max_rows(self) -> int:
        """
        The maximum number of rows to query.
        """
        return pulumi.get(self, "max_rows")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The Twitter query to retrieve the data.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class DataSourcePermission(dict):
    def __init__(__self__, *,
                 actions: Sequence[str],
                 principal: str):
        """
        :param Sequence[str] actions: Set of IAM actions to grant or revoke permissions on. Max of 16 items.
        :param str principal: The Amazon Resource Name (ARN) of the principal.
        """
        DataSourcePermission._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            principal=principal,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[Sequence[str]] = None,
             principal: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions is None:
            raise TypeError("Missing 'actions' argument")
        if principal is None:
            raise TypeError("Missing 'principal' argument")

        _setter("actions", actions)
        _setter("principal", principal)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        Set of IAM actions to grant or revoke permissions on. Max of 16 items.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def principal(self) -> str:
        """
        The Amazon Resource Name (ARN) of the principal.
        """
        return pulumi.get(self, "principal")


@pulumi.output_type
class DataSourceSslProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableSsl":
            suggest = "disable_ssl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceSslProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceSslProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceSslProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_ssl: bool):
        """
        :param bool disable_ssl: A Boolean option to control whether SSL should be disabled.
        """
        DataSourceSslProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disable_ssl=disable_ssl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disable_ssl: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if disable_ssl is None and 'disableSsl' in kwargs:
            disable_ssl = kwargs['disableSsl']
        if disable_ssl is None:
            raise TypeError("Missing 'disable_ssl' argument")

        _setter("disable_ssl", disable_ssl)

    @property
    @pulumi.getter(name="disableSsl")
    def disable_ssl(self) -> bool:
        """
        A Boolean option to control whether SSL should be disabled.
        """
        return pulumi.get(self, "disable_ssl")


@pulumi.output_type
class DataSourceVpcConnectionProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpcConnectionArn":
            suggest = "vpc_connection_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceVpcConnectionProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceVpcConnectionProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceVpcConnectionProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vpc_connection_arn: str):
        """
        :param str vpc_connection_arn: The Amazon Resource Name (ARN) for the VPC connection.
        """
        DataSourceVpcConnectionProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            vpc_connection_arn=vpc_connection_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             vpc_connection_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if vpc_connection_arn is None and 'vpcConnectionArn' in kwargs:
            vpc_connection_arn = kwargs['vpcConnectionArn']
        if vpc_connection_arn is None:
            raise TypeError("Missing 'vpc_connection_arn' argument")

        _setter("vpc_connection_arn", vpc_connection_arn)

    @property
    @pulumi.getter(name="vpcConnectionArn")
    def vpc_connection_arn(self) -> str:
        """
        The Amazon Resource Name (ARN) for the VPC connection.
        """
        return pulumi.get(self, "vpc_connection_arn")


@pulumi.output_type
class FolderPermission(dict):
    def __init__(__self__, *,
                 actions: Sequence[str],
                 principal: str):
        """
        :param Sequence[str] actions: List of IAM actions to grant or revoke permissions on.
        :param str principal: ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        FolderPermission._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            principal=principal,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[Sequence[str]] = None,
             principal: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions is None:
            raise TypeError("Missing 'actions' argument")
        if principal is None:
            raise TypeError("Missing 'principal' argument")

        _setter("actions", actions)
        _setter("principal", principal)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        List of IAM actions to grant or revoke permissions on.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def principal(self) -> str:
        """
        ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        return pulumi.get(self, "principal")


@pulumi.output_type
class IamPolicyAssignmentIdentities(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence[str]] = None,
                 users: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] users: Array of Quicksight user names to assign the policy to.
        """
        IamPolicyAssignmentIdentities._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            groups=groups,
            users=users,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             groups: Optional[Sequence[str]] = None,
             users: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if groups is not None:
            _setter("groups", groups)
        if users is not None:
            _setter("users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence[str]]:
        """
        Array of Quicksight user names to assign the policy to.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class NamespaceTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[str] = None,
                 delete: Optional[str] = None):
        NamespaceTimeouts._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create=create,
            delete=delete,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create: Optional[str] = None,
             delete: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if create is not None:
            _setter("create", create)
        if delete is not None:
            _setter("delete", delete)

    @property
    @pulumi.getter
    def create(self) -> Optional[str]:
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[str]:
        return pulumi.get(self, "delete")


@pulumi.output_type
class RefreshScheduleSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "refreshType":
            suggest = "refresh_type"
        elif key == "scheduleFrequency":
            suggest = "schedule_frequency"
        elif key == "startAfterDateTime":
            suggest = "start_after_date_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RefreshScheduleSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RefreshScheduleSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RefreshScheduleSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 refresh_type: str,
                 schedule_frequency: Optional['outputs.RefreshScheduleScheduleScheduleFrequency'] = None,
                 start_after_date_time: Optional[str] = None):
        """
        :param str refresh_type: The type of refresh that the dataset undergoes. Valid values are `INCREMENTAL_REFRESH` and `FULL_REFRESH`.
        :param 'RefreshScheduleScheduleScheduleFrequencyArgs' schedule_frequency: The configuration of the [schedule frequency](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_RefreshFrequency.html). See schedule_frequency.
        :param str start_after_date_time: Time after which the refresh schedule can be started, expressed in `YYYY-MM-DDTHH:MM:SS` format.
        """
        RefreshScheduleSchedule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            refresh_type=refresh_type,
            schedule_frequency=schedule_frequency,
            start_after_date_time=start_after_date_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             refresh_type: Optional[str] = None,
             schedule_frequency: Optional['outputs.RefreshScheduleScheduleScheduleFrequency'] = None,
             start_after_date_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if refresh_type is None and 'refreshType' in kwargs:
            refresh_type = kwargs['refreshType']
        if refresh_type is None:
            raise TypeError("Missing 'refresh_type' argument")
        if schedule_frequency is None and 'scheduleFrequency' in kwargs:
            schedule_frequency = kwargs['scheduleFrequency']
        if start_after_date_time is None and 'startAfterDateTime' in kwargs:
            start_after_date_time = kwargs['startAfterDateTime']

        _setter("refresh_type", refresh_type)
        if schedule_frequency is not None:
            _setter("schedule_frequency", schedule_frequency)
        if start_after_date_time is not None:
            _setter("start_after_date_time", start_after_date_time)

    @property
    @pulumi.getter(name="refreshType")
    def refresh_type(self) -> str:
        """
        The type of refresh that the dataset undergoes. Valid values are `INCREMENTAL_REFRESH` and `FULL_REFRESH`.
        """
        return pulumi.get(self, "refresh_type")

    @property
    @pulumi.getter(name="scheduleFrequency")
    def schedule_frequency(self) -> Optional['outputs.RefreshScheduleScheduleScheduleFrequency']:
        """
        The configuration of the [schedule frequency](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_RefreshFrequency.html). See schedule_frequency.
        """
        return pulumi.get(self, "schedule_frequency")

    @property
    @pulumi.getter(name="startAfterDateTime")
    def start_after_date_time(self) -> Optional[str]:
        """
        Time after which the refresh schedule can be started, expressed in `YYYY-MM-DDTHH:MM:SS` format.
        """
        return pulumi.get(self, "start_after_date_time")


@pulumi.output_type
class RefreshScheduleScheduleScheduleFrequency(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "refreshOnDay":
            suggest = "refresh_on_day"
        elif key == "timeOfTheDay":
            suggest = "time_of_the_day"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RefreshScheduleScheduleScheduleFrequency. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RefreshScheduleScheduleScheduleFrequency.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RefreshScheduleScheduleScheduleFrequency.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval: str,
                 refresh_on_day: Optional['outputs.RefreshScheduleScheduleScheduleFrequencyRefreshOnDay'] = None,
                 time_of_the_day: Optional[str] = None,
                 timezone: Optional[str] = None):
        """
        :param str interval: The interval between scheduled refreshes. Valid values are `MINUTE15`, `MINUTE30`, `HOURLY`, `DAILY`, `WEEKLY` and `MONTHLY`.
        :param 'RefreshScheduleScheduleScheduleFrequencyRefreshOnDayArgs' refresh_on_day: The [refresh on entity](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ScheduleRefreshOnEntity.html) configuration for weekly or monthly schedules. See refresh_on_day.
        :param str time_of_the_day: The time of day that you want the dataset to refresh. This value is expressed in `HH:MM` format. This field is not required for schedules that refresh hourly.
        :param str timezone: The timezone that you want the refresh schedule to use.
        """
        RefreshScheduleScheduleScheduleFrequency._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            interval=interval,
            refresh_on_day=refresh_on_day,
            time_of_the_day=time_of_the_day,
            timezone=timezone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             interval: Optional[str] = None,
             refresh_on_day: Optional['outputs.RefreshScheduleScheduleScheduleFrequencyRefreshOnDay'] = None,
             time_of_the_day: Optional[str] = None,
             timezone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if interval is None:
            raise TypeError("Missing 'interval' argument")
        if refresh_on_day is None and 'refreshOnDay' in kwargs:
            refresh_on_day = kwargs['refreshOnDay']
        if time_of_the_day is None and 'timeOfTheDay' in kwargs:
            time_of_the_day = kwargs['timeOfTheDay']

        _setter("interval", interval)
        if refresh_on_day is not None:
            _setter("refresh_on_day", refresh_on_day)
        if time_of_the_day is not None:
            _setter("time_of_the_day", time_of_the_day)
        if timezone is not None:
            _setter("timezone", timezone)

    @property
    @pulumi.getter
    def interval(self) -> str:
        """
        The interval between scheduled refreshes. Valid values are `MINUTE15`, `MINUTE30`, `HOURLY`, `DAILY`, `WEEKLY` and `MONTHLY`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="refreshOnDay")
    def refresh_on_day(self) -> Optional['outputs.RefreshScheduleScheduleScheduleFrequencyRefreshOnDay']:
        """
        The [refresh on entity](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ScheduleRefreshOnEntity.html) configuration for weekly or monthly schedules. See refresh_on_day.
        """
        return pulumi.get(self, "refresh_on_day")

    @property
    @pulumi.getter(name="timeOfTheDay")
    def time_of_the_day(self) -> Optional[str]:
        """
        The time of day that you want the dataset to refresh. This value is expressed in `HH:MM` format. This field is not required for schedules that refresh hourly.
        """
        return pulumi.get(self, "time_of_the_day")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        The timezone that you want the refresh schedule to use.
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class RefreshScheduleScheduleScheduleFrequencyRefreshOnDay(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfMonth":
            suggest = "day_of_month"
        elif key == "dayOfWeek":
            suggest = "day_of_week"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RefreshScheduleScheduleScheduleFrequencyRefreshOnDay. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RefreshScheduleScheduleScheduleFrequencyRefreshOnDay.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RefreshScheduleScheduleScheduleFrequencyRefreshOnDay.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_month: Optional[str] = None,
                 day_of_week: Optional[str] = None):
        """
        :param str day_of_month: The day of the month that you want to schedule refresh on.
        :param str day_of_week: The day of the week that you want to schedule a refresh on. Valid values are `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY` and `SATURDAY`.
        """
        RefreshScheduleScheduleScheduleFrequencyRefreshOnDay._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            day_of_month=day_of_month,
            day_of_week=day_of_week,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             day_of_month: Optional[str] = None,
             day_of_week: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if day_of_month is None and 'dayOfMonth' in kwargs:
            day_of_month = kwargs['dayOfMonth']
        if day_of_week is None and 'dayOfWeek' in kwargs:
            day_of_week = kwargs['dayOfWeek']

        if day_of_month is not None:
            _setter("day_of_month", day_of_month)
        if day_of_week is not None:
            _setter("day_of_week", day_of_week)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[str]:
        """
        The day of the month that you want to schedule refresh on.
        """
        return pulumi.get(self, "day_of_month")

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[str]:
        """
        The day of the week that you want to schedule a refresh on. Valid values are `SUNDAY`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY` and `SATURDAY`.
        """
        return pulumi.get(self, "day_of_week")


@pulumi.output_type
class TemplatePermission(dict):
    def __init__(__self__, *,
                 actions: Sequence[str],
                 principal: str):
        """
        :param Sequence[str] actions: List of IAM actions to grant or revoke permissions on.
        :param str principal: ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        TemplatePermission._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            principal=principal,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[Sequence[str]] = None,
             principal: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions is None:
            raise TypeError("Missing 'actions' argument")
        if principal is None:
            raise TypeError("Missing 'principal' argument")

        _setter("actions", actions)
        _setter("principal", principal)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        List of IAM actions to grant or revoke permissions on.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def principal(self) -> str:
        """
        ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        return pulumi.get(self, "principal")


@pulumi.output_type
class TemplateSourceEntity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceAnalysis":
            suggest = "source_analysis"
        elif key == "sourceTemplate":
            suggest = "source_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSourceEntity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSourceEntity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSourceEntity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_analysis: Optional['outputs.TemplateSourceEntitySourceAnalysis'] = None,
                 source_template: Optional['outputs.TemplateSourceEntitySourceTemplate'] = None):
        """
        :param 'TemplateSourceEntitySourceAnalysisArgs' source_analysis: The source analysis, if it is based on an analysis.. Only one of `source_analysis` or `source_template` should be configured. See source_analysis.
        :param 'TemplateSourceEntitySourceTemplateArgs' source_template: The source template, if it is based on an template.. Only one of `source_analysis` or `source_template` should be configured. See source_template.
        """
        TemplateSourceEntity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_analysis=source_analysis,
            source_template=source_template,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_analysis: Optional['outputs.TemplateSourceEntitySourceAnalysis'] = None,
             source_template: Optional['outputs.TemplateSourceEntitySourceTemplate'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source_analysis is None and 'sourceAnalysis' in kwargs:
            source_analysis = kwargs['sourceAnalysis']
        if source_template is None and 'sourceTemplate' in kwargs:
            source_template = kwargs['sourceTemplate']

        if source_analysis is not None:
            _setter("source_analysis", source_analysis)
        if source_template is not None:
            _setter("source_template", source_template)

    @property
    @pulumi.getter(name="sourceAnalysis")
    def source_analysis(self) -> Optional['outputs.TemplateSourceEntitySourceAnalysis']:
        """
        The source analysis, if it is based on an analysis.. Only one of `source_analysis` or `source_template` should be configured. See source_analysis.
        """
        return pulumi.get(self, "source_analysis")

    @property
    @pulumi.getter(name="sourceTemplate")
    def source_template(self) -> Optional['outputs.TemplateSourceEntitySourceTemplate']:
        """
        The source template, if it is based on an template.. Only one of `source_analysis` or `source_template` should be configured. See source_template.
        """
        return pulumi.get(self, "source_template")


@pulumi.output_type
class TemplateSourceEntitySourceAnalysis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetReferences":
            suggest = "data_set_references"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSourceEntitySourceAnalysis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSourceEntitySourceAnalysis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSourceEntitySourceAnalysis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 data_set_references: Sequence['outputs.TemplateSourceEntitySourceAnalysisDataSetReference']):
        """
        :param str arn: The Amazon Resource Name (ARN) of the resource.
        :param Sequence['TemplateSourceEntitySourceAnalysisDataSetReferenceArgs'] data_set_references: A list of dataset references used as placeholders in the template. See data_set_references.
        """
        TemplateSourceEntitySourceAnalysis._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            data_set_references=data_set_references,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             data_set_references: Optional[Sequence['outputs.TemplateSourceEntitySourceAnalysisDataSetReference']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if data_set_references is None and 'dataSetReferences' in kwargs:
            data_set_references = kwargs['dataSetReferences']
        if data_set_references is None:
            raise TypeError("Missing 'data_set_references' argument")

        _setter("arn", arn)
        _setter("data_set_references", data_set_references)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the resource.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="dataSetReferences")
    def data_set_references(self) -> Sequence['outputs.TemplateSourceEntitySourceAnalysisDataSetReference']:
        """
        A list of dataset references used as placeholders in the template. See data_set_references.
        """
        return pulumi.get(self, "data_set_references")


@pulumi.output_type
class TemplateSourceEntitySourceAnalysisDataSetReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetArn":
            suggest = "data_set_arn"
        elif key == "dataSetPlaceholder":
            suggest = "data_set_placeholder"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateSourceEntitySourceAnalysisDataSetReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateSourceEntitySourceAnalysisDataSetReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateSourceEntitySourceAnalysisDataSetReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_arn: str,
                 data_set_placeholder: str):
        """
        :param str data_set_arn: Dataset Amazon Resource Name (ARN).
        :param str data_set_placeholder: Dataset placeholder.
        """
        TemplateSourceEntitySourceAnalysisDataSetReference._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_arn=data_set_arn,
            data_set_placeholder=data_set_placeholder,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_arn: Optional[str] = None,
             data_set_placeholder: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_set_arn is None and 'dataSetArn' in kwargs:
            data_set_arn = kwargs['dataSetArn']
        if data_set_arn is None:
            raise TypeError("Missing 'data_set_arn' argument")
        if data_set_placeholder is None and 'dataSetPlaceholder' in kwargs:
            data_set_placeholder = kwargs['dataSetPlaceholder']
        if data_set_placeholder is None:
            raise TypeError("Missing 'data_set_placeholder' argument")

        _setter("data_set_arn", data_set_arn)
        _setter("data_set_placeholder", data_set_placeholder)

    @property
    @pulumi.getter(name="dataSetArn")
    def data_set_arn(self) -> str:
        """
        Dataset Amazon Resource Name (ARN).
        """
        return pulumi.get(self, "data_set_arn")

    @property
    @pulumi.getter(name="dataSetPlaceholder")
    def data_set_placeholder(self) -> str:
        """
        Dataset placeholder.
        """
        return pulumi.get(self, "data_set_placeholder")


@pulumi.output_type
class TemplateSourceEntitySourceTemplate(dict):
    def __init__(__self__, *,
                 arn: str):
        """
        :param str arn: The Amazon Resource Name (ARN) of the resource.
        """
        TemplateSourceEntitySourceTemplate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")

        _setter("arn", arn)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the resource.
        """
        return pulumi.get(self, "arn")


@pulumi.output_type
class ThemeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataColorPalette":
            suggest = "data_color_palette"
        elif key == "uiColorPalette":
            suggest = "ui_color_palette"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThemeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThemeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThemeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_color_palette: Optional['outputs.ThemeConfigurationDataColorPalette'] = None,
                 sheet: Optional['outputs.ThemeConfigurationSheet'] = None,
                 typography: Optional['outputs.ThemeConfigurationTypography'] = None,
                 ui_color_palette: Optional['outputs.ThemeConfigurationUiColorPalette'] = None):
        """
        :param 'ThemeConfigurationDataColorPaletteArgs' data_color_palette: Color properties that apply to chart data colors. See data_color_palette.
        :param 'ThemeConfigurationSheetArgs' sheet: Display options related to sheets. See sheet.
        :param 'ThemeConfigurationTypographyArgs' typography: Determines the typography options. See typography.
        :param 'ThemeConfigurationUiColorPaletteArgs' ui_color_palette: Color properties that apply to the UI and to charts, excluding the colors that apply to data. See ui_color_palette.
        """
        ThemeConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_color_palette=data_color_palette,
            sheet=sheet,
            typography=typography,
            ui_color_palette=ui_color_palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_color_palette: Optional['outputs.ThemeConfigurationDataColorPalette'] = None,
             sheet: Optional['outputs.ThemeConfigurationSheet'] = None,
             typography: Optional['outputs.ThemeConfigurationTypography'] = None,
             ui_color_palette: Optional['outputs.ThemeConfigurationUiColorPalette'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_color_palette is None and 'dataColorPalette' in kwargs:
            data_color_palette = kwargs['dataColorPalette']
        if ui_color_palette is None and 'uiColorPalette' in kwargs:
            ui_color_palette = kwargs['uiColorPalette']

        if data_color_palette is not None:
            _setter("data_color_palette", data_color_palette)
        if sheet is not None:
            _setter("sheet", sheet)
        if typography is not None:
            _setter("typography", typography)
        if ui_color_palette is not None:
            _setter("ui_color_palette", ui_color_palette)

    @property
    @pulumi.getter(name="dataColorPalette")
    def data_color_palette(self) -> Optional['outputs.ThemeConfigurationDataColorPalette']:
        """
        Color properties that apply to chart data colors. See data_color_palette.
        """
        return pulumi.get(self, "data_color_palette")

    @property
    @pulumi.getter
    def sheet(self) -> Optional['outputs.ThemeConfigurationSheet']:
        """
        Display options related to sheets. See sheet.
        """
        return pulumi.get(self, "sheet")

    @property
    @pulumi.getter
    def typography(self) -> Optional['outputs.ThemeConfigurationTypography']:
        """
        Determines the typography options. See typography.
        """
        return pulumi.get(self, "typography")

    @property
    @pulumi.getter(name="uiColorPalette")
    def ui_color_palette(self) -> Optional['outputs.ThemeConfigurationUiColorPalette']:
        """
        Color properties that apply to the UI and to charts, excluding the colors that apply to data. See ui_color_palette.
        """
        return pulumi.get(self, "ui_color_palette")


@pulumi.output_type
class ThemeConfigurationDataColorPalette(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emptyFillColor":
            suggest = "empty_fill_color"
        elif key == "minMaxGradients":
            suggest = "min_max_gradients"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThemeConfigurationDataColorPalette. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThemeConfigurationDataColorPalette.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThemeConfigurationDataColorPalette.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 colors: Optional[Sequence[str]] = None,
                 empty_fill_color: Optional[str] = None,
                 min_max_gradients: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] colors: List of hexadecimal codes for the colors. Minimum of 8 items and maximum of 20 items.
        :param str empty_fill_color: The hexadecimal code of a color that applies to charts where a lack of data is highlighted.
        :param Sequence[str] min_max_gradients: The minimum and maximum hexadecimal codes that describe a color gradient. List of exactly 2 items.
        """
        ThemeConfigurationDataColorPalette._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            colors=colors,
            empty_fill_color=empty_fill_color,
            min_max_gradients=min_max_gradients,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             colors: Optional[Sequence[str]] = None,
             empty_fill_color: Optional[str] = None,
             min_max_gradients: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if empty_fill_color is None and 'emptyFillColor' in kwargs:
            empty_fill_color = kwargs['emptyFillColor']
        if min_max_gradients is None and 'minMaxGradients' in kwargs:
            min_max_gradients = kwargs['minMaxGradients']

        if colors is not None:
            _setter("colors", colors)
        if empty_fill_color is not None:
            _setter("empty_fill_color", empty_fill_color)
        if min_max_gradients is not None:
            _setter("min_max_gradients", min_max_gradients)

    @property
    @pulumi.getter
    def colors(self) -> Optional[Sequence[str]]:
        """
        List of hexadecimal codes for the colors. Minimum of 8 items and maximum of 20 items.
        """
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter(name="emptyFillColor")
    def empty_fill_color(self) -> Optional[str]:
        """
        The hexadecimal code of a color that applies to charts where a lack of data is highlighted.
        """
        return pulumi.get(self, "empty_fill_color")

    @property
    @pulumi.getter(name="minMaxGradients")
    def min_max_gradients(self) -> Optional[Sequence[str]]:
        """
        The minimum and maximum hexadecimal codes that describe a color gradient. List of exactly 2 items.
        """
        return pulumi.get(self, "min_max_gradients")


@pulumi.output_type
class ThemeConfigurationSheet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tileLayout":
            suggest = "tile_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThemeConfigurationSheet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThemeConfigurationSheet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThemeConfigurationSheet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tile: Optional['outputs.ThemeConfigurationSheetTile'] = None,
                 tile_layout: Optional['outputs.ThemeConfigurationSheetTileLayout'] = None):
        """
        :param 'ThemeConfigurationSheetTileArgs' tile: The display options for tiles. See tile.
        :param 'ThemeConfigurationSheetTileLayoutArgs' tile_layout: The layout options for tiles. See tile_layout.
        """
        ThemeConfigurationSheet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tile=tile,
            tile_layout=tile_layout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tile: Optional['outputs.ThemeConfigurationSheetTile'] = None,
             tile_layout: Optional['outputs.ThemeConfigurationSheetTileLayout'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if tile_layout is None and 'tileLayout' in kwargs:
            tile_layout = kwargs['tileLayout']

        if tile is not None:
            _setter("tile", tile)
        if tile_layout is not None:
            _setter("tile_layout", tile_layout)

    @property
    @pulumi.getter
    def tile(self) -> Optional['outputs.ThemeConfigurationSheetTile']:
        """
        The display options for tiles. See tile.
        """
        return pulumi.get(self, "tile")

    @property
    @pulumi.getter(name="tileLayout")
    def tile_layout(self) -> Optional['outputs.ThemeConfigurationSheetTileLayout']:
        """
        The layout options for tiles. See tile_layout.
        """
        return pulumi.get(self, "tile_layout")


@pulumi.output_type
class ThemeConfigurationSheetTile(dict):
    def __init__(__self__, *,
                 border: Optional['outputs.ThemeConfigurationSheetTileBorder'] = None):
        """
        :param 'ThemeConfigurationSheetTileBorderArgs' border: The border around a tile. See border.
        """
        ThemeConfigurationSheetTile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            border=border,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             border: Optional['outputs.ThemeConfigurationSheetTileBorder'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if border is not None:
            _setter("border", border)

    @property
    @pulumi.getter
    def border(self) -> Optional['outputs.ThemeConfigurationSheetTileBorder']:
        """
        The border around a tile. See border.
        """
        return pulumi.get(self, "border")


@pulumi.output_type
class ThemeConfigurationSheetTileBorder(dict):
    def __init__(__self__, *,
                 show: Optional[bool] = None):
        """
        :param bool show: The option to enable display of borders for visuals.
        """
        ThemeConfigurationSheetTileBorder._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            show=show,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             show: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if show is not None:
            _setter("show", show)

    @property
    @pulumi.getter
    def show(self) -> Optional[bool]:
        """
        The option to enable display of borders for visuals.
        """
        return pulumi.get(self, "show")


@pulumi.output_type
class ThemeConfigurationSheetTileLayout(dict):
    def __init__(__self__, *,
                 gutter: Optional['outputs.ThemeConfigurationSheetTileLayoutGutter'] = None,
                 margin: Optional['outputs.ThemeConfigurationSheetTileLayoutMargin'] = None):
        """
        :param 'ThemeConfigurationSheetTileLayoutGutterArgs' gutter: The gutter settings that apply between tiles. See gutter.
        :param 'ThemeConfigurationSheetTileLayoutMarginArgs' margin: The margin settings that apply around the outside edge of sheets. See margin.
        """
        ThemeConfigurationSheetTileLayout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gutter=gutter,
            margin=margin,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gutter: Optional['outputs.ThemeConfigurationSheetTileLayoutGutter'] = None,
             margin: Optional['outputs.ThemeConfigurationSheetTileLayoutMargin'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if gutter is not None:
            _setter("gutter", gutter)
        if margin is not None:
            _setter("margin", margin)

    @property
    @pulumi.getter
    def gutter(self) -> Optional['outputs.ThemeConfigurationSheetTileLayoutGutter']:
        """
        The gutter settings that apply between tiles. See gutter.
        """
        return pulumi.get(self, "gutter")

    @property
    @pulumi.getter
    def margin(self) -> Optional['outputs.ThemeConfigurationSheetTileLayoutMargin']:
        """
        The margin settings that apply around the outside edge of sheets. See margin.
        """
        return pulumi.get(self, "margin")


@pulumi.output_type
class ThemeConfigurationSheetTileLayoutGutter(dict):
    def __init__(__self__, *,
                 show: Optional[bool] = None):
        """
        :param bool show: This Boolean value controls whether to display a gutter space between sheet tiles.
        """
        ThemeConfigurationSheetTileLayoutGutter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            show=show,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             show: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if show is not None:
            _setter("show", show)

    @property
    @pulumi.getter
    def show(self) -> Optional[bool]:
        """
        This Boolean value controls whether to display a gutter space between sheet tiles.
        """
        return pulumi.get(self, "show")


@pulumi.output_type
class ThemeConfigurationSheetTileLayoutMargin(dict):
    def __init__(__self__, *,
                 show: Optional[bool] = None):
        """
        :param bool show: This Boolean value controls whether to display sheet margins.
        """
        ThemeConfigurationSheetTileLayoutMargin._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            show=show,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             show: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if show is not None:
            _setter("show", show)

    @property
    @pulumi.getter
    def show(self) -> Optional[bool]:
        """
        This Boolean value controls whether to display sheet margins.
        """
        return pulumi.get(self, "show")


@pulumi.output_type
class ThemeConfigurationTypography(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontFamilies":
            suggest = "font_families"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThemeConfigurationTypography. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThemeConfigurationTypography.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThemeConfigurationTypography.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 font_families: Optional[Sequence['outputs.ThemeConfigurationTypographyFontFamily']] = None):
        """
        :param Sequence['ThemeConfigurationTypographyFontFamilyArgs'] font_families: Determines the list of font families. Maximum number of 5 items. See font_families.
        """
        ThemeConfigurationTypography._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            font_families=font_families,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             font_families: Optional[Sequence['outputs.ThemeConfigurationTypographyFontFamily']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if font_families is None and 'fontFamilies' in kwargs:
            font_families = kwargs['fontFamilies']

        if font_families is not None:
            _setter("font_families", font_families)

    @property
    @pulumi.getter(name="fontFamilies")
    def font_families(self) -> Optional[Sequence['outputs.ThemeConfigurationTypographyFontFamily']]:
        """
        Determines the list of font families. Maximum number of 5 items. See font_families.
        """
        return pulumi.get(self, "font_families")


@pulumi.output_type
class ThemeConfigurationTypographyFontFamily(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontFamily":
            suggest = "font_family"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThemeConfigurationTypographyFontFamily. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThemeConfigurationTypographyFontFamily.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThemeConfigurationTypographyFontFamily.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 font_family: Optional[str] = None):
        """
        :param str font_family: Font family name.
        """
        ThemeConfigurationTypographyFontFamily._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            font_family=font_family,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             font_family: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if font_family is None and 'fontFamily' in kwargs:
            font_family = kwargs['fontFamily']

        if font_family is not None:
            _setter("font_family", font_family)

    @property
    @pulumi.getter(name="fontFamily")
    def font_family(self) -> Optional[str]:
        """
        Font family name.
        """
        return pulumi.get(self, "font_family")


@pulumi.output_type
class ThemeConfigurationUiColorPalette(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accentForeground":
            suggest = "accent_foreground"
        elif key == "dangerForeground":
            suggest = "danger_foreground"
        elif key == "dimensionForeground":
            suggest = "dimension_foreground"
        elif key == "measureForeground":
            suggest = "measure_foreground"
        elif key == "primaryBackground":
            suggest = "primary_background"
        elif key == "primaryForeground":
            suggest = "primary_foreground"
        elif key == "secondaryBackground":
            suggest = "secondary_background"
        elif key == "secondaryForeground":
            suggest = "secondary_foreground"
        elif key == "successForeground":
            suggest = "success_foreground"
        elif key == "warningForeground":
            suggest = "warning_foreground"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThemeConfigurationUiColorPalette. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThemeConfigurationUiColorPalette.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThemeConfigurationUiColorPalette.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accent: Optional[str] = None,
                 accent_foreground: Optional[str] = None,
                 danger: Optional[str] = None,
                 danger_foreground: Optional[str] = None,
                 dimension: Optional[str] = None,
                 dimension_foreground: Optional[str] = None,
                 measure: Optional[str] = None,
                 measure_foreground: Optional[str] = None,
                 primary_background: Optional[str] = None,
                 primary_foreground: Optional[str] = None,
                 secondary_background: Optional[str] = None,
                 secondary_foreground: Optional[str] = None,
                 success: Optional[str] = None,
                 success_foreground: Optional[str] = None,
                 warning: Optional[str] = None,
                 warning_foreground: Optional[str] = None):
        """
        :param str accent: Color (hexadecimal) that applies to selected states and buttons.
        :param str accent_foreground: Color (hexadecimal) that applies to any text or other elements that appear over the accent color.
        :param str danger: Color (hexadecimal) that applies to error messages.
        :param str danger_foreground: Color (hexadecimal) that applies to any text or other elements that appear over the error color.
        :param str dimension: Color (hexadecimal) that applies to the names of fields that are identified as dimensions.
        :param str dimension_foreground: Color (hexadecimal) that applies to any text or other elements that appear over the dimension color.
        :param str measure: Color (hexadecimal) that applies to the names of fields that are identified as measures.
        :param str measure_foreground: Color (hexadecimal) that applies to any text or other elements that appear over the measure color.
        :param str primary_background: Color (hexadecimal) that applies to visuals and other high emphasis UI.
        :param str primary_foreground: Color (hexadecimal) of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.
        :param str secondary_background: Color (hexadecimal) that applies to the sheet background and sheet controls.
        :param str secondary_foreground: Color (hexadecimal) that applies to any sheet title, sheet control text, or UI that appears over the secondary background.
        :param str success: Color (hexadecimal) that applies to success messages, for example the check mark for a successful download.
        :param str success_foreground: Color (hexadecimal) that applies to any text or other elements that appear over the success color.
        :param str warning: Color (hexadecimal) that applies to warning and informational messages.
        :param str warning_foreground: Color (hexadecimal) that applies to any text or other elements that appear over the warning color.
        """
        ThemeConfigurationUiColorPalette._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            accent=accent,
            accent_foreground=accent_foreground,
            danger=danger,
            danger_foreground=danger_foreground,
            dimension=dimension,
            dimension_foreground=dimension_foreground,
            measure=measure,
            measure_foreground=measure_foreground,
            primary_background=primary_background,
            primary_foreground=primary_foreground,
            secondary_background=secondary_background,
            secondary_foreground=secondary_foreground,
            success=success,
            success_foreground=success_foreground,
            warning=warning,
            warning_foreground=warning_foreground,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             accent: Optional[str] = None,
             accent_foreground: Optional[str] = None,
             danger: Optional[str] = None,
             danger_foreground: Optional[str] = None,
             dimension: Optional[str] = None,
             dimension_foreground: Optional[str] = None,
             measure: Optional[str] = None,
             measure_foreground: Optional[str] = None,
             primary_background: Optional[str] = None,
             primary_foreground: Optional[str] = None,
             secondary_background: Optional[str] = None,
             secondary_foreground: Optional[str] = None,
             success: Optional[str] = None,
             success_foreground: Optional[str] = None,
             warning: Optional[str] = None,
             warning_foreground: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if accent_foreground is None and 'accentForeground' in kwargs:
            accent_foreground = kwargs['accentForeground']
        if danger_foreground is None and 'dangerForeground' in kwargs:
            danger_foreground = kwargs['dangerForeground']
        if dimension_foreground is None and 'dimensionForeground' in kwargs:
            dimension_foreground = kwargs['dimensionForeground']
        if measure_foreground is None and 'measureForeground' in kwargs:
            measure_foreground = kwargs['measureForeground']
        if primary_background is None and 'primaryBackground' in kwargs:
            primary_background = kwargs['primaryBackground']
        if primary_foreground is None and 'primaryForeground' in kwargs:
            primary_foreground = kwargs['primaryForeground']
        if secondary_background is None and 'secondaryBackground' in kwargs:
            secondary_background = kwargs['secondaryBackground']
        if secondary_foreground is None and 'secondaryForeground' in kwargs:
            secondary_foreground = kwargs['secondaryForeground']
        if success_foreground is None and 'successForeground' in kwargs:
            success_foreground = kwargs['successForeground']
        if warning_foreground is None and 'warningForeground' in kwargs:
            warning_foreground = kwargs['warningForeground']

        if accent is not None:
            _setter("accent", accent)
        if accent_foreground is not None:
            _setter("accent_foreground", accent_foreground)
        if danger is not None:
            _setter("danger", danger)
        if danger_foreground is not None:
            _setter("danger_foreground", danger_foreground)
        if dimension is not None:
            _setter("dimension", dimension)
        if dimension_foreground is not None:
            _setter("dimension_foreground", dimension_foreground)
        if measure is not None:
            _setter("measure", measure)
        if measure_foreground is not None:
            _setter("measure_foreground", measure_foreground)
        if primary_background is not None:
            _setter("primary_background", primary_background)
        if primary_foreground is not None:
            _setter("primary_foreground", primary_foreground)
        if secondary_background is not None:
            _setter("secondary_background", secondary_background)
        if secondary_foreground is not None:
            _setter("secondary_foreground", secondary_foreground)
        if success is not None:
            _setter("success", success)
        if success_foreground is not None:
            _setter("success_foreground", success_foreground)
        if warning is not None:
            _setter("warning", warning)
        if warning_foreground is not None:
            _setter("warning_foreground", warning_foreground)

    @property
    @pulumi.getter
    def accent(self) -> Optional[str]:
        """
        Color (hexadecimal) that applies to selected states and buttons.
        """
        return pulumi.get(self, "accent")

    @property
    @pulumi.getter(name="accentForeground")
    def accent_foreground(self) -> Optional[str]:
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the accent color.
        """
        return pulumi.get(self, "accent_foreground")

    @property
    @pulumi.getter
    def danger(self) -> Optional[str]:
        """
        Color (hexadecimal) that applies to error messages.
        """
        return pulumi.get(self, "danger")

    @property
    @pulumi.getter(name="dangerForeground")
    def danger_foreground(self) -> Optional[str]:
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the error color.
        """
        return pulumi.get(self, "danger_foreground")

    @property
    @pulumi.getter
    def dimension(self) -> Optional[str]:
        """
        Color (hexadecimal) that applies to the names of fields that are identified as dimensions.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter(name="dimensionForeground")
    def dimension_foreground(self) -> Optional[str]:
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the dimension color.
        """
        return pulumi.get(self, "dimension_foreground")

    @property
    @pulumi.getter
    def measure(self) -> Optional[str]:
        """
        Color (hexadecimal) that applies to the names of fields that are identified as measures.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="measureForeground")
    def measure_foreground(self) -> Optional[str]:
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the measure color.
        """
        return pulumi.get(self, "measure_foreground")

    @property
    @pulumi.getter(name="primaryBackground")
    def primary_background(self) -> Optional[str]:
        """
        Color (hexadecimal) that applies to visuals and other high emphasis UI.
        """
        return pulumi.get(self, "primary_background")

    @property
    @pulumi.getter(name="primaryForeground")
    def primary_foreground(self) -> Optional[str]:
        """
        Color (hexadecimal) of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.
        """
        return pulumi.get(self, "primary_foreground")

    @property
    @pulumi.getter(name="secondaryBackground")
    def secondary_background(self) -> Optional[str]:
        """
        Color (hexadecimal) that applies to the sheet background and sheet controls.
        """
        return pulumi.get(self, "secondary_background")

    @property
    @pulumi.getter(name="secondaryForeground")
    def secondary_foreground(self) -> Optional[str]:
        """
        Color (hexadecimal) that applies to any sheet title, sheet control text, or UI that appears over the secondary background.
        """
        return pulumi.get(self, "secondary_foreground")

    @property
    @pulumi.getter
    def success(self) -> Optional[str]:
        """
        Color (hexadecimal) that applies to success messages, for example the check mark for a successful download.
        """
        return pulumi.get(self, "success")

    @property
    @pulumi.getter(name="successForeground")
    def success_foreground(self) -> Optional[str]:
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the success color.
        """
        return pulumi.get(self, "success_foreground")

    @property
    @pulumi.getter
    def warning(self) -> Optional[str]:
        """
        Color (hexadecimal) that applies to warning and informational messages.
        """
        return pulumi.get(self, "warning")

    @property
    @pulumi.getter(name="warningForeground")
    def warning_foreground(self) -> Optional[str]:
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the warning color.
        """
        return pulumi.get(self, "warning_foreground")


@pulumi.output_type
class ThemePermission(dict):
    def __init__(__self__, *,
                 actions: Sequence[str],
                 principal: str):
        """
        :param Sequence[str] actions: List of IAM actions to grant or revoke permissions on.
        :param str principal: ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        ThemePermission._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            principal=principal,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[Sequence[str]] = None,
             principal: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions is None:
            raise TypeError("Missing 'actions' argument")
        if principal is None:
            raise TypeError("Missing 'principal' argument")

        _setter("actions", actions)
        _setter("principal", principal)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        List of IAM actions to grant or revoke permissions on.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def principal(self) -> str:
        """
        ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        return pulumi.get(self, "principal")


@pulumi.output_type
class VpcConnectionTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[str] = None,
                 delete: Optional[str] = None,
                 update: Optional[str] = None):
        VpcConnectionTimeouts._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create=create,
            delete=delete,
            update=update,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create: Optional[str] = None,
             delete: Optional[str] = None,
             update: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if create is not None:
            _setter("create", create)
        if delete is not None:
            _setter("delete", delete)
        if update is not None:
            _setter("update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[str]:
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[str]:
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> Optional[str]:
        return pulumi.get(self, "update")


@pulumi.output_type
class GetDataSetColumnGroupResult(dict):
    def __init__(__self__, *,
                 geo_spatial_column_groups: Sequence['outputs.GetDataSetColumnGroupGeoSpatialColumnGroupResult']):
        GetDataSetColumnGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            geo_spatial_column_groups=geo_spatial_column_groups,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             geo_spatial_column_groups: Optional[Sequence['outputs.GetDataSetColumnGroupGeoSpatialColumnGroupResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if geo_spatial_column_groups is None and 'geoSpatialColumnGroups' in kwargs:
            geo_spatial_column_groups = kwargs['geoSpatialColumnGroups']
        if geo_spatial_column_groups is None:
            raise TypeError("Missing 'geo_spatial_column_groups' argument")

        _setter("geo_spatial_column_groups", geo_spatial_column_groups)

    @property
    @pulumi.getter(name="geoSpatialColumnGroups")
    def geo_spatial_column_groups(self) -> Sequence['outputs.GetDataSetColumnGroupGeoSpatialColumnGroupResult']:
        return pulumi.get(self, "geo_spatial_column_groups")


@pulumi.output_type
class GetDataSetColumnGroupGeoSpatialColumnGroupResult(dict):
    def __init__(__self__, *,
                 columns: Sequence[str],
                 country_code: str,
                 name: str):
        GetDataSetColumnGroupGeoSpatialColumnGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            country_code=country_code,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Optional[Sequence[str]] = None,
             country_code: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if columns is None:
            raise TypeError("Missing 'columns' argument")
        if country_code is None and 'countryCode' in kwargs:
            country_code = kwargs['countryCode']
        if country_code is None:
            raise TypeError("Missing 'country_code' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("columns", columns)
        _setter("country_code", country_code)
        _setter("name", name)

    @property
    @pulumi.getter
    def columns(self) -> Sequence[str]:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> str:
        return pulumi.get(self, "country_code")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDataSetColumnLevelPermissionRuleResult(dict):
    def __init__(__self__, *,
                 column_names: Sequence[str],
                 principals: Sequence[str]):
        GetDataSetColumnLevelPermissionRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_names=column_names,
            principals=principals,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_names: Optional[Sequence[str]] = None,
             principals: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_names is None and 'columnNames' in kwargs:
            column_names = kwargs['columnNames']
        if column_names is None:
            raise TypeError("Missing 'column_names' argument")
        if principals is None:
            raise TypeError("Missing 'principals' argument")

        _setter("column_names", column_names)
        _setter("principals", principals)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Sequence[str]:
        return pulumi.get(self, "column_names")

    @property
    @pulumi.getter
    def principals(self) -> Sequence[str]:
        return pulumi.get(self, "principals")


@pulumi.output_type
class GetDataSetDataSetUsageConfigurationResult(dict):
    def __init__(__self__, *,
                 disable_use_as_direct_query_source: bool,
                 disable_use_as_imported_source: bool):
        GetDataSetDataSetUsageConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disable_use_as_direct_query_source=disable_use_as_direct_query_source,
            disable_use_as_imported_source=disable_use_as_imported_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disable_use_as_direct_query_source: Optional[bool] = None,
             disable_use_as_imported_source: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if disable_use_as_direct_query_source is None and 'disableUseAsDirectQuerySource' in kwargs:
            disable_use_as_direct_query_source = kwargs['disableUseAsDirectQuerySource']
        if disable_use_as_direct_query_source is None:
            raise TypeError("Missing 'disable_use_as_direct_query_source' argument")
        if disable_use_as_imported_source is None and 'disableUseAsImportedSource' in kwargs:
            disable_use_as_imported_source = kwargs['disableUseAsImportedSource']
        if disable_use_as_imported_source is None:
            raise TypeError("Missing 'disable_use_as_imported_source' argument")

        _setter("disable_use_as_direct_query_source", disable_use_as_direct_query_source)
        _setter("disable_use_as_imported_source", disable_use_as_imported_source)

    @property
    @pulumi.getter(name="disableUseAsDirectQuerySource")
    def disable_use_as_direct_query_source(self) -> bool:
        return pulumi.get(self, "disable_use_as_direct_query_source")

    @property
    @pulumi.getter(name="disableUseAsImportedSource")
    def disable_use_as_imported_source(self) -> bool:
        return pulumi.get(self, "disable_use_as_imported_source")


@pulumi.output_type
class GetDataSetFieldFolderResult(dict):
    def __init__(__self__, *,
                 columns: Sequence[str],
                 description: str,
                 field_folders_id: str):
        GetDataSetFieldFolderResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            description=description,
            field_folders_id=field_folders_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Optional[Sequence[str]] = None,
             description: Optional[str] = None,
             field_folders_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if columns is None:
            raise TypeError("Missing 'columns' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if field_folders_id is None and 'fieldFoldersId' in kwargs:
            field_folders_id = kwargs['fieldFoldersId']
        if field_folders_id is None:
            raise TypeError("Missing 'field_folders_id' argument")

        _setter("columns", columns)
        _setter("description", description)
        _setter("field_folders_id", field_folders_id)

    @property
    @pulumi.getter
    def columns(self) -> Sequence[str]:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="fieldFoldersId")
    def field_folders_id(self) -> str:
        return pulumi.get(self, "field_folders_id")


@pulumi.output_type
class GetDataSetLogicalTableMapResult(dict):
    def __init__(__self__, *,
                 alias: str,
                 data_transforms: Sequence['outputs.GetDataSetLogicalTableMapDataTransformResult'],
                 logical_table_map_id: str,
                 sources: Sequence['outputs.GetDataSetLogicalTableMapSourceResult']):
        GetDataSetLogicalTableMapResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alias=alias,
            data_transforms=data_transforms,
            logical_table_map_id=logical_table_map_id,
            sources=sources,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alias: Optional[str] = None,
             data_transforms: Optional[Sequence['outputs.GetDataSetLogicalTableMapDataTransformResult']] = None,
             logical_table_map_id: Optional[str] = None,
             sources: Optional[Sequence['outputs.GetDataSetLogicalTableMapSourceResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alias is None:
            raise TypeError("Missing 'alias' argument")
        if data_transforms is None and 'dataTransforms' in kwargs:
            data_transforms = kwargs['dataTransforms']
        if data_transforms is None:
            raise TypeError("Missing 'data_transforms' argument")
        if logical_table_map_id is None and 'logicalTableMapId' in kwargs:
            logical_table_map_id = kwargs['logicalTableMapId']
        if logical_table_map_id is None:
            raise TypeError("Missing 'logical_table_map_id' argument")
        if sources is None:
            raise TypeError("Missing 'sources' argument")

        _setter("alias", alias)
        _setter("data_transforms", data_transforms)
        _setter("logical_table_map_id", logical_table_map_id)
        _setter("sources", sources)

    @property
    @pulumi.getter
    def alias(self) -> str:
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="dataTransforms")
    def data_transforms(self) -> Sequence['outputs.GetDataSetLogicalTableMapDataTransformResult']:
        return pulumi.get(self, "data_transforms")

    @property
    @pulumi.getter(name="logicalTableMapId")
    def logical_table_map_id(self) -> str:
        return pulumi.get(self, "logical_table_map_id")

    @property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.GetDataSetLogicalTableMapSourceResult']:
        return pulumi.get(self, "sources")


@pulumi.output_type
class GetDataSetLogicalTableMapDataTransformResult(dict):
    def __init__(__self__, *,
                 cast_column_type_operations: Sequence['outputs.GetDataSetLogicalTableMapDataTransformCastColumnTypeOperationResult'],
                 create_columns_operations: Sequence['outputs.GetDataSetLogicalTableMapDataTransformCreateColumnsOperationResult'],
                 filter_operations: Sequence['outputs.GetDataSetLogicalTableMapDataTransformFilterOperationResult'],
                 project_operations: Sequence['outputs.GetDataSetLogicalTableMapDataTransformProjectOperationResult'],
                 rename_column_operations: Sequence['outputs.GetDataSetLogicalTableMapDataTransformRenameColumnOperationResult'],
                 tag_column_operations: Sequence['outputs.GetDataSetLogicalTableMapDataTransformTagColumnOperationResult'],
                 untag_column_operations: Sequence['outputs.GetDataSetLogicalTableMapDataTransformUntagColumnOperationResult']):
        GetDataSetLogicalTableMapDataTransformResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cast_column_type_operations=cast_column_type_operations,
            create_columns_operations=create_columns_operations,
            filter_operations=filter_operations,
            project_operations=project_operations,
            rename_column_operations=rename_column_operations,
            tag_column_operations=tag_column_operations,
            untag_column_operations=untag_column_operations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cast_column_type_operations: Optional[Sequence['outputs.GetDataSetLogicalTableMapDataTransformCastColumnTypeOperationResult']] = None,
             create_columns_operations: Optional[Sequence['outputs.GetDataSetLogicalTableMapDataTransformCreateColumnsOperationResult']] = None,
             filter_operations: Optional[Sequence['outputs.GetDataSetLogicalTableMapDataTransformFilterOperationResult']] = None,
             project_operations: Optional[Sequence['outputs.GetDataSetLogicalTableMapDataTransformProjectOperationResult']] = None,
             rename_column_operations: Optional[Sequence['outputs.GetDataSetLogicalTableMapDataTransformRenameColumnOperationResult']] = None,
             tag_column_operations: Optional[Sequence['outputs.GetDataSetLogicalTableMapDataTransformTagColumnOperationResult']] = None,
             untag_column_operations: Optional[Sequence['outputs.GetDataSetLogicalTableMapDataTransformUntagColumnOperationResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cast_column_type_operations is None and 'castColumnTypeOperations' in kwargs:
            cast_column_type_operations = kwargs['castColumnTypeOperations']
        if cast_column_type_operations is None:
            raise TypeError("Missing 'cast_column_type_operations' argument")
        if create_columns_operations is None and 'createColumnsOperations' in kwargs:
            create_columns_operations = kwargs['createColumnsOperations']
        if create_columns_operations is None:
            raise TypeError("Missing 'create_columns_operations' argument")
        if filter_operations is None and 'filterOperations' in kwargs:
            filter_operations = kwargs['filterOperations']
        if filter_operations is None:
            raise TypeError("Missing 'filter_operations' argument")
        if project_operations is None and 'projectOperations' in kwargs:
            project_operations = kwargs['projectOperations']
        if project_operations is None:
            raise TypeError("Missing 'project_operations' argument")
        if rename_column_operations is None and 'renameColumnOperations' in kwargs:
            rename_column_operations = kwargs['renameColumnOperations']
        if rename_column_operations is None:
            raise TypeError("Missing 'rename_column_operations' argument")
        if tag_column_operations is None and 'tagColumnOperations' in kwargs:
            tag_column_operations = kwargs['tagColumnOperations']
        if tag_column_operations is None:
            raise TypeError("Missing 'tag_column_operations' argument")
        if untag_column_operations is None and 'untagColumnOperations' in kwargs:
            untag_column_operations = kwargs['untagColumnOperations']
        if untag_column_operations is None:
            raise TypeError("Missing 'untag_column_operations' argument")

        _setter("cast_column_type_operations", cast_column_type_operations)
        _setter("create_columns_operations", create_columns_operations)
        _setter("filter_operations", filter_operations)
        _setter("project_operations", project_operations)
        _setter("rename_column_operations", rename_column_operations)
        _setter("tag_column_operations", tag_column_operations)
        _setter("untag_column_operations", untag_column_operations)

    @property
    @pulumi.getter(name="castColumnTypeOperations")
    def cast_column_type_operations(self) -> Sequence['outputs.GetDataSetLogicalTableMapDataTransformCastColumnTypeOperationResult']:
        return pulumi.get(self, "cast_column_type_operations")

    @property
    @pulumi.getter(name="createColumnsOperations")
    def create_columns_operations(self) -> Sequence['outputs.GetDataSetLogicalTableMapDataTransformCreateColumnsOperationResult']:
        return pulumi.get(self, "create_columns_operations")

    @property
    @pulumi.getter(name="filterOperations")
    def filter_operations(self) -> Sequence['outputs.GetDataSetLogicalTableMapDataTransformFilterOperationResult']:
        return pulumi.get(self, "filter_operations")

    @property
    @pulumi.getter(name="projectOperations")
    def project_operations(self) -> Sequence['outputs.GetDataSetLogicalTableMapDataTransformProjectOperationResult']:
        return pulumi.get(self, "project_operations")

    @property
    @pulumi.getter(name="renameColumnOperations")
    def rename_column_operations(self) -> Sequence['outputs.GetDataSetLogicalTableMapDataTransformRenameColumnOperationResult']:
        return pulumi.get(self, "rename_column_operations")

    @property
    @pulumi.getter(name="tagColumnOperations")
    def tag_column_operations(self) -> Sequence['outputs.GetDataSetLogicalTableMapDataTransformTagColumnOperationResult']:
        return pulumi.get(self, "tag_column_operations")

    @property
    @pulumi.getter(name="untagColumnOperations")
    def untag_column_operations(self) -> Sequence['outputs.GetDataSetLogicalTableMapDataTransformUntagColumnOperationResult']:
        return pulumi.get(self, "untag_column_operations")


@pulumi.output_type
class GetDataSetLogicalTableMapDataTransformCastColumnTypeOperationResult(dict):
    def __init__(__self__, *,
                 column_name: str,
                 format: str,
                 new_column_type: str):
        GetDataSetLogicalTableMapDataTransformCastColumnTypeOperationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            format=format,
            new_column_type=new_column_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             format: Optional[str] = None,
             new_column_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if format is None:
            raise TypeError("Missing 'format' argument")
        if new_column_type is None and 'newColumnType' in kwargs:
            new_column_type = kwargs['newColumnType']
        if new_column_type is None:
            raise TypeError("Missing 'new_column_type' argument")

        _setter("column_name", column_name)
        _setter("format", format)
        _setter("new_column_type", new_column_type)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="newColumnType")
    def new_column_type(self) -> str:
        return pulumi.get(self, "new_column_type")


@pulumi.output_type
class GetDataSetLogicalTableMapDataTransformCreateColumnsOperationResult(dict):
    def __init__(__self__, *,
                 columns: Sequence['outputs.GetDataSetLogicalTableMapDataTransformCreateColumnsOperationColumnResult']):
        GetDataSetLogicalTableMapDataTransformCreateColumnsOperationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Optional[Sequence['outputs.GetDataSetLogicalTableMapDataTransformCreateColumnsOperationColumnResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if columns is None:
            raise TypeError("Missing 'columns' argument")

        _setter("columns", columns)

    @property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.GetDataSetLogicalTableMapDataTransformCreateColumnsOperationColumnResult']:
        return pulumi.get(self, "columns")


@pulumi.output_type
class GetDataSetLogicalTableMapDataTransformCreateColumnsOperationColumnResult(dict):
    def __init__(__self__, *,
                 column_id: str,
                 column_name: str,
                 expression: str):
        GetDataSetLogicalTableMapDataTransformCreateColumnsOperationColumnResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_id=column_id,
            column_name=column_name,
            expression=expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_id: Optional[str] = None,
             column_name: Optional[str] = None,
             expression: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_id is None and 'columnId' in kwargs:
            column_id = kwargs['columnId']
        if column_id is None:
            raise TypeError("Missing 'column_id' argument")
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if expression is None:
            raise TypeError("Missing 'expression' argument")

        _setter("column_id", column_id)
        _setter("column_name", column_name)
        _setter("expression", expression)

    @property
    @pulumi.getter(name="columnId")
    def column_id(self) -> str:
        return pulumi.get(self, "column_id")

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")


@pulumi.output_type
class GetDataSetLogicalTableMapDataTransformFilterOperationResult(dict):
    def __init__(__self__, *,
                 condition_expression: str):
        GetDataSetLogicalTableMapDataTransformFilterOperationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition_expression=condition_expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition_expression: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if condition_expression is None and 'conditionExpression' in kwargs:
            condition_expression = kwargs['conditionExpression']
        if condition_expression is None:
            raise TypeError("Missing 'condition_expression' argument")

        _setter("condition_expression", condition_expression)

    @property
    @pulumi.getter(name="conditionExpression")
    def condition_expression(self) -> str:
        return pulumi.get(self, "condition_expression")


@pulumi.output_type
class GetDataSetLogicalTableMapDataTransformProjectOperationResult(dict):
    def __init__(__self__, *,
                 projected_columns: Sequence[str]):
        GetDataSetLogicalTableMapDataTransformProjectOperationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            projected_columns=projected_columns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             projected_columns: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if projected_columns is None and 'projectedColumns' in kwargs:
            projected_columns = kwargs['projectedColumns']
        if projected_columns is None:
            raise TypeError("Missing 'projected_columns' argument")

        _setter("projected_columns", projected_columns)

    @property
    @pulumi.getter(name="projectedColumns")
    def projected_columns(self) -> Sequence[str]:
        return pulumi.get(self, "projected_columns")


@pulumi.output_type
class GetDataSetLogicalTableMapDataTransformRenameColumnOperationResult(dict):
    def __init__(__self__, *,
                 column_name: str,
                 new_column_name: str):
        GetDataSetLogicalTableMapDataTransformRenameColumnOperationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            new_column_name=new_column_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             new_column_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if new_column_name is None and 'newColumnName' in kwargs:
            new_column_name = kwargs['newColumnName']
        if new_column_name is None:
            raise TypeError("Missing 'new_column_name' argument")

        _setter("column_name", column_name)
        _setter("new_column_name", new_column_name)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="newColumnName")
    def new_column_name(self) -> str:
        return pulumi.get(self, "new_column_name")


@pulumi.output_type
class GetDataSetLogicalTableMapDataTransformTagColumnOperationResult(dict):
    def __init__(__self__, *,
                 column_name: str,
                 tags: Sequence['outputs.GetDataSetLogicalTableMapDataTransformTagColumnOperationTagResult']):
        GetDataSetLogicalTableMapDataTransformTagColumnOperationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             tags: Optional[Sequence['outputs.GetDataSetLogicalTableMapDataTransformTagColumnOperationTagResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if tags is None:
            raise TypeError("Missing 'tags' argument")

        _setter("column_name", column_name)
        _setter("tags", tags)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetDataSetLogicalTableMapDataTransformTagColumnOperationTagResult']:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetDataSetLogicalTableMapDataTransformTagColumnOperationTagResult(dict):
    def __init__(__self__, *,
                 column_descriptions: Sequence['outputs.GetDataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionResult'],
                 column_geographic_role: str):
        GetDataSetLogicalTableMapDataTransformTagColumnOperationTagResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_descriptions=column_descriptions,
            column_geographic_role=column_geographic_role,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_descriptions: Optional[Sequence['outputs.GetDataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionResult']] = None,
             column_geographic_role: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_descriptions is None and 'columnDescriptions' in kwargs:
            column_descriptions = kwargs['columnDescriptions']
        if column_descriptions is None:
            raise TypeError("Missing 'column_descriptions' argument")
        if column_geographic_role is None and 'columnGeographicRole' in kwargs:
            column_geographic_role = kwargs['columnGeographicRole']
        if column_geographic_role is None:
            raise TypeError("Missing 'column_geographic_role' argument")

        _setter("column_descriptions", column_descriptions)
        _setter("column_geographic_role", column_geographic_role)

    @property
    @pulumi.getter(name="columnDescriptions")
    def column_descriptions(self) -> Sequence['outputs.GetDataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionResult']:
        return pulumi.get(self, "column_descriptions")

    @property
    @pulumi.getter(name="columnGeographicRole")
    def column_geographic_role(self) -> str:
        return pulumi.get(self, "column_geographic_role")


@pulumi.output_type
class GetDataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionResult(dict):
    def __init__(__self__, *,
                 text: str):
        GetDataSetLogicalTableMapDataTransformTagColumnOperationTagColumnDescriptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text=text,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if text is None:
            raise TypeError("Missing 'text' argument")

        _setter("text", text)

    @property
    @pulumi.getter
    def text(self) -> str:
        return pulumi.get(self, "text")


@pulumi.output_type
class GetDataSetLogicalTableMapDataTransformUntagColumnOperationResult(dict):
    def __init__(__self__, *,
                 column_name: str,
                 tag_names: Sequence[str]):
        GetDataSetLogicalTableMapDataTransformUntagColumnOperationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            tag_names=tag_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             tag_names: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if tag_names is None and 'tagNames' in kwargs:
            tag_names = kwargs['tagNames']
        if tag_names is None:
            raise TypeError("Missing 'tag_names' argument")

        _setter("column_name", column_name)
        _setter("tag_names", tag_names)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="tagNames")
    def tag_names(self) -> Sequence[str]:
        return pulumi.get(self, "tag_names")


@pulumi.output_type
class GetDataSetLogicalTableMapSourceResult(dict):
    def __init__(__self__, *,
                 data_set_arn: str,
                 join_instructions: Sequence['outputs.GetDataSetLogicalTableMapSourceJoinInstructionResult'],
                 physical_table_id: str):
        GetDataSetLogicalTableMapSourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_set_arn=data_set_arn,
            join_instructions=join_instructions,
            physical_table_id=physical_table_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_set_arn: Optional[str] = None,
             join_instructions: Optional[Sequence['outputs.GetDataSetLogicalTableMapSourceJoinInstructionResult']] = None,
             physical_table_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_set_arn is None and 'dataSetArn' in kwargs:
            data_set_arn = kwargs['dataSetArn']
        if data_set_arn is None:
            raise TypeError("Missing 'data_set_arn' argument")
        if join_instructions is None and 'joinInstructions' in kwargs:
            join_instructions = kwargs['joinInstructions']
        if join_instructions is None:
            raise TypeError("Missing 'join_instructions' argument")
        if physical_table_id is None and 'physicalTableId' in kwargs:
            physical_table_id = kwargs['physicalTableId']
        if physical_table_id is None:
            raise TypeError("Missing 'physical_table_id' argument")

        _setter("data_set_arn", data_set_arn)
        _setter("join_instructions", join_instructions)
        _setter("physical_table_id", physical_table_id)

    @property
    @pulumi.getter(name="dataSetArn")
    def data_set_arn(self) -> str:
        return pulumi.get(self, "data_set_arn")

    @property
    @pulumi.getter(name="joinInstructions")
    def join_instructions(self) -> Sequence['outputs.GetDataSetLogicalTableMapSourceJoinInstructionResult']:
        return pulumi.get(self, "join_instructions")

    @property
    @pulumi.getter(name="physicalTableId")
    def physical_table_id(self) -> str:
        return pulumi.get(self, "physical_table_id")


@pulumi.output_type
class GetDataSetLogicalTableMapSourceJoinInstructionResult(dict):
    def __init__(__self__, *,
                 left_join_key_properties: Sequence['outputs.GetDataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertyResult'],
                 left_operand: str,
                 on_clause: str,
                 right_join_key_properties: Sequence['outputs.GetDataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertyResult'],
                 right_operand: str,
                 type: str):
        GetDataSetLogicalTableMapSourceJoinInstructionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            left_join_key_properties=left_join_key_properties,
            left_operand=left_operand,
            on_clause=on_clause,
            right_join_key_properties=right_join_key_properties,
            right_operand=right_operand,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             left_join_key_properties: Optional[Sequence['outputs.GetDataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertyResult']] = None,
             left_operand: Optional[str] = None,
             on_clause: Optional[str] = None,
             right_join_key_properties: Optional[Sequence['outputs.GetDataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertyResult']] = None,
             right_operand: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if left_join_key_properties is None and 'leftJoinKeyProperties' in kwargs:
            left_join_key_properties = kwargs['leftJoinKeyProperties']
        if left_join_key_properties is None:
            raise TypeError("Missing 'left_join_key_properties' argument")
        if left_operand is None and 'leftOperand' in kwargs:
            left_operand = kwargs['leftOperand']
        if left_operand is None:
            raise TypeError("Missing 'left_operand' argument")
        if on_clause is None and 'onClause' in kwargs:
            on_clause = kwargs['onClause']
        if on_clause is None:
            raise TypeError("Missing 'on_clause' argument")
        if right_join_key_properties is None and 'rightJoinKeyProperties' in kwargs:
            right_join_key_properties = kwargs['rightJoinKeyProperties']
        if right_join_key_properties is None:
            raise TypeError("Missing 'right_join_key_properties' argument")
        if right_operand is None and 'rightOperand' in kwargs:
            right_operand = kwargs['rightOperand']
        if right_operand is None:
            raise TypeError("Missing 'right_operand' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("left_join_key_properties", left_join_key_properties)
        _setter("left_operand", left_operand)
        _setter("on_clause", on_clause)
        _setter("right_join_key_properties", right_join_key_properties)
        _setter("right_operand", right_operand)
        _setter("type", type)

    @property
    @pulumi.getter(name="leftJoinKeyProperties")
    def left_join_key_properties(self) -> Sequence['outputs.GetDataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertyResult']:
        return pulumi.get(self, "left_join_key_properties")

    @property
    @pulumi.getter(name="leftOperand")
    def left_operand(self) -> str:
        return pulumi.get(self, "left_operand")

    @property
    @pulumi.getter(name="onClause")
    def on_clause(self) -> str:
        return pulumi.get(self, "on_clause")

    @property
    @pulumi.getter(name="rightJoinKeyProperties")
    def right_join_key_properties(self) -> Sequence['outputs.GetDataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertyResult']:
        return pulumi.get(self, "right_join_key_properties")

    @property
    @pulumi.getter(name="rightOperand")
    def right_operand(self) -> str:
        return pulumi.get(self, "right_operand")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertyResult(dict):
    def __init__(__self__, *,
                 unique_key: bool):
        GetDataSetLogicalTableMapSourceJoinInstructionLeftJoinKeyPropertyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unique_key=unique_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unique_key: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unique_key is None and 'uniqueKey' in kwargs:
            unique_key = kwargs['uniqueKey']
        if unique_key is None:
            raise TypeError("Missing 'unique_key' argument")

        _setter("unique_key", unique_key)

    @property
    @pulumi.getter(name="uniqueKey")
    def unique_key(self) -> bool:
        return pulumi.get(self, "unique_key")


@pulumi.output_type
class GetDataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertyResult(dict):
    def __init__(__self__, *,
                 unique_key: bool):
        GetDataSetLogicalTableMapSourceJoinInstructionRightJoinKeyPropertyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unique_key=unique_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unique_key: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if unique_key is None and 'uniqueKey' in kwargs:
            unique_key = kwargs['uniqueKey']
        if unique_key is None:
            raise TypeError("Missing 'unique_key' argument")

        _setter("unique_key", unique_key)

    @property
    @pulumi.getter(name="uniqueKey")
    def unique_key(self) -> bool:
        return pulumi.get(self, "unique_key")


@pulumi.output_type
class GetDataSetPermissionResult(dict):
    def __init__(__self__, *,
                 actions: Sequence[str],
                 principal: str):
        GetDataSetPermissionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            principal=principal,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[Sequence[str]] = None,
             principal: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions is None:
            raise TypeError("Missing 'actions' argument")
        if principal is None:
            raise TypeError("Missing 'principal' argument")

        _setter("actions", actions)
        _setter("principal", principal)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def principal(self) -> str:
        return pulumi.get(self, "principal")


@pulumi.output_type
class GetDataSetPhysicalTableMapResult(dict):
    def __init__(__self__, *,
                 custom_sqls: Sequence['outputs.GetDataSetPhysicalTableMapCustomSqlResult'],
                 physical_table_map_id: str,
                 relational_tables: Sequence['outputs.GetDataSetPhysicalTableMapRelationalTableResult'],
                 s3_sources: Sequence['outputs.GetDataSetPhysicalTableMapS3SourceResult']):
        GetDataSetPhysicalTableMapResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_sqls=custom_sqls,
            physical_table_map_id=physical_table_map_id,
            relational_tables=relational_tables,
            s3_sources=s3_sources,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_sqls: Optional[Sequence['outputs.GetDataSetPhysicalTableMapCustomSqlResult']] = None,
             physical_table_map_id: Optional[str] = None,
             relational_tables: Optional[Sequence['outputs.GetDataSetPhysicalTableMapRelationalTableResult']] = None,
             s3_sources: Optional[Sequence['outputs.GetDataSetPhysicalTableMapS3SourceResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_sqls is None and 'customSqls' in kwargs:
            custom_sqls = kwargs['customSqls']
        if custom_sqls is None:
            raise TypeError("Missing 'custom_sqls' argument")
        if physical_table_map_id is None and 'physicalTableMapId' in kwargs:
            physical_table_map_id = kwargs['physicalTableMapId']
        if physical_table_map_id is None:
            raise TypeError("Missing 'physical_table_map_id' argument")
        if relational_tables is None and 'relationalTables' in kwargs:
            relational_tables = kwargs['relationalTables']
        if relational_tables is None:
            raise TypeError("Missing 'relational_tables' argument")
        if s3_sources is None and 's3Sources' in kwargs:
            s3_sources = kwargs['s3Sources']
        if s3_sources is None:
            raise TypeError("Missing 's3_sources' argument")

        _setter("custom_sqls", custom_sqls)
        _setter("physical_table_map_id", physical_table_map_id)
        _setter("relational_tables", relational_tables)
        _setter("s3_sources", s3_sources)

    @property
    @pulumi.getter(name="customSqls")
    def custom_sqls(self) -> Sequence['outputs.GetDataSetPhysicalTableMapCustomSqlResult']:
        return pulumi.get(self, "custom_sqls")

    @property
    @pulumi.getter(name="physicalTableMapId")
    def physical_table_map_id(self) -> str:
        return pulumi.get(self, "physical_table_map_id")

    @property
    @pulumi.getter(name="relationalTables")
    def relational_tables(self) -> Sequence['outputs.GetDataSetPhysicalTableMapRelationalTableResult']:
        return pulumi.get(self, "relational_tables")

    @property
    @pulumi.getter(name="s3Sources")
    def s3_sources(self) -> Sequence['outputs.GetDataSetPhysicalTableMapS3SourceResult']:
        return pulumi.get(self, "s3_sources")


@pulumi.output_type
class GetDataSetPhysicalTableMapCustomSqlResult(dict):
    def __init__(__self__, *,
                 columns: Sequence['outputs.GetDataSetPhysicalTableMapCustomSqlColumnResult'],
                 data_source_arn: str,
                 name: str,
                 sql_query: str):
        GetDataSetPhysicalTableMapCustomSqlResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            data_source_arn=data_source_arn,
            name=name,
            sql_query=sql_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Optional[Sequence['outputs.GetDataSetPhysicalTableMapCustomSqlColumnResult']] = None,
             data_source_arn: Optional[str] = None,
             name: Optional[str] = None,
             sql_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if columns is None:
            raise TypeError("Missing 'columns' argument")
        if data_source_arn is None and 'dataSourceArn' in kwargs:
            data_source_arn = kwargs['dataSourceArn']
        if data_source_arn is None:
            raise TypeError("Missing 'data_source_arn' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if sql_query is None and 'sqlQuery' in kwargs:
            sql_query = kwargs['sqlQuery']
        if sql_query is None:
            raise TypeError("Missing 'sql_query' argument")

        _setter("columns", columns)
        _setter("data_source_arn", data_source_arn)
        _setter("name", name)
        _setter("sql_query", sql_query)

    @property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.GetDataSetPhysicalTableMapCustomSqlColumnResult']:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter(name="dataSourceArn")
    def data_source_arn(self) -> str:
        return pulumi.get(self, "data_source_arn")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sqlQuery")
    def sql_query(self) -> str:
        return pulumi.get(self, "sql_query")


@pulumi.output_type
class GetDataSetPhysicalTableMapCustomSqlColumnResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        GetDataSetPhysicalTableMapCustomSqlColumnResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("name", name)
        _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDataSetPhysicalTableMapRelationalTableResult(dict):
    def __init__(__self__, *,
                 catalog: str,
                 data_source_arn: str,
                 input_columns: Sequence['outputs.GetDataSetPhysicalTableMapRelationalTableInputColumnResult'],
                 name: str,
                 schema: str):
        GetDataSetPhysicalTableMapRelationalTableResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            catalog=catalog,
            data_source_arn=data_source_arn,
            input_columns=input_columns,
            name=name,
            schema=schema,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             catalog: Optional[str] = None,
             data_source_arn: Optional[str] = None,
             input_columns: Optional[Sequence['outputs.GetDataSetPhysicalTableMapRelationalTableInputColumnResult']] = None,
             name: Optional[str] = None,
             schema: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if catalog is None:
            raise TypeError("Missing 'catalog' argument")
        if data_source_arn is None and 'dataSourceArn' in kwargs:
            data_source_arn = kwargs['dataSourceArn']
        if data_source_arn is None:
            raise TypeError("Missing 'data_source_arn' argument")
        if input_columns is None and 'inputColumns' in kwargs:
            input_columns = kwargs['inputColumns']
        if input_columns is None:
            raise TypeError("Missing 'input_columns' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if schema is None:
            raise TypeError("Missing 'schema' argument")

        _setter("catalog", catalog)
        _setter("data_source_arn", data_source_arn)
        _setter("input_columns", input_columns)
        _setter("name", name)
        _setter("schema", schema)

    @property
    @pulumi.getter
    def catalog(self) -> str:
        return pulumi.get(self, "catalog")

    @property
    @pulumi.getter(name="dataSourceArn")
    def data_source_arn(self) -> str:
        return pulumi.get(self, "data_source_arn")

    @property
    @pulumi.getter(name="inputColumns")
    def input_columns(self) -> Sequence['outputs.GetDataSetPhysicalTableMapRelationalTableInputColumnResult']:
        return pulumi.get(self, "input_columns")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def schema(self) -> str:
        return pulumi.get(self, "schema")


@pulumi.output_type
class GetDataSetPhysicalTableMapRelationalTableInputColumnResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        GetDataSetPhysicalTableMapRelationalTableInputColumnResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("name", name)
        _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDataSetPhysicalTableMapS3SourceResult(dict):
    def __init__(__self__, *,
                 data_source_arn: str,
                 input_columns: Sequence['outputs.GetDataSetPhysicalTableMapS3SourceInputColumnResult'],
                 upload_settings: Sequence['outputs.GetDataSetPhysicalTableMapS3SourceUploadSettingResult']):
        GetDataSetPhysicalTableMapS3SourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source_arn=data_source_arn,
            input_columns=input_columns,
            upload_settings=upload_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source_arn: Optional[str] = None,
             input_columns: Optional[Sequence['outputs.GetDataSetPhysicalTableMapS3SourceInputColumnResult']] = None,
             upload_settings: Optional[Sequence['outputs.GetDataSetPhysicalTableMapS3SourceUploadSettingResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_source_arn is None and 'dataSourceArn' in kwargs:
            data_source_arn = kwargs['dataSourceArn']
        if data_source_arn is None:
            raise TypeError("Missing 'data_source_arn' argument")
        if input_columns is None and 'inputColumns' in kwargs:
            input_columns = kwargs['inputColumns']
        if input_columns is None:
            raise TypeError("Missing 'input_columns' argument")
        if upload_settings is None and 'uploadSettings' in kwargs:
            upload_settings = kwargs['uploadSettings']
        if upload_settings is None:
            raise TypeError("Missing 'upload_settings' argument")

        _setter("data_source_arn", data_source_arn)
        _setter("input_columns", input_columns)
        _setter("upload_settings", upload_settings)

    @property
    @pulumi.getter(name="dataSourceArn")
    def data_source_arn(self) -> str:
        return pulumi.get(self, "data_source_arn")

    @property
    @pulumi.getter(name="inputColumns")
    def input_columns(self) -> Sequence['outputs.GetDataSetPhysicalTableMapS3SourceInputColumnResult']:
        return pulumi.get(self, "input_columns")

    @property
    @pulumi.getter(name="uploadSettings")
    def upload_settings(self) -> Sequence['outputs.GetDataSetPhysicalTableMapS3SourceUploadSettingResult']:
        return pulumi.get(self, "upload_settings")


@pulumi.output_type
class GetDataSetPhysicalTableMapS3SourceInputColumnResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        GetDataSetPhysicalTableMapS3SourceInputColumnResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("name", name)
        _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDataSetPhysicalTableMapS3SourceUploadSettingResult(dict):
    def __init__(__self__, *,
                 contains_header: bool,
                 delimiter: str,
                 format: str,
                 start_from_row: int,
                 text_qualifier: str):
        GetDataSetPhysicalTableMapS3SourceUploadSettingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            contains_header=contains_header,
            delimiter=delimiter,
            format=format,
            start_from_row=start_from_row,
            text_qualifier=text_qualifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             contains_header: Optional[bool] = None,
             delimiter: Optional[str] = None,
             format: Optional[str] = None,
             start_from_row: Optional[int] = None,
             text_qualifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if contains_header is None and 'containsHeader' in kwargs:
            contains_header = kwargs['containsHeader']
        if contains_header is None:
            raise TypeError("Missing 'contains_header' argument")
        if delimiter is None:
            raise TypeError("Missing 'delimiter' argument")
        if format is None:
            raise TypeError("Missing 'format' argument")
        if start_from_row is None and 'startFromRow' in kwargs:
            start_from_row = kwargs['startFromRow']
        if start_from_row is None:
            raise TypeError("Missing 'start_from_row' argument")
        if text_qualifier is None and 'textQualifier' in kwargs:
            text_qualifier = kwargs['textQualifier']
        if text_qualifier is None:
            raise TypeError("Missing 'text_qualifier' argument")

        _setter("contains_header", contains_header)
        _setter("delimiter", delimiter)
        _setter("format", format)
        _setter("start_from_row", start_from_row)
        _setter("text_qualifier", text_qualifier)

    @property
    @pulumi.getter(name="containsHeader")
    def contains_header(self) -> bool:
        return pulumi.get(self, "contains_header")

    @property
    @pulumi.getter
    def delimiter(self) -> str:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="startFromRow")
    def start_from_row(self) -> int:
        return pulumi.get(self, "start_from_row")

    @property
    @pulumi.getter(name="textQualifier")
    def text_qualifier(self) -> str:
        return pulumi.get(self, "text_qualifier")


@pulumi.output_type
class GetDataSetRowLevelPermissionDataSetResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 format_version: str,
                 namespace: str,
                 permission_policy: str,
                 status: str):
        GetDataSetRowLevelPermissionDataSetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            format_version=format_version,
            namespace=namespace,
            permission_policy=permission_policy,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             format_version: Optional[str] = None,
             namespace: Optional[str] = None,
             permission_policy: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if format_version is None and 'formatVersion' in kwargs:
            format_version = kwargs['formatVersion']
        if format_version is None:
            raise TypeError("Missing 'format_version' argument")
        if namespace is None:
            raise TypeError("Missing 'namespace' argument")
        if permission_policy is None and 'permissionPolicy' in kwargs:
            permission_policy = kwargs['permissionPolicy']
        if permission_policy is None:
            raise TypeError("Missing 'permission_policy' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")

        _setter("arn", arn)
        _setter("format_version", format_version)
        _setter("namespace", namespace)
        _setter("permission_policy", permission_policy)
        _setter("status", status)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> str:
        return pulumi.get(self, "format_version")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="permissionPolicy")
    def permission_policy(self) -> str:
        return pulumi.get(self, "permission_policy")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetDataSetRowLevelPermissionTagConfigurationResult(dict):
    def __init__(__self__, *,
                 status: str,
                 tag_rules: Sequence['outputs.GetDataSetRowLevelPermissionTagConfigurationTagRuleResult']):
        GetDataSetRowLevelPermissionTagConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status=status,
            tag_rules=tag_rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status: Optional[str] = None,
             tag_rules: Optional[Sequence['outputs.GetDataSetRowLevelPermissionTagConfigurationTagRuleResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if status is None:
            raise TypeError("Missing 'status' argument")
        if tag_rules is None and 'tagRules' in kwargs:
            tag_rules = kwargs['tagRules']
        if tag_rules is None:
            raise TypeError("Missing 'tag_rules' argument")

        _setter("status", status)
        _setter("tag_rules", tag_rules)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="tagRules")
    def tag_rules(self) -> Sequence['outputs.GetDataSetRowLevelPermissionTagConfigurationTagRuleResult']:
        return pulumi.get(self, "tag_rules")


@pulumi.output_type
class GetDataSetRowLevelPermissionTagConfigurationTagRuleResult(dict):
    def __init__(__self__, *,
                 column_name: str,
                 match_all_value: str,
                 tag_key: str,
                 tag_multi_value_delimiter: str):
        GetDataSetRowLevelPermissionTagConfigurationTagRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            match_all_value=match_all_value,
            tag_key=tag_key,
            tag_multi_value_delimiter=tag_multi_value_delimiter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             match_all_value: Optional[str] = None,
             tag_key: Optional[str] = None,
             tag_multi_value_delimiter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if match_all_value is None and 'matchAllValue' in kwargs:
            match_all_value = kwargs['matchAllValue']
        if match_all_value is None:
            raise TypeError("Missing 'match_all_value' argument")
        if tag_key is None and 'tagKey' in kwargs:
            tag_key = kwargs['tagKey']
        if tag_key is None:
            raise TypeError("Missing 'tag_key' argument")
        if tag_multi_value_delimiter is None and 'tagMultiValueDelimiter' in kwargs:
            tag_multi_value_delimiter = kwargs['tagMultiValueDelimiter']
        if tag_multi_value_delimiter is None:
            raise TypeError("Missing 'tag_multi_value_delimiter' argument")

        _setter("column_name", column_name)
        _setter("match_all_value", match_all_value)
        _setter("tag_key", tag_key)
        _setter("tag_multi_value_delimiter", tag_multi_value_delimiter)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="matchAllValue")
    def match_all_value(self) -> str:
        return pulumi.get(self, "match_all_value")

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> str:
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter(name="tagMultiValueDelimiter")
    def tag_multi_value_delimiter(self) -> str:
        return pulumi.get(self, "tag_multi_value_delimiter")


@pulumi.output_type
class GetThemeConfigurationResult(dict):
    def __init__(__self__, *,
                 data_color_palettes: Sequence['outputs.GetThemeConfigurationDataColorPaletteResult'],
                 sheets: Sequence['outputs.GetThemeConfigurationSheetResult'],
                 typographies: Sequence['outputs.GetThemeConfigurationTypographyResult'],
                 ui_color_palettes: Sequence['outputs.GetThemeConfigurationUiColorPaletteResult']):
        """
        :param Sequence['GetThemeConfigurationDataColorPaletteArgs'] data_color_palettes: Color properties that apply to chart data colors. See data_color_palette.
        :param Sequence['GetThemeConfigurationSheetArgs'] sheets: Display options related to sheets. See sheet.
        :param Sequence['GetThemeConfigurationTypographyArgs'] typographies: Determines the typography options. See typography.
        :param Sequence['GetThemeConfigurationUiColorPaletteArgs'] ui_color_palettes: Color properties that apply to the UI and to charts, excluding the colors that apply to data. See ui_color_palette.
        """
        GetThemeConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_color_palettes=data_color_palettes,
            sheets=sheets,
            typographies=typographies,
            ui_color_palettes=ui_color_palettes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_color_palettes: Optional[Sequence['outputs.GetThemeConfigurationDataColorPaletteResult']] = None,
             sheets: Optional[Sequence['outputs.GetThemeConfigurationSheetResult']] = None,
             typographies: Optional[Sequence['outputs.GetThemeConfigurationTypographyResult']] = None,
             ui_color_palettes: Optional[Sequence['outputs.GetThemeConfigurationUiColorPaletteResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_color_palettes is None and 'dataColorPalettes' in kwargs:
            data_color_palettes = kwargs['dataColorPalettes']
        if data_color_palettes is None:
            raise TypeError("Missing 'data_color_palettes' argument")
        if sheets is None:
            raise TypeError("Missing 'sheets' argument")
        if typographies is None:
            raise TypeError("Missing 'typographies' argument")
        if ui_color_palettes is None and 'uiColorPalettes' in kwargs:
            ui_color_palettes = kwargs['uiColorPalettes']
        if ui_color_palettes is None:
            raise TypeError("Missing 'ui_color_palettes' argument")

        _setter("data_color_palettes", data_color_palettes)
        _setter("sheets", sheets)
        _setter("typographies", typographies)
        _setter("ui_color_palettes", ui_color_palettes)

    @property
    @pulumi.getter(name="dataColorPalettes")
    def data_color_palettes(self) -> Sequence['outputs.GetThemeConfigurationDataColorPaletteResult']:
        """
        Color properties that apply to chart data colors. See data_color_palette.
        """
        return pulumi.get(self, "data_color_palettes")

    @property
    @pulumi.getter
    def sheets(self) -> Sequence['outputs.GetThemeConfigurationSheetResult']:
        """
        Display options related to sheets. See sheet.
        """
        return pulumi.get(self, "sheets")

    @property
    @pulumi.getter
    def typographies(self) -> Sequence['outputs.GetThemeConfigurationTypographyResult']:
        """
        Determines the typography options. See typography.
        """
        return pulumi.get(self, "typographies")

    @property
    @pulumi.getter(name="uiColorPalettes")
    def ui_color_palettes(self) -> Sequence['outputs.GetThemeConfigurationUiColorPaletteResult']:
        """
        Color properties that apply to the UI and to charts, excluding the colors that apply to data. See ui_color_palette.
        """
        return pulumi.get(self, "ui_color_palettes")


@pulumi.output_type
class GetThemeConfigurationDataColorPaletteResult(dict):
    def __init__(__self__, *,
                 colors: Sequence[str],
                 empty_fill_color: str,
                 min_max_gradients: Sequence[str]):
        """
        :param Sequence[str] colors: List of hexadecimal codes for the colors. Minimum of 8 items and maximum of 20 items.
        :param str empty_fill_color: The hexadecimal code of a color that applies to charts where a lack of data is highlighted.
        :param Sequence[str] min_max_gradients: The minimum and maximum hexadecimal codes that describe a color gradient. List of exactly 2 items.
        """
        GetThemeConfigurationDataColorPaletteResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            colors=colors,
            empty_fill_color=empty_fill_color,
            min_max_gradients=min_max_gradients,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             colors: Optional[Sequence[str]] = None,
             empty_fill_color: Optional[str] = None,
             min_max_gradients: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if colors is None:
            raise TypeError("Missing 'colors' argument")
        if empty_fill_color is None and 'emptyFillColor' in kwargs:
            empty_fill_color = kwargs['emptyFillColor']
        if empty_fill_color is None:
            raise TypeError("Missing 'empty_fill_color' argument")
        if min_max_gradients is None and 'minMaxGradients' in kwargs:
            min_max_gradients = kwargs['minMaxGradients']
        if min_max_gradients is None:
            raise TypeError("Missing 'min_max_gradients' argument")

        _setter("colors", colors)
        _setter("empty_fill_color", empty_fill_color)
        _setter("min_max_gradients", min_max_gradients)

    @property
    @pulumi.getter
    def colors(self) -> Sequence[str]:
        """
        List of hexadecimal codes for the colors. Minimum of 8 items and maximum of 20 items.
        """
        return pulumi.get(self, "colors")

    @property
    @pulumi.getter(name="emptyFillColor")
    def empty_fill_color(self) -> str:
        """
        The hexadecimal code of a color that applies to charts where a lack of data is highlighted.
        """
        return pulumi.get(self, "empty_fill_color")

    @property
    @pulumi.getter(name="minMaxGradients")
    def min_max_gradients(self) -> Sequence[str]:
        """
        The minimum and maximum hexadecimal codes that describe a color gradient. List of exactly 2 items.
        """
        return pulumi.get(self, "min_max_gradients")


@pulumi.output_type
class GetThemeConfigurationSheetResult(dict):
    def __init__(__self__, *,
                 tile_layouts: Sequence['outputs.GetThemeConfigurationSheetTileLayoutResult'],
                 tiles: Sequence['outputs.GetThemeConfigurationSheetTileResult']):
        """
        :param Sequence['GetThemeConfigurationSheetTileLayoutArgs'] tile_layouts: The layout options for tiles. See tile_layout.
        :param Sequence['GetThemeConfigurationSheetTileArgs'] tiles: The display options for tiles. See tile.
        """
        GetThemeConfigurationSheetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tile_layouts=tile_layouts,
            tiles=tiles,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tile_layouts: Optional[Sequence['outputs.GetThemeConfigurationSheetTileLayoutResult']] = None,
             tiles: Optional[Sequence['outputs.GetThemeConfigurationSheetTileResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if tile_layouts is None and 'tileLayouts' in kwargs:
            tile_layouts = kwargs['tileLayouts']
        if tile_layouts is None:
            raise TypeError("Missing 'tile_layouts' argument")
        if tiles is None:
            raise TypeError("Missing 'tiles' argument")

        _setter("tile_layouts", tile_layouts)
        _setter("tiles", tiles)

    @property
    @pulumi.getter(name="tileLayouts")
    def tile_layouts(self) -> Sequence['outputs.GetThemeConfigurationSheetTileLayoutResult']:
        """
        The layout options for tiles. See tile_layout.
        """
        return pulumi.get(self, "tile_layouts")

    @property
    @pulumi.getter
    def tiles(self) -> Sequence['outputs.GetThemeConfigurationSheetTileResult']:
        """
        The display options for tiles. See tile.
        """
        return pulumi.get(self, "tiles")


@pulumi.output_type
class GetThemeConfigurationSheetTileResult(dict):
    def __init__(__self__, *,
                 borders: Sequence['outputs.GetThemeConfigurationSheetTileBorderResult']):
        """
        :param Sequence['GetThemeConfigurationSheetTileBorderArgs'] borders: The border around a tile. See border.
        """
        GetThemeConfigurationSheetTileResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            borders=borders,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             borders: Optional[Sequence['outputs.GetThemeConfigurationSheetTileBorderResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if borders is None:
            raise TypeError("Missing 'borders' argument")

        _setter("borders", borders)

    @property
    @pulumi.getter
    def borders(self) -> Sequence['outputs.GetThemeConfigurationSheetTileBorderResult']:
        """
        The border around a tile. See border.
        """
        return pulumi.get(self, "borders")


@pulumi.output_type
class GetThemeConfigurationSheetTileBorderResult(dict):
    def __init__(__self__, *,
                 show: bool):
        """
        :param bool show: This Boolean value controls whether to display sheet margins.
        """
        GetThemeConfigurationSheetTileBorderResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            show=show,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             show: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if show is None:
            raise TypeError("Missing 'show' argument")

        _setter("show", show)

    @property
    @pulumi.getter
    def show(self) -> bool:
        """
        This Boolean value controls whether to display sheet margins.
        """
        return pulumi.get(self, "show")


@pulumi.output_type
class GetThemeConfigurationSheetTileLayoutResult(dict):
    def __init__(__self__, *,
                 gutters: Sequence['outputs.GetThemeConfigurationSheetTileLayoutGutterResult'],
                 margins: Sequence['outputs.GetThemeConfigurationSheetTileLayoutMarginResult']):
        """
        :param Sequence['GetThemeConfigurationSheetTileLayoutGutterArgs'] gutters: The gutter settings that apply between tiles. See gutter.
        :param Sequence['GetThemeConfigurationSheetTileLayoutMarginArgs'] margins: The margin settings that apply around the outside edge of sheets. See margin.
        """
        GetThemeConfigurationSheetTileLayoutResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gutters=gutters,
            margins=margins,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gutters: Optional[Sequence['outputs.GetThemeConfigurationSheetTileLayoutGutterResult']] = None,
             margins: Optional[Sequence['outputs.GetThemeConfigurationSheetTileLayoutMarginResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if gutters is None:
            raise TypeError("Missing 'gutters' argument")
        if margins is None:
            raise TypeError("Missing 'margins' argument")

        _setter("gutters", gutters)
        _setter("margins", margins)

    @property
    @pulumi.getter
    def gutters(self) -> Sequence['outputs.GetThemeConfigurationSheetTileLayoutGutterResult']:
        """
        The gutter settings that apply between tiles. See gutter.
        """
        return pulumi.get(self, "gutters")

    @property
    @pulumi.getter
    def margins(self) -> Sequence['outputs.GetThemeConfigurationSheetTileLayoutMarginResult']:
        """
        The margin settings that apply around the outside edge of sheets. See margin.
        """
        return pulumi.get(self, "margins")


@pulumi.output_type
class GetThemeConfigurationSheetTileLayoutGutterResult(dict):
    def __init__(__self__, *,
                 show: bool):
        """
        :param bool show: This Boolean value controls whether to display sheet margins.
        """
        GetThemeConfigurationSheetTileLayoutGutterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            show=show,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             show: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if show is None:
            raise TypeError("Missing 'show' argument")

        _setter("show", show)

    @property
    @pulumi.getter
    def show(self) -> bool:
        """
        This Boolean value controls whether to display sheet margins.
        """
        return pulumi.get(self, "show")


@pulumi.output_type
class GetThemeConfigurationSheetTileLayoutMarginResult(dict):
    def __init__(__self__, *,
                 show: bool):
        """
        :param bool show: This Boolean value controls whether to display sheet margins.
        """
        GetThemeConfigurationSheetTileLayoutMarginResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            show=show,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             show: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if show is None:
            raise TypeError("Missing 'show' argument")

        _setter("show", show)

    @property
    @pulumi.getter
    def show(self) -> bool:
        """
        This Boolean value controls whether to display sheet margins.
        """
        return pulumi.get(self, "show")


@pulumi.output_type
class GetThemeConfigurationTypographyResult(dict):
    def __init__(__self__, *,
                 font_families: Sequence['outputs.GetThemeConfigurationTypographyFontFamilyResult']):
        """
        :param Sequence['GetThemeConfigurationTypographyFontFamilyArgs'] font_families: Determines the list of font families. Maximum number of 5 items. See font_families.
        """
        GetThemeConfigurationTypographyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            font_families=font_families,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             font_families: Optional[Sequence['outputs.GetThemeConfigurationTypographyFontFamilyResult']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if font_families is None and 'fontFamilies' in kwargs:
            font_families = kwargs['fontFamilies']
        if font_families is None:
            raise TypeError("Missing 'font_families' argument")

        _setter("font_families", font_families)

    @property
    @pulumi.getter(name="fontFamilies")
    def font_families(self) -> Sequence['outputs.GetThemeConfigurationTypographyFontFamilyResult']:
        """
        Determines the list of font families. Maximum number of 5 items. See font_families.
        """
        return pulumi.get(self, "font_families")


@pulumi.output_type
class GetThemeConfigurationTypographyFontFamilyResult(dict):
    def __init__(__self__, *,
                 font_family: str):
        """
        :param str font_family: Font family name.
        """
        GetThemeConfigurationTypographyFontFamilyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            font_family=font_family,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             font_family: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if font_family is None and 'fontFamily' in kwargs:
            font_family = kwargs['fontFamily']
        if font_family is None:
            raise TypeError("Missing 'font_family' argument")

        _setter("font_family", font_family)

    @property
    @pulumi.getter(name="fontFamily")
    def font_family(self) -> str:
        """
        Font family name.
        """
        return pulumi.get(self, "font_family")


@pulumi.output_type
class GetThemeConfigurationUiColorPaletteResult(dict):
    def __init__(__self__, *,
                 accent: str,
                 accent_foreground: str,
                 danger: str,
                 danger_foreground: str,
                 dimension: str,
                 dimension_foreground: str,
                 measure: str,
                 measure_foreground: str,
                 primary_background: str,
                 primary_foreground: str,
                 secondary_background: str,
                 secondary_foreground: str,
                 success: str,
                 success_foreground: str,
                 warning: str,
                 warning_foreground: str):
        """
        :param str accent: Color (hexadecimal) that applies to selected states and buttons.
        :param str accent_foreground: Color (hexadecimal) that applies to any text or other elements that appear over the accent color.
        :param str danger: Color (hexadecimal) that applies to error messages.
        :param str danger_foreground: Color (hexadecimal) that applies to any text or other elements that appear over the error color.
        :param str dimension: Color (hexadecimal) that applies to the names of fields that are identified as dimensions.
        :param str dimension_foreground: Color (hexadecimal) that applies to any text or other elements that appear over the dimension color.
        :param str measure: Color (hexadecimal) that applies to the names of fields that are identified as measures.
        :param str measure_foreground: Color (hexadecimal) that applies to any text or other elements that appear over the measure color.
        :param str primary_background: Color (hexadecimal) that applies to visuals and other high emphasis UI.
        :param str primary_foreground: Color (hexadecimal) of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.
        :param str secondary_background: Color (hexadecimal) that applies to the sheet background and sheet controls.
        :param str secondary_foreground: Color (hexadecimal) that applies to any sheet title, sheet control text, or UI that appears over the secondary background.
        :param str success: Color (hexadecimal) that applies to success messages, for example the check mark for a successful download.
        :param str success_foreground: Color (hexadecimal) that applies to any text or other elements that appear over the success color.
        :param str warning: Color (hexadecimal) that applies to warning and informational messages.
        :param str warning_foreground: Color (hexadecimal) that applies to any text or other elements that appear over the warning color.
        """
        GetThemeConfigurationUiColorPaletteResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            accent=accent,
            accent_foreground=accent_foreground,
            danger=danger,
            danger_foreground=danger_foreground,
            dimension=dimension,
            dimension_foreground=dimension_foreground,
            measure=measure,
            measure_foreground=measure_foreground,
            primary_background=primary_background,
            primary_foreground=primary_foreground,
            secondary_background=secondary_background,
            secondary_foreground=secondary_foreground,
            success=success,
            success_foreground=success_foreground,
            warning=warning,
            warning_foreground=warning_foreground,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             accent: Optional[str] = None,
             accent_foreground: Optional[str] = None,
             danger: Optional[str] = None,
             danger_foreground: Optional[str] = None,
             dimension: Optional[str] = None,
             dimension_foreground: Optional[str] = None,
             measure: Optional[str] = None,
             measure_foreground: Optional[str] = None,
             primary_background: Optional[str] = None,
             primary_foreground: Optional[str] = None,
             secondary_background: Optional[str] = None,
             secondary_foreground: Optional[str] = None,
             success: Optional[str] = None,
             success_foreground: Optional[str] = None,
             warning: Optional[str] = None,
             warning_foreground: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if accent is None:
            raise TypeError("Missing 'accent' argument")
        if accent_foreground is None and 'accentForeground' in kwargs:
            accent_foreground = kwargs['accentForeground']
        if accent_foreground is None:
            raise TypeError("Missing 'accent_foreground' argument")
        if danger is None:
            raise TypeError("Missing 'danger' argument")
        if danger_foreground is None and 'dangerForeground' in kwargs:
            danger_foreground = kwargs['dangerForeground']
        if danger_foreground is None:
            raise TypeError("Missing 'danger_foreground' argument")
        if dimension is None:
            raise TypeError("Missing 'dimension' argument")
        if dimension_foreground is None and 'dimensionForeground' in kwargs:
            dimension_foreground = kwargs['dimensionForeground']
        if dimension_foreground is None:
            raise TypeError("Missing 'dimension_foreground' argument")
        if measure is None:
            raise TypeError("Missing 'measure' argument")
        if measure_foreground is None and 'measureForeground' in kwargs:
            measure_foreground = kwargs['measureForeground']
        if measure_foreground is None:
            raise TypeError("Missing 'measure_foreground' argument")
        if primary_background is None and 'primaryBackground' in kwargs:
            primary_background = kwargs['primaryBackground']
        if primary_background is None:
            raise TypeError("Missing 'primary_background' argument")
        if primary_foreground is None and 'primaryForeground' in kwargs:
            primary_foreground = kwargs['primaryForeground']
        if primary_foreground is None:
            raise TypeError("Missing 'primary_foreground' argument")
        if secondary_background is None and 'secondaryBackground' in kwargs:
            secondary_background = kwargs['secondaryBackground']
        if secondary_background is None:
            raise TypeError("Missing 'secondary_background' argument")
        if secondary_foreground is None and 'secondaryForeground' in kwargs:
            secondary_foreground = kwargs['secondaryForeground']
        if secondary_foreground is None:
            raise TypeError("Missing 'secondary_foreground' argument")
        if success is None:
            raise TypeError("Missing 'success' argument")
        if success_foreground is None and 'successForeground' in kwargs:
            success_foreground = kwargs['successForeground']
        if success_foreground is None:
            raise TypeError("Missing 'success_foreground' argument")
        if warning is None:
            raise TypeError("Missing 'warning' argument")
        if warning_foreground is None and 'warningForeground' in kwargs:
            warning_foreground = kwargs['warningForeground']
        if warning_foreground is None:
            raise TypeError("Missing 'warning_foreground' argument")

        _setter("accent", accent)
        _setter("accent_foreground", accent_foreground)
        _setter("danger", danger)
        _setter("danger_foreground", danger_foreground)
        _setter("dimension", dimension)
        _setter("dimension_foreground", dimension_foreground)
        _setter("measure", measure)
        _setter("measure_foreground", measure_foreground)
        _setter("primary_background", primary_background)
        _setter("primary_foreground", primary_foreground)
        _setter("secondary_background", secondary_background)
        _setter("secondary_foreground", secondary_foreground)
        _setter("success", success)
        _setter("success_foreground", success_foreground)
        _setter("warning", warning)
        _setter("warning_foreground", warning_foreground)

    @property
    @pulumi.getter
    def accent(self) -> str:
        """
        Color (hexadecimal) that applies to selected states and buttons.
        """
        return pulumi.get(self, "accent")

    @property
    @pulumi.getter(name="accentForeground")
    def accent_foreground(self) -> str:
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the accent color.
        """
        return pulumi.get(self, "accent_foreground")

    @property
    @pulumi.getter
    def danger(self) -> str:
        """
        Color (hexadecimal) that applies to error messages.
        """
        return pulumi.get(self, "danger")

    @property
    @pulumi.getter(name="dangerForeground")
    def danger_foreground(self) -> str:
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the error color.
        """
        return pulumi.get(self, "danger_foreground")

    @property
    @pulumi.getter
    def dimension(self) -> str:
        """
        Color (hexadecimal) that applies to the names of fields that are identified as dimensions.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter(name="dimensionForeground")
    def dimension_foreground(self) -> str:
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the dimension color.
        """
        return pulumi.get(self, "dimension_foreground")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        Color (hexadecimal) that applies to the names of fields that are identified as measures.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="measureForeground")
    def measure_foreground(self) -> str:
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the measure color.
        """
        return pulumi.get(self, "measure_foreground")

    @property
    @pulumi.getter(name="primaryBackground")
    def primary_background(self) -> str:
        """
        Color (hexadecimal) that applies to visuals and other high emphasis UI.
        """
        return pulumi.get(self, "primary_background")

    @property
    @pulumi.getter(name="primaryForeground")
    def primary_foreground(self) -> str:
        """
        Color (hexadecimal) of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.
        """
        return pulumi.get(self, "primary_foreground")

    @property
    @pulumi.getter(name="secondaryBackground")
    def secondary_background(self) -> str:
        """
        Color (hexadecimal) that applies to the sheet background and sheet controls.
        """
        return pulumi.get(self, "secondary_background")

    @property
    @pulumi.getter(name="secondaryForeground")
    def secondary_foreground(self) -> str:
        """
        Color (hexadecimal) that applies to any sheet title, sheet control text, or UI that appears over the secondary background.
        """
        return pulumi.get(self, "secondary_foreground")

    @property
    @pulumi.getter
    def success(self) -> str:
        """
        Color (hexadecimal) that applies to success messages, for example the check mark for a successful download.
        """
        return pulumi.get(self, "success")

    @property
    @pulumi.getter(name="successForeground")
    def success_foreground(self) -> str:
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the success color.
        """
        return pulumi.get(self, "success_foreground")

    @property
    @pulumi.getter
    def warning(self) -> str:
        """
        Color (hexadecimal) that applies to warning and informational messages.
        """
        return pulumi.get(self, "warning")

    @property
    @pulumi.getter(name="warningForeground")
    def warning_foreground(self) -> str:
        """
        Color (hexadecimal) that applies to any text or other elements that appear over the warning color.
        """
        return pulumi.get(self, "warning_foreground")


@pulumi.output_type
class GetThemePermissionResult(dict):
    def __init__(__self__, *,
                 actions: Sequence[str],
                 principal: str):
        """
        :param Sequence[str] actions: List of IAM actions to grant or revoke permissions on.
        :param str principal: ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        GetThemePermissionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            principal=principal,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[Sequence[str]] = None,
             principal: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions is None:
            raise TypeError("Missing 'actions' argument")
        if principal is None:
            raise TypeError("Missing 'principal' argument")

        _setter("actions", actions)
        _setter("principal", principal)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        List of IAM actions to grant or revoke permissions on.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def principal(self) -> str:
        """
        ARN of the principal. See the [ResourcePermission documentation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ResourcePermission.html) for the applicable ARN values.
        """
        return pulumi.get(self, "principal")


