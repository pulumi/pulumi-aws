# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'ListenerDefaultActionArgs',
    'ListenerDefaultActionFixedResponseArgs',
    'ListenerDefaultActionForwardArgs',
    'ListenerDefaultActionForwardTargetGroupArgs',
    'ListenerRuleActionArgs',
    'ListenerRuleActionFixedResponseArgs',
    'ListenerRuleActionForwardArgs',
    'ListenerRuleActionForwardTargetGroupArgs',
    'ListenerRuleMatchArgs',
    'ListenerRuleMatchHttpMatchArgs',
    'ListenerRuleMatchHttpMatchHeaderMatchArgs',
    'ListenerRuleMatchHttpMatchHeaderMatchMatchArgs',
    'ListenerRuleMatchHttpMatchPathMatchArgs',
    'ListenerRuleMatchHttpMatchPathMatchMatchArgs',
    'ServiceDnsEntryArgs',
    'ServiceNetworkServiceAssociationDnsEntryArgs',
    'TargetGroupAttachmentTargetArgs',
    'TargetGroupConfigArgs',
    'TargetGroupConfigHealthCheckArgs',
    'TargetGroupConfigHealthCheckMatcherArgs',
]

@pulumi.input_type
class ListenerDefaultActionArgs:
    def __init__(__self__, *,
                 fixed_response: Optional[pulumi.Input['ListenerDefaultActionFixedResponseArgs']] = None,
                 forwards: Optional[pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardArgs']]] forwards: Route requests to one or more target groups. See Forward blocks below.
               
               > **NOTE:** You must specify exactly one of the following argument blocks: `fixed_response` or `forward`.
        """
        if fixed_response is not None:
            pulumi.set(__self__, "fixed_response", fixed_response)
        if forwards is not None:
            pulumi.set(__self__, "forwards", forwards)

    @property
    @pulumi.getter(name="fixedResponse")
    def fixed_response(self) -> Optional[pulumi.Input['ListenerDefaultActionFixedResponseArgs']]:
        return pulumi.get(self, "fixed_response")

    @fixed_response.setter
    def fixed_response(self, value: Optional[pulumi.Input['ListenerDefaultActionFixedResponseArgs']]):
        pulumi.set(self, "fixed_response", value)

    @property
    @pulumi.getter
    def forwards(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardArgs']]]]:
        """
        Route requests to one or more target groups. See Forward blocks below.

        > **NOTE:** You must specify exactly one of the following argument blocks: `fixed_response` or `forward`.
        """
        return pulumi.get(self, "forwards")

    @forwards.setter
    def forwards(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardArgs']]]]):
        pulumi.set(self, "forwards", value)


@pulumi.input_type
class ListenerDefaultActionFixedResponseArgs:
    def __init__(__self__, *,
                 status_code: pulumi.Input[int]):
        """
        :param pulumi.Input[int] status_code: Custom HTTP status code to return, e.g. a 404 response code. See [Listeners](https://docs.aws.amazon.com/vpc-lattice/latest/ug/listeners.html) in the AWS documentation for a list of supported codes.
        """
        pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> pulumi.Input[int]:
        """
        Custom HTTP status code to return, e.g. a 404 response code. See [Listeners](https://docs.aws.amazon.com/vpc-lattice/latest/ug/listeners.html) in the AWS documentation for a list of supported codes.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "status_code", value)


@pulumi.input_type
class ListenerDefaultActionForwardArgs:
    def __init__(__self__, *,
                 target_groups: Optional[pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardTargetGroupArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardTargetGroupArgs']]] target_groups: One or more target group blocks.
        """
        if target_groups is not None:
            pulumi.set(__self__, "target_groups", target_groups)

    @property
    @pulumi.getter(name="targetGroups")
    def target_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardTargetGroupArgs']]]]:
        """
        One or more target group blocks.
        """
        return pulumi.get(self, "target_groups")

    @target_groups.setter
    def target_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardTargetGroupArgs']]]]):
        pulumi.set(self, "target_groups", value)


@pulumi.input_type
class ListenerDefaultActionForwardTargetGroupArgs:
    def __init__(__self__, *,
                 target_group_identifier: Optional[pulumi.Input[str]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] target_group_identifier: ID or Amazon Resource Name (ARN) of the target group.
        :param pulumi.Input[int] weight: Determines how requests are distributed to the target group. Only required if you specify multiple target groups for a forward action. For example, if you specify two target groups, one with a
               weight of 10 and the other with a weight of 20, the target group with a weight of 20 receives twice as many requests as the other target group. See [Listener rules](https://docs.aws.amazon.com/vpc-lattice/latest/ug/listeners.html#listener-rules) in the AWS documentation for additional examples. Default: `100`.
        """
        if target_group_identifier is not None:
            pulumi.set(__self__, "target_group_identifier", target_group_identifier)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="targetGroupIdentifier")
    def target_group_identifier(self) -> Optional[pulumi.Input[str]]:
        """
        ID or Amazon Resource Name (ARN) of the target group.
        """
        return pulumi.get(self, "target_group_identifier")

    @target_group_identifier.setter
    def target_group_identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_group_identifier", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        Determines how requests are distributed to the target group. Only required if you specify multiple target groups for a forward action. For example, if you specify two target groups, one with a
        weight of 10 and the other with a weight of 20, the target group with a weight of 20 receives twice as many requests as the other target group. See [Listener rules](https://docs.aws.amazon.com/vpc-lattice/latest/ug/listeners.html#listener-rules) in the AWS documentation for additional examples. Default: `100`.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class ListenerRuleActionArgs:
    def __init__(__self__, *,
                 fixed_response: Optional[pulumi.Input['ListenerRuleActionFixedResponseArgs']] = None,
                 forward: Optional[pulumi.Input['ListenerRuleActionForwardArgs']] = None):
        """
        :param pulumi.Input['ListenerRuleActionFixedResponseArgs'] fixed_response: Describes the rule action that returns a custom HTTP response.
        :param pulumi.Input['ListenerRuleActionForwardArgs'] forward: The forward action. Traffic that matches the rule is forwarded to the specified target groups.
        """
        if fixed_response is not None:
            pulumi.set(__self__, "fixed_response", fixed_response)
        if forward is not None:
            pulumi.set(__self__, "forward", forward)

    @property
    @pulumi.getter(name="fixedResponse")
    def fixed_response(self) -> Optional[pulumi.Input['ListenerRuleActionFixedResponseArgs']]:
        """
        Describes the rule action that returns a custom HTTP response.
        """
        return pulumi.get(self, "fixed_response")

    @fixed_response.setter
    def fixed_response(self, value: Optional[pulumi.Input['ListenerRuleActionFixedResponseArgs']]):
        pulumi.set(self, "fixed_response", value)

    @property
    @pulumi.getter
    def forward(self) -> Optional[pulumi.Input['ListenerRuleActionForwardArgs']]:
        """
        The forward action. Traffic that matches the rule is forwarded to the specified target groups.
        """
        return pulumi.get(self, "forward")

    @forward.setter
    def forward(self, value: Optional[pulumi.Input['ListenerRuleActionForwardArgs']]):
        pulumi.set(self, "forward", value)


@pulumi.input_type
class ListenerRuleActionFixedResponseArgs:
    def __init__(__self__, *,
                 status_code: pulumi.Input[int]):
        """
        :param pulumi.Input[int] status_code: The HTTP response code.
        """
        pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> pulumi.Input[int]:
        """
        The HTTP response code.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "status_code", value)


@pulumi.input_type
class ListenerRuleActionForwardArgs:
    def __init__(__self__, *,
                 target_groups: pulumi.Input[Sequence[pulumi.Input['ListenerRuleActionForwardTargetGroupArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ListenerRuleActionForwardTargetGroupArgs']]] target_groups: The target groups. Traffic matching the rule is forwarded to the specified target groups. With forward actions, you can assign a weight that controls the prioritization and selection of each target group. This means that requests are distributed to individual target groups based on their weights. For example, if two target groups have the same weight, each target group receives half of the traffic.
               
               The default value is 1 with maximum number of 2. If only one target group is provided, there is no need to set the weight; 100% of traffic will go to that target group.
        """
        pulumi.set(__self__, "target_groups", target_groups)

    @property
    @pulumi.getter(name="targetGroups")
    def target_groups(self) -> pulumi.Input[Sequence[pulumi.Input['ListenerRuleActionForwardTargetGroupArgs']]]:
        """
        The target groups. Traffic matching the rule is forwarded to the specified target groups. With forward actions, you can assign a weight that controls the prioritization and selection of each target group. This means that requests are distributed to individual target groups based on their weights. For example, if two target groups have the same weight, each target group receives half of the traffic.

        The default value is 1 with maximum number of 2. If only one target group is provided, there is no need to set the weight; 100% of traffic will go to that target group.
        """
        return pulumi.get(self, "target_groups")

    @target_groups.setter
    def target_groups(self, value: pulumi.Input[Sequence[pulumi.Input['ListenerRuleActionForwardTargetGroupArgs']]]):
        pulumi.set(self, "target_groups", value)


@pulumi.input_type
class ListenerRuleActionForwardTargetGroupArgs:
    def __init__(__self__, *,
                 target_group_identifier: pulumi.Input[str],
                 weight: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "target_group_identifier", target_group_identifier)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="targetGroupIdentifier")
    def target_group_identifier(self) -> pulumi.Input[str]:
        return pulumi.get(self, "target_group_identifier")

    @target_group_identifier.setter
    def target_group_identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_group_identifier", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class ListenerRuleMatchArgs:
    def __init__(__self__, *,
                 http_match: Optional[pulumi.Input['ListenerRuleMatchHttpMatchArgs']] = None):
        """
        :param pulumi.Input['ListenerRuleMatchHttpMatchArgs'] http_match: The HTTP criteria that a rule must match.
        """
        if http_match is not None:
            pulumi.set(__self__, "http_match", http_match)

    @property
    @pulumi.getter(name="httpMatch")
    def http_match(self) -> Optional[pulumi.Input['ListenerRuleMatchHttpMatchArgs']]:
        """
        The HTTP criteria that a rule must match.
        """
        return pulumi.get(self, "http_match")

    @http_match.setter
    def http_match(self, value: Optional[pulumi.Input['ListenerRuleMatchHttpMatchArgs']]):
        pulumi.set(self, "http_match", value)


@pulumi.input_type
class ListenerRuleMatchHttpMatchArgs:
    def __init__(__self__, *,
                 header_matches: Optional[pulumi.Input[Sequence[pulumi.Input['ListenerRuleMatchHttpMatchHeaderMatchArgs']]]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 path_match: Optional[pulumi.Input['ListenerRuleMatchHttpMatchPathMatchArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ListenerRuleMatchHttpMatchHeaderMatchArgs']]] header_matches: The header matches. Matches incoming requests with rule based on request header value before applying rule action.
        :param pulumi.Input[str] method: The HTTP method type.
        :param pulumi.Input['ListenerRuleMatchHttpMatchPathMatchArgs'] path_match: The path match.
        """
        if header_matches is not None:
            pulumi.set(__self__, "header_matches", header_matches)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if path_match is not None:
            pulumi.set(__self__, "path_match", path_match)

    @property
    @pulumi.getter(name="headerMatches")
    def header_matches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ListenerRuleMatchHttpMatchHeaderMatchArgs']]]]:
        """
        The header matches. Matches incoming requests with rule based on request header value before applying rule action.
        """
        return pulumi.get(self, "header_matches")

    @header_matches.setter
    def header_matches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ListenerRuleMatchHttpMatchHeaderMatchArgs']]]]):
        pulumi.set(self, "header_matches", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP method type.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="pathMatch")
    def path_match(self) -> Optional[pulumi.Input['ListenerRuleMatchHttpMatchPathMatchArgs']]:
        """
        The path match.
        """
        return pulumi.get(self, "path_match")

    @path_match.setter
    def path_match(self, value: Optional[pulumi.Input['ListenerRuleMatchHttpMatchPathMatchArgs']]):
        pulumi.set(self, "path_match", value)


@pulumi.input_type
class ListenerRuleMatchHttpMatchHeaderMatchArgs:
    def __init__(__self__, *,
                 match: pulumi.Input['ListenerRuleMatchHttpMatchHeaderMatchMatchArgs'],
                 name: pulumi.Input[str],
                 case_sensitive: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['ListenerRuleMatchHttpMatchHeaderMatchMatchArgs'] match: The header match type.
        :param pulumi.Input[str] name: The name of the header.
        :param pulumi.Input[bool] case_sensitive: Indicates whether the match is case sensitive. Defaults to false.
        """
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "name", name)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input['ListenerRuleMatchHttpMatchHeaderMatchMatchArgs']:
        """
        The header match type.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input['ListenerRuleMatchHttpMatchHeaderMatchMatchArgs']):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the header.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the match is case sensitive. Defaults to false.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)


@pulumi.input_type
class ListenerRuleMatchHttpMatchHeaderMatchMatchArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[str]] = None,
                 exact: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] contains: Specifies a contains type match.
        :param pulumi.Input[str] exact: Specifies an exact type match.
        :param pulumi.Input[str] prefix: Specifies a prefix type match. Matches the value with the prefix.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a contains type match.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "contains", value)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an exact type match.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a prefix type match. Matches the value with the prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


@pulumi.input_type
class ListenerRuleMatchHttpMatchPathMatchArgs:
    def __init__(__self__, *,
                 match: pulumi.Input['ListenerRuleMatchHttpMatchPathMatchMatchArgs'],
                 case_sensitive: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['ListenerRuleMatchHttpMatchPathMatchMatchArgs'] match: The header match type.
        :param pulumi.Input[bool] case_sensitive: Indicates whether the match is case sensitive. Defaults to false.
        """
        pulumi.set(__self__, "match", match)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input['ListenerRuleMatchHttpMatchPathMatchMatchArgs']:
        """
        The header match type.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input['ListenerRuleMatchHttpMatchPathMatchMatchArgs']):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the match is case sensitive. Defaults to false.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)


@pulumi.input_type
class ListenerRuleMatchHttpMatchPathMatchMatchArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: Specifies an exact type match.
        :param pulumi.Input[str] prefix: Specifies a prefix type match. Matches the value with the prefix.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies an exact type match.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a prefix type match. Matches the value with the prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


@pulumi.input_type
class ServiceDnsEntryArgs:
    def __init__(__self__, *,
                 domain_name: Optional[pulumi.Input[str]] = None,
                 hosted_zone_id: Optional[pulumi.Input[str]] = None):
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if hosted_zone_id is not None:
            pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "hosted_zone_id")

    @hosted_zone_id.setter
    def hosted_zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hosted_zone_id", value)


@pulumi.input_type
class ServiceNetworkServiceAssociationDnsEntryArgs:
    def __init__(__self__, *,
                 domain_name: Optional[pulumi.Input[str]] = None,
                 hosted_zone_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] domain_name: The domain name of the service.
        :param pulumi.Input[str] hosted_zone_id: The ID of the hosted zone.
        """
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if hosted_zone_id is not None:
            pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        The domain name of the service.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the hosted zone.
        """
        return pulumi.get(self, "hosted_zone_id")

    @hosted_zone_id.setter
    def hosted_zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hosted_zone_id", value)


@pulumi.input_type
class TargetGroupAttachmentTargetArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] id: The ID of the target. If the target type of the target group is INSTANCE, this is an instance ID. If the target type is IP , this is an IP address. If the target type is LAMBDA, this is the ARN of the Lambda function. If the target type is ALB, this is the ARN of the Application Load Balancer.
        :param pulumi.Input[int] port: This port is used for routing traffic to the target, and defaults to the target group port. However, you can override the default and specify a custom port.
        """
        pulumi.set(__self__, "id", id)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the target. If the target type of the target group is INSTANCE, this is an instance ID. If the target type is IP , this is an IP address. If the target type is LAMBDA, this is the ARN of the Lambda function. If the target type is ALB, this is the ARN of the Application Load Balancer.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        This port is used for routing traffic to the target, and defaults to the target group port. However, you can override the default and specify a custom port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class TargetGroupConfigArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 vpc_identifier: pulumi.Input[str],
                 health_check: Optional[pulumi.Input['TargetGroupConfigHealthCheckArgs']] = None,
                 ip_address_type: Optional[pulumi.Input[str]] = None,
                 protocol_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] port: The port on which the targets are listening.
        :param pulumi.Input[str] protocol: The protocol to use for routing traffic to the targets. Valid Values are `HTTP` | `HTTPS`
        :param pulumi.Input[str] vpc_identifier: The ID of the VPC.
        :param pulumi.Input['TargetGroupConfigHealthCheckArgs'] health_check: The health check configuration.
        :param pulumi.Input[str] ip_address_type: The type of IP address used for the target group. Valid values: `IPV4` | `IPV6`
        :param pulumi.Input[str] protocol_version: The protocol version. Valid Values are `HTTP1` | `HTTP2` | `GRPC`. Default value is `HTTP1`.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "vpc_identifier", vpc_identifier)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if protocol_version is not None:
            pulumi.set(__self__, "protocol_version", protocol_version)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The port on which the targets are listening.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The protocol to use for routing traffic to the targets. Valid Values are `HTTP` | `HTTPS`
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="vpcIdentifier")
    def vpc_identifier(self) -> pulumi.Input[str]:
        """
        The ID of the VPC.
        """
        return pulumi.get(self, "vpc_identifier")

    @vpc_identifier.setter
    def vpc_identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "vpc_identifier", value)

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[pulumi.Input['TargetGroupConfigHealthCheckArgs']]:
        """
        The health check configuration.
        """
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[pulumi.Input['TargetGroupConfigHealthCheckArgs']]):
        pulumi.set(self, "health_check", value)

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of IP address used for the target group. Valid values: `IPV4` | `IPV6`
        """
        return pulumi.get(self, "ip_address_type")

    @ip_address_type.setter
    def ip_address_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address_type", value)

    @property
    @pulumi.getter(name="protocolVersion")
    def protocol_version(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol version. Valid Values are `HTTP1` | `HTTP2` | `GRPC`. Default value is `HTTP1`.
        """
        return pulumi.get(self, "protocol_version")

    @protocol_version.setter
    def protocol_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol_version", value)


@pulumi.input_type
class TargetGroupConfigHealthCheckArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 health_check_interval_seconds: Optional[pulumi.Input[int]] = None,
                 health_check_timeout_seconds: Optional[pulumi.Input[int]] = None,
                 healthy_threshold_count: Optional[pulumi.Input[int]] = None,
                 matcher: Optional[pulumi.Input['TargetGroupConfigHealthCheckMatcherArgs']] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 protocol_version: Optional[pulumi.Input[str]] = None,
                 unhealthy_threshold_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Indicates whether health checking is enabled. Defaults to `true`.
        :param pulumi.Input[int] health_check_interval_seconds: The approximate amount of time, in seconds, between health checks of an individual target. The range is 5–300 seconds. The default is 30 seconds.
        :param pulumi.Input[int] health_check_timeout_seconds: The amount of time, in seconds, to wait before reporting a target as unhealthy. The range is 1–120 seconds. The default is 5 seconds.
               * `healthy_threshold_count ` - (Optional) The number of consecutive successful health checks required before considering an unhealthy target healthy. The range is 2–10. The default is 5.
        :param pulumi.Input['TargetGroupConfigHealthCheckMatcherArgs'] matcher: The codes to use when checking for a successful response from a target. These are called _Success codes_ in the console.
        :param pulumi.Input[str] path: The destination for health checks on the targets. If the protocol version is HTTP/1.1 or HTTP/2, specify a valid URI (for example, /path?query). The default path is `/`. Health checks are not supported if the protocol version is gRPC, however, you can choose HTTP/1.1 or HTTP/2 and specify a valid URI.
        :param pulumi.Input[int] port: The port used when performing health checks on targets. The default setting is the port that a target receives traffic on.
        :param pulumi.Input[str] protocol: The protocol used when performing health checks on targets. The possible protocols are `HTTP` and `HTTPS`.
        :param pulumi.Input[str] protocol_version: The protocol version used when performing health checks on targets. The possible protocol versions are `HTTP1` and `HTTP2`. The default is `HTTP1`.
        :param pulumi.Input[int] unhealthy_threshold_count: The number of consecutive failed health checks required before considering a target unhealthy. The range is 2–10. The default is 2.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if health_check_interval_seconds is not None:
            pulumi.set(__self__, "health_check_interval_seconds", health_check_interval_seconds)
        if health_check_timeout_seconds is not None:
            pulumi.set(__self__, "health_check_timeout_seconds", health_check_timeout_seconds)
        if healthy_threshold_count is not None:
            pulumi.set(__self__, "healthy_threshold_count", healthy_threshold_count)
        if matcher is not None:
            pulumi.set(__self__, "matcher", matcher)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if protocol_version is not None:
            pulumi.set(__self__, "protocol_version", protocol_version)
        if unhealthy_threshold_count is not None:
            pulumi.set(__self__, "unhealthy_threshold_count", unhealthy_threshold_count)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether health checking is enabled. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="healthCheckIntervalSeconds")
    def health_check_interval_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The approximate amount of time, in seconds, between health checks of an individual target. The range is 5–300 seconds. The default is 30 seconds.
        """
        return pulumi.get(self, "health_check_interval_seconds")

    @health_check_interval_seconds.setter
    def health_check_interval_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_interval_seconds", value)

    @property
    @pulumi.getter(name="healthCheckTimeoutSeconds")
    def health_check_timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, to wait before reporting a target as unhealthy. The range is 1–120 seconds. The default is 5 seconds.
        * `healthy_threshold_count ` - (Optional) The number of consecutive successful health checks required before considering an unhealthy target healthy. The range is 2–10. The default is 5.
        """
        return pulumi.get(self, "health_check_timeout_seconds")

    @health_check_timeout_seconds.setter
    def health_check_timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_timeout_seconds", value)

    @property
    @pulumi.getter(name="healthyThresholdCount")
    def healthy_threshold_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "healthy_threshold_count")

    @healthy_threshold_count.setter
    def healthy_threshold_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "healthy_threshold_count", value)

    @property
    @pulumi.getter
    def matcher(self) -> Optional[pulumi.Input['TargetGroupConfigHealthCheckMatcherArgs']]:
        """
        The codes to use when checking for a successful response from a target. These are called _Success codes_ in the console.
        """
        return pulumi.get(self, "matcher")

    @matcher.setter
    def matcher(self, value: Optional[pulumi.Input['TargetGroupConfigHealthCheckMatcherArgs']]):
        pulumi.set(self, "matcher", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The destination for health checks on the targets. If the protocol version is HTTP/1.1 or HTTP/2, specify a valid URI (for example, /path?query). The default path is `/`. Health checks are not supported if the protocol version is gRPC, however, you can choose HTTP/1.1 or HTTP/2 and specify a valid URI.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port used when performing health checks on targets. The default setting is the port that a target receives traffic on.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol used when performing health checks on targets. The possible protocols are `HTTP` and `HTTPS`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="protocolVersion")
    def protocol_version(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol version used when performing health checks on targets. The possible protocol versions are `HTTP1` and `HTTP2`. The default is `HTTP1`.
        """
        return pulumi.get(self, "protocol_version")

    @protocol_version.setter
    def protocol_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol_version", value)

    @property
    @pulumi.getter(name="unhealthyThresholdCount")
    def unhealthy_threshold_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of consecutive failed health checks required before considering a target unhealthy. The range is 2–10. The default is 2.
        """
        return pulumi.get(self, "unhealthy_threshold_count")

    @unhealthy_threshold_count.setter
    def unhealthy_threshold_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unhealthy_threshold_count", value)


@pulumi.input_type
class TargetGroupConfigHealthCheckMatcherArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: The HTTP codes to use when checking for a successful response from a target.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP codes to use when checking for a successful response from a target.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


