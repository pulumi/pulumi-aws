# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ListenerDefaultActionArgs',
    'ListenerDefaultActionArgsDict',
    'ListenerDefaultActionFixedResponseArgs',
    'ListenerDefaultActionFixedResponseArgsDict',
    'ListenerDefaultActionForwardArgs',
    'ListenerDefaultActionForwardArgsDict',
    'ListenerDefaultActionForwardTargetGroupArgs',
    'ListenerDefaultActionForwardTargetGroupArgsDict',
    'ListenerRuleActionArgs',
    'ListenerRuleActionArgsDict',
    'ListenerRuleActionFixedResponseArgs',
    'ListenerRuleActionFixedResponseArgsDict',
    'ListenerRuleActionForwardArgs',
    'ListenerRuleActionForwardArgsDict',
    'ListenerRuleActionForwardTargetGroupArgs',
    'ListenerRuleActionForwardTargetGroupArgsDict',
    'ListenerRuleMatchArgs',
    'ListenerRuleMatchArgsDict',
    'ListenerRuleMatchHttpMatchArgs',
    'ListenerRuleMatchHttpMatchArgsDict',
    'ListenerRuleMatchHttpMatchHeaderMatchArgs',
    'ListenerRuleMatchHttpMatchHeaderMatchArgsDict',
    'ListenerRuleMatchHttpMatchHeaderMatchMatchArgs',
    'ListenerRuleMatchHttpMatchHeaderMatchMatchArgsDict',
    'ListenerRuleMatchHttpMatchPathMatchArgs',
    'ListenerRuleMatchHttpMatchPathMatchArgsDict',
    'ListenerRuleMatchHttpMatchPathMatchMatchArgs',
    'ListenerRuleMatchHttpMatchPathMatchMatchArgsDict',
    'ResourceConfigurationResourceConfigurationDefinitionArgs',
    'ResourceConfigurationResourceConfigurationDefinitionArgsDict',
    'ResourceConfigurationResourceConfigurationDefinitionArnResourceArgs',
    'ResourceConfigurationResourceConfigurationDefinitionArnResourceArgsDict',
    'ResourceConfigurationResourceConfigurationDefinitionDnsResourceArgs',
    'ResourceConfigurationResourceConfigurationDefinitionDnsResourceArgsDict',
    'ResourceConfigurationResourceConfigurationDefinitionIpResourceArgs',
    'ResourceConfigurationResourceConfigurationDefinitionIpResourceArgsDict',
    'ResourceConfigurationTimeoutsArgs',
    'ResourceConfigurationTimeoutsArgsDict',
    'ResourceGatewayTimeoutsArgs',
    'ResourceGatewayTimeoutsArgsDict',
    'ServiceDnsEntryArgs',
    'ServiceDnsEntryArgsDict',
    'ServiceNetworkResourceAssociationDnsEntryArgs',
    'ServiceNetworkResourceAssociationDnsEntryArgsDict',
    'ServiceNetworkResourceAssociationTimeoutsArgs',
    'ServiceNetworkResourceAssociationTimeoutsArgsDict',
    'ServiceNetworkServiceAssociationDnsEntryArgs',
    'ServiceNetworkServiceAssociationDnsEntryArgsDict',
    'ServiceNetworkVpcAssociationDnsOptionsArgs',
    'ServiceNetworkVpcAssociationDnsOptionsArgsDict',
    'TargetGroupAttachmentTargetArgs',
    'TargetGroupAttachmentTargetArgsDict',
    'TargetGroupConfigArgs',
    'TargetGroupConfigArgsDict',
    'TargetGroupConfigHealthCheckArgs',
    'TargetGroupConfigHealthCheckArgsDict',
    'TargetGroupConfigHealthCheckMatcherArgs',
    'TargetGroupConfigHealthCheckMatcherArgsDict',
]

MYPY = False

if not MYPY:
    class ListenerDefaultActionArgsDict(TypedDict):
        fixed_response: NotRequired[pulumi.Input['ListenerDefaultActionFixedResponseArgsDict']]
        forwards: NotRequired[pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardArgsDict']]]]
elif False:
    ListenerDefaultActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerDefaultActionArgs:
    def __init__(__self__, *,
                 fixed_response: Optional[pulumi.Input['ListenerDefaultActionFixedResponseArgs']] = None,
                 forwards: Optional[pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardArgs']]]] = None):
        if fixed_response is not None:
            pulumi.set(__self__, "fixed_response", fixed_response)
        if forwards is not None:
            pulumi.set(__self__, "forwards", forwards)

    @_builtins.property
    @pulumi.getter(name="fixedResponse")
    def fixed_response(self) -> Optional[pulumi.Input['ListenerDefaultActionFixedResponseArgs']]:
        return pulumi.get(self, "fixed_response")

    @fixed_response.setter
    def fixed_response(self, value: Optional[pulumi.Input['ListenerDefaultActionFixedResponseArgs']]):
        pulumi.set(self, "fixed_response", value)

    @_builtins.property
    @pulumi.getter
    def forwards(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardArgs']]]]:
        return pulumi.get(self, "forwards")

    @forwards.setter
    def forwards(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardArgs']]]]):
        pulumi.set(self, "forwards", value)


if not MYPY:
    class ListenerDefaultActionFixedResponseArgsDict(TypedDict):
        status_code: pulumi.Input[_builtins.int]
elif False:
    ListenerDefaultActionFixedResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerDefaultActionFixedResponseArgs:
    def __init__(__self__, *,
                 status_code: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "status_code", status_code)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class ListenerDefaultActionForwardArgsDict(TypedDict):
        target_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardTargetGroupArgsDict']]]]
elif False:
    ListenerDefaultActionForwardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerDefaultActionForwardArgs:
    def __init__(__self__, *,
                 target_groups: Optional[pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardTargetGroupArgs']]]] = None):
        if target_groups is not None:
            pulumi.set(__self__, "target_groups", target_groups)

    @_builtins.property
    @pulumi.getter(name="targetGroups")
    def target_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardTargetGroupArgs']]]]:
        return pulumi.get(self, "target_groups")

    @target_groups.setter
    def target_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ListenerDefaultActionForwardTargetGroupArgs']]]]):
        pulumi.set(self, "target_groups", value)


if not MYPY:
    class ListenerDefaultActionForwardTargetGroupArgsDict(TypedDict):
        target_group_identifier: NotRequired[pulumi.Input[_builtins.str]]
        weight: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ListenerDefaultActionForwardTargetGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerDefaultActionForwardTargetGroupArgs:
    def __init__(__self__, *,
                 target_group_identifier: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        if target_group_identifier is not None:
            pulumi.set(__self__, "target_group_identifier", target_group_identifier)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="targetGroupIdentifier")
    def target_group_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "target_group_identifier")

    @target_group_identifier.setter
    def target_group_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_group_identifier", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class ListenerRuleActionArgsDict(TypedDict):
        fixed_response: NotRequired[pulumi.Input['ListenerRuleActionFixedResponseArgsDict']]
        forward: NotRequired[pulumi.Input['ListenerRuleActionForwardArgsDict']]
elif False:
    ListenerRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerRuleActionArgs:
    def __init__(__self__, *,
                 fixed_response: Optional[pulumi.Input['ListenerRuleActionFixedResponseArgs']] = None,
                 forward: Optional[pulumi.Input['ListenerRuleActionForwardArgs']] = None):
        if fixed_response is not None:
            pulumi.set(__self__, "fixed_response", fixed_response)
        if forward is not None:
            pulumi.set(__self__, "forward", forward)

    @_builtins.property
    @pulumi.getter(name="fixedResponse")
    def fixed_response(self) -> Optional[pulumi.Input['ListenerRuleActionFixedResponseArgs']]:
        return pulumi.get(self, "fixed_response")

    @fixed_response.setter
    def fixed_response(self, value: Optional[pulumi.Input['ListenerRuleActionFixedResponseArgs']]):
        pulumi.set(self, "fixed_response", value)

    @_builtins.property
    @pulumi.getter
    def forward(self) -> Optional[pulumi.Input['ListenerRuleActionForwardArgs']]:
        return pulumi.get(self, "forward")

    @forward.setter
    def forward(self, value: Optional[pulumi.Input['ListenerRuleActionForwardArgs']]):
        pulumi.set(self, "forward", value)


if not MYPY:
    class ListenerRuleActionFixedResponseArgsDict(TypedDict):
        status_code: pulumi.Input[_builtins.int]
elif False:
    ListenerRuleActionFixedResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerRuleActionFixedResponseArgs:
    def __init__(__self__, *,
                 status_code: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "status_code", status_code)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class ListenerRuleActionForwardArgsDict(TypedDict):
        target_groups: pulumi.Input[Sequence[pulumi.Input['ListenerRuleActionForwardTargetGroupArgsDict']]]
elif False:
    ListenerRuleActionForwardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerRuleActionForwardArgs:
    def __init__(__self__, *,
                 target_groups: pulumi.Input[Sequence[pulumi.Input['ListenerRuleActionForwardTargetGroupArgs']]]):
        pulumi.set(__self__, "target_groups", target_groups)

    @_builtins.property
    @pulumi.getter(name="targetGroups")
    def target_groups(self) -> pulumi.Input[Sequence[pulumi.Input['ListenerRuleActionForwardTargetGroupArgs']]]:
        return pulumi.get(self, "target_groups")

    @target_groups.setter
    def target_groups(self, value: pulumi.Input[Sequence[pulumi.Input['ListenerRuleActionForwardTargetGroupArgs']]]):
        pulumi.set(self, "target_groups", value)


if not MYPY:
    class ListenerRuleActionForwardTargetGroupArgsDict(TypedDict):
        target_group_identifier: pulumi.Input[_builtins.str]
        weight: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ListenerRuleActionForwardTargetGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerRuleActionForwardTargetGroupArgs:
    def __init__(__self__, *,
                 target_group_identifier: pulumi.Input[_builtins.str],
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "target_group_identifier", target_group_identifier)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="targetGroupIdentifier")
    def target_group_identifier(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target_group_identifier")

    @target_group_identifier.setter
    def target_group_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_group_identifier", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class ListenerRuleMatchArgsDict(TypedDict):
        http_match: pulumi.Input['ListenerRuleMatchHttpMatchArgsDict']
elif False:
    ListenerRuleMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerRuleMatchArgs:
    def __init__(__self__, *,
                 http_match: pulumi.Input['ListenerRuleMatchHttpMatchArgs']):
        pulumi.set(__self__, "http_match", http_match)

    @_builtins.property
    @pulumi.getter(name="httpMatch")
    def http_match(self) -> pulumi.Input['ListenerRuleMatchHttpMatchArgs']:
        return pulumi.get(self, "http_match")

    @http_match.setter
    def http_match(self, value: pulumi.Input['ListenerRuleMatchHttpMatchArgs']):
        pulumi.set(self, "http_match", value)


if not MYPY:
    class ListenerRuleMatchHttpMatchArgsDict(TypedDict):
        header_matches: NotRequired[pulumi.Input[Sequence[pulumi.Input['ListenerRuleMatchHttpMatchHeaderMatchArgsDict']]]]
        method: NotRequired[pulumi.Input[_builtins.str]]
        path_match: NotRequired[pulumi.Input['ListenerRuleMatchHttpMatchPathMatchArgsDict']]
elif False:
    ListenerRuleMatchHttpMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerRuleMatchHttpMatchArgs:
    def __init__(__self__, *,
                 header_matches: Optional[pulumi.Input[Sequence[pulumi.Input['ListenerRuleMatchHttpMatchHeaderMatchArgs']]]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 path_match: Optional[pulumi.Input['ListenerRuleMatchHttpMatchPathMatchArgs']] = None):
        if header_matches is not None:
            pulumi.set(__self__, "header_matches", header_matches)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if path_match is not None:
            pulumi.set(__self__, "path_match", path_match)

    @_builtins.property
    @pulumi.getter(name="headerMatches")
    def header_matches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ListenerRuleMatchHttpMatchHeaderMatchArgs']]]]:
        return pulumi.get(self, "header_matches")

    @header_matches.setter
    def header_matches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ListenerRuleMatchHttpMatchHeaderMatchArgs']]]]):
        pulumi.set(self, "header_matches", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="pathMatch")
    def path_match(self) -> Optional[pulumi.Input['ListenerRuleMatchHttpMatchPathMatchArgs']]:
        return pulumi.get(self, "path_match")

    @path_match.setter
    def path_match(self, value: Optional[pulumi.Input['ListenerRuleMatchHttpMatchPathMatchArgs']]):
        pulumi.set(self, "path_match", value)


if not MYPY:
    class ListenerRuleMatchHttpMatchHeaderMatchArgsDict(TypedDict):
        match: pulumi.Input['ListenerRuleMatchHttpMatchHeaderMatchMatchArgsDict']
        name: pulumi.Input[_builtins.str]
        case_sensitive: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ListenerRuleMatchHttpMatchHeaderMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerRuleMatchHttpMatchHeaderMatchArgs:
    def __init__(__self__, *,
                 match: pulumi.Input['ListenerRuleMatchHttpMatchHeaderMatchMatchArgs'],
                 name: pulumi.Input[_builtins.str],
                 case_sensitive: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "name", name)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @_builtins.property
    @pulumi.getter
    def match(self) -> pulumi.Input['ListenerRuleMatchHttpMatchHeaderMatchMatchArgs']:
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input['ListenerRuleMatchHttpMatchHeaderMatchMatchArgs']):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "case_sensitive", value)


if not MYPY:
    class ListenerRuleMatchHttpMatchHeaderMatchMatchArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        exact: NotRequired[pulumi.Input[_builtins.str]]
        prefix: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ListenerRuleMatchHttpMatchHeaderMatchMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerRuleMatchHttpMatchHeaderMatchMatchArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class ListenerRuleMatchHttpMatchPathMatchArgsDict(TypedDict):
        match: pulumi.Input['ListenerRuleMatchHttpMatchPathMatchMatchArgsDict']
        case_sensitive: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ListenerRuleMatchHttpMatchPathMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerRuleMatchHttpMatchPathMatchArgs:
    def __init__(__self__, *,
                 match: pulumi.Input['ListenerRuleMatchHttpMatchPathMatchMatchArgs'],
                 case_sensitive: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "match", match)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @_builtins.property
    @pulumi.getter
    def match(self) -> pulumi.Input['ListenerRuleMatchHttpMatchPathMatchMatchArgs']:
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input['ListenerRuleMatchHttpMatchPathMatchMatchArgs']):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "case_sensitive", value)


if not MYPY:
    class ListenerRuleMatchHttpMatchPathMatchMatchArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[_builtins.str]]
        prefix: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ListenerRuleMatchHttpMatchPathMatchMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerRuleMatchHttpMatchPathMatchMatchArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class ResourceConfigurationResourceConfigurationDefinitionArgsDict(TypedDict):
        arn_resource: NotRequired[pulumi.Input['ResourceConfigurationResourceConfigurationDefinitionArnResourceArgsDict']]
        dns_resource: NotRequired[pulumi.Input['ResourceConfigurationResourceConfigurationDefinitionDnsResourceArgsDict']]
        ip_resource: NotRequired[pulumi.Input['ResourceConfigurationResourceConfigurationDefinitionIpResourceArgsDict']]
elif False:
    ResourceConfigurationResourceConfigurationDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceConfigurationResourceConfigurationDefinitionArgs:
    def __init__(__self__, *,
                 arn_resource: Optional[pulumi.Input['ResourceConfigurationResourceConfigurationDefinitionArnResourceArgs']] = None,
                 dns_resource: Optional[pulumi.Input['ResourceConfigurationResourceConfigurationDefinitionDnsResourceArgs']] = None,
                 ip_resource: Optional[pulumi.Input['ResourceConfigurationResourceConfigurationDefinitionIpResourceArgs']] = None):
        if arn_resource is not None:
            pulumi.set(__self__, "arn_resource", arn_resource)
        if dns_resource is not None:
            pulumi.set(__self__, "dns_resource", dns_resource)
        if ip_resource is not None:
            pulumi.set(__self__, "ip_resource", ip_resource)

    @_builtins.property
    @pulumi.getter(name="arnResource")
    def arn_resource(self) -> Optional[pulumi.Input['ResourceConfigurationResourceConfigurationDefinitionArnResourceArgs']]:
        return pulumi.get(self, "arn_resource")

    @arn_resource.setter
    def arn_resource(self, value: Optional[pulumi.Input['ResourceConfigurationResourceConfigurationDefinitionArnResourceArgs']]):
        pulumi.set(self, "arn_resource", value)

    @_builtins.property
    @pulumi.getter(name="dnsResource")
    def dns_resource(self) -> Optional[pulumi.Input['ResourceConfigurationResourceConfigurationDefinitionDnsResourceArgs']]:
        return pulumi.get(self, "dns_resource")

    @dns_resource.setter
    def dns_resource(self, value: Optional[pulumi.Input['ResourceConfigurationResourceConfigurationDefinitionDnsResourceArgs']]):
        pulumi.set(self, "dns_resource", value)

    @_builtins.property
    @pulumi.getter(name="ipResource")
    def ip_resource(self) -> Optional[pulumi.Input['ResourceConfigurationResourceConfigurationDefinitionIpResourceArgs']]:
        return pulumi.get(self, "ip_resource")

    @ip_resource.setter
    def ip_resource(self, value: Optional[pulumi.Input['ResourceConfigurationResourceConfigurationDefinitionIpResourceArgs']]):
        pulumi.set(self, "ip_resource", value)


if not MYPY:
    class ResourceConfigurationResourceConfigurationDefinitionArnResourceArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
elif False:
    ResourceConfigurationResourceConfigurationDefinitionArnResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceConfigurationResourceConfigurationDefinitionArnResourceArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class ResourceConfigurationResourceConfigurationDefinitionDnsResourceArgsDict(TypedDict):
        domain_name: pulumi.Input[_builtins.str]
        ip_address_type: pulumi.Input[_builtins.str]
elif False:
    ResourceConfigurationResourceConfigurationDefinitionDnsResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceConfigurationResourceConfigurationDefinitionDnsResourceArgs:
    def __init__(__self__, *,
                 domain_name: pulumi.Input[_builtins.str],
                 ip_address_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "ip_address_type", ip_address_type)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain_name", value)

    @_builtins.property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "ip_address_type")

    @ip_address_type.setter
    def ip_address_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_address_type", value)


if not MYPY:
    class ResourceConfigurationResourceConfigurationDefinitionIpResourceArgsDict(TypedDict):
        ip_address: pulumi.Input[_builtins.str]
elif False:
    ResourceConfigurationResourceConfigurationDefinitionIpResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceConfigurationResourceConfigurationDefinitionIpResourceArgs:
    def __init__(__self__, *,
                 ip_address: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "ip_address", ip_address)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_address", value)


if not MYPY:
    class ResourceConfigurationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    ResourceConfigurationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceConfigurationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ResourceGatewayTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    ResourceGatewayTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGatewayTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ServiceDnsEntryArgsDict(TypedDict):
        domain_name: NotRequired[pulumi.Input[_builtins.str]]
        hosted_zone_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ServiceDnsEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceDnsEntryArgs:
    def __init__(__self__, *,
                 domain_name: Optional[pulumi.Input[_builtins.str]] = None,
                 hosted_zone_id: Optional[pulumi.Input[_builtins.str]] = None):
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if hosted_zone_id is not None:
            pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain_name", value)

    @_builtins.property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "hosted_zone_id")

    @hosted_zone_id.setter
    def hosted_zone_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hosted_zone_id", value)


if not MYPY:
    class ServiceNetworkResourceAssociationDnsEntryArgsDict(TypedDict):
        domain_name: pulumi.Input[_builtins.str]
        hosted_zone_id: pulumi.Input[_builtins.str]
elif False:
    ServiceNetworkResourceAssociationDnsEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceNetworkResourceAssociationDnsEntryArgs:
    def __init__(__self__, *,
                 domain_name: pulumi.Input[_builtins.str],
                 hosted_zone_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain_name", value)

    @_builtins.property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "hosted_zone_id")

    @hosted_zone_id.setter
    def hosted_zone_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hosted_zone_id", value)


if not MYPY:
    class ServiceNetworkResourceAssociationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
elif False:
    ServiceNetworkResourceAssociationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceNetworkResourceAssociationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)


if not MYPY:
    class ServiceNetworkServiceAssociationDnsEntryArgsDict(TypedDict):
        domain_name: NotRequired[pulumi.Input[_builtins.str]]
        hosted_zone_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ServiceNetworkServiceAssociationDnsEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceNetworkServiceAssociationDnsEntryArgs:
    def __init__(__self__, *,
                 domain_name: Optional[pulumi.Input[_builtins.str]] = None,
                 hosted_zone_id: Optional[pulumi.Input[_builtins.str]] = None):
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if hosted_zone_id is not None:
            pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain_name", value)

    @_builtins.property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "hosted_zone_id")

    @hosted_zone_id.setter
    def hosted_zone_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hosted_zone_id", value)


if not MYPY:
    class ServiceNetworkVpcAssociationDnsOptionsArgsDict(TypedDict):
        private_dns_preference: NotRequired[pulumi.Input[_builtins.str]]
        private_dns_specified_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ServiceNetworkVpcAssociationDnsOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceNetworkVpcAssociationDnsOptionsArgs:
    def __init__(__self__, *,
                 private_dns_preference: Optional[pulumi.Input[_builtins.str]] = None,
                 private_dns_specified_domains: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if private_dns_preference is not None:
            pulumi.set(__self__, "private_dns_preference", private_dns_preference)
        if private_dns_specified_domains is not None:
            pulumi.set(__self__, "private_dns_specified_domains", private_dns_specified_domains)

    @_builtins.property
    @pulumi.getter(name="privateDnsPreference")
    def private_dns_preference(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "private_dns_preference")

    @private_dns_preference.setter
    def private_dns_preference(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_dns_preference", value)

    @_builtins.property
    @pulumi.getter(name="privateDnsSpecifiedDomains")
    def private_dns_specified_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "private_dns_specified_domains")

    @private_dns_specified_domains.setter
    def private_dns_specified_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "private_dns_specified_domains", value)


if not MYPY:
    class TargetGroupAttachmentTargetArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        port: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    TargetGroupAttachmentTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetGroupAttachmentTargetArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "id", id)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class TargetGroupConfigArgsDict(TypedDict):
        health_check: NotRequired[pulumi.Input['TargetGroupConfigHealthCheckArgsDict']]
        ip_address_type: NotRequired[pulumi.Input[_builtins.str]]
        lambda_event_structure_version: NotRequired[pulumi.Input[_builtins.str]]
        port: NotRequired[pulumi.Input[_builtins.int]]
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        protocol_version: NotRequired[pulumi.Input[_builtins.str]]
        vpc_identifier: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TargetGroupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetGroupConfigArgs:
    def __init__(__self__, *,
                 health_check: Optional[pulumi.Input['TargetGroupConfigHealthCheckArgs']] = None,
                 ip_address_type: Optional[pulumi.Input[_builtins.str]] = None,
                 lambda_event_structure_version: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol_version: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_identifier: Optional[pulumi.Input[_builtins.str]] = None):
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if lambda_event_structure_version is not None:
            pulumi.set(__self__, "lambda_event_structure_version", lambda_event_structure_version)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if protocol_version is not None:
            pulumi.set(__self__, "protocol_version", protocol_version)
        if vpc_identifier is not None:
            pulumi.set(__self__, "vpc_identifier", vpc_identifier)

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[pulumi.Input['TargetGroupConfigHealthCheckArgs']]:
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[pulumi.Input['TargetGroupConfigHealthCheckArgs']]):
        pulumi.set(self, "health_check", value)

    @_builtins.property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip_address_type")

    @ip_address_type.setter
    def ip_address_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address_type", value)

    @_builtins.property
    @pulumi.getter(name="lambdaEventStructureVersion")
    def lambda_event_structure_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "lambda_event_structure_version")

    @lambda_event_structure_version.setter
    def lambda_event_structure_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lambda_event_structure_version", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="protocolVersion")
    def protocol_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "protocol_version")

    @protocol_version.setter
    def protocol_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol_version", value)

    @_builtins.property
    @pulumi.getter(name="vpcIdentifier")
    def vpc_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "vpc_identifier")

    @vpc_identifier.setter
    def vpc_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_identifier", value)


if not MYPY:
    class TargetGroupConfigHealthCheckArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        health_check_interval_seconds: NotRequired[pulumi.Input[_builtins.int]]
        health_check_timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        healthy_threshold_count: NotRequired[pulumi.Input[_builtins.int]]
        matcher: NotRequired[pulumi.Input['TargetGroupConfigHealthCheckMatcherArgsDict']]
        path: NotRequired[pulumi.Input[_builtins.str]]
        port: NotRequired[pulumi.Input[_builtins.int]]
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        protocol_version: NotRequired[pulumi.Input[_builtins.str]]
        unhealthy_threshold_count: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    TargetGroupConfigHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetGroupConfigHealthCheckArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 health_check_interval_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 health_check_timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 healthy_threshold_count: Optional[pulumi.Input[_builtins.int]] = None,
                 matcher: Optional[pulumi.Input['TargetGroupConfigHealthCheckMatcherArgs']] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol_version: Optional[pulumi.Input[_builtins.str]] = None,
                 unhealthy_threshold_count: Optional[pulumi.Input[_builtins.int]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if health_check_interval_seconds is not None:
            pulumi.set(__self__, "health_check_interval_seconds", health_check_interval_seconds)
        if health_check_timeout_seconds is not None:
            pulumi.set(__self__, "health_check_timeout_seconds", health_check_timeout_seconds)
        if healthy_threshold_count is not None:
            pulumi.set(__self__, "healthy_threshold_count", healthy_threshold_count)
        if matcher is not None:
            pulumi.set(__self__, "matcher", matcher)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if protocol_version is not None:
            pulumi.set(__self__, "protocol_version", protocol_version)
        if unhealthy_threshold_count is not None:
            pulumi.set(__self__, "unhealthy_threshold_count", unhealthy_threshold_count)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="healthCheckIntervalSeconds")
    def health_check_interval_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "health_check_interval_seconds")

    @health_check_interval_seconds.setter
    def health_check_interval_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "health_check_interval_seconds", value)

    @_builtins.property
    @pulumi.getter(name="healthCheckTimeoutSeconds")
    def health_check_timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "health_check_timeout_seconds")

    @health_check_timeout_seconds.setter
    def health_check_timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "health_check_timeout_seconds", value)

    @_builtins.property
    @pulumi.getter(name="healthyThresholdCount")
    def healthy_threshold_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "healthy_threshold_count")

    @healthy_threshold_count.setter
    def healthy_threshold_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "healthy_threshold_count", value)

    @_builtins.property
    @pulumi.getter
    def matcher(self) -> Optional[pulumi.Input['TargetGroupConfigHealthCheckMatcherArgs']]:
        return pulumi.get(self, "matcher")

    @matcher.setter
    def matcher(self, value: Optional[pulumi.Input['TargetGroupConfigHealthCheckMatcherArgs']]):
        pulumi.set(self, "matcher", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="protocolVersion")
    def protocol_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "protocol_version")

    @protocol_version.setter
    def protocol_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol_version", value)

    @_builtins.property
    @pulumi.getter(name="unhealthyThresholdCount")
    def unhealthy_threshold_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "unhealthy_threshold_count")

    @unhealthy_threshold_count.setter
    def unhealthy_threshold_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "unhealthy_threshold_count", value)


if not MYPY:
    class TargetGroupConfigHealthCheckMatcherArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TargetGroupConfigHealthCheckMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetGroupConfigHealthCheckMatcherArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


