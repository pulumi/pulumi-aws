# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'RegexPatternSetRegularExpression',
    'RuleGroupCustomResponseBody',
    'RuleGroupRule',
    'RuleGroupRuleAction',
    'RuleGroupRuleActionAllow',
    'RuleGroupRuleActionAllowCustomRequestHandling',
    'RuleGroupRuleActionAllowCustomRequestHandlingInsertHeader',
    'RuleGroupRuleActionBlock',
    'RuleGroupRuleActionBlockCustomResponse',
    'RuleGroupRuleActionBlockCustomResponseResponseHeader',
    'RuleGroupRuleActionCaptcha',
    'RuleGroupRuleActionCaptchaCustomRequestHandling',
    'RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeader',
    'RuleGroupRuleActionChallenge',
    'RuleGroupRuleActionChallengeCustomRequestHandling',
    'RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeader',
    'RuleGroupRuleActionCount',
    'RuleGroupRuleActionCountCustomRequestHandling',
    'RuleGroupRuleActionCountCustomRequestHandlingInsertHeader',
    'RuleGroupRuleCaptchaConfig',
    'RuleGroupRuleCaptchaConfigImmunityTimeProperty',
    'RuleGroupRuleRuleLabel',
    'RuleGroupRuleStatement',
    'RuleGroupRuleStatementAndStatement',
    'RuleGroupRuleStatementByteMatchStatement',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatch',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchBody',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookies',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeader',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchMethod',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementByteMatchStatementTextTransformation',
    'RuleGroupRuleStatementGeoMatchStatement',
    'RuleGroupRuleStatementGeoMatchStatementForwardedIpConfig',
    'RuleGroupRuleStatementIpSetReferenceStatement',
    'RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig',
    'RuleGroupRuleStatementLabelMatchStatement',
    'RuleGroupRuleStatementNotStatement',
    'RuleGroupRuleStatementOrStatement',
    'RuleGroupRuleStatementRateBasedStatement',
    'RuleGroupRuleStatementRateBasedStatementCustomKey',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyCookie',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformation',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIp',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHeader',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethod',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyIp',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespace',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgument',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryString',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyUriPath',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation',
    'RuleGroupRuleStatementRateBasedStatementForwardedIpConfig',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation',
    'RuleGroupRuleStatementRegexMatchStatement',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatch',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchBody',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookies',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeader',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethod',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementRegexMatchStatementTextTransformation',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatement',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatch',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformation',
    'RuleGroupRuleStatementSizeConstraintStatement',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatch',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBody',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookies',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeader',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethod',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementSizeConstraintStatementTextTransformation',
    'RuleGroupRuleStatementSqliMatchStatement',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatch',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchBody',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookies',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeader',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethod',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementSqliMatchStatementTextTransformation',
    'RuleGroupRuleStatementXssMatchStatement',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatch',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchBody',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookies',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeader',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchMethod',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementXssMatchStatementTextTransformation',
    'RuleGroupRuleVisibilityConfig',
    'RuleGroupVisibilityConfig',
    'WebAclAssociationConfig',
    'WebAclAssociationConfigRequestBody',
    'WebAclAssociationConfigRequestBodyCloudfront',
    'WebAclCaptchaConfig',
    'WebAclCaptchaConfigImmunityTimeProperty',
    'WebAclCustomResponseBody',
    'WebAclDefaultAction',
    'WebAclDefaultActionAllow',
    'WebAclDefaultActionAllowCustomRequestHandling',
    'WebAclDefaultActionAllowCustomRequestHandlingInsertHeader',
    'WebAclDefaultActionBlock',
    'WebAclDefaultActionBlockCustomResponse',
    'WebAclDefaultActionBlockCustomResponseResponseHeader',
    'WebAclLoggingConfigurationLoggingFilter',
    'WebAclLoggingConfigurationLoggingFilterFilter',
    'WebAclLoggingConfigurationLoggingFilterFilterCondition',
    'WebAclLoggingConfigurationLoggingFilterFilterConditionActionCondition',
    'WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameCondition',
    'WebAclLoggingConfigurationRedactedField',
    'WebAclLoggingConfigurationRedactedFieldMethod',
    'WebAclLoggingConfigurationRedactedFieldQueryString',
    'WebAclLoggingConfigurationRedactedFieldSingleHeader',
    'WebAclLoggingConfigurationRedactedFieldUriPath',
    'WebAclRule',
    'WebAclRuleAction',
    'WebAclRuleActionAllow',
    'WebAclRuleActionAllowCustomRequestHandling',
    'WebAclRuleActionAllowCustomRequestHandlingInsertHeader',
    'WebAclRuleActionBlock',
    'WebAclRuleActionBlockCustomResponse',
    'WebAclRuleActionBlockCustomResponseResponseHeader',
    'WebAclRuleActionCaptcha',
    'WebAclRuleActionCaptchaCustomRequestHandling',
    'WebAclRuleActionCaptchaCustomRequestHandlingInsertHeader',
    'WebAclRuleActionChallenge',
    'WebAclRuleActionChallengeCustomRequestHandling',
    'WebAclRuleActionChallengeCustomRequestHandlingInsertHeader',
    'WebAclRuleActionCount',
    'WebAclRuleActionCountCustomRequestHandling',
    'WebAclRuleActionCountCustomRequestHandlingInsertHeader',
    'WebAclRuleCaptchaConfig',
    'WebAclRuleCaptchaConfigImmunityTimeProperty',
    'WebAclRuleOverrideAction',
    'WebAclRuleOverrideActionCount',
    'WebAclRuleOverrideActionNone',
    'WebAclRuleRuleLabel',
    'WebAclRuleStatement',
    'WebAclRuleStatementAndStatement',
    'WebAclRuleStatementByteMatchStatement',
    'WebAclRuleStatementByteMatchStatementFieldToMatch',
    'WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementByteMatchStatementFieldToMatchBody',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementByteMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementByteMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementByteMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementByteMatchStatementTextTransformation',
    'WebAclRuleStatementGeoMatchStatement',
    'WebAclRuleStatementGeoMatchStatementForwardedIpConfig',
    'WebAclRuleStatementIpSetReferenceStatement',
    'WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig',
    'WebAclRuleStatementLabelMatchStatement',
    'WebAclRuleStatementManagedRuleGroupStatement',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfig',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSet',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspection',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailField',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordField',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameField',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspection',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContains',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeader',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJson',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCode',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSet',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspection',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordField',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameField',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspection',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContains',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeader',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJson',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCode',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSet',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordField',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameField',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverride',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUse',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllow',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandling',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlock',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponse',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptcha',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallenge',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCount',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandling',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatch',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformation',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfig',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatch',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformation',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatch',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformation',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatch',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformation',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatch',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformation',
    'WebAclRuleStatementNotStatement',
    'WebAclRuleStatementOrStatement',
    'WebAclRuleStatementRateBasedStatement',
    'WebAclRuleStatementRateBasedStatementCustomKey',
    'WebAclRuleStatementRateBasedStatementCustomKeyCookie',
    'WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformation',
    'WebAclRuleStatementRateBasedStatementCustomKeyForwardedIp',
    'WebAclRuleStatementRateBasedStatementCustomKeyHeader',
    'WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation',
    'WebAclRuleStatementRateBasedStatementCustomKeyHttpMethod',
    'WebAclRuleStatementRateBasedStatementCustomKeyIp',
    'WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespace',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryArgument',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryString',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation',
    'WebAclRuleStatementRateBasedStatementCustomKeyUriPath',
    'WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation',
    'WebAclRuleStatementRateBasedStatementForwardedIpConfig',
    'WebAclRuleStatementRateBasedStatementScopeDownStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation',
    'WebAclRuleStatementRegexMatchStatement',
    'WebAclRuleStatementRegexMatchStatementFieldToMatch',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchBody',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementRegexMatchStatementTextTransformation',
    'WebAclRuleStatementRegexPatternSetReferenceStatement',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatch',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath',
    'WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformation',
    'WebAclRuleStatementRuleGroupReferenceStatement',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverride',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUse',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllow',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandling',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlock',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponse',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptcha',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallenge',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCount',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandling',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader',
    'WebAclRuleStatementSizeConstraintStatement',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatch',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchBody',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookies',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeader',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBody',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchMethod',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryString',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPath',
    'WebAclRuleStatementSizeConstraintStatementTextTransformation',
    'WebAclRuleStatementSqliMatchStatement',
    'WebAclRuleStatementSqliMatchStatementFieldToMatch',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchBody',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementSqliMatchStatementTextTransformation',
    'WebAclRuleStatementXssMatchStatement',
    'WebAclRuleStatementXssMatchStatementFieldToMatch',
    'WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementXssMatchStatementFieldToMatchBody',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementXssMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementXssMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementXssMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementXssMatchStatementTextTransformation',
    'WebAclRuleVisibilityConfig',
    'WebAclVisibilityConfig',
    'GetRegexPatternSetRegularExpressionResult',
]

@pulumi.output_type
class RegexPatternSetRegularExpression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regexString":
            suggest = "regex_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegexPatternSetRegularExpression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegexPatternSetRegularExpression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegexPatternSetRegularExpression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regex_string: str):
        """
        :param str regex_string: The string representing the regular expression, see the AWS WAF [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-regex-pattern-set-creating.html) for more information.
        """
        RegexPatternSetRegularExpression._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            regex_string=regex_string,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             regex_string: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if regex_string is None and 'regexString' in kwargs:
            regex_string = kwargs['regexString']
        if regex_string is None:
            raise TypeError("Missing 'regex_string' argument")

        _setter("regex_string", regex_string)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> str:
        """
        The string representing the regular expression, see the AWS WAF [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-regex-pattern-set-creating.html) for more information.
        """
        return pulumi.get(self, "regex_string")


@pulumi.output_type
class RuleGroupCustomResponseBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupCustomResponseBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupCustomResponseBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupCustomResponseBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: str,
                 content_type: str,
                 key: str):
        """
        :param str content: The payload of the custom response.
        :param str content_type: The type of content in the payload that you are defining in the `content` argument. Valid values are `TEXT_PLAIN`, `TEXT_HTML`, or `APPLICATION_JSON`.
        :param str key: A unique key identifying the custom response body. This is referenced by the `custom_response_body_key` argument in the Custom Response block.
        """
        RuleGroupCustomResponseBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content=content,
            content_type=content_type,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content: Optional[str] = None,
             content_type: Optional[str] = None,
             key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if content is None:
            raise TypeError("Missing 'content' argument")
        if content_type is None and 'contentType' in kwargs:
            content_type = kwargs['contentType']
        if content_type is None:
            raise TypeError("Missing 'content_type' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")

        _setter("content", content)
        _setter("content_type", content_type)
        _setter("key", key)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        The payload of the custom response.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> str:
        """
        The type of content in the payload that you are defining in the `content` argument. Valid values are `TEXT_PLAIN`, `TEXT_HTML`, or `APPLICATION_JSON`.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A unique key identifying the custom response body. This is referenced by the `custom_response_body_key` argument in the Custom Response block.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class RuleGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visibilityConfig":
            suggest = "visibility_config"
        elif key == "captchaConfig":
            suggest = "captcha_config"
        elif key == "ruleLabels":
            suggest = "rule_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: 'outputs.RuleGroupRuleAction',
                 name: str,
                 priority: int,
                 statement: 'outputs.RuleGroupRuleStatement',
                 visibility_config: 'outputs.RuleGroupRuleVisibilityConfig',
                 captcha_config: Optional['outputs.RuleGroupRuleCaptchaConfig'] = None,
                 rule_labels: Optional[Sequence['outputs.RuleGroupRuleRuleLabel']] = None):
        """
        :param 'RuleGroupRuleActionArgs' action: The action that AWS WAF should take on a web request when it matches the rule's statement. Settings at the `wafv2.WebAcl` level can override the rule action setting. See Action below for details.
        :param str name: A friendly name of the rule.
        :param int priority: If you define more than one Rule in a WebACL, AWS WAF evaluates each request against the `rules` in order based on the value of `priority`. AWS WAF processes rules with lower priority first.
        :param 'RuleGroupRuleStatementArgs' statement: The AWS WAF processing statement for the rule, for example `byte_match_statement` or `geo_match_statement`. See Statement below for details.
        :param 'RuleGroupRuleVisibilityConfigArgs' visibility_config: Defines and enables Amazon CloudWatch metrics and web request sample collection. See Visibility Configuration below for details.
        :param 'RuleGroupRuleCaptchaConfigArgs' captcha_config: Specifies how AWS WAF should handle CAPTCHA evaluations. See Captcha Configuration below for details.
        :param Sequence['RuleGroupRuleRuleLabelArgs'] rule_labels: Labels to apply to web requests that match the rule match statement. See Rule Label below for details.
        """
        RuleGroupRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            name=name,
            priority=priority,
            statement=statement,
            visibility_config=visibility_config,
            captcha_config=captcha_config,
            rule_labels=rule_labels,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional['outputs.RuleGroupRuleAction'] = None,
             name: Optional[str] = None,
             priority: Optional[int] = None,
             statement: Optional['outputs.RuleGroupRuleStatement'] = None,
             visibility_config: Optional['outputs.RuleGroupRuleVisibilityConfig'] = None,
             captcha_config: Optional['outputs.RuleGroupRuleCaptchaConfig'] = None,
             rule_labels: Optional[Sequence['outputs.RuleGroupRuleRuleLabel']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if statement is None:
            raise TypeError("Missing 'statement' argument")
        if visibility_config is None and 'visibilityConfig' in kwargs:
            visibility_config = kwargs['visibilityConfig']
        if visibility_config is None:
            raise TypeError("Missing 'visibility_config' argument")
        if captcha_config is None and 'captchaConfig' in kwargs:
            captcha_config = kwargs['captchaConfig']
        if rule_labels is None and 'ruleLabels' in kwargs:
            rule_labels = kwargs['ruleLabels']

        _setter("action", action)
        _setter("name", name)
        _setter("priority", priority)
        _setter("statement", statement)
        _setter("visibility_config", visibility_config)
        if captcha_config is not None:
            _setter("captcha_config", captcha_config)
        if rule_labels is not None:
            _setter("rule_labels", rule_labels)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.RuleGroupRuleAction':
        """
        The action that AWS WAF should take on a web request when it matches the rule's statement. Settings at the `wafv2.WebAcl` level can override the rule action setting. See Action below for details.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A friendly name of the rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        If you define more than one Rule in a WebACL, AWS WAF evaluates each request against the `rules` in order based on the value of `priority`. AWS WAF processes rules with lower priority first.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def statement(self) -> 'outputs.RuleGroupRuleStatement':
        """
        The AWS WAF processing statement for the rule, for example `byte_match_statement` or `geo_match_statement`. See Statement below for details.
        """
        return pulumi.get(self, "statement")

    @property
    @pulumi.getter(name="visibilityConfig")
    def visibility_config(self) -> 'outputs.RuleGroupRuleVisibilityConfig':
        """
        Defines and enables Amazon CloudWatch metrics and web request sample collection. See Visibility Configuration below for details.
        """
        return pulumi.get(self, "visibility_config")

    @property
    @pulumi.getter(name="captchaConfig")
    def captcha_config(self) -> Optional['outputs.RuleGroupRuleCaptchaConfig']:
        """
        Specifies how AWS WAF should handle CAPTCHA evaluations. See Captcha Configuration below for details.
        """
        return pulumi.get(self, "captcha_config")

    @property
    @pulumi.getter(name="ruleLabels")
    def rule_labels(self) -> Optional[Sequence['outputs.RuleGroupRuleRuleLabel']]:
        """
        Labels to apply to web requests that match the rule match statement. See Rule Label below for details.
        """
        return pulumi.get(self, "rule_labels")


@pulumi.output_type
class RuleGroupRuleAction(dict):
    def __init__(__self__, *,
                 allow: Optional['outputs.RuleGroupRuleActionAllow'] = None,
                 block: Optional['outputs.RuleGroupRuleActionBlock'] = None,
                 captcha: Optional['outputs.RuleGroupRuleActionCaptcha'] = None,
                 challenge: Optional['outputs.RuleGroupRuleActionChallenge'] = None,
                 count: Optional['outputs.RuleGroupRuleActionCount'] = None):
        """
        :param 'RuleGroupRuleActionAllowArgs' allow: Instructs AWS WAF to allow the web request. See Allow below for details.
        :param 'RuleGroupRuleActionBlockArgs' block: Instructs AWS WAF to block the web request. See Block below for details.
        :param 'RuleGroupRuleActionCaptchaArgs' captcha: Instructs AWS WAF to run a `CAPTCHA` check against the web request. See Captcha below for details.
        :param 'RuleGroupRuleActionChallengeArgs' challenge: Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See Challenge below for details.
        :param 'RuleGroupRuleActionCountArgs' count: Instructs AWS WAF to count the web request and allow it. See Count below for details.
        """
        RuleGroupRuleAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow=allow,
            block=block,
            captcha=captcha,
            challenge=challenge,
            count=count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow: Optional['outputs.RuleGroupRuleActionAllow'] = None,
             block: Optional['outputs.RuleGroupRuleActionBlock'] = None,
             captcha: Optional['outputs.RuleGroupRuleActionCaptcha'] = None,
             challenge: Optional['outputs.RuleGroupRuleActionChallenge'] = None,
             count: Optional['outputs.RuleGroupRuleActionCount'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if allow is not None:
            _setter("allow", allow)
        if block is not None:
            _setter("block", block)
        if captcha is not None:
            _setter("captcha", captcha)
        if challenge is not None:
            _setter("challenge", challenge)
        if count is not None:
            _setter("count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional['outputs.RuleGroupRuleActionAllow']:
        """
        Instructs AWS WAF to allow the web request. See Allow below for details.
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def block(self) -> Optional['outputs.RuleGroupRuleActionBlock']:
        """
        Instructs AWS WAF to block the web request. See Block below for details.
        """
        return pulumi.get(self, "block")

    @property
    @pulumi.getter
    def captcha(self) -> Optional['outputs.RuleGroupRuleActionCaptcha']:
        """
        Instructs AWS WAF to run a `CAPTCHA` check against the web request. See Captcha below for details.
        """
        return pulumi.get(self, "captcha")

    @property
    @pulumi.getter
    def challenge(self) -> Optional['outputs.RuleGroupRuleActionChallenge']:
        """
        Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See Challenge below for details.
        """
        return pulumi.get(self, "challenge")

    @property
    @pulumi.getter
    def count(self) -> Optional['outputs.RuleGroupRuleActionCount']:
        """
        Instructs AWS WAF to count the web request and allow it. See Count below for details.
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class RuleGroupRuleActionAllow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionAllow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionAllow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionAllow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.RuleGroupRuleActionAllowCustomRequestHandling'] = None):
        """
        :param 'RuleGroupRuleActionAllowCustomRequestHandlingArgs' custom_request_handling: Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        RuleGroupRuleActionAllow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.RuleGroupRuleActionAllowCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.RuleGroupRuleActionAllowCustomRequestHandling']:
        """
        Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class RuleGroupRuleActionAllowCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionAllowCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionAllowCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionAllowCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.RuleGroupRuleActionAllowCustomRequestHandlingInsertHeader']):
        """
        :param Sequence['RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgs'] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        RuleGroupRuleActionAllowCustomRequestHandling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insert_headers=insert_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insert_headers: Optional[Sequence['outputs.RuleGroupRuleActionAllowCustomRequestHandlingInsertHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insert_headers is None and 'insertHeaders' in kwargs:
            insert_headers = kwargs['insertHeaders']
        if insert_headers is None:
            raise TypeError("Missing 'insert_headers' argument")

        _setter("insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.RuleGroupRuleActionAllowCustomRequestHandlingInsertHeader']:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class RuleGroupRuleActionAllowCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: A friendly name of the rule group.
        :param str value: The value of the custom header.
        """
        RuleGroupRuleActionAllowCustomRequestHandlingInsertHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleGroupRuleActionBlock(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customResponse":
            suggest = "custom_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionBlock. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionBlock.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionBlock.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_response: Optional['outputs.RuleGroupRuleActionBlockCustomResponse'] = None):
        """
        :param 'RuleGroupRuleActionBlockCustomResponseArgs' custom_response: Defines a custom response for the web request. See Custom Response below for details.
        """
        RuleGroupRuleActionBlock._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_response=custom_response,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_response: Optional['outputs.RuleGroupRuleActionBlockCustomResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_response is None and 'customResponse' in kwargs:
            custom_response = kwargs['customResponse']

        if custom_response is not None:
            _setter("custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional['outputs.RuleGroupRuleActionBlockCustomResponse']:
        """
        Defines a custom response for the web request. See Custom Response below for details.
        """
        return pulumi.get(self, "custom_response")


@pulumi.output_type
class RuleGroupRuleActionBlockCustomResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseCode":
            suggest = "response_code"
        elif key == "customResponseBodyKey":
            suggest = "custom_response_body_key"
        elif key == "responseHeaders":
            suggest = "response_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionBlockCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionBlockCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionBlockCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_code: int,
                 custom_response_body_key: Optional[str] = None,
                 response_headers: Optional[Sequence['outputs.RuleGroupRuleActionBlockCustomResponseResponseHeader']] = None):
        """
        :param int response_code: The HTTP status code to return to the client.
        :param str custom_response_body_key: References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        :param Sequence['RuleGroupRuleActionBlockCustomResponseResponseHeaderArgs'] response_headers: The `response_header` blocks used to define the HTTP response headers added to the response. See Custom HTTP Header below for details.
        """
        RuleGroupRuleActionBlockCustomResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            response_code=response_code,
            custom_response_body_key=custom_response_body_key,
            response_headers=response_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             response_code: Optional[int] = None,
             custom_response_body_key: Optional[str] = None,
             response_headers: Optional[Sequence['outputs.RuleGroupRuleActionBlockCustomResponseResponseHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if response_code is None and 'responseCode' in kwargs:
            response_code = kwargs['responseCode']
        if response_code is None:
            raise TypeError("Missing 'response_code' argument")
        if custom_response_body_key is None and 'customResponseBodyKey' in kwargs:
            custom_response_body_key = kwargs['customResponseBodyKey']
        if response_headers is None and 'responseHeaders' in kwargs:
            response_headers = kwargs['responseHeaders']

        _setter("response_code", response_code)
        if custom_response_body_key is not None:
            _setter("custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            _setter("response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> int:
        """
        The HTTP status code to return to the client.
        """
        return pulumi.get(self, "response_code")

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[str]:
        """
        References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        """
        return pulumi.get(self, "custom_response_body_key")

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[Sequence['outputs.RuleGroupRuleActionBlockCustomResponseResponseHeader']]:
        """
        The `response_header` blocks used to define the HTTP response headers added to the response. See Custom HTTP Header below for details.
        """
        return pulumi.get(self, "response_headers")


@pulumi.output_type
class RuleGroupRuleActionBlockCustomResponseResponseHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: A friendly name of the rule group.
        :param str value: The value of the custom header.
        """
        RuleGroupRuleActionBlockCustomResponseResponseHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleGroupRuleActionCaptcha(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionCaptcha. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionCaptcha.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionCaptcha.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.RuleGroupRuleActionCaptchaCustomRequestHandling'] = None):
        """
        :param 'RuleGroupRuleActionCaptchaCustomRequestHandlingArgs' custom_request_handling: Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        RuleGroupRuleActionCaptcha._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.RuleGroupRuleActionCaptchaCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.RuleGroupRuleActionCaptchaCustomRequestHandling']:
        """
        Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class RuleGroupRuleActionCaptchaCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionCaptchaCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionCaptchaCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionCaptchaCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeader']):
        """
        :param Sequence['RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs'] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        RuleGroupRuleActionCaptchaCustomRequestHandling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insert_headers=insert_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insert_headers: Optional[Sequence['outputs.RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insert_headers is None and 'insertHeaders' in kwargs:
            insert_headers = kwargs['insertHeaders']
        if insert_headers is None:
            raise TypeError("Missing 'insert_headers' argument")

        _setter("insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeader']:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: A friendly name of the rule group.
        :param str value: The value of the custom header.
        """
        RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleGroupRuleActionChallenge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionChallenge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionChallenge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionChallenge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.RuleGroupRuleActionChallengeCustomRequestHandling'] = None):
        """
        :param 'RuleGroupRuleActionChallengeCustomRequestHandlingArgs' custom_request_handling: Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        RuleGroupRuleActionChallenge._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.RuleGroupRuleActionChallengeCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.RuleGroupRuleActionChallengeCustomRequestHandling']:
        """
        Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class RuleGroupRuleActionChallengeCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionChallengeCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionChallengeCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionChallengeCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeader']):
        """
        :param Sequence['RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgs'] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        RuleGroupRuleActionChallengeCustomRequestHandling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insert_headers=insert_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insert_headers: Optional[Sequence['outputs.RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insert_headers is None and 'insertHeaders' in kwargs:
            insert_headers = kwargs['insertHeaders']
        if insert_headers is None:
            raise TypeError("Missing 'insert_headers' argument")

        _setter("insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeader']:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: A friendly name of the rule group.
        :param str value: The value of the custom header.
        """
        RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleGroupRuleActionCount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionCount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionCount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionCount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.RuleGroupRuleActionCountCustomRequestHandling'] = None):
        """
        :param 'RuleGroupRuleActionCountCustomRequestHandlingArgs' custom_request_handling: Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        RuleGroupRuleActionCount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.RuleGroupRuleActionCountCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.RuleGroupRuleActionCountCustomRequestHandling']:
        """
        Defines custom handling for the web request. See Custom Request Handling below for details.
        """
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class RuleGroupRuleActionCountCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionCountCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionCountCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionCountCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.RuleGroupRuleActionCountCustomRequestHandlingInsertHeader']):
        """
        :param Sequence['RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgs'] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        RuleGroupRuleActionCountCustomRequestHandling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insert_headers=insert_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insert_headers: Optional[Sequence['outputs.RuleGroupRuleActionCountCustomRequestHandlingInsertHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insert_headers is None and 'insertHeaders' in kwargs:
            insert_headers = kwargs['insertHeaders']
        if insert_headers is None:
            raise TypeError("Missing 'insert_headers' argument")

        _setter("insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.RuleGroupRuleActionCountCustomRequestHandlingInsertHeader']:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See Custom HTTP Header below for details.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class RuleGroupRuleActionCountCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: A friendly name of the rule group.
        :param str value: The value of the custom header.
        """
        RuleGroupRuleActionCountCustomRequestHandlingInsertHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleGroupRuleCaptchaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTimeProperty":
            suggest = "immunity_time_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleCaptchaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleCaptchaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleCaptchaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time_property: Optional['outputs.RuleGroupRuleCaptchaConfigImmunityTimeProperty'] = None):
        """
        :param 'RuleGroupRuleCaptchaConfigImmunityTimePropertyArgs' immunity_time_property: Defines custom immunity time. See Immunity Time Property below for details.
        """
        RuleGroupRuleCaptchaConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            immunity_time_property=immunity_time_property,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             immunity_time_property: Optional['outputs.RuleGroupRuleCaptchaConfigImmunityTimeProperty'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if immunity_time_property is None and 'immunityTimeProperty' in kwargs:
            immunity_time_property = kwargs['immunityTimeProperty']

        if immunity_time_property is not None:
            _setter("immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional['outputs.RuleGroupRuleCaptchaConfigImmunityTimeProperty']:
        """
        Defines custom immunity time. See Immunity Time Property below for details.
        """
        return pulumi.get(self, "immunity_time_property")


@pulumi.output_type
class RuleGroupRuleCaptchaConfigImmunityTimeProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTime":
            suggest = "immunity_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleCaptchaConfigImmunityTimeProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleCaptchaConfigImmunityTimeProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleCaptchaConfigImmunityTimeProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time: Optional[int] = None):
        """
        :param int immunity_time: The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        RuleGroupRuleCaptchaConfigImmunityTimeProperty._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            immunity_time=immunity_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             immunity_time: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if immunity_time is None and 'immunityTime' in kwargs:
            immunity_time = kwargs['immunityTime']

        if immunity_time is not None:
            _setter("immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[int]:
        """
        The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        return pulumi.get(self, "immunity_time")


@pulumi.output_type
class RuleGroupRuleRuleLabel(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The label string.
        """
        RuleGroupRuleRuleLabel._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The label string.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andStatement":
            suggest = "and_statement"
        elif key == "byteMatchStatement":
            suggest = "byte_match_statement"
        elif key == "geoMatchStatement":
            suggest = "geo_match_statement"
        elif key == "ipSetReferenceStatement":
            suggest = "ip_set_reference_statement"
        elif key == "labelMatchStatement":
            suggest = "label_match_statement"
        elif key == "notStatement":
            suggest = "not_statement"
        elif key == "orStatement":
            suggest = "or_statement"
        elif key == "rateBasedStatement":
            suggest = "rate_based_statement"
        elif key == "regexMatchStatement":
            suggest = "regex_match_statement"
        elif key == "regexPatternSetReferenceStatement":
            suggest = "regex_pattern_set_reference_statement"
        elif key == "sizeConstraintStatement":
            suggest = "size_constraint_statement"
        elif key == "sqliMatchStatement":
            suggest = "sqli_match_statement"
        elif key == "xssMatchStatement":
            suggest = "xss_match_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_statement: Optional['outputs.RuleGroupRuleStatementAndStatement'] = None,
                 byte_match_statement: Optional['outputs.RuleGroupRuleStatementByteMatchStatement'] = None,
                 geo_match_statement: Optional['outputs.RuleGroupRuleStatementGeoMatchStatement'] = None,
                 ip_set_reference_statement: Optional['outputs.RuleGroupRuleStatementIpSetReferenceStatement'] = None,
                 label_match_statement: Optional['outputs.RuleGroupRuleStatementLabelMatchStatement'] = None,
                 not_statement: Optional['outputs.RuleGroupRuleStatementNotStatement'] = None,
                 or_statement: Optional['outputs.RuleGroupRuleStatementOrStatement'] = None,
                 rate_based_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatement'] = None,
                 regex_match_statement: Optional['outputs.RuleGroupRuleStatementRegexMatchStatement'] = None,
                 regex_pattern_set_reference_statement: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatement'] = None,
                 size_constraint_statement: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatement'] = None,
                 sqli_match_statement: Optional['outputs.RuleGroupRuleStatementSqliMatchStatement'] = None,
                 xss_match_statement: Optional['outputs.RuleGroupRuleStatementXssMatchStatement'] = None):
        """
        :param 'RuleGroupRuleStatementAndStatementArgs' and_statement: A logical rule statement used to combine other rule statements with AND logic. See AND Statement below for details.
        :param 'RuleGroupRuleStatementByteMatchStatementArgs' byte_match_statement: A rule statement that defines a string match search for AWS WAF to apply to web requests. See Byte Match Statement below for details.
        :param 'RuleGroupRuleStatementGeoMatchStatementArgs' geo_match_statement: A rule statement used to identify web requests based on country of origin. See GEO Match Statement below for details.
        :param 'RuleGroupRuleStatementIpSetReferenceStatementArgs' ip_set_reference_statement: A rule statement used to detect web requests coming from particular IP addresses or address ranges. See IP Set Reference Statement below for details.
        :param 'RuleGroupRuleStatementLabelMatchStatementArgs' label_match_statement: A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See Label Match Statement below for details.
        :param 'RuleGroupRuleStatementNotStatementArgs' not_statement: A logical rule statement used to negate the results of another rule statement. See NOT Statement below for details.
        :param 'RuleGroupRuleStatementOrStatementArgs' or_statement: A logical rule statement used to combine other rule statements with OR logic. See OR Statement below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementArgs' rate_based_statement: A rate-based rule tracks the rate of requests for each originating `IP address`, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any `5-minute` time span. This statement can not be nested. See Rate Based Statement below for details.
        :param 'RuleGroupRuleStatementRegexMatchStatementArgs' regex_match_statement: A rule statement used to search web request components for a match against a single regular expression. See Regex Match Statement below for details.
        :param 'RuleGroupRuleStatementRegexPatternSetReferenceStatementArgs' regex_pattern_set_reference_statement: A rule statement used to search web request components for matches with regular expressions. See Regex Pattern Set Reference Statement below for details.
        :param 'RuleGroupRuleStatementSizeConstraintStatementArgs' size_constraint_statement: A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See Size Constraint Statement below for more details.
        :param 'RuleGroupRuleStatementSqliMatchStatementArgs' sqli_match_statement: An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See SQL Injection Match Statement below for details.
        :param 'RuleGroupRuleStatementXssMatchStatementArgs' xss_match_statement: A rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See XSS Match Statement below for details.
        """
        RuleGroupRuleStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            and_statement=and_statement,
            byte_match_statement=byte_match_statement,
            geo_match_statement=geo_match_statement,
            ip_set_reference_statement=ip_set_reference_statement,
            label_match_statement=label_match_statement,
            not_statement=not_statement,
            or_statement=or_statement,
            rate_based_statement=rate_based_statement,
            regex_match_statement=regex_match_statement,
            regex_pattern_set_reference_statement=regex_pattern_set_reference_statement,
            size_constraint_statement=size_constraint_statement,
            sqli_match_statement=sqli_match_statement,
            xss_match_statement=xss_match_statement,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             and_statement: Optional['outputs.RuleGroupRuleStatementAndStatement'] = None,
             byte_match_statement: Optional['outputs.RuleGroupRuleStatementByteMatchStatement'] = None,
             geo_match_statement: Optional['outputs.RuleGroupRuleStatementGeoMatchStatement'] = None,
             ip_set_reference_statement: Optional['outputs.RuleGroupRuleStatementIpSetReferenceStatement'] = None,
             label_match_statement: Optional['outputs.RuleGroupRuleStatementLabelMatchStatement'] = None,
             not_statement: Optional['outputs.RuleGroupRuleStatementNotStatement'] = None,
             or_statement: Optional['outputs.RuleGroupRuleStatementOrStatement'] = None,
             rate_based_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatement'] = None,
             regex_match_statement: Optional['outputs.RuleGroupRuleStatementRegexMatchStatement'] = None,
             regex_pattern_set_reference_statement: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatement'] = None,
             size_constraint_statement: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatement'] = None,
             sqli_match_statement: Optional['outputs.RuleGroupRuleStatementSqliMatchStatement'] = None,
             xss_match_statement: Optional['outputs.RuleGroupRuleStatementXssMatchStatement'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if and_statement is None and 'andStatement' in kwargs:
            and_statement = kwargs['andStatement']
        if byte_match_statement is None and 'byteMatchStatement' in kwargs:
            byte_match_statement = kwargs['byteMatchStatement']
        if geo_match_statement is None and 'geoMatchStatement' in kwargs:
            geo_match_statement = kwargs['geoMatchStatement']
        if ip_set_reference_statement is None and 'ipSetReferenceStatement' in kwargs:
            ip_set_reference_statement = kwargs['ipSetReferenceStatement']
        if label_match_statement is None and 'labelMatchStatement' in kwargs:
            label_match_statement = kwargs['labelMatchStatement']
        if not_statement is None and 'notStatement' in kwargs:
            not_statement = kwargs['notStatement']
        if or_statement is None and 'orStatement' in kwargs:
            or_statement = kwargs['orStatement']
        if rate_based_statement is None and 'rateBasedStatement' in kwargs:
            rate_based_statement = kwargs['rateBasedStatement']
        if regex_match_statement is None and 'regexMatchStatement' in kwargs:
            regex_match_statement = kwargs['regexMatchStatement']
        if regex_pattern_set_reference_statement is None and 'regexPatternSetReferenceStatement' in kwargs:
            regex_pattern_set_reference_statement = kwargs['regexPatternSetReferenceStatement']
        if size_constraint_statement is None and 'sizeConstraintStatement' in kwargs:
            size_constraint_statement = kwargs['sizeConstraintStatement']
        if sqli_match_statement is None and 'sqliMatchStatement' in kwargs:
            sqli_match_statement = kwargs['sqliMatchStatement']
        if xss_match_statement is None and 'xssMatchStatement' in kwargs:
            xss_match_statement = kwargs['xssMatchStatement']

        if and_statement is not None:
            _setter("and_statement", and_statement)
        if byte_match_statement is not None:
            _setter("byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            _setter("geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            _setter("ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            _setter("label_match_statement", label_match_statement)
        if not_statement is not None:
            _setter("not_statement", not_statement)
        if or_statement is not None:
            _setter("or_statement", or_statement)
        if rate_based_statement is not None:
            _setter("rate_based_statement", rate_based_statement)
        if regex_match_statement is not None:
            _setter("regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            _setter("regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            _setter("size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            _setter("sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            _setter("xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional['outputs.RuleGroupRuleStatementAndStatement']:
        """
        A logical rule statement used to combine other rule statements with AND logic. See AND Statement below for details.
        """
        return pulumi.get(self, "and_statement")

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatement']:
        """
        A rule statement that defines a string match search for AWS WAF to apply to web requests. See Byte Match Statement below for details.
        """
        return pulumi.get(self, "byte_match_statement")

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementGeoMatchStatement']:
        """
        A rule statement used to identify web requests based on country of origin. See GEO Match Statement below for details.
        """
        return pulumi.get(self, "geo_match_statement")

    @property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional['outputs.RuleGroupRuleStatementIpSetReferenceStatement']:
        """
        A rule statement used to detect web requests coming from particular IP addresses or address ranges. See IP Set Reference Statement below for details.
        """
        return pulumi.get(self, "ip_set_reference_statement")

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementLabelMatchStatement']:
        """
        A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See Label Match Statement below for details.
        """
        return pulumi.get(self, "label_match_statement")

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional['outputs.RuleGroupRuleStatementNotStatement']:
        """
        A logical rule statement used to negate the results of another rule statement. See NOT Statement below for details.
        """
        return pulumi.get(self, "not_statement")

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional['outputs.RuleGroupRuleStatementOrStatement']:
        """
        A logical rule statement used to combine other rule statements with OR logic. See OR Statement below for details.
        """
        return pulumi.get(self, "or_statement")

    @property
    @pulumi.getter(name="rateBasedStatement")
    def rate_based_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatement']:
        """
        A rate-based rule tracks the rate of requests for each originating `IP address`, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any `5-minute` time span. This statement can not be nested. See Rate Based Statement below for details.
        """
        return pulumi.get(self, "rate_based_statement")

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatement']:
        """
        A rule statement used to search web request components for a match against a single regular expression. See Regex Match Statement below for details.
        """
        return pulumi.get(self, "regex_match_statement")

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatement']:
        """
        A rule statement used to search web request components for matches with regular expressions. See Regex Pattern Set Reference Statement below for details.
        """
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatement']:
        """
        A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See Size Constraint Statement below for more details.
        """
        return pulumi.get(self, "size_constraint_statement")

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatement']:
        """
        An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See SQL Injection Match Statement below for details.
        """
        return pulumi.get(self, "sqli_match_statement")

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatement']:
        """
        A rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See XSS Match Statement below for details.
        """
        return pulumi.get(self, "xss_match_statement")


@pulumi.output_type
class RuleGroupRuleStatementAndStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.RuleGroupRuleStatement']):
        """
        :param Sequence['RuleGroupRuleStatementArgs'] statements: The statements to combine.
        """
        RuleGroupRuleStatementAndStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statements=statements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statements: Optional[Sequence['outputs.RuleGroupRuleStatement']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statements is None:
            raise TypeError("Missing 'statements' argument")

        _setter("statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.RuleGroupRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "positionalConstraint":
            suggest = "positional_constraint"
        elif key == "searchString":
            suggest = "search_string"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 positional_constraint: str,
                 search_string: str,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementByteMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatch'] = None):
        """
        :param str positional_constraint: The area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        :param str search_string: A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        :param Sequence['RuleGroupRuleStatementByteMatchStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param 'RuleGroupRuleStatementByteMatchStatementFieldToMatchArgs' field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        RuleGroupRuleStatementByteMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            positional_constraint=positional_constraint,
            search_string=search_string,
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             positional_constraint: Optional[str] = None,
             search_string: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.RuleGroupRuleStatementByteMatchStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if positional_constraint is None and 'positionalConstraint' in kwargs:
            positional_constraint = kwargs['positionalConstraint']
        if positional_constraint is None:
            raise TypeError("Missing 'positional_constraint' argument")
        if search_string is None and 'searchString' in kwargs:
            search_string = kwargs['searchString']
        if search_string is None:
            raise TypeError("Missing 'search_string' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("positional_constraint", positional_constraint)
        _setter("search_string", search_string)
        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> str:
        """
        The area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        """
        return pulumi.get(self, "positional_constraint")

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> str:
        """
        A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        """
        return pulumi.get(self, "search_string")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementByteMatchStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatch']:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPath'] = None):
        """
        :param 'RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers.
        :param 'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param Sequence['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See Headers below for details.
        :param 'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See JSON Body for details.
        :param 'RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See Single Header below for details.
        :param 'RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param 'RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        RuleGroupRuleStatementByteMatchStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementByteMatchStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementByteMatchStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        RuleGroupRuleStatementByteMatchStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        RuleGroupRuleStatementByteMatchStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementGeoMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCodes":
            suggest = "country_codes"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementGeoMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementGeoMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementGeoMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_codes: Sequence[str],
                 forwarded_ip_config: Optional['outputs.RuleGroupRuleStatementGeoMatchStatementForwardedIpConfig'] = None):
        """
        :param Sequence[str] country_codes: An array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        :param 'RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgs' forwarded_ip_config: The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See Forwarded IP Config below for details.
        """
        RuleGroupRuleStatementGeoMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            country_codes=country_codes,
            forwarded_ip_config=forwarded_ip_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             country_codes: Optional[Sequence[str]] = None,
             forwarded_ip_config: Optional['outputs.RuleGroupRuleStatementGeoMatchStatementForwardedIpConfig'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if country_codes is None and 'countryCodes' in kwargs:
            country_codes = kwargs['countryCodes']
        if country_codes is None:
            raise TypeError("Missing 'country_codes' argument")
        if forwarded_ip_config is None and 'forwardedIpConfig' in kwargs:
            forwarded_ip_config = kwargs['forwardedIpConfig']

        _setter("country_codes", country_codes)
        if forwarded_ip_config is not None:
            _setter("forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Sequence[str]:
        """
        An array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        """
        return pulumi.get(self, "country_codes")

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.RuleGroupRuleStatementGeoMatchStatementForwardedIpConfig']:
        """
        The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See Forwarded IP Config below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class RuleGroupRuleStatementGeoMatchStatementForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementGeoMatchStatementForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementGeoMatchStatementForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementGeoMatchStatementForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: str,
                 header_name: str):
        """
        :param str fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param str header_name: The name of the HTTP header to use for the IP address.
        """
        RuleGroupRuleStatementGeoMatchStatementForwardedIpConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fallback_behavior=fallback_behavior,
            header_name=header_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fallback_behavior: Optional[str] = None,
             header_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fallback_behavior is None and 'fallbackBehavior' in kwargs:
            fallback_behavior = kwargs['fallbackBehavior']
        if fallback_behavior is None:
            raise TypeError("Missing 'fallback_behavior' argument")
        if header_name is None and 'headerName' in kwargs:
            header_name = kwargs['headerName']
        if header_name is None:
            raise TypeError("Missing 'header_name' argument")

        _setter("fallback_behavior", fallback_behavior)
        _setter("header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> str:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")


@pulumi.output_type
class RuleGroupRuleStatementIpSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipSetForwardedIpConfig":
            suggest = "ip_set_forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementIpSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementIpSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementIpSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 ip_set_forwarded_ip_config: Optional['outputs.RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig'] = None):
        """
        :param str arn: The Amazon Resource Name (ARN) of the IP Set that this statement references.
        :param 'RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs' ip_set_forwarded_ip_config: The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See IPSet Forwarded IP Config below for more details.
        """
        RuleGroupRuleStatementIpSetReferenceStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            ip_set_forwarded_ip_config=ip_set_forwarded_ip_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             ip_set_forwarded_ip_config: Optional['outputs.RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if ip_set_forwarded_ip_config is None and 'ipSetForwardedIpConfig' in kwargs:
            ip_set_forwarded_ip_config = kwargs['ipSetForwardedIpConfig']

        _setter("arn", arn)
        if ip_set_forwarded_ip_config is not None:
            _setter("ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the IP Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional['outputs.RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig']:
        """
        The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See IPSet Forwarded IP Config below for more details.
        """
        return pulumi.get(self, "ip_set_forwarded_ip_config")


@pulumi.output_type
class RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: str,
                 header_name: str,
                 position: str):
        """
        :param str fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param str header_name: The name of the HTTP header to use for the IP address.
        :param str position: The position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fallback_behavior=fallback_behavior,
            header_name=header_name,
            position=position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fallback_behavior: Optional[str] = None,
             header_name: Optional[str] = None,
             position: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fallback_behavior is None and 'fallbackBehavior' in kwargs:
            fallback_behavior = kwargs['fallbackBehavior']
        if fallback_behavior is None:
            raise TypeError("Missing 'fallback_behavior' argument")
        if header_name is None and 'headerName' in kwargs:
            header_name = kwargs['headerName']
        if header_name is None:
            raise TypeError("Missing 'header_name' argument")
        if position is None:
            raise TypeError("Missing 'position' argument")

        _setter("fallback_behavior", fallback_behavior)
        _setter("header_name", header_name)
        _setter("position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> str:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter
    def position(self) -> str:
        """
        The position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        return pulumi.get(self, "position")


@pulumi.output_type
class RuleGroupRuleStatementLabelMatchStatement(dict):
    def __init__(__self__, *,
                 key: str,
                 scope: str):
        """
        :param str key: The string to match against.
        :param str scope: Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        RuleGroupRuleStatementLabelMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            scope=scope,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             scope: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if scope is None:
            raise TypeError("Missing 'scope' argument")

        _setter("key", key)
        _setter("scope", scope)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The string to match against.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def scope(self) -> str:
        """
        Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class RuleGroupRuleStatementNotStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.RuleGroupRuleStatement']):
        """
        :param Sequence['RuleGroupRuleStatementArgs'] statements: The statements to combine.
        """
        RuleGroupRuleStatementNotStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statements=statements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statements: Optional[Sequence['outputs.RuleGroupRuleStatement']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statements is None:
            raise TypeError("Missing 'statements' argument")

        _setter("statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.RuleGroupRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class RuleGroupRuleStatementOrStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.RuleGroupRuleStatement']):
        """
        :param Sequence['RuleGroupRuleStatementArgs'] statements: The statements to combine.
        """
        RuleGroupRuleStatementOrStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statements=statements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statements: Optional[Sequence['outputs.RuleGroupRuleStatement']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statements is None:
            raise TypeError("Missing 'statements' argument")

        _setter("statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.RuleGroupRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregateKeyType":
            suggest = "aggregate_key_type"
        elif key == "customKeys":
            suggest = "custom_keys"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"
        elif key == "scopeDownStatement":
            suggest = "scope_down_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit: int,
                 aggregate_key_type: Optional[str] = None,
                 custom_keys: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKey']] = None,
                 forwarded_ip_config: Optional['outputs.RuleGroupRuleStatementRateBasedStatementForwardedIpConfig'] = None,
                 scope_down_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatement'] = None):
        """
        :param int limit: The limit on requests per 5-minute period for a single originating IP address.
        :param str aggregate_key_type: Setting that indicates how to aggregate the request counts. Valid values include: `CONSTANT`, `CUSTOM_KEYS`, `FORWARDED_IP` or `IP`. Default: `IP`.
        :param Sequence['RuleGroupRuleStatementRateBasedStatementCustomKeyArgs'] custom_keys: Aggregate the request counts using one or more web request components as the aggregate keys. See `custom_key` below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgs' forwarded_ip_config: The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. If `aggregate_key_type` is set to `FORWARDED_IP`, this block is required. See Forwarded IP Config below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgs' scope_down_statement: An optional nested statement that narrows the scope of the rate-based statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See Statement above for details. If `aggregate_key_type` is set to `CONSTANT`, this block is required.
        """
        RuleGroupRuleStatementRateBasedStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            limit=limit,
            aggregate_key_type=aggregate_key_type,
            custom_keys=custom_keys,
            forwarded_ip_config=forwarded_ip_config,
            scope_down_statement=scope_down_statement,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             limit: Optional[int] = None,
             aggregate_key_type: Optional[str] = None,
             custom_keys: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKey']] = None,
             forwarded_ip_config: Optional['outputs.RuleGroupRuleStatementRateBasedStatementForwardedIpConfig'] = None,
             scope_down_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatement'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if limit is None:
            raise TypeError("Missing 'limit' argument")
        if aggregate_key_type is None and 'aggregateKeyType' in kwargs:
            aggregate_key_type = kwargs['aggregateKeyType']
        if custom_keys is None and 'customKeys' in kwargs:
            custom_keys = kwargs['customKeys']
        if forwarded_ip_config is None and 'forwardedIpConfig' in kwargs:
            forwarded_ip_config = kwargs['forwardedIpConfig']
        if scope_down_statement is None and 'scopeDownStatement' in kwargs:
            scope_down_statement = kwargs['scopeDownStatement']

        _setter("limit", limit)
        if aggregate_key_type is not None:
            _setter("aggregate_key_type", aggregate_key_type)
        if custom_keys is not None:
            _setter("custom_keys", custom_keys)
        if forwarded_ip_config is not None:
            _setter("forwarded_ip_config", forwarded_ip_config)
        if scope_down_statement is not None:
            _setter("scope_down_statement", scope_down_statement)

    @property
    @pulumi.getter
    def limit(self) -> int:
        """
        The limit on requests per 5-minute period for a single originating IP address.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="aggregateKeyType")
    def aggregate_key_type(self) -> Optional[str]:
        """
        Setting that indicates how to aggregate the request counts. Valid values include: `CONSTANT`, `CUSTOM_KEYS`, `FORWARDED_IP` or `IP`. Default: `IP`.
        """
        return pulumi.get(self, "aggregate_key_type")

    @property
    @pulumi.getter(name="customKeys")
    def custom_keys(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKey']]:
        """
        Aggregate the request counts using one or more web request components as the aggregate keys. See `custom_key` below for details.
        """
        return pulumi.get(self, "custom_keys")

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementForwardedIpConfig']:
        """
        The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. If `aggregate_key_type` is set to `FORWARDED_IP`, this block is required. See Forwarded IP Config below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatement']:
        """
        An optional nested statement that narrows the scope of the rate-based statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See Statement above for details. If `aggregate_key_type` is set to `CONSTANT`, this block is required.
        """
        return pulumi.get(self, "scope_down_statement")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forwardedIp":
            suggest = "forwarded_ip"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "labelNamespace":
            suggest = "label_namespace"
        elif key == "queryArgument":
            suggest = "query_argument"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementCustomKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyCookie'] = None,
                 forwarded_ip: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIp'] = None,
                 header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyHeader'] = None,
                 http_method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethod'] = None,
                 ip: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyIp'] = None,
                 label_namespace: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespace'] = None,
                 query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgument'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryString'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyUriPath'] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgs' cookie: (Optional) Use the value of a cookie in the request as an aggregate key. See RateLimit `cookie` below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgs' forwarded_ip: (Optional) Use the first IP address in an HTTP header as an aggregate key. See `forwarded_ip` below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgs' header: (Optional) Use the value of a header in the request as an aggregate key. See RateLimit `header` below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgs' http_method: (Optional) Use the request's HTTP method as an aggregate key. See RateLimit `http_method` below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgs' ip: (Optional) Use the request's originating IP address as an aggregate key. See `RateLimit ip` below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs' label_namespace: (Optional) Use the specified label namespace as an aggregate key. See RateLimit `label_namespace` below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs' query_argument: (Optional) Use the specified query argument as an aggregate key. See RateLimit `query_argument` below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        RuleGroupRuleStatementRateBasedStatementCustomKey._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cookie=cookie,
            forwarded_ip=forwarded_ip,
            header=header,
            http_method=http_method,
            ip=ip,
            label_namespace=label_namespace,
            query_argument=query_argument,
            query_string=query_string,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cookie: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyCookie'] = None,
             forwarded_ip: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIp'] = None,
             header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyHeader'] = None,
             http_method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethod'] = None,
             ip: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyIp'] = None,
             label_namespace: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespace'] = None,
             query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgument'] = None,
             query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryString'] = None,
             uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if forwarded_ip is None and 'forwardedIp' in kwargs:
            forwarded_ip = kwargs['forwardedIp']
        if http_method is None and 'httpMethod' in kwargs:
            http_method = kwargs['httpMethod']
        if label_namespace is None and 'labelNamespace' in kwargs:
            label_namespace = kwargs['labelNamespace']
        if query_argument is None and 'queryArgument' in kwargs:
            query_argument = kwargs['queryArgument']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if cookie is not None:
            _setter("cookie", cookie)
        if forwarded_ip is not None:
            _setter("forwarded_ip", forwarded_ip)
        if header is not None:
            _setter("header", header)
        if http_method is not None:
            _setter("http_method", http_method)
        if ip is not None:
            _setter("ip", ip)
        if label_namespace is not None:
            _setter("label_namespace", label_namespace)
        if query_argument is not None:
            _setter("query_argument", query_argument)
        if query_string is not None:
            _setter("query_string", query_string)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyCookie']:
        """
        (Optional) Use the value of a cookie in the request as an aggregate key. See RateLimit `cookie` below for details.
        """
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter(name="forwardedIp")
    def forwarded_ip(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIp']:
        """
        (Optional) Use the first IP address in an HTTP header as an aggregate key. See `forwarded_ip` below for details.
        """
        return pulumi.get(self, "forwarded_ip")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyHeader']:
        """
        (Optional) Use the value of a header in the request as an aggregate key. See RateLimit `header` below for details.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethod']:
        """
        (Optional) Use the request's HTTP method as an aggregate key. See RateLimit `http_method` below for details.
        """
        return pulumi.get(self, "http_method")

    @property
    @pulumi.getter
    def ip(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyIp']:
        """
        (Optional) Use the request's originating IP address as an aggregate key. See `RateLimit ip` below for details.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="labelNamespace")
    def label_namespace(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespace']:
        """
        (Optional) Use the specified label namespace as an aggregate key. See RateLimit `label_namespace` below for details.
        """
        return pulumi.get(self, "label_namespace")

    @property
    @pulumi.getter(name="queryArgument")
    def query_argument(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgument']:
        """
        (Optional) Use the specified query argument as an aggregate key. See RateLimit `query_argument` below for details.
        """
        return pulumi.get(self, "query_argument")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyCookie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementCustomKeyCookie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyCookie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyCookie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformation']):
        """
        :param str name: A friendly name of the rule group.
        :param Sequence['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        """
        RuleGroupRuleStatementRateBasedStatementCustomKeyCookie._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("name", name)
        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIp(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementCustomKeyHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation']):
        """
        :param str name: A friendly name of the rule group.
        :param Sequence['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        """
        RuleGroupRuleStatementRateBasedStatementCustomKeyHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("name", name)
        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyIp(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespace(dict):
    def __init__(__self__, *,
                 namespace: str):
        """
        :param str namespace: The namespace to use for aggregation
        """
        RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespace._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            namespace=namespace,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             namespace: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if namespace is None:
            raise TypeError("Missing 'namespace' argument")

        _setter("namespace", namespace)

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The namespace to use for aggregation
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgument(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgument. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgument.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgument.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation']):
        """
        :param str name: A friendly name of the rule group.
        :param Sequence['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        """
        RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("name", name)
        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A friendly name of the rule group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementCustomKeyQueryString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyQueryString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyQueryString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation']):
        """
        :param Sequence['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        """
        RuleGroupRuleStatementRateBasedStatementCustomKeyQueryString._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text_transformations: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyUriPath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementCustomKeyUriPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyUriPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyUriPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation']):
        """
        :param Sequence['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        """
        RuleGroupRuleStatementRateBasedStatementCustomKeyUriPath._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text_transformations: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: str,
                 header_name: str):
        """
        :param str fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param str header_name: The name of the HTTP header to use for the IP address.
        """
        RuleGroupRuleStatementRateBasedStatementForwardedIpConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fallback_behavior=fallback_behavior,
            header_name=header_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fallback_behavior: Optional[str] = None,
             header_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fallback_behavior is None and 'fallbackBehavior' in kwargs:
            fallback_behavior = kwargs['fallbackBehavior']
        if fallback_behavior is None:
            raise TypeError("Missing 'fallback_behavior' argument")
        if header_name is None and 'headerName' in kwargs:
            header_name = kwargs['headerName']
        if header_name is None:
            raise TypeError("Missing 'header_name' argument")

        _setter("fallback_behavior", fallback_behavior)
        _setter("header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> str:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andStatement":
            suggest = "and_statement"
        elif key == "byteMatchStatement":
            suggest = "byte_match_statement"
        elif key == "geoMatchStatement":
            suggest = "geo_match_statement"
        elif key == "ipSetReferenceStatement":
            suggest = "ip_set_reference_statement"
        elif key == "labelMatchStatement":
            suggest = "label_match_statement"
        elif key == "notStatement":
            suggest = "not_statement"
        elif key == "orStatement":
            suggest = "or_statement"
        elif key == "regexMatchStatement":
            suggest = "regex_match_statement"
        elif key == "regexPatternSetReferenceStatement":
            suggest = "regex_pattern_set_reference_statement"
        elif key == "sizeConstraintStatement":
            suggest = "size_constraint_statement"
        elif key == "sqliMatchStatement":
            suggest = "sqli_match_statement"
        elif key == "xssMatchStatement":
            suggest = "xss_match_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatement'] = None,
                 byte_match_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement'] = None,
                 geo_match_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement'] = None,
                 ip_set_reference_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement'] = None,
                 label_match_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement'] = None,
                 not_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatement'] = None,
                 or_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatement'] = None,
                 regex_match_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement'] = None,
                 regex_pattern_set_reference_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement'] = None,
                 size_constraint_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement'] = None,
                 sqli_match_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement'] = None,
                 xss_match_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement'] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs' and_statement: A logical rule statement used to combine other rule statements with AND logic. See AND Statement below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs' byte_match_statement: A rule statement that defines a string match search for AWS WAF to apply to web requests. See Byte Match Statement below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs' geo_match_statement: A rule statement used to identify web requests based on country of origin. See GEO Match Statement below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs' ip_set_reference_statement: A rule statement used to detect web requests coming from particular IP addresses or address ranges. See IP Set Reference Statement below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs' label_match_statement: A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See Label Match Statement below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs' not_statement: A logical rule statement used to negate the results of another rule statement. See NOT Statement below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs' or_statement: A logical rule statement used to combine other rule statements with OR logic. See OR Statement below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs' regex_match_statement: A rule statement used to search web request components for a match against a single regular expression. See Regex Match Statement below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs' regex_pattern_set_reference_statement: A rule statement used to search web request components for matches with regular expressions. See Regex Pattern Set Reference Statement below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs' size_constraint_statement: A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See Size Constraint Statement below for more details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs' sqli_match_statement: An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See SQL Injection Match Statement below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs' xss_match_statement: A rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See XSS Match Statement below for details.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            and_statement=and_statement,
            byte_match_statement=byte_match_statement,
            geo_match_statement=geo_match_statement,
            ip_set_reference_statement=ip_set_reference_statement,
            label_match_statement=label_match_statement,
            not_statement=not_statement,
            or_statement=or_statement,
            regex_match_statement=regex_match_statement,
            regex_pattern_set_reference_statement=regex_pattern_set_reference_statement,
            size_constraint_statement=size_constraint_statement,
            sqli_match_statement=sqli_match_statement,
            xss_match_statement=xss_match_statement,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             and_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatement'] = None,
             byte_match_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement'] = None,
             geo_match_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement'] = None,
             ip_set_reference_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement'] = None,
             label_match_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement'] = None,
             not_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatement'] = None,
             or_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatement'] = None,
             regex_match_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement'] = None,
             regex_pattern_set_reference_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement'] = None,
             size_constraint_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement'] = None,
             sqli_match_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement'] = None,
             xss_match_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if and_statement is None and 'andStatement' in kwargs:
            and_statement = kwargs['andStatement']
        if byte_match_statement is None and 'byteMatchStatement' in kwargs:
            byte_match_statement = kwargs['byteMatchStatement']
        if geo_match_statement is None and 'geoMatchStatement' in kwargs:
            geo_match_statement = kwargs['geoMatchStatement']
        if ip_set_reference_statement is None and 'ipSetReferenceStatement' in kwargs:
            ip_set_reference_statement = kwargs['ipSetReferenceStatement']
        if label_match_statement is None and 'labelMatchStatement' in kwargs:
            label_match_statement = kwargs['labelMatchStatement']
        if not_statement is None and 'notStatement' in kwargs:
            not_statement = kwargs['notStatement']
        if or_statement is None and 'orStatement' in kwargs:
            or_statement = kwargs['orStatement']
        if regex_match_statement is None and 'regexMatchStatement' in kwargs:
            regex_match_statement = kwargs['regexMatchStatement']
        if regex_pattern_set_reference_statement is None and 'regexPatternSetReferenceStatement' in kwargs:
            regex_pattern_set_reference_statement = kwargs['regexPatternSetReferenceStatement']
        if size_constraint_statement is None and 'sizeConstraintStatement' in kwargs:
            size_constraint_statement = kwargs['sizeConstraintStatement']
        if sqli_match_statement is None and 'sqliMatchStatement' in kwargs:
            sqli_match_statement = kwargs['sqliMatchStatement']
        if xss_match_statement is None and 'xssMatchStatement' in kwargs:
            xss_match_statement = kwargs['xssMatchStatement']

        if and_statement is not None:
            _setter("and_statement", and_statement)
        if byte_match_statement is not None:
            _setter("byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            _setter("geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            _setter("ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            _setter("label_match_statement", label_match_statement)
        if not_statement is not None:
            _setter("not_statement", not_statement)
        if or_statement is not None:
            _setter("or_statement", or_statement)
        if regex_match_statement is not None:
            _setter("regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            _setter("regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            _setter("size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            _setter("sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            _setter("xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatement']:
        """
        A logical rule statement used to combine other rule statements with AND logic. See AND Statement below for details.
        """
        return pulumi.get(self, "and_statement")

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement']:
        """
        A rule statement that defines a string match search for AWS WAF to apply to web requests. See Byte Match Statement below for details.
        """
        return pulumi.get(self, "byte_match_statement")

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement']:
        """
        A rule statement used to identify web requests based on country of origin. See GEO Match Statement below for details.
        """
        return pulumi.get(self, "geo_match_statement")

    @property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement']:
        """
        A rule statement used to detect web requests coming from particular IP addresses or address ranges. See IP Set Reference Statement below for details.
        """
        return pulumi.get(self, "ip_set_reference_statement")

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement']:
        """
        A rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See Label Match Statement below for details.
        """
        return pulumi.get(self, "label_match_statement")

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatement']:
        """
        A logical rule statement used to negate the results of another rule statement. See NOT Statement below for details.
        """
        return pulumi.get(self, "not_statement")

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatement']:
        """
        A logical rule statement used to combine other rule statements with OR logic. See OR Statement below for details.
        """
        return pulumi.get(self, "or_statement")

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement']:
        """
        A rule statement used to search web request components for a match against a single regular expression. See Regex Match Statement below for details.
        """
        return pulumi.get(self, "regex_match_statement")

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement']:
        """
        A rule statement used to search web request components for matches with regular expressions. See Regex Pattern Set Reference Statement below for details.
        """
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement']:
        """
        A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See Size Constraint Statement below for more details.
        """
        return pulumi.get(self, "size_constraint_statement")

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement']:
        """
        An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See SQL Injection Match Statement below for details.
        """
        return pulumi.get(self, "sqli_match_statement")

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement']:
        """
        A rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See XSS Match Statement below for details.
        """
        return pulumi.get(self, "xss_match_statement")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.RuleGroupRuleStatement']):
        """
        :param Sequence['RuleGroupRuleStatementArgs'] statements: The statements to combine.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statements=statements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statements: Optional[Sequence['outputs.RuleGroupRuleStatement']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statements is None:
            raise TypeError("Missing 'statements' argument")

        _setter("statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.RuleGroupRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "positionalConstraint":
            suggest = "positional_constraint"
        elif key == "searchString":
            suggest = "search_string"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 positional_constraint: str,
                 search_string: str,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch'] = None):
        """
        :param str positional_constraint: The area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        :param str search_string: A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        :param Sequence['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs' field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            positional_constraint=positional_constraint,
            search_string=search_string,
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             positional_constraint: Optional[str] = None,
             search_string: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if positional_constraint is None and 'positionalConstraint' in kwargs:
            positional_constraint = kwargs['positionalConstraint']
        if positional_constraint is None:
            raise TypeError("Missing 'positional_constraint' argument")
        if search_string is None and 'searchString' in kwargs:
            search_string = kwargs['searchString']
        if search_string is None:
            raise TypeError("Missing 'search_string' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("positional_constraint", positional_constraint)
        _setter("search_string", search_string)
        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> str:
        """
        The area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        """
        return pulumi.get(self, "positional_constraint")

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> str:
        """
        A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        """
        return pulumi.get(self, "search_string")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch']:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath'] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param Sequence['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See Headers below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See JSON Body for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See Single Header below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCodes":
            suggest = "country_codes"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_codes: Sequence[str],
                 forwarded_ip_config: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig'] = None):
        """
        :param Sequence[str] country_codes: An array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs' forwarded_ip_config: The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See Forwarded IP Config below for details.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            country_codes=country_codes,
            forwarded_ip_config=forwarded_ip_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             country_codes: Optional[Sequence[str]] = None,
             forwarded_ip_config: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if country_codes is None and 'countryCodes' in kwargs:
            country_codes = kwargs['countryCodes']
        if country_codes is None:
            raise TypeError("Missing 'country_codes' argument")
        if forwarded_ip_config is None and 'forwardedIpConfig' in kwargs:
            forwarded_ip_config = kwargs['forwardedIpConfig']

        _setter("country_codes", country_codes)
        if forwarded_ip_config is not None:
            _setter("forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Sequence[str]:
        """
        An array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        """
        return pulumi.get(self, "country_codes")

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig']:
        """
        The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See Forwarded IP Config below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: str,
                 header_name: str):
        """
        :param str fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param str header_name: The name of the HTTP header to use for the IP address.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fallback_behavior=fallback_behavior,
            header_name=header_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fallback_behavior: Optional[str] = None,
             header_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fallback_behavior is None and 'fallbackBehavior' in kwargs:
            fallback_behavior = kwargs['fallbackBehavior']
        if fallback_behavior is None:
            raise TypeError("Missing 'fallback_behavior' argument")
        if header_name is None and 'headerName' in kwargs:
            header_name = kwargs['headerName']
        if header_name is None:
            raise TypeError("Missing 'header_name' argument")

        _setter("fallback_behavior", fallback_behavior)
        _setter("header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> str:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipSetForwardedIpConfig":
            suggest = "ip_set_forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 ip_set_forwarded_ip_config: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig'] = None):
        """
        :param str arn: The Amazon Resource Name (ARN) of the IP Set that this statement references.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs' ip_set_forwarded_ip_config: The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See IPSet Forwarded IP Config below for more details.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            ip_set_forwarded_ip_config=ip_set_forwarded_ip_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             ip_set_forwarded_ip_config: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if ip_set_forwarded_ip_config is None and 'ipSetForwardedIpConfig' in kwargs:
            ip_set_forwarded_ip_config = kwargs['ipSetForwardedIpConfig']

        _setter("arn", arn)
        if ip_set_forwarded_ip_config is not None:
            _setter("ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the IP Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig']:
        """
        The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See IPSet Forwarded IP Config below for more details.
        """
        return pulumi.get(self, "ip_set_forwarded_ip_config")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: str,
                 header_name: str,
                 position: str):
        """
        :param str fallback_behavior: The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param str header_name: The name of the HTTP header to use for the IP address.
        :param str position: The position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fallback_behavior=fallback_behavior,
            header_name=header_name,
            position=position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fallback_behavior: Optional[str] = None,
             header_name: Optional[str] = None,
             position: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fallback_behavior is None and 'fallbackBehavior' in kwargs:
            fallback_behavior = kwargs['fallbackBehavior']
        if fallback_behavior is None:
            raise TypeError("Missing 'fallback_behavior' argument")
        if header_name is None and 'headerName' in kwargs:
            header_name = kwargs['headerName']
        if header_name is None:
            raise TypeError("Missing 'header_name' argument")
        if position is None:
            raise TypeError("Missing 'position' argument")

        _setter("fallback_behavior", fallback_behavior)
        _setter("header_name", header_name)
        _setter("position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> str:
        """
        The match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter
    def position(self) -> str:
        """
        The position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        return pulumi.get(self, "position")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement(dict):
    def __init__(__self__, *,
                 key: str,
                 scope: str):
        """
        :param str key: The string to match against.
        :param str scope: Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            scope=scope,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             scope: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if scope is None:
            raise TypeError("Missing 'scope' argument")

        _setter("key", key)
        _setter("scope", scope)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The string to match against.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def scope(self) -> str:
        """
        Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.RuleGroupRuleStatement']):
        """
        :param Sequence['RuleGroupRuleStatementArgs'] statements: The statements to combine.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statements=statements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statements: Optional[Sequence['outputs.RuleGroupRuleStatement']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statements is None:
            raise TypeError("Missing 'statements' argument")

        _setter("statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.RuleGroupRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.RuleGroupRuleStatement']):
        """
        :param Sequence['RuleGroupRuleStatementArgs'] statements: The statements to combine.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statements=statements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statements: Optional[Sequence['outputs.RuleGroupRuleStatement']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statements is None:
            raise TypeError("Missing 'statements' argument")

        _setter("statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.RuleGroupRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regexString":
            suggest = "regex_string"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regex_string: str,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch'] = None):
        """
        :param str regex_string: The string representing the regular expression. Minimum of `1` and maximum of `512` characters.
        :param Sequence['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs' field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            regex_string=regex_string,
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             regex_string: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if regex_string is None and 'regexString' in kwargs:
            regex_string = kwargs['regexString']
        if regex_string is None:
            raise TypeError("Missing 'regex_string' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("regex_string", regex_string)
        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> str:
        """
        The string representing the regular expression. Minimum of `1` and maximum of `512` characters.
        """
        return pulumi.get(self, "regex_string")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch']:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath'] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param Sequence['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See Headers below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See JSON Body for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See Single Header below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch'] = None):
        """
        :param str arn: The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        :param Sequence['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs' field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("arn", arn)
        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch']:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath'] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param Sequence['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See Headers below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See JSON Body for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See Single Header below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: str,
                 size: int,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch'] = None):
        """
        :param str comparison_operator: The operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        :param int size: The size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        :param Sequence['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs' field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            size=size,
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             size: Optional[int] = None,
             text_transformations: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']
        if comparison_operator is None:
            raise TypeError("Missing 'comparison_operator' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("comparison_operator", comparison_operator)
        _setter("size", size)
        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> str:
        """
        The operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch']:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath'] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param Sequence['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See Headers below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See JSON Body for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See Single Header below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch'] = None):
        """
        :param Sequence['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs' field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text_transformations: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch']:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath'] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param Sequence['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See Headers below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See JSON Body for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See Single Header below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch'] = None):
        """
        :param Sequence['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs' field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text_transformations: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch']:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath'] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param Sequence['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See Headers below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See JSON Body for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See Single Header below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regexString":
            suggest = "regex_string"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regex_string: str,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRegexMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatch'] = None):
        """
        :param str regex_string: The string representing the regular expression. Minimum of `1` and maximum of `512` characters.
        :param Sequence['RuleGroupRuleStatementRegexMatchStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param 'RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgs' field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        RuleGroupRuleStatementRegexMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            regex_string=regex_string,
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             regex_string: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.RuleGroupRuleStatementRegexMatchStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if regex_string is None and 'regexString' in kwargs:
            regex_string = kwargs['regexString']
        if regex_string is None:
            raise TypeError("Missing 'regex_string' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("regex_string", regex_string)
        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> str:
        """
        The string representing the regular expression. Minimum of `1` and maximum of `512` characters.
        """
        return pulumi.get(self, "regex_string")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRegexMatchStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatch']:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPath'] = None):
        """
        :param 'RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers.
        :param 'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param Sequence['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See Headers below for details.
        :param 'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See JSON Body for details.
        :param 'RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See Single Header below for details.
        :param 'RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param 'RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        RuleGroupRuleStatementRegexMatchStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        RuleGroupRuleStatementRegexMatchStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatch'] = None):
        """
        :param str arn: The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        :param Sequence['RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param 'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs' field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        RuleGroupRuleStatementRegexPatternSetReferenceStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("arn", arn)
        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatch']:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath'] = None):
        """
        :param 'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers.
        :param 'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param Sequence['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See Headers below for details.
        :param 'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See JSON Body for details.
        :param 'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See Single Header below for details.
        :param 'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param 'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: str,
                 size: int,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementSizeConstraintStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatch'] = None):
        """
        :param str comparison_operator: The operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        :param int size: The size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        :param Sequence['RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param 'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgs' field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        RuleGroupRuleStatementSizeConstraintStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            size=size,
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             size: Optional[int] = None,
             text_transformations: Optional[Sequence['outputs.RuleGroupRuleStatementSizeConstraintStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']
        if comparison_operator is None:
            raise TypeError("Missing 'comparison_operator' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("comparison_operator", comparison_operator)
        _setter("size", size)
        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> str:
        """
        The operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementSizeConstraintStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatch']:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPath'] = None):
        """
        :param 'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers.
        :param 'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param Sequence['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See Headers below for details.
        :param 'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See JSON Body for details.
        :param 'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See Single Header below for details.
        :param 'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param 'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        RuleGroupRuleStatementSizeConstraintStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementSqliMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatch'] = None):
        """
        :param Sequence['RuleGroupRuleStatementSqliMatchStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param 'RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgs' field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        RuleGroupRuleStatementSqliMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text_transformations: Optional[Sequence['outputs.RuleGroupRuleStatementSqliMatchStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementSqliMatchStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatch']:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPath'] = None):
        """
        :param 'RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers.
        :param 'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param Sequence['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See Headers below for details.
        :param 'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See JSON Body for details.
        :param 'RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See Single Header below for details.
        :param 'RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param 'RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        RuleGroupRuleStatementSqliMatchStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        RuleGroupRuleStatementSqliMatchStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementXssMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatch'] = None):
        """
        :param Sequence['RuleGroupRuleStatementXssMatchStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
               At least one required.
               See Text Transformation below for details.
        :param 'RuleGroupRuleStatementXssMatchStatementFieldToMatchArgs' field_to_match: The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        RuleGroupRuleStatementXssMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text_transformations: Optional[Sequence['outputs.RuleGroupRuleStatementXssMatchStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementXssMatchStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection.
        At least one required.
        See Text Transformation below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatch']:
        """
        The part of a web request that you want AWS WAF to inspect. See Field to Match below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPath'] = None):
        """
        :param 'RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers.
        :param 'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See Cookies below for details.
        :param Sequence['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See Headers below for details.
        :param 'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See JSON Body for details.
        :param 'RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See Single Header below for details.
        :param 'RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See Single Query Argument below for details.
        :param 'RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        RuleGroupRuleStatementXssMatchStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See Cookies below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See Headers below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See JSON Body for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See Single Header below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See Single Query Argument below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementXssMatchStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        RuleGroupRuleStatementXssMatchStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        RuleGroupRuleStatementXssMatchStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        RuleGroupRuleStatementXssMatchStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleVisibilityConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchMetricsEnabled":
            suggest = "cloudwatch_metrics_enabled"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "sampledRequestsEnabled":
            suggest = "sampled_requests_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleVisibilityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleVisibilityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleVisibilityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_metrics_enabled: bool,
                 metric_name: str,
                 sampled_requests_enabled: bool):
        """
        :param bool cloudwatch_metrics_enabled: A boolean indicating whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        :param str metric_name: A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        :param bool sampled_requests_enabled: A boolean indicating whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        RuleGroupRuleVisibilityConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloudwatch_metrics_enabled=cloudwatch_metrics_enabled,
            metric_name=metric_name,
            sampled_requests_enabled=sampled_requests_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloudwatch_metrics_enabled: Optional[bool] = None,
             metric_name: Optional[str] = None,
             sampled_requests_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloudwatch_metrics_enabled is None and 'cloudwatchMetricsEnabled' in kwargs:
            cloudwatch_metrics_enabled = kwargs['cloudwatchMetricsEnabled']
        if cloudwatch_metrics_enabled is None:
            raise TypeError("Missing 'cloudwatch_metrics_enabled' argument")
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if metric_name is None:
            raise TypeError("Missing 'metric_name' argument")
        if sampled_requests_enabled is None and 'sampledRequestsEnabled' in kwargs:
            sampled_requests_enabled = kwargs['sampledRequestsEnabled']
        if sampled_requests_enabled is None:
            raise TypeError("Missing 'sampled_requests_enabled' argument")

        _setter("cloudwatch_metrics_enabled", cloudwatch_metrics_enabled)
        _setter("metric_name", metric_name)
        _setter("sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudwatchMetricsEnabled")
    def cloudwatch_metrics_enabled(self) -> bool:
        """
        A boolean indicating whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        """
        return pulumi.get(self, "cloudwatch_metrics_enabled")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> bool:
        """
        A boolean indicating whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        return pulumi.get(self, "sampled_requests_enabled")


@pulumi.output_type
class RuleGroupVisibilityConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchMetricsEnabled":
            suggest = "cloudwatch_metrics_enabled"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "sampledRequestsEnabled":
            suggest = "sampled_requests_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupVisibilityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupVisibilityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupVisibilityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_metrics_enabled: bool,
                 metric_name: str,
                 sampled_requests_enabled: bool):
        """
        :param bool cloudwatch_metrics_enabled: A boolean indicating whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        :param str metric_name: A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        :param bool sampled_requests_enabled: A boolean indicating whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        RuleGroupVisibilityConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloudwatch_metrics_enabled=cloudwatch_metrics_enabled,
            metric_name=metric_name,
            sampled_requests_enabled=sampled_requests_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloudwatch_metrics_enabled: Optional[bool] = None,
             metric_name: Optional[str] = None,
             sampled_requests_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloudwatch_metrics_enabled is None and 'cloudwatchMetricsEnabled' in kwargs:
            cloudwatch_metrics_enabled = kwargs['cloudwatchMetricsEnabled']
        if cloudwatch_metrics_enabled is None:
            raise TypeError("Missing 'cloudwatch_metrics_enabled' argument")
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if metric_name is None:
            raise TypeError("Missing 'metric_name' argument")
        if sampled_requests_enabled is None and 'sampledRequestsEnabled' in kwargs:
            sampled_requests_enabled = kwargs['sampledRequestsEnabled']
        if sampled_requests_enabled is None:
            raise TypeError("Missing 'sampled_requests_enabled' argument")

        _setter("cloudwatch_metrics_enabled", cloudwatch_metrics_enabled)
        _setter("metric_name", metric_name)
        _setter("sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudwatchMetricsEnabled")
    def cloudwatch_metrics_enabled(self) -> bool:
        """
        A boolean indicating whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        """
        return pulumi.get(self, "cloudwatch_metrics_enabled")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> bool:
        """
        A boolean indicating whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        return pulumi.get(self, "sampled_requests_enabled")


@pulumi.output_type
class WebAclAssociationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestBodies":
            suggest = "request_bodies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclAssociationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclAssociationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclAssociationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_bodies: Optional[Sequence['outputs.WebAclAssociationConfigRequestBody']] = None):
        """
        :param Sequence['WebAclAssociationConfigRequestBodyArgs'] request_bodies: Customizes the request body that your protected resource forward to AWS WAF for inspection. See `request_body` below for details.
        """
        WebAclAssociationConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            request_bodies=request_bodies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             request_bodies: Optional[Sequence['outputs.WebAclAssociationConfigRequestBody']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if request_bodies is None and 'requestBodies' in kwargs:
            request_bodies = kwargs['requestBodies']

        if request_bodies is not None:
            _setter("request_bodies", request_bodies)

    @property
    @pulumi.getter(name="requestBodies")
    def request_bodies(self) -> Optional[Sequence['outputs.WebAclAssociationConfigRequestBody']]:
        """
        Customizes the request body that your protected resource forward to AWS WAF for inspection. See `request_body` below for details.
        """
        return pulumi.get(self, "request_bodies")


@pulumi.output_type
class WebAclAssociationConfigRequestBody(dict):
    def __init__(__self__, *,
                 cloudfronts: Optional[Sequence['outputs.WebAclAssociationConfigRequestBodyCloudfront']] = None):
        """
        :param Sequence['WebAclAssociationConfigRequestBodyCloudfrontArgs'] cloudfronts: Customizes the request body that your protected CloudFront distributions forward to AWS WAF for inspection. See `cloudfront` below for details.
        """
        WebAclAssociationConfigRequestBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloudfronts=cloudfronts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloudfronts: Optional[Sequence['outputs.WebAclAssociationConfigRequestBodyCloudfront']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if cloudfronts is not None:
            _setter("cloudfronts", cloudfronts)

    @property
    @pulumi.getter
    def cloudfronts(self) -> Optional[Sequence['outputs.WebAclAssociationConfigRequestBodyCloudfront']]:
        """
        Customizes the request body that your protected CloudFront distributions forward to AWS WAF for inspection. See `cloudfront` below for details.
        """
        return pulumi.get(self, "cloudfronts")


@pulumi.output_type
class WebAclAssociationConfigRequestBodyCloudfront(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultSizeInspectionLimit":
            suggest = "default_size_inspection_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclAssociationConfigRequestBodyCloudfront. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclAssociationConfigRequestBodyCloudfront.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclAssociationConfigRequestBodyCloudfront.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_size_inspection_limit: str):
        """
        :param str default_size_inspection_limit: Specifies the maximum size of the web request body component that an associated CloudFront distribution should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body. Valid values are `KB_16`, `KB_32`, `KB_48` and `KB_64`.
        """
        WebAclAssociationConfigRequestBodyCloudfront._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_size_inspection_limit=default_size_inspection_limit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_size_inspection_limit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_size_inspection_limit is None and 'defaultSizeInspectionLimit' in kwargs:
            default_size_inspection_limit = kwargs['defaultSizeInspectionLimit']
        if default_size_inspection_limit is None:
            raise TypeError("Missing 'default_size_inspection_limit' argument")

        _setter("default_size_inspection_limit", default_size_inspection_limit)

    @property
    @pulumi.getter(name="defaultSizeInspectionLimit")
    def default_size_inspection_limit(self) -> str:
        """
        Specifies the maximum size of the web request body component that an associated CloudFront distribution should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body. Valid values are `KB_16`, `KB_32`, `KB_48` and `KB_64`.
        """
        return pulumi.get(self, "default_size_inspection_limit")


@pulumi.output_type
class WebAclCaptchaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTimeProperty":
            suggest = "immunity_time_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclCaptchaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclCaptchaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclCaptchaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time_property: Optional['outputs.WebAclCaptchaConfigImmunityTimeProperty'] = None):
        """
        :param 'WebAclCaptchaConfigImmunityTimePropertyArgs' immunity_time_property: Defines custom immunity time. See `immunity_time_property` below for details.
        """
        WebAclCaptchaConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            immunity_time_property=immunity_time_property,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             immunity_time_property: Optional['outputs.WebAclCaptchaConfigImmunityTimeProperty'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if immunity_time_property is None and 'immunityTimeProperty' in kwargs:
            immunity_time_property = kwargs['immunityTimeProperty']

        if immunity_time_property is not None:
            _setter("immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional['outputs.WebAclCaptchaConfigImmunityTimeProperty']:
        """
        Defines custom immunity time. See `immunity_time_property` below for details.
        """
        return pulumi.get(self, "immunity_time_property")


@pulumi.output_type
class WebAclCaptchaConfigImmunityTimeProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTime":
            suggest = "immunity_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclCaptchaConfigImmunityTimeProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclCaptchaConfigImmunityTimeProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclCaptchaConfigImmunityTimeProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time: Optional[int] = None):
        """
        :param int immunity_time: The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        WebAclCaptchaConfigImmunityTimeProperty._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            immunity_time=immunity_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             immunity_time: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if immunity_time is None and 'immunityTime' in kwargs:
            immunity_time = kwargs['immunityTime']

        if immunity_time is not None:
            _setter("immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[int]:
        """
        The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        return pulumi.get(self, "immunity_time")


@pulumi.output_type
class WebAclCustomResponseBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclCustomResponseBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclCustomResponseBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclCustomResponseBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: str,
                 content_type: str,
                 key: str):
        """
        :param str content: Payload of the custom response.
        :param str content_type: Type of content in the payload that you are defining in the `content` argument. Valid values are `TEXT_PLAIN`, `TEXT_HTML`, or `APPLICATION_JSON`.
        :param str key: Unique key identifying the custom response body. This is referenced by the `custom_response_body_key` argument in the `custom_response` block.
        """
        WebAclCustomResponseBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content=content,
            content_type=content_type,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content: Optional[str] = None,
             content_type: Optional[str] = None,
             key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if content is None:
            raise TypeError("Missing 'content' argument")
        if content_type is None and 'contentType' in kwargs:
            content_type = kwargs['contentType']
        if content_type is None:
            raise TypeError("Missing 'content_type' argument")
        if key is None:
            raise TypeError("Missing 'key' argument")

        _setter("content", content)
        _setter("content_type", content_type)
        _setter("key", key)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        Payload of the custom response.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> str:
        """
        Type of content in the payload that you are defining in the `content` argument. Valid values are `TEXT_PLAIN`, `TEXT_HTML`, or `APPLICATION_JSON`.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Unique key identifying the custom response body. This is referenced by the `custom_response_body_key` argument in the `custom_response` block.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class WebAclDefaultAction(dict):
    def __init__(__self__, *,
                 allow: Optional['outputs.WebAclDefaultActionAllow'] = None,
                 block: Optional['outputs.WebAclDefaultActionBlock'] = None):
        """
        :param 'WebAclDefaultActionAllowArgs' allow: Specifies that AWS WAF should allow requests by default. See `allow` below for details.
        :param 'WebAclDefaultActionBlockArgs' block: Specifies that AWS WAF should block requests by default. See `block` below for details.
        """
        WebAclDefaultAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow=allow,
            block=block,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow: Optional['outputs.WebAclDefaultActionAllow'] = None,
             block: Optional['outputs.WebAclDefaultActionBlock'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if allow is not None:
            _setter("allow", allow)
        if block is not None:
            _setter("block", block)

    @property
    @pulumi.getter
    def allow(self) -> Optional['outputs.WebAclDefaultActionAllow']:
        """
        Specifies that AWS WAF should allow requests by default. See `allow` below for details.
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def block(self) -> Optional['outputs.WebAclDefaultActionBlock']:
        """
        Specifies that AWS WAF should block requests by default. See `block` below for details.
        """
        return pulumi.get(self, "block")


@pulumi.output_type
class WebAclDefaultActionAllow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclDefaultActionAllow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclDefaultActionAllow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclDefaultActionAllow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclDefaultActionAllowCustomRequestHandling'] = None):
        """
        :param 'WebAclDefaultActionAllowCustomRequestHandlingArgs' custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        WebAclDefaultActionAllow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.WebAclDefaultActionAllowCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclDefaultActionAllowCustomRequestHandling']:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclDefaultActionAllowCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclDefaultActionAllowCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclDefaultActionAllowCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclDefaultActionAllowCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclDefaultActionAllowCustomRequestHandlingInsertHeader']):
        """
        :param Sequence['WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgs'] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        WebAclDefaultActionAllowCustomRequestHandling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insert_headers=insert_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insert_headers: Optional[Sequence['outputs.WebAclDefaultActionAllowCustomRequestHandlingInsertHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insert_headers is None and 'insertHeaders' in kwargs:
            insert_headers = kwargs['insertHeaders']
        if insert_headers is None:
            raise TypeError("Missing 'insert_headers' argument")

        _setter("insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclDefaultActionAllowCustomRequestHandlingInsertHeader']:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclDefaultActionAllowCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param str value: Value of the custom header.
        """
        WebAclDefaultActionAllowCustomRequestHandlingInsertHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclDefaultActionBlock(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customResponse":
            suggest = "custom_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclDefaultActionBlock. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclDefaultActionBlock.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclDefaultActionBlock.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_response: Optional['outputs.WebAclDefaultActionBlockCustomResponse'] = None):
        """
        :param 'WebAclDefaultActionBlockCustomResponseArgs' custom_response: Defines a custom response for the web request. See `custom_response` below for details.
        """
        WebAclDefaultActionBlock._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_response=custom_response,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_response: Optional['outputs.WebAclDefaultActionBlockCustomResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_response is None and 'customResponse' in kwargs:
            custom_response = kwargs['customResponse']

        if custom_response is not None:
            _setter("custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional['outputs.WebAclDefaultActionBlockCustomResponse']:
        """
        Defines a custom response for the web request. See `custom_response` below for details.
        """
        return pulumi.get(self, "custom_response")


@pulumi.output_type
class WebAclDefaultActionBlockCustomResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseCode":
            suggest = "response_code"
        elif key == "customResponseBodyKey":
            suggest = "custom_response_body_key"
        elif key == "responseHeaders":
            suggest = "response_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclDefaultActionBlockCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclDefaultActionBlockCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclDefaultActionBlockCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_code: int,
                 custom_response_body_key: Optional[str] = None,
                 response_headers: Optional[Sequence['outputs.WebAclDefaultActionBlockCustomResponseResponseHeader']] = None):
        """
        :param int response_code: The HTTP status code to return to the client.
        :param str custom_response_body_key: References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        :param Sequence['WebAclDefaultActionBlockCustomResponseResponseHeaderArgs'] response_headers: The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        WebAclDefaultActionBlockCustomResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            response_code=response_code,
            custom_response_body_key=custom_response_body_key,
            response_headers=response_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             response_code: Optional[int] = None,
             custom_response_body_key: Optional[str] = None,
             response_headers: Optional[Sequence['outputs.WebAclDefaultActionBlockCustomResponseResponseHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if response_code is None and 'responseCode' in kwargs:
            response_code = kwargs['responseCode']
        if response_code is None:
            raise TypeError("Missing 'response_code' argument")
        if custom_response_body_key is None and 'customResponseBodyKey' in kwargs:
            custom_response_body_key = kwargs['customResponseBodyKey']
        if response_headers is None and 'responseHeaders' in kwargs:
            response_headers = kwargs['responseHeaders']

        _setter("response_code", response_code)
        if custom_response_body_key is not None:
            _setter("custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            _setter("response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> int:
        """
        The HTTP status code to return to the client.
        """
        return pulumi.get(self, "response_code")

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[str]:
        """
        References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        """
        return pulumi.get(self, "custom_response_body_key")

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[Sequence['outputs.WebAclDefaultActionBlockCustomResponseResponseHeader']]:
        """
        The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        return pulumi.get(self, "response_headers")


@pulumi.output_type
class WebAclDefaultActionBlockCustomResponseResponseHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param str value: Value of the custom header.
        """
        WebAclDefaultActionBlockCustomResponseResponseHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclLoggingConfigurationLoggingFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultBehavior":
            suggest = "default_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclLoggingConfigurationLoggingFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclLoggingConfigurationLoggingFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclLoggingConfigurationLoggingFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_behavior: str,
                 filters: Sequence['outputs.WebAclLoggingConfigurationLoggingFilterFilter']):
        """
        :param str default_behavior: Default handling for logs that don't match any of the specified filtering conditions. Valid values for `default_behavior` are `KEEP` or `DROP`.
        :param Sequence['WebAclLoggingConfigurationLoggingFilterFilterArgs'] filters: Filter(s) that you want to apply to the logs. See Filter below for more details.
        """
        WebAclLoggingConfigurationLoggingFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_behavior=default_behavior,
            filters=filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_behavior: Optional[str] = None,
             filters: Optional[Sequence['outputs.WebAclLoggingConfigurationLoggingFilterFilter']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_behavior is None and 'defaultBehavior' in kwargs:
            default_behavior = kwargs['defaultBehavior']
        if default_behavior is None:
            raise TypeError("Missing 'default_behavior' argument")
        if filters is None:
            raise TypeError("Missing 'filters' argument")

        _setter("default_behavior", default_behavior)
        _setter("filters", filters)

    @property
    @pulumi.getter(name="defaultBehavior")
    def default_behavior(self) -> str:
        """
        Default handling for logs that don't match any of the specified filtering conditions. Valid values for `default_behavior` are `KEEP` or `DROP`.
        """
        return pulumi.get(self, "default_behavior")

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.WebAclLoggingConfigurationLoggingFilterFilter']:
        """
        Filter(s) that you want to apply to the logs. See Filter below for more details.
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class WebAclLoggingConfigurationLoggingFilterFilter(dict):
    def __init__(__self__, *,
                 behavior: str,
                 conditions: Sequence['outputs.WebAclLoggingConfigurationLoggingFilterFilterCondition'],
                 requirement: str):
        """
        :param str behavior: Parameter that determines how to handle logs that meet the conditions and requirements of the filter. The valid values for `behavior` are `KEEP` or `DROP`.
        :param Sequence['WebAclLoggingConfigurationLoggingFilterFilterConditionArgs'] conditions: Match condition(s) for the filter. See Condition below for more details.
        :param str requirement: Logic to apply to the filtering conditions. You can specify that a log must match all conditions or at least one condition in order to satisfy the filter. Valid values for `requirement` are `MEETS_ALL` or `MEETS_ANY`.
        """
        WebAclLoggingConfigurationLoggingFilterFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            behavior=behavior,
            conditions=conditions,
            requirement=requirement,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             behavior: Optional[str] = None,
             conditions: Optional[Sequence['outputs.WebAclLoggingConfigurationLoggingFilterFilterCondition']] = None,
             requirement: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if behavior is None:
            raise TypeError("Missing 'behavior' argument")
        if conditions is None:
            raise TypeError("Missing 'conditions' argument")
        if requirement is None:
            raise TypeError("Missing 'requirement' argument")

        _setter("behavior", behavior)
        _setter("conditions", conditions)
        _setter("requirement", requirement)

    @property
    @pulumi.getter
    def behavior(self) -> str:
        """
        Parameter that determines how to handle logs that meet the conditions and requirements of the filter. The valid values for `behavior` are `KEEP` or `DROP`.
        """
        return pulumi.get(self, "behavior")

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.WebAclLoggingConfigurationLoggingFilterFilterCondition']:
        """
        Match condition(s) for the filter. See Condition below for more details.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def requirement(self) -> str:
        """
        Logic to apply to the filtering conditions. You can specify that a log must match all conditions or at least one condition in order to satisfy the filter. Valid values for `requirement` are `MEETS_ALL` or `MEETS_ANY`.
        """
        return pulumi.get(self, "requirement")


@pulumi.output_type
class WebAclLoggingConfigurationLoggingFilterFilterCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionCondition":
            suggest = "action_condition"
        elif key == "labelNameCondition":
            suggest = "label_name_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclLoggingConfigurationLoggingFilterFilterCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclLoggingConfigurationLoggingFilterFilterCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclLoggingConfigurationLoggingFilterFilterCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_condition: Optional['outputs.WebAclLoggingConfigurationLoggingFilterFilterConditionActionCondition'] = None,
                 label_name_condition: Optional['outputs.WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameCondition'] = None):
        """
        :param 'WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgs' action_condition: Configuration for a single action condition. See Action Condition below for more details.
        :param 'WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgs' label_name_condition: Condition for a single label name. See Label Name Condition below for more details.
        """
        WebAclLoggingConfigurationLoggingFilterFilterCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_condition=action_condition,
            label_name_condition=label_name_condition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_condition: Optional['outputs.WebAclLoggingConfigurationLoggingFilterFilterConditionActionCondition'] = None,
             label_name_condition: Optional['outputs.WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameCondition'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_condition is None and 'actionCondition' in kwargs:
            action_condition = kwargs['actionCondition']
        if label_name_condition is None and 'labelNameCondition' in kwargs:
            label_name_condition = kwargs['labelNameCondition']

        if action_condition is not None:
            _setter("action_condition", action_condition)
        if label_name_condition is not None:
            _setter("label_name_condition", label_name_condition)

    @property
    @pulumi.getter(name="actionCondition")
    def action_condition(self) -> Optional['outputs.WebAclLoggingConfigurationLoggingFilterFilterConditionActionCondition']:
        """
        Configuration for a single action condition. See Action Condition below for more details.
        """
        return pulumi.get(self, "action_condition")

    @property
    @pulumi.getter(name="labelNameCondition")
    def label_name_condition(self) -> Optional['outputs.WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameCondition']:
        """
        Condition for a single label name. See Label Name Condition below for more details.
        """
        return pulumi.get(self, "label_name_condition")


@pulumi.output_type
class WebAclLoggingConfigurationLoggingFilterFilterConditionActionCondition(dict):
    def __init__(__self__, *,
                 action: str):
        """
        :param str action: Action setting that a log record must contain in order to meet the condition. Valid values for `action` are `ALLOW`, `BLOCK`, and `COUNT`.
        """
        WebAclLoggingConfigurationLoggingFilterFilterConditionActionCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")

        _setter("action", action)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action setting that a log record must contain in order to meet the condition. Valid values for `action` are `ALLOW`, `BLOCK`, and `COUNT`.
        """
        return pulumi.get(self, "action")


@pulumi.output_type
class WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelName":
            suggest = "label_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_name: str):
        """
        :param str label_name: Name of the label that a log record must contain in order to meet the condition. It must be a fully qualified label name, which includes a prefix, optional namespaces, and the label name itself. The prefix identifies the rule group or web ACL context of the rule that added the label.
        """
        WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label_name=label_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if label_name is None and 'labelName' in kwargs:
            label_name = kwargs['labelName']
        if label_name is None:
            raise TypeError("Missing 'label_name' argument")

        _setter("label_name", label_name)

    @property
    @pulumi.getter(name="labelName")
    def label_name(self) -> str:
        """
        Name of the label that a log record must contain in order to meet the condition. It must be a fully qualified label name, which includes a prefix, optional namespaces, and the label name itself. The prefix identifies the rule group or web ACL context of the rule that added the label.
        """
        return pulumi.get(self, "label_name")


@pulumi.output_type
class WebAclLoggingConfigurationRedactedField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclLoggingConfigurationRedactedField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclLoggingConfigurationRedactedField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclLoggingConfigurationRedactedField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: Optional['outputs.WebAclLoggingConfigurationRedactedFieldMethod'] = None,
                 query_string: Optional['outputs.WebAclLoggingConfigurationRedactedFieldQueryString'] = None,
                 single_header: Optional['outputs.WebAclLoggingConfigurationRedactedFieldSingleHeader'] = None,
                 uri_path: Optional['outputs.WebAclLoggingConfigurationRedactedFieldUriPath'] = None):
        """
        :param 'WebAclLoggingConfigurationRedactedFieldMethodArgs' method: HTTP method to be redacted. It must be specified as an empty configuration block `{}`. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'WebAclLoggingConfigurationRedactedFieldQueryStringArgs' query_string: Whether to redact the query string. It must be specified as an empty configuration block `{}`. The query string is the part of a URL that appears after a `?` character, if any.
        :param 'WebAclLoggingConfigurationRedactedFieldSingleHeaderArgs' single_header: "single_header" refers to the redaction of a single header. For more information, please see the details below under Single Header.
        :param 'WebAclLoggingConfigurationRedactedFieldUriPathArgs' uri_path: Configuration block that redacts the request URI path. It should be specified as an empty configuration block `{}`. The URI path is the part of a web request that identifies a resource, such as `/images/daily-ad.jpg`.
        """
        WebAclLoggingConfigurationRedactedField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            method=method,
            query_string=query_string,
            single_header=single_header,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             method: Optional['outputs.WebAclLoggingConfigurationRedactedFieldMethod'] = None,
             query_string: Optional['outputs.WebAclLoggingConfigurationRedactedFieldQueryString'] = None,
             single_header: Optional['outputs.WebAclLoggingConfigurationRedactedFieldSingleHeader'] = None,
             uri_path: Optional['outputs.WebAclLoggingConfigurationRedactedFieldUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclLoggingConfigurationRedactedFieldMethod']:
        """
        HTTP method to be redacted. It must be specified as an empty configuration block `{}`. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclLoggingConfigurationRedactedFieldQueryString']:
        """
        Whether to redact the query string. It must be specified as an empty configuration block `{}`. The query string is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclLoggingConfigurationRedactedFieldSingleHeader']:
        """
        "single_header" refers to the redaction of a single header. For more information, please see the details below under Single Header.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclLoggingConfigurationRedactedFieldUriPath']:
        """
        Configuration block that redacts the request URI path. It should be specified as an empty configuration block `{}`. The URI path is the part of a web request that identifies a resource, such as `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclLoggingConfigurationRedactedFieldMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclLoggingConfigurationRedactedFieldQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclLoggingConfigurationRedactedFieldSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to redact. This setting must be provided in lowercase characters.
        """
        WebAclLoggingConfigurationRedactedFieldSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to redact. This setting must be provided in lowercase characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclLoggingConfigurationRedactedFieldUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visibilityConfig":
            suggest = "visibility_config"
        elif key == "captchaConfig":
            suggest = "captcha_config"
        elif key == "overrideAction":
            suggest = "override_action"
        elif key == "ruleLabels":
            suggest = "rule_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 priority: int,
                 statement: 'outputs.WebAclRuleStatement',
                 visibility_config: 'outputs.WebAclRuleVisibilityConfig',
                 action: Optional['outputs.WebAclRuleAction'] = None,
                 captcha_config: Optional['outputs.WebAclRuleCaptchaConfig'] = None,
                 override_action: Optional['outputs.WebAclRuleOverrideAction'] = None,
                 rule_labels: Optional[Sequence['outputs.WebAclRuleRuleLabel']] = None):
        """
        :param str name: Friendly name of the rule. Note that the provider assumes that rules with names matching this pattern, `^ShieldMitigationRuleGroup_<account-id>_<web-acl-guid>_.*`, are AWS-added for [automatic application layer DDoS mitigation activities](https://docs.aws.amazon.com/waf/latest/developerguide/ddos-automatic-app-layer-response-rg.html). Such rules will be ignored by the provider unless you explicitly include them in your configuration (for example, by using the AWS CLI to discover their properties and creating matching configuration). However, since these rules are owned and managed by AWS, you may get permission errors.
        :param int priority: If you define more than one Rule in a WebACL, AWS WAF evaluates each request against the `rules` in order based on the value of `priority`. AWS WAF processes rules with lower priority first.
        :param 'WebAclRuleStatementArgs' statement: The AWS WAF processing statement for the rule, for example `byte_match_statement` or `geo_match_statement`. See `statement` below for details.
        :param 'WebAclRuleVisibilityConfigArgs' visibility_config: Defines and enables Amazon CloudWatch metrics and web request sample collection. See `visibility_config` below for details.
        :param 'WebAclRuleActionArgs' action: Action that AWS WAF should take on a web request when it matches the rule's statement. This is used only for rules whose **statements do not reference a rule group**. See `action` for details.
        :param 'WebAclRuleCaptchaConfigArgs' captcha_config: Specifies how AWS WAF should handle CAPTCHA evaluations. See `captcha_config` below for details.
        :param 'WebAclRuleOverrideActionArgs' override_action: Override action to apply to the rules in a rule group. Used only for rule **statements that reference a rule group**, like `rule_group_reference_statement` and `managed_rule_group_statement`. See `override_action` below for details.
        :param Sequence['WebAclRuleRuleLabelArgs'] rule_labels: Labels to apply to web requests that match the rule match statement. See `rule_label` below for details.
        """
        WebAclRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            priority=priority,
            statement=statement,
            visibility_config=visibility_config,
            action=action,
            captcha_config=captcha_config,
            override_action=override_action,
            rule_labels=rule_labels,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             priority: Optional[int] = None,
             statement: Optional['outputs.WebAclRuleStatement'] = None,
             visibility_config: Optional['outputs.WebAclRuleVisibilityConfig'] = None,
             action: Optional['outputs.WebAclRuleAction'] = None,
             captcha_config: Optional['outputs.WebAclRuleCaptchaConfig'] = None,
             override_action: Optional['outputs.WebAclRuleOverrideAction'] = None,
             rule_labels: Optional[Sequence['outputs.WebAclRuleRuleLabel']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if statement is None:
            raise TypeError("Missing 'statement' argument")
        if visibility_config is None and 'visibilityConfig' in kwargs:
            visibility_config = kwargs['visibilityConfig']
        if visibility_config is None:
            raise TypeError("Missing 'visibility_config' argument")
        if captcha_config is None and 'captchaConfig' in kwargs:
            captcha_config = kwargs['captchaConfig']
        if override_action is None and 'overrideAction' in kwargs:
            override_action = kwargs['overrideAction']
        if rule_labels is None and 'ruleLabels' in kwargs:
            rule_labels = kwargs['ruleLabels']

        _setter("name", name)
        _setter("priority", priority)
        _setter("statement", statement)
        _setter("visibility_config", visibility_config)
        if action is not None:
            _setter("action", action)
        if captcha_config is not None:
            _setter("captcha_config", captcha_config)
        if override_action is not None:
            _setter("override_action", override_action)
        if rule_labels is not None:
            _setter("rule_labels", rule_labels)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Friendly name of the rule. Note that the provider assumes that rules with names matching this pattern, `^ShieldMitigationRuleGroup_<account-id>_<web-acl-guid>_.*`, are AWS-added for [automatic application layer DDoS mitigation activities](https://docs.aws.amazon.com/waf/latest/developerguide/ddos-automatic-app-layer-response-rg.html). Such rules will be ignored by the provider unless you explicitly include them in your configuration (for example, by using the AWS CLI to discover their properties and creating matching configuration). However, since these rules are owned and managed by AWS, you may get permission errors.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        If you define more than one Rule in a WebACL, AWS WAF evaluates each request against the `rules` in order based on the value of `priority`. AWS WAF processes rules with lower priority first.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def statement(self) -> 'outputs.WebAclRuleStatement':
        """
        The AWS WAF processing statement for the rule, for example `byte_match_statement` or `geo_match_statement`. See `statement` below for details.
        """
        return pulumi.get(self, "statement")

    @property
    @pulumi.getter(name="visibilityConfig")
    def visibility_config(self) -> 'outputs.WebAclRuleVisibilityConfig':
        """
        Defines and enables Amazon CloudWatch metrics and web request sample collection. See `visibility_config` below for details.
        """
        return pulumi.get(self, "visibility_config")

    @property
    @pulumi.getter
    def action(self) -> Optional['outputs.WebAclRuleAction']:
        """
        Action that AWS WAF should take on a web request when it matches the rule's statement. This is used only for rules whose **statements do not reference a rule group**. See `action` for details.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="captchaConfig")
    def captcha_config(self) -> Optional['outputs.WebAclRuleCaptchaConfig']:
        """
        Specifies how AWS WAF should handle CAPTCHA evaluations. See `captcha_config` below for details.
        """
        return pulumi.get(self, "captcha_config")

    @property
    @pulumi.getter(name="overrideAction")
    def override_action(self) -> Optional['outputs.WebAclRuleOverrideAction']:
        """
        Override action to apply to the rules in a rule group. Used only for rule **statements that reference a rule group**, like `rule_group_reference_statement` and `managed_rule_group_statement`. See `override_action` below for details.
        """
        return pulumi.get(self, "override_action")

    @property
    @pulumi.getter(name="ruleLabels")
    def rule_labels(self) -> Optional[Sequence['outputs.WebAclRuleRuleLabel']]:
        """
        Labels to apply to web requests that match the rule match statement. See `rule_label` below for details.
        """
        return pulumi.get(self, "rule_labels")


@pulumi.output_type
class WebAclRuleAction(dict):
    def __init__(__self__, *,
                 allow: Optional['outputs.WebAclRuleActionAllow'] = None,
                 block: Optional['outputs.WebAclRuleActionBlock'] = None,
                 captcha: Optional['outputs.WebAclRuleActionCaptcha'] = None,
                 challenge: Optional['outputs.WebAclRuleActionChallenge'] = None,
                 count: Optional['outputs.WebAclRuleActionCount'] = None):
        """
        :param 'WebAclRuleActionAllowArgs' allow: Instructs AWS WAF to allow the web request. See `allow` below for details.
        :param 'WebAclRuleActionBlockArgs' block: Instructs AWS WAF to block the web request. See `block` below for details.
        :param 'WebAclRuleActionCaptchaArgs' captcha: Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        :param 'WebAclRuleActionChallengeArgs' challenge: Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        :param 'WebAclRuleActionCountArgs' count: Instructs AWS WAF to count the web request and allow it. See `count` below for details.
        """
        WebAclRuleAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow=allow,
            block=block,
            captcha=captcha,
            challenge=challenge,
            count=count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow: Optional['outputs.WebAclRuleActionAllow'] = None,
             block: Optional['outputs.WebAclRuleActionBlock'] = None,
             captcha: Optional['outputs.WebAclRuleActionCaptcha'] = None,
             challenge: Optional['outputs.WebAclRuleActionChallenge'] = None,
             count: Optional['outputs.WebAclRuleActionCount'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if allow is not None:
            _setter("allow", allow)
        if block is not None:
            _setter("block", block)
        if captcha is not None:
            _setter("captcha", captcha)
        if challenge is not None:
            _setter("challenge", challenge)
        if count is not None:
            _setter("count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional['outputs.WebAclRuleActionAllow']:
        """
        Instructs AWS WAF to allow the web request. See `allow` below for details.
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def block(self) -> Optional['outputs.WebAclRuleActionBlock']:
        """
        Instructs AWS WAF to block the web request. See `block` below for details.
        """
        return pulumi.get(self, "block")

    @property
    @pulumi.getter
    def captcha(self) -> Optional['outputs.WebAclRuleActionCaptcha']:
        """
        Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        """
        return pulumi.get(self, "captcha")

    @property
    @pulumi.getter
    def challenge(self) -> Optional['outputs.WebAclRuleActionChallenge']:
        """
        Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        """
        return pulumi.get(self, "challenge")

    @property
    @pulumi.getter
    def count(self) -> Optional['outputs.WebAclRuleActionCount']:
        """
        Instructs AWS WAF to count the web request and allow it. See `count` below for details.
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class WebAclRuleActionAllow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionAllow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionAllow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionAllow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleActionAllowCustomRequestHandling'] = None):
        """
        :param 'WebAclRuleActionAllowCustomRequestHandlingArgs' custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        WebAclRuleActionAllow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.WebAclRuleActionAllowCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleActionAllowCustomRequestHandling']:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleActionAllowCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionAllowCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionAllowCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionAllowCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleActionAllowCustomRequestHandlingInsertHeader']):
        """
        :param Sequence['WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgs'] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        WebAclRuleActionAllowCustomRequestHandling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insert_headers=insert_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insert_headers: Optional[Sequence['outputs.WebAclRuleActionAllowCustomRequestHandlingInsertHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insert_headers is None and 'insertHeaders' in kwargs:
            insert_headers = kwargs['insertHeaders']
        if insert_headers is None:
            raise TypeError("Missing 'insert_headers' argument")

        _setter("insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleActionAllowCustomRequestHandlingInsertHeader']:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleActionAllowCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param str value: Value of the custom header.
        """
        WebAclRuleActionAllowCustomRequestHandlingInsertHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleActionBlock(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customResponse":
            suggest = "custom_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionBlock. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionBlock.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionBlock.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_response: Optional['outputs.WebAclRuleActionBlockCustomResponse'] = None):
        """
        :param 'WebAclRuleActionBlockCustomResponseArgs' custom_response: Defines a custom response for the web request. See `custom_response` below for details.
        """
        WebAclRuleActionBlock._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_response=custom_response,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_response: Optional['outputs.WebAclRuleActionBlockCustomResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_response is None and 'customResponse' in kwargs:
            custom_response = kwargs['customResponse']

        if custom_response is not None:
            _setter("custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional['outputs.WebAclRuleActionBlockCustomResponse']:
        """
        Defines a custom response for the web request. See `custom_response` below for details.
        """
        return pulumi.get(self, "custom_response")


@pulumi.output_type
class WebAclRuleActionBlockCustomResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseCode":
            suggest = "response_code"
        elif key == "customResponseBodyKey":
            suggest = "custom_response_body_key"
        elif key == "responseHeaders":
            suggest = "response_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionBlockCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionBlockCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionBlockCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_code: int,
                 custom_response_body_key: Optional[str] = None,
                 response_headers: Optional[Sequence['outputs.WebAclRuleActionBlockCustomResponseResponseHeader']] = None):
        """
        :param int response_code: The HTTP status code to return to the client.
        :param str custom_response_body_key: References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        :param Sequence['WebAclRuleActionBlockCustomResponseResponseHeaderArgs'] response_headers: The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        WebAclRuleActionBlockCustomResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            response_code=response_code,
            custom_response_body_key=custom_response_body_key,
            response_headers=response_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             response_code: Optional[int] = None,
             custom_response_body_key: Optional[str] = None,
             response_headers: Optional[Sequence['outputs.WebAclRuleActionBlockCustomResponseResponseHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if response_code is None and 'responseCode' in kwargs:
            response_code = kwargs['responseCode']
        if response_code is None:
            raise TypeError("Missing 'response_code' argument")
        if custom_response_body_key is None and 'customResponseBodyKey' in kwargs:
            custom_response_body_key = kwargs['customResponseBodyKey']
        if response_headers is None and 'responseHeaders' in kwargs:
            response_headers = kwargs['responseHeaders']

        _setter("response_code", response_code)
        if custom_response_body_key is not None:
            _setter("custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            _setter("response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> int:
        """
        The HTTP status code to return to the client.
        """
        return pulumi.get(self, "response_code")

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[str]:
        """
        References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        """
        return pulumi.get(self, "custom_response_body_key")

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[Sequence['outputs.WebAclRuleActionBlockCustomResponseResponseHeader']]:
        """
        The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        return pulumi.get(self, "response_headers")


@pulumi.output_type
class WebAclRuleActionBlockCustomResponseResponseHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param str value: Value of the custom header.
        """
        WebAclRuleActionBlockCustomResponseResponseHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleActionCaptcha(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionCaptcha. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionCaptcha.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionCaptcha.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleActionCaptchaCustomRequestHandling'] = None):
        """
        :param 'WebAclRuleActionCaptchaCustomRequestHandlingArgs' custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        WebAclRuleActionCaptcha._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.WebAclRuleActionCaptchaCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleActionCaptchaCustomRequestHandling']:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleActionCaptchaCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionCaptchaCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionCaptchaCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionCaptchaCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleActionCaptchaCustomRequestHandlingInsertHeader']):
        """
        :param Sequence['WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs'] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        WebAclRuleActionCaptchaCustomRequestHandling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insert_headers=insert_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insert_headers: Optional[Sequence['outputs.WebAclRuleActionCaptchaCustomRequestHandlingInsertHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insert_headers is None and 'insertHeaders' in kwargs:
            insert_headers = kwargs['insertHeaders']
        if insert_headers is None:
            raise TypeError("Missing 'insert_headers' argument")

        _setter("insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleActionCaptchaCustomRequestHandlingInsertHeader']:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleActionCaptchaCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param str value: Value of the custom header.
        """
        WebAclRuleActionCaptchaCustomRequestHandlingInsertHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleActionChallenge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionChallenge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionChallenge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionChallenge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleActionChallengeCustomRequestHandling'] = None):
        """
        :param 'WebAclRuleActionChallengeCustomRequestHandlingArgs' custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        WebAclRuleActionChallenge._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.WebAclRuleActionChallengeCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleActionChallengeCustomRequestHandling']:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleActionChallengeCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionChallengeCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionChallengeCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionChallengeCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleActionChallengeCustomRequestHandlingInsertHeader']):
        """
        :param Sequence['WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgs'] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        WebAclRuleActionChallengeCustomRequestHandling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insert_headers=insert_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insert_headers: Optional[Sequence['outputs.WebAclRuleActionChallengeCustomRequestHandlingInsertHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insert_headers is None and 'insertHeaders' in kwargs:
            insert_headers = kwargs['insertHeaders']
        if insert_headers is None:
            raise TypeError("Missing 'insert_headers' argument")

        _setter("insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleActionChallengeCustomRequestHandlingInsertHeader']:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleActionChallengeCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param str value: Value of the custom header.
        """
        WebAclRuleActionChallengeCustomRequestHandlingInsertHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleActionCount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionCount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionCount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionCount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleActionCountCustomRequestHandling'] = None):
        """
        :param 'WebAclRuleActionCountCustomRequestHandlingArgs' custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        WebAclRuleActionCount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.WebAclRuleActionCountCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleActionCountCustomRequestHandling']:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleActionCountCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionCountCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionCountCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionCountCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleActionCountCustomRequestHandlingInsertHeader']):
        """
        :param Sequence['WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgs'] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        WebAclRuleActionCountCustomRequestHandling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insert_headers=insert_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insert_headers: Optional[Sequence['outputs.WebAclRuleActionCountCustomRequestHandlingInsertHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insert_headers is None and 'insertHeaders' in kwargs:
            insert_headers = kwargs['insertHeaders']
        if insert_headers is None:
            raise TypeError("Missing 'insert_headers' argument")

        _setter("insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleActionCountCustomRequestHandlingInsertHeader']:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleActionCountCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param str value: Value of the custom header.
        """
        WebAclRuleActionCountCustomRequestHandlingInsertHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleCaptchaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTimeProperty":
            suggest = "immunity_time_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleCaptchaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleCaptchaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleCaptchaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time_property: Optional['outputs.WebAclRuleCaptchaConfigImmunityTimeProperty'] = None):
        """
        :param 'WebAclRuleCaptchaConfigImmunityTimePropertyArgs' immunity_time_property: Defines custom immunity time. See `immunity_time_property` below for details.
        """
        WebAclRuleCaptchaConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            immunity_time_property=immunity_time_property,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             immunity_time_property: Optional['outputs.WebAclRuleCaptchaConfigImmunityTimeProperty'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if immunity_time_property is None and 'immunityTimeProperty' in kwargs:
            immunity_time_property = kwargs['immunityTimeProperty']

        if immunity_time_property is not None:
            _setter("immunity_time_property", immunity_time_property)

    @property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional['outputs.WebAclRuleCaptchaConfigImmunityTimeProperty']:
        """
        Defines custom immunity time. See `immunity_time_property` below for details.
        """
        return pulumi.get(self, "immunity_time_property")


@pulumi.output_type
class WebAclRuleCaptchaConfigImmunityTimeProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTime":
            suggest = "immunity_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleCaptchaConfigImmunityTimeProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleCaptchaConfigImmunityTimeProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleCaptchaConfigImmunityTimeProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time: Optional[int] = None):
        """
        :param int immunity_time: The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        WebAclRuleCaptchaConfigImmunityTimeProperty._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            immunity_time=immunity_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             immunity_time: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if immunity_time is None and 'immunityTime' in kwargs:
            immunity_time = kwargs['immunityTime']

        if immunity_time is not None:
            _setter("immunity_time", immunity_time)

    @property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[int]:
        """
        The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by AWS WAF. The default setting is 300.
        """
        return pulumi.get(self, "immunity_time")


@pulumi.output_type
class WebAclRuleOverrideAction(dict):
    def __init__(__self__, *,
                 count: Optional['outputs.WebAclRuleOverrideActionCount'] = None,
                 none: Optional['outputs.WebAclRuleOverrideActionNone'] = None):
        """
        :param 'WebAclRuleOverrideActionCountArgs' count: Override the rule action setting to count (i.e., only count matches). Configured as an empty block `{}`.
        :param 'WebAclRuleOverrideActionNoneArgs' none: Don't override the rule action setting. Configured as an empty block `{}`.
        """
        WebAclRuleOverrideAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            none=none,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional['outputs.WebAclRuleOverrideActionCount'] = None,
             none: Optional['outputs.WebAclRuleOverrideActionNone'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if count is not None:
            _setter("count", count)
        if none is not None:
            _setter("none", none)

    @property
    @pulumi.getter
    def count(self) -> Optional['outputs.WebAclRuleOverrideActionCount']:
        """
        Override the rule action setting to count (i.e., only count matches). Configured as an empty block `{}`.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def none(self) -> Optional['outputs.WebAclRuleOverrideActionNone']:
        """
        Don't override the rule action setting. Configured as an empty block `{}`.
        """
        return pulumi.get(self, "none")


@pulumi.output_type
class WebAclRuleOverrideActionCount(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleOverrideActionNone(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleRuleLabel(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Label string.
        """
        WebAclRuleRuleLabel._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Label string.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andStatement":
            suggest = "and_statement"
        elif key == "byteMatchStatement":
            suggest = "byte_match_statement"
        elif key == "geoMatchStatement":
            suggest = "geo_match_statement"
        elif key == "ipSetReferenceStatement":
            suggest = "ip_set_reference_statement"
        elif key == "labelMatchStatement":
            suggest = "label_match_statement"
        elif key == "managedRuleGroupStatement":
            suggest = "managed_rule_group_statement"
        elif key == "notStatement":
            suggest = "not_statement"
        elif key == "orStatement":
            suggest = "or_statement"
        elif key == "rateBasedStatement":
            suggest = "rate_based_statement"
        elif key == "regexMatchStatement":
            suggest = "regex_match_statement"
        elif key == "regexPatternSetReferenceStatement":
            suggest = "regex_pattern_set_reference_statement"
        elif key == "ruleGroupReferenceStatement":
            suggest = "rule_group_reference_statement"
        elif key == "sizeConstraintStatement":
            suggest = "size_constraint_statement"
        elif key == "sqliMatchStatement":
            suggest = "sqli_match_statement"
        elif key == "xssMatchStatement":
            suggest = "xss_match_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_statement: Optional['outputs.WebAclRuleStatementAndStatement'] = None,
                 byte_match_statement: Optional['outputs.WebAclRuleStatementByteMatchStatement'] = None,
                 geo_match_statement: Optional['outputs.WebAclRuleStatementGeoMatchStatement'] = None,
                 ip_set_reference_statement: Optional['outputs.WebAclRuleStatementIpSetReferenceStatement'] = None,
                 label_match_statement: Optional['outputs.WebAclRuleStatementLabelMatchStatement'] = None,
                 managed_rule_group_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatement'] = None,
                 not_statement: Optional['outputs.WebAclRuleStatementNotStatement'] = None,
                 or_statement: Optional['outputs.WebAclRuleStatementOrStatement'] = None,
                 rate_based_statement: Optional['outputs.WebAclRuleStatementRateBasedStatement'] = None,
                 regex_match_statement: Optional['outputs.WebAclRuleStatementRegexMatchStatement'] = None,
                 regex_pattern_set_reference_statement: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatement'] = None,
                 rule_group_reference_statement: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatement'] = None,
                 size_constraint_statement: Optional['outputs.WebAclRuleStatementSizeConstraintStatement'] = None,
                 sqli_match_statement: Optional['outputs.WebAclRuleStatementSqliMatchStatement'] = None,
                 xss_match_statement: Optional['outputs.WebAclRuleStatementXssMatchStatement'] = None):
        """
        :param 'WebAclRuleStatementAndStatementArgs' and_statement: Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        :param 'WebAclRuleStatementByteMatchStatementArgs' byte_match_statement: Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        :param 'WebAclRuleStatementGeoMatchStatementArgs' geo_match_statement: Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        :param 'WebAclRuleStatementIpSetReferenceStatementArgs' ip_set_reference_statement: Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        :param 'WebAclRuleStatementLabelMatchStatementArgs' label_match_statement: Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementArgs' managed_rule_group_statement: Rule statement used to run the rules that are defined in a managed rule group.  This statement can not be nested. See `managed_rule_group_statement` below for details.
        :param 'WebAclRuleStatementNotStatementArgs' not_statement: Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        :param 'WebAclRuleStatementOrStatementArgs' or_statement: Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        :param 'WebAclRuleStatementRateBasedStatementArgs' rate_based_statement: Rate-based rule tracks the rate of requests for each originating `IP address`, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any `5-minute` time span. This statement can not be nested. See `rate_based_statement` below for details.
        :param 'WebAclRuleStatementRegexMatchStatementArgs' regex_match_statement: Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        :param 'WebAclRuleStatementRegexPatternSetReferenceStatementArgs' regex_pattern_set_reference_statement: Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        :param 'WebAclRuleStatementRuleGroupReferenceStatementArgs' rule_group_reference_statement: Rule statement used to run the rules that are defined in an WAFv2 Rule Group. See `rule_group_reference_statement` below for details.
        :param 'WebAclRuleStatementSizeConstraintStatementArgs' size_constraint_statement: Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        :param 'WebAclRuleStatementSqliMatchStatementArgs' sqli_match_statement: An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        :param 'WebAclRuleStatementXssMatchStatementArgs' xss_match_statement: Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
        WebAclRuleStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            and_statement=and_statement,
            byte_match_statement=byte_match_statement,
            geo_match_statement=geo_match_statement,
            ip_set_reference_statement=ip_set_reference_statement,
            label_match_statement=label_match_statement,
            managed_rule_group_statement=managed_rule_group_statement,
            not_statement=not_statement,
            or_statement=or_statement,
            rate_based_statement=rate_based_statement,
            regex_match_statement=regex_match_statement,
            regex_pattern_set_reference_statement=regex_pattern_set_reference_statement,
            rule_group_reference_statement=rule_group_reference_statement,
            size_constraint_statement=size_constraint_statement,
            sqli_match_statement=sqli_match_statement,
            xss_match_statement=xss_match_statement,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             and_statement: Optional['outputs.WebAclRuleStatementAndStatement'] = None,
             byte_match_statement: Optional['outputs.WebAclRuleStatementByteMatchStatement'] = None,
             geo_match_statement: Optional['outputs.WebAclRuleStatementGeoMatchStatement'] = None,
             ip_set_reference_statement: Optional['outputs.WebAclRuleStatementIpSetReferenceStatement'] = None,
             label_match_statement: Optional['outputs.WebAclRuleStatementLabelMatchStatement'] = None,
             managed_rule_group_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatement'] = None,
             not_statement: Optional['outputs.WebAclRuleStatementNotStatement'] = None,
             or_statement: Optional['outputs.WebAclRuleStatementOrStatement'] = None,
             rate_based_statement: Optional['outputs.WebAclRuleStatementRateBasedStatement'] = None,
             regex_match_statement: Optional['outputs.WebAclRuleStatementRegexMatchStatement'] = None,
             regex_pattern_set_reference_statement: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatement'] = None,
             rule_group_reference_statement: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatement'] = None,
             size_constraint_statement: Optional['outputs.WebAclRuleStatementSizeConstraintStatement'] = None,
             sqli_match_statement: Optional['outputs.WebAclRuleStatementSqliMatchStatement'] = None,
             xss_match_statement: Optional['outputs.WebAclRuleStatementXssMatchStatement'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if and_statement is None and 'andStatement' in kwargs:
            and_statement = kwargs['andStatement']
        if byte_match_statement is None and 'byteMatchStatement' in kwargs:
            byte_match_statement = kwargs['byteMatchStatement']
        if geo_match_statement is None and 'geoMatchStatement' in kwargs:
            geo_match_statement = kwargs['geoMatchStatement']
        if ip_set_reference_statement is None and 'ipSetReferenceStatement' in kwargs:
            ip_set_reference_statement = kwargs['ipSetReferenceStatement']
        if label_match_statement is None and 'labelMatchStatement' in kwargs:
            label_match_statement = kwargs['labelMatchStatement']
        if managed_rule_group_statement is None and 'managedRuleGroupStatement' in kwargs:
            managed_rule_group_statement = kwargs['managedRuleGroupStatement']
        if not_statement is None and 'notStatement' in kwargs:
            not_statement = kwargs['notStatement']
        if or_statement is None and 'orStatement' in kwargs:
            or_statement = kwargs['orStatement']
        if rate_based_statement is None and 'rateBasedStatement' in kwargs:
            rate_based_statement = kwargs['rateBasedStatement']
        if regex_match_statement is None and 'regexMatchStatement' in kwargs:
            regex_match_statement = kwargs['regexMatchStatement']
        if regex_pattern_set_reference_statement is None and 'regexPatternSetReferenceStatement' in kwargs:
            regex_pattern_set_reference_statement = kwargs['regexPatternSetReferenceStatement']
        if rule_group_reference_statement is None and 'ruleGroupReferenceStatement' in kwargs:
            rule_group_reference_statement = kwargs['ruleGroupReferenceStatement']
        if size_constraint_statement is None and 'sizeConstraintStatement' in kwargs:
            size_constraint_statement = kwargs['sizeConstraintStatement']
        if sqli_match_statement is None and 'sqliMatchStatement' in kwargs:
            sqli_match_statement = kwargs['sqliMatchStatement']
        if xss_match_statement is None and 'xssMatchStatement' in kwargs:
            xss_match_statement = kwargs['xssMatchStatement']

        if and_statement is not None:
            _setter("and_statement", and_statement)
        if byte_match_statement is not None:
            _setter("byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            _setter("geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            _setter("ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            _setter("label_match_statement", label_match_statement)
        if managed_rule_group_statement is not None:
            _setter("managed_rule_group_statement", managed_rule_group_statement)
        if not_statement is not None:
            _setter("not_statement", not_statement)
        if or_statement is not None:
            _setter("or_statement", or_statement)
        if rate_based_statement is not None:
            _setter("rate_based_statement", rate_based_statement)
        if regex_match_statement is not None:
            _setter("regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            _setter("regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if rule_group_reference_statement is not None:
            _setter("rule_group_reference_statement", rule_group_reference_statement)
        if size_constraint_statement is not None:
            _setter("size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            _setter("sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            _setter("xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional['outputs.WebAclRuleStatementAndStatement']:
        """
        Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        """
        return pulumi.get(self, "and_statement")

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatement']:
        """
        Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        """
        return pulumi.get(self, "byte_match_statement")

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional['outputs.WebAclRuleStatementGeoMatchStatement']:
        """
        Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        """
        return pulumi.get(self, "geo_match_statement")

    @property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional['outputs.WebAclRuleStatementIpSetReferenceStatement']:
        """
        Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        """
        return pulumi.get(self, "ip_set_reference_statement")

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional['outputs.WebAclRuleStatementLabelMatchStatement']:
        """
        Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        """
        return pulumi.get(self, "label_match_statement")

    @property
    @pulumi.getter(name="managedRuleGroupStatement")
    def managed_rule_group_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatement']:
        """
        Rule statement used to run the rules that are defined in a managed rule group.  This statement can not be nested. See `managed_rule_group_statement` below for details.
        """
        return pulumi.get(self, "managed_rule_group_statement")

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional['outputs.WebAclRuleStatementNotStatement']:
        """
        Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        """
        return pulumi.get(self, "not_statement")

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional['outputs.WebAclRuleStatementOrStatement']:
        """
        Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        """
        return pulumi.get(self, "or_statement")

    @property
    @pulumi.getter(name="rateBasedStatement")
    def rate_based_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatement']:
        """
        Rate-based rule tracks the rate of requests for each originating `IP address`, and triggers the rule action when the rate exceeds a limit that you specify on the number of requests in any `5-minute` time span. This statement can not be nested. See `rate_based_statement` below for details.
        """
        return pulumi.get(self, "rate_based_statement")

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatement']:
        """
        Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        """
        return pulumi.get(self, "regex_match_statement")

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatement']:
        """
        Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        """
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @property
    @pulumi.getter(name="ruleGroupReferenceStatement")
    def rule_group_reference_statement(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatement']:
        """
        Rule statement used to run the rules that are defined in an WAFv2 Rule Group. See `rule_group_reference_statement` below for details.
        """
        return pulumi.get(self, "rule_group_reference_statement")

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatement']:
        """
        Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        """
        return pulumi.get(self, "size_constraint_statement")

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatement']:
        """
        An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        """
        return pulumi.get(self, "sqli_match_statement")

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatement']:
        """
        Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
        return pulumi.get(self, "xss_match_statement")


@pulumi.output_type
class WebAclRuleStatementAndStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebAclRuleStatement']):
        """
        :param Sequence['WebAclRuleStatementArgs'] statements: The statements to combine.
        """
        WebAclRuleStatementAndStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statements=statements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statements: Optional[Sequence['outputs.WebAclRuleStatement']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statements is None:
            raise TypeError("Missing 'statements' argument")

        _setter("statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebAclRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "positionalConstraint":
            suggest = "positional_constraint"
        elif key == "searchString":
            suggest = "search_string"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 positional_constraint: str,
                 search_string: str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementByteMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatch'] = None):
        """
        :param str positional_constraint: Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        :param str search_string: String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        :param Sequence['WebAclRuleStatementByteMatchStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param 'WebAclRuleStatementByteMatchStatementFieldToMatchArgs' field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        WebAclRuleStatementByteMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            positional_constraint=positional_constraint,
            search_string=search_string,
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             positional_constraint: Optional[str] = None,
             search_string: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementByteMatchStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if positional_constraint is None and 'positionalConstraint' in kwargs:
            positional_constraint = kwargs['positionalConstraint']
        if positional_constraint is None:
            raise TypeError("Missing 'positional_constraint' argument")
        if search_string is None and 'searchString' in kwargs:
            search_string = kwargs['searchString']
        if search_string is None:
            raise TypeError("Missing 'search_string' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("positional_constraint", positional_constraint)
        _setter("search_string", search_string)
        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> str:
        """
        Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        """
        return pulumi.get(self, "positional_constraint")

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> str:
        """
        String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        """
        return pulumi.get(self, "search_string")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementByteMatchStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatch']:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchUriPath'] = None):
        """
        :param 'WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param 'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param Sequence['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See `headers` below for details.
        :param 'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See `json_body` for details.
        :param 'WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See `single_header` below for details.
        :param 'WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param 'WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        WebAclRuleStatementByteMatchStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementByteMatchStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementByteMatchStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        WebAclRuleStatementByteMatchStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        WebAclRuleStatementByteMatchStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementByteMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementByteMatchStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementGeoMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCodes":
            suggest = "country_codes"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementGeoMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementGeoMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementGeoMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_codes: Sequence[str],
                 forwarded_ip_config: Optional['outputs.WebAclRuleStatementGeoMatchStatementForwardedIpConfig'] = None):
        """
        :param Sequence[str] country_codes: Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        :param 'WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgs' forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
        WebAclRuleStatementGeoMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            country_codes=country_codes,
            forwarded_ip_config=forwarded_ip_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             country_codes: Optional[Sequence[str]] = None,
             forwarded_ip_config: Optional['outputs.WebAclRuleStatementGeoMatchStatementForwardedIpConfig'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if country_codes is None and 'countryCodes' in kwargs:
            country_codes = kwargs['countryCodes']
        if country_codes is None:
            raise TypeError("Missing 'country_codes' argument")
        if forwarded_ip_config is None and 'forwardedIpConfig' in kwargs:
            forwarded_ip_config = kwargs['forwardedIpConfig']

        _setter("country_codes", country_codes)
        if forwarded_ip_config is not None:
            _setter("forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Sequence[str]:
        """
        Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        """
        return pulumi.get(self, "country_codes")

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.WebAclRuleStatementGeoMatchStatementForwardedIpConfig']:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class WebAclRuleStatementGeoMatchStatementForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementGeoMatchStatementForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementGeoMatchStatementForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementGeoMatchStatementForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: str,
                 header_name: str):
        """
        :param str fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param str header_name: Name of the HTTP header to use for the IP address.
        """
        WebAclRuleStatementGeoMatchStatementForwardedIpConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fallback_behavior=fallback_behavior,
            header_name=header_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fallback_behavior: Optional[str] = None,
             header_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fallback_behavior is None and 'fallbackBehavior' in kwargs:
            fallback_behavior = kwargs['fallbackBehavior']
        if fallback_behavior is None:
            raise TypeError("Missing 'fallback_behavior' argument")
        if header_name is None and 'headerName' in kwargs:
            header_name = kwargs['headerName']
        if header_name is None:
            raise TypeError("Missing 'header_name' argument")

        _setter("fallback_behavior", fallback_behavior)
        _setter("header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> str:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")


@pulumi.output_type
class WebAclRuleStatementIpSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipSetForwardedIpConfig":
            suggest = "ip_set_forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementIpSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementIpSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementIpSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 ip_set_forwarded_ip_config: Optional['outputs.WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig'] = None):
        """
        :param str arn: The Amazon Resource Name (ARN) of the IP Set that this statement references.
        :param 'WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs' ip_set_forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
        WebAclRuleStatementIpSetReferenceStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            ip_set_forwarded_ip_config=ip_set_forwarded_ip_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             ip_set_forwarded_ip_config: Optional['outputs.WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if ip_set_forwarded_ip_config is None and 'ipSetForwardedIpConfig' in kwargs:
            ip_set_forwarded_ip_config = kwargs['ipSetForwardedIpConfig']

        _setter("arn", arn)
        if ip_set_forwarded_ip_config is not None:
            _setter("ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the IP Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional['outputs.WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig']:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
        return pulumi.get(self, "ip_set_forwarded_ip_config")


@pulumi.output_type
class WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: str,
                 header_name: str,
                 position: str):
        """
        :param str fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param str header_name: Name of the HTTP header to use for the IP address.
        :param str position: Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fallback_behavior=fallback_behavior,
            header_name=header_name,
            position=position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fallback_behavior: Optional[str] = None,
             header_name: Optional[str] = None,
             position: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fallback_behavior is None and 'fallbackBehavior' in kwargs:
            fallback_behavior = kwargs['fallbackBehavior']
        if fallback_behavior is None:
            raise TypeError("Missing 'fallback_behavior' argument")
        if header_name is None and 'headerName' in kwargs:
            header_name = kwargs['headerName']
        if header_name is None:
            raise TypeError("Missing 'header_name' argument")
        if position is None:
            raise TypeError("Missing 'position' argument")

        _setter("fallback_behavior", fallback_behavior)
        _setter("header_name", header_name)
        _setter("position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> str:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter
    def position(self) -> str:
        """
        Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        return pulumi.get(self, "position")


@pulumi.output_type
class WebAclRuleStatementLabelMatchStatement(dict):
    def __init__(__self__, *,
                 key: str,
                 scope: str):
        """
        :param str key: String to match against.
        :param str scope: Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        WebAclRuleStatementLabelMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            scope=scope,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             scope: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if scope is None:
            raise TypeError("Missing 'scope' argument")

        _setter("key", key)
        _setter("scope", scope)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        String to match against.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def scope(self) -> str:
        """
        Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vendorName":
            suggest = "vendor_name"
        elif key == "managedRuleGroupConfigs":
            suggest = "managed_rule_group_configs"
        elif key == "ruleActionOverrides":
            suggest = "rule_action_overrides"
        elif key == "scopeDownStatement":
            suggest = "scope_down_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 vendor_name: str,
                 managed_rule_group_configs: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfig']] = None,
                 rule_action_overrides: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverride']] = None,
                 scope_down_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatement'] = None,
                 version: Optional[str] = None):
        """
        :param str name: Name of the managed rule group.
        :param str vendor_name: Name of the managed rule group vendor.
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgs'] managed_rule_group_configs: Additional information that's used by a managed rule group. Only one rule attribute is allowed in each config. See `managed_rule_group_configs` for more details
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgs'] rule_action_overrides: Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. See `rule_action_override` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgs' scope_down_statement: Narrows the scope of the statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See `statement` above for details.
        :param str version: Version of the managed rule group. You can set `Version_1.0` or `Version_1.1` etc. If you want to use the default version, do not set anything.
        """
        WebAclRuleStatementManagedRuleGroupStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            vendor_name=vendor_name,
            managed_rule_group_configs=managed_rule_group_configs,
            rule_action_overrides=rule_action_overrides,
            scope_down_statement=scope_down_statement,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             vendor_name: Optional[str] = None,
             managed_rule_group_configs: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfig']] = None,
             rule_action_overrides: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverride']] = None,
             scope_down_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatement'] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if vendor_name is None and 'vendorName' in kwargs:
            vendor_name = kwargs['vendorName']
        if vendor_name is None:
            raise TypeError("Missing 'vendor_name' argument")
        if managed_rule_group_configs is None and 'managedRuleGroupConfigs' in kwargs:
            managed_rule_group_configs = kwargs['managedRuleGroupConfigs']
        if rule_action_overrides is None and 'ruleActionOverrides' in kwargs:
            rule_action_overrides = kwargs['ruleActionOverrides']
        if scope_down_statement is None and 'scopeDownStatement' in kwargs:
            scope_down_statement = kwargs['scopeDownStatement']

        _setter("name", name)
        _setter("vendor_name", vendor_name)
        if managed_rule_group_configs is not None:
            _setter("managed_rule_group_configs", managed_rule_group_configs)
        if rule_action_overrides is not None:
            _setter("rule_action_overrides", rule_action_overrides)
        if scope_down_statement is not None:
            _setter("scope_down_statement", scope_down_statement)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the managed rule group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="vendorName")
    def vendor_name(self) -> str:
        """
        Name of the managed rule group vendor.
        """
        return pulumi.get(self, "vendor_name")

    @property
    @pulumi.getter(name="managedRuleGroupConfigs")
    def managed_rule_group_configs(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfig']]:
        """
        Additional information that's used by a managed rule group. Only one rule attribute is allowed in each config. See `managed_rule_group_configs` for more details
        """
        return pulumi.get(self, "managed_rule_group_configs")

    @property
    @pulumi.getter(name="ruleActionOverrides")
    def rule_action_overrides(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverride']]:
        """
        Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. See `rule_action_override` below for details.
        """
        return pulumi.get(self, "rule_action_overrides")

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatement']:
        """
        Narrows the scope of the statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See `statement` above for details.
        """
        return pulumi.get(self, "scope_down_statement")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of the managed rule group. You can set `Version_1.0` or `Version_1.1` etc. If you want to use the default version, do not set anything.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsManagedRulesAcfpRuleSet":
            suggest = "aws_managed_rules_acfp_rule_set"
        elif key == "awsManagedRulesAtpRuleSet":
            suggest = "aws_managed_rules_atp_rule_set"
        elif key == "awsManagedRulesBotControlRuleSet":
            suggest = "aws_managed_rules_bot_control_rule_set"
        elif key == "loginPath":
            suggest = "login_path"
        elif key == "passwordField":
            suggest = "password_field"
        elif key == "payloadType":
            suggest = "payload_type"
        elif key == "usernameField":
            suggest = "username_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_managed_rules_acfp_rule_set: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSet'] = None,
                 aws_managed_rules_atp_rule_set: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSet'] = None,
                 aws_managed_rules_bot_control_rule_set: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSet'] = None,
                 login_path: Optional[str] = None,
                 password_field: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordField'] = None,
                 payload_type: Optional[str] = None,
                 username_field: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameField'] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgs' aws_managed_rules_acfp_rule_set: Additional configuration for using the Account Creation Fraud Prevention managed rule group. Use this to specify information such as the registration page of your application and the type of content to accept or reject from the client.
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgs' aws_managed_rules_atp_rule_set: Additional configuration for using the Account Takeover Protection managed rule group. Use this to specify information such as the sign-in page of your application and the type of content to accept or reject from the client.
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgs' aws_managed_rules_bot_control_rule_set: Additional configuration for using the Bot Control managed rule group. Use this to specify the inspection level that you want to use. See `aws_managed_rules_bot_control_rule_set` for more details
        :param str login_path: The path of the login endpoint for your application.
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgs' password_field: Details about your login page password field. See `password_field` for more details.
        :param str payload_type: The payload type for your login endpoint, either JSON or form encoded.
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgs' username_field: Details about your login page username field. See `username_field` for more details.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aws_managed_rules_acfp_rule_set=aws_managed_rules_acfp_rule_set,
            aws_managed_rules_atp_rule_set=aws_managed_rules_atp_rule_set,
            aws_managed_rules_bot_control_rule_set=aws_managed_rules_bot_control_rule_set,
            login_path=login_path,
            password_field=password_field,
            payload_type=payload_type,
            username_field=username_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aws_managed_rules_acfp_rule_set: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSet'] = None,
             aws_managed_rules_atp_rule_set: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSet'] = None,
             aws_managed_rules_bot_control_rule_set: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSet'] = None,
             login_path: Optional[str] = None,
             password_field: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordField'] = None,
             payload_type: Optional[str] = None,
             username_field: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameField'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aws_managed_rules_acfp_rule_set is None and 'awsManagedRulesAcfpRuleSet' in kwargs:
            aws_managed_rules_acfp_rule_set = kwargs['awsManagedRulesAcfpRuleSet']
        if aws_managed_rules_atp_rule_set is None and 'awsManagedRulesAtpRuleSet' in kwargs:
            aws_managed_rules_atp_rule_set = kwargs['awsManagedRulesAtpRuleSet']
        if aws_managed_rules_bot_control_rule_set is None and 'awsManagedRulesBotControlRuleSet' in kwargs:
            aws_managed_rules_bot_control_rule_set = kwargs['awsManagedRulesBotControlRuleSet']
        if login_path is None and 'loginPath' in kwargs:
            login_path = kwargs['loginPath']
        if password_field is None and 'passwordField' in kwargs:
            password_field = kwargs['passwordField']
        if payload_type is None and 'payloadType' in kwargs:
            payload_type = kwargs['payloadType']
        if username_field is None and 'usernameField' in kwargs:
            username_field = kwargs['usernameField']

        if aws_managed_rules_acfp_rule_set is not None:
            _setter("aws_managed_rules_acfp_rule_set", aws_managed_rules_acfp_rule_set)
        if aws_managed_rules_atp_rule_set is not None:
            _setter("aws_managed_rules_atp_rule_set", aws_managed_rules_atp_rule_set)
        if aws_managed_rules_bot_control_rule_set is not None:
            _setter("aws_managed_rules_bot_control_rule_set", aws_managed_rules_bot_control_rule_set)
        if login_path is not None:
            _setter("login_path", login_path)
        if password_field is not None:
            _setter("password_field", password_field)
        if payload_type is not None:
            _setter("payload_type", payload_type)
        if username_field is not None:
            _setter("username_field", username_field)

    @property
    @pulumi.getter(name="awsManagedRulesAcfpRuleSet")
    def aws_managed_rules_acfp_rule_set(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSet']:
        """
        Additional configuration for using the Account Creation Fraud Prevention managed rule group. Use this to specify information such as the registration page of your application and the type of content to accept or reject from the client.
        """
        return pulumi.get(self, "aws_managed_rules_acfp_rule_set")

    @property
    @pulumi.getter(name="awsManagedRulesAtpRuleSet")
    def aws_managed_rules_atp_rule_set(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSet']:
        """
        Additional configuration for using the Account Takeover Protection managed rule group. Use this to specify information such as the sign-in page of your application and the type of content to accept or reject from the client.
        """
        return pulumi.get(self, "aws_managed_rules_atp_rule_set")

    @property
    @pulumi.getter(name="awsManagedRulesBotControlRuleSet")
    def aws_managed_rules_bot_control_rule_set(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSet']:
        """
        Additional configuration for using the Bot Control managed rule group. Use this to specify the inspection level that you want to use. See `aws_managed_rules_bot_control_rule_set` for more details
        """
        return pulumi.get(self, "aws_managed_rules_bot_control_rule_set")

    @property
    @pulumi.getter(name="loginPath")
    def login_path(self) -> Optional[str]:
        """
        The path of the login endpoint for your application.
        """
        return pulumi.get(self, "login_path")

    @property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordField']:
        """
        Details about your login page password field. See `password_field` for more details.
        """
        return pulumi.get(self, "password_field")

    @property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> Optional[str]:
        """
        The payload type for your login endpoint, either JSON or form encoded.
        """
        return pulumi.get(self, "payload_type")

    @property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameField']:
        """
        Details about your login page username field. See `username_field` for more details.
        """
        return pulumi.get(self, "username_field")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "creationPath":
            suggest = "creation_path"
        elif key == "registrationPagePath":
            suggest = "registration_page_path"
        elif key == "requestInspection":
            suggest = "request_inspection"
        elif key == "enableRegexInPath":
            suggest = "enable_regex_in_path"
        elif key == "responseInspection":
            suggest = "response_inspection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 creation_path: str,
                 registration_page_path: str,
                 request_inspection: 'outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspection',
                 enable_regex_in_path: Optional[bool] = None,
                 response_inspection: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspection'] = None):
        """
        :param str creation_path: The path of the account creation endpoint for your application. This is the page on your website that accepts the completed registration form for a new user. This page must accept POST requests.
        :param str registration_page_path: The path of the account registration endpoint for your application. This is the page on your website that presents the registration form to new users. This page must accept GET text/html requests.
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgs' request_inspection: The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage. See `request_inspection` for more details.
        :param bool enable_regex_in_path: Whether or not to allow the use of regular expressions in the login page path.
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgs' response_inspection: The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates. Note that Response Inspection is available only on web ACLs that protect CloudFront distributions. See `response_inspection` for more details.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            creation_path=creation_path,
            registration_page_path=registration_page_path,
            request_inspection=request_inspection,
            enable_regex_in_path=enable_regex_in_path,
            response_inspection=response_inspection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             creation_path: Optional[str] = None,
             registration_page_path: Optional[str] = None,
             request_inspection: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspection'] = None,
             enable_regex_in_path: Optional[bool] = None,
             response_inspection: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspection'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if creation_path is None and 'creationPath' in kwargs:
            creation_path = kwargs['creationPath']
        if creation_path is None:
            raise TypeError("Missing 'creation_path' argument")
        if registration_page_path is None and 'registrationPagePath' in kwargs:
            registration_page_path = kwargs['registrationPagePath']
        if registration_page_path is None:
            raise TypeError("Missing 'registration_page_path' argument")
        if request_inspection is None and 'requestInspection' in kwargs:
            request_inspection = kwargs['requestInspection']
        if request_inspection is None:
            raise TypeError("Missing 'request_inspection' argument")
        if enable_regex_in_path is None and 'enableRegexInPath' in kwargs:
            enable_regex_in_path = kwargs['enableRegexInPath']
        if response_inspection is None and 'responseInspection' in kwargs:
            response_inspection = kwargs['responseInspection']

        _setter("creation_path", creation_path)
        _setter("registration_page_path", registration_page_path)
        _setter("request_inspection", request_inspection)
        if enable_regex_in_path is not None:
            _setter("enable_regex_in_path", enable_regex_in_path)
        if response_inspection is not None:
            _setter("response_inspection", response_inspection)

    @property
    @pulumi.getter(name="creationPath")
    def creation_path(self) -> str:
        """
        The path of the account creation endpoint for your application. This is the page on your website that accepts the completed registration form for a new user. This page must accept POST requests.
        """
        return pulumi.get(self, "creation_path")

    @property
    @pulumi.getter(name="registrationPagePath")
    def registration_page_path(self) -> str:
        """
        The path of the account registration endpoint for your application. This is the page on your website that presents the registration form to new users. This page must accept GET text/html requests.
        """
        return pulumi.get(self, "registration_page_path")

    @property
    @pulumi.getter(name="requestInspection")
    def request_inspection(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspection':
        """
        The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage. See `request_inspection` for more details.
        """
        return pulumi.get(self, "request_inspection")

    @property
    @pulumi.getter(name="enableRegexInPath")
    def enable_regex_in_path(self) -> Optional[bool]:
        """
        Whether or not to allow the use of regular expressions in the login page path.
        """
        return pulumi.get(self, "enable_regex_in_path")

    @property
    @pulumi.getter(name="responseInspection")
    def response_inspection(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspection']:
        """
        The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates. Note that Response Inspection is available only on web ACLs that protect CloudFront distributions. See `response_inspection` for more details.
        """
        return pulumi.get(self, "response_inspection")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "payloadType":
            suggest = "payload_type"
        elif key == "emailField":
            suggest = "email_field"
        elif key == "passwordField":
            suggest = "password_field"
        elif key == "usernameField":
            suggest = "username_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 payload_type: str,
                 email_field: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailField'] = None,
                 password_field: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordField'] = None,
                 username_field: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameField'] = None):
        """
        :param str payload_type: The payload type for your login endpoint, either JSON or form encoded.
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgs' password_field: Details about your login page password field. See `password_field` for more details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgs' username_field: Details about your login page username field. See `username_field` for more details.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            payload_type=payload_type,
            email_field=email_field,
            password_field=password_field,
            username_field=username_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             payload_type: Optional[str] = None,
             email_field: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailField'] = None,
             password_field: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordField'] = None,
             username_field: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameField'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if payload_type is None and 'payloadType' in kwargs:
            payload_type = kwargs['payloadType']
        if payload_type is None:
            raise TypeError("Missing 'payload_type' argument")
        if email_field is None and 'emailField' in kwargs:
            email_field = kwargs['emailField']
        if password_field is None and 'passwordField' in kwargs:
            password_field = kwargs['passwordField']
        if username_field is None and 'usernameField' in kwargs:
            username_field = kwargs['usernameField']

        _setter("payload_type", payload_type)
        if email_field is not None:
            _setter("email_field", email_field)
        if password_field is not None:
            _setter("password_field", password_field)
        if username_field is not None:
            _setter("username_field", username_field)

    @property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> str:
        """
        The payload type for your login endpoint, either JSON or form encoded.
        """
        return pulumi.get(self, "payload_type")

    @property
    @pulumi.getter(name="emailField")
    def email_field(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailField']:
        return pulumi.get(self, "email_field")

    @property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordField']:
        """
        Details about your login page password field. See `password_field` for more details.
        """
        return pulumi.get(self, "password_field")

    @property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameField']:
        """
        Details about your login page username field. See `username_field` for more details.
        """
        return pulumi.get(self, "username_field")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailField(dict):
    def __init__(__self__, *,
                 identifier: str):
        """
        :param str identifier: The identifier for the value to match against in the JSON.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identifier=identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if identifier is None:
            raise TypeError("Missing 'identifier' argument")

        _setter("identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        The identifier for the value to match against in the JSON.
        """
        return pulumi.get(self, "identifier")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordField(dict):
    def __init__(__self__, *,
                 identifier: str):
        """
        :param str identifier: The name of the password field.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identifier=identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if identifier is None:
            raise TypeError("Missing 'identifier' argument")

        _setter("identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        The name of the password field.
        """
        return pulumi.get(self, "identifier")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameField(dict):
    def __init__(__self__, *,
                 identifier: str):
        """
        :param str identifier: The name of the username field.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identifier=identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if identifier is None:
            raise TypeError("Missing 'identifier' argument")

        _setter("identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        The name of the username field.
        """
        return pulumi.get(self, "identifier")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bodyContains":
            suggest = "body_contains"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body_contains: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContains'] = None,
                 header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeader'] = None,
                 json: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJson'] = None,
                 status_code: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCode'] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgs' body_contains: Configures inspection of the response body. See `body_contains` for more details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgs' header: Configures inspection of the response header.See `header` for more details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgs' json: Configures inspection of the response JSON. See `json` for more details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgs' status_code: Configures inspection of the response status code.See `status_code` for more details.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            body_contains=body_contains,
            header=header,
            json=json,
            status_code=status_code,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             body_contains: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContains'] = None,
             header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeader'] = None,
             json: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJson'] = None,
             status_code: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCode'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if body_contains is None and 'bodyContains' in kwargs:
            body_contains = kwargs['bodyContains']
        if status_code is None and 'statusCode' in kwargs:
            status_code = kwargs['statusCode']

        if body_contains is not None:
            _setter("body_contains", body_contains)
        if header is not None:
            _setter("header", header)
        if json is not None:
            _setter("json", json)
        if status_code is not None:
            _setter("status_code", status_code)

    @property
    @pulumi.getter(name="bodyContains")
    def body_contains(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContains']:
        """
        Configures inspection of the response body. See `body_contains` for more details.
        """
        return pulumi.get(self, "body_contains")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeader']:
        """
        Configures inspection of the response header.See `header` for more details.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def json(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJson']:
        """
        Configures inspection of the response JSON. See `json` for more details.
        """
        return pulumi.get(self, "json")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCode']:
        """
        Configures inspection of the response status code.See `status_code` for more details.
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContains(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureStrings":
            suggest = "failure_strings"
        elif key == "successStrings":
            suggest = "success_strings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContains. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContains.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContains.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_strings: Sequence[str],
                 success_strings: Sequence[str]):
        """
        :param Sequence[str] failure_strings: Strings in the body of the response that indicate a failed login attempt.
        :param Sequence[str] success_strings: Strings in the body of the response that indicate a successful login attempt.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContains._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failure_strings=failure_strings,
            success_strings=success_strings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failure_strings: Optional[Sequence[str]] = None,
             success_strings: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failure_strings is None and 'failureStrings' in kwargs:
            failure_strings = kwargs['failureStrings']
        if failure_strings is None:
            raise TypeError("Missing 'failure_strings' argument")
        if success_strings is None and 'successStrings' in kwargs:
            success_strings = kwargs['successStrings']
        if success_strings is None:
            raise TypeError("Missing 'success_strings' argument")

        _setter("failure_strings", failure_strings)
        _setter("success_strings", success_strings)

    @property
    @pulumi.getter(name="failureStrings")
    def failure_strings(self) -> Sequence[str]:
        """
        Strings in the body of the response that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_strings")

    @property
    @pulumi.getter(name="successStrings")
    def success_strings(self) -> Sequence[str]:
        """
        Strings in the body of the response that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_strings")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureValues":
            suggest = "failure_values"
        elif key == "successValues":
            suggest = "success_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_values: Sequence[str],
                 name: str,
                 success_values: Sequence[str]):
        """
        :param Sequence[str] failure_values: Values in the response header with the specified name that indicate a failed login attempt.
        :param str name: The name of the header to use.
        :param Sequence[str] success_values: Values in the response header with the specified name that indicate a successful login attempt.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failure_values=failure_values,
            name=name,
            success_values=success_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failure_values: Optional[Sequence[str]] = None,
             name: Optional[str] = None,
             success_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failure_values is None and 'failureValues' in kwargs:
            failure_values = kwargs['failureValues']
        if failure_values is None:
            raise TypeError("Missing 'failure_values' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if success_values is None and 'successValues' in kwargs:
            success_values = kwargs['successValues']
        if success_values is None:
            raise TypeError("Missing 'success_values' argument")

        _setter("failure_values", failure_values)
        _setter("name", name)
        _setter("success_values", success_values)

    @property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> Sequence[str]:
        """
        Values in the response header with the specified name that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_values")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the header to use.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="successValues")
    def success_values(self) -> Sequence[str]:
        """
        Values in the response header with the specified name that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_values")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJson(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureValues":
            suggest = "failure_values"
        elif key == "successValues":
            suggest = "success_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJson. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJson.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJson.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_values: Sequence[str],
                 identifier: str,
                 success_values: Sequence[str]):
        """
        :param Sequence[str] failure_values: Values in the response header with the specified name that indicate a failed login attempt.
        :param str identifier: The identifier for the value to match against in the JSON.
        :param Sequence[str] success_values: Values in the response header with the specified name that indicate a successful login attempt.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJson._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failure_values=failure_values,
            identifier=identifier,
            success_values=success_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failure_values: Optional[Sequence[str]] = None,
             identifier: Optional[str] = None,
             success_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failure_values is None and 'failureValues' in kwargs:
            failure_values = kwargs['failureValues']
        if failure_values is None:
            raise TypeError("Missing 'failure_values' argument")
        if identifier is None:
            raise TypeError("Missing 'identifier' argument")
        if success_values is None and 'successValues' in kwargs:
            success_values = kwargs['successValues']
        if success_values is None:
            raise TypeError("Missing 'success_values' argument")

        _setter("failure_values", failure_values)
        _setter("identifier", identifier)
        _setter("success_values", success_values)

    @property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> Sequence[str]:
        """
        Values in the response header with the specified name that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_values")

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        The identifier for the value to match against in the JSON.
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter(name="successValues")
    def success_values(self) -> Sequence[str]:
        """
        Values in the response header with the specified name that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_values")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureCodes":
            suggest = "failure_codes"
        elif key == "successCodes":
            suggest = "success_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_codes: Sequence[int],
                 success_codes: Sequence[int]):
        """
        :param Sequence[int] failure_codes: Status codes in the response that indicate a failed login attempt.
        :param Sequence[int] success_codes: Status codes in the response that indicate a successful login attempt.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failure_codes=failure_codes,
            success_codes=success_codes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failure_codes: Optional[Sequence[int]] = None,
             success_codes: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failure_codes is None and 'failureCodes' in kwargs:
            failure_codes = kwargs['failureCodes']
        if failure_codes is None:
            raise TypeError("Missing 'failure_codes' argument")
        if success_codes is None and 'successCodes' in kwargs:
            success_codes = kwargs['successCodes']
        if success_codes is None:
            raise TypeError("Missing 'success_codes' argument")

        _setter("failure_codes", failure_codes)
        _setter("success_codes", success_codes)

    @property
    @pulumi.getter(name="failureCodes")
    def failure_codes(self) -> Sequence[int]:
        """
        Status codes in the response that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_codes")

    @property
    @pulumi.getter(name="successCodes")
    def success_codes(self) -> Sequence[int]:
        """
        Status codes in the response that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_codes")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loginPath":
            suggest = "login_path"
        elif key == "enableRegexInPath":
            suggest = "enable_regex_in_path"
        elif key == "requestInspection":
            suggest = "request_inspection"
        elif key == "responseInspection":
            suggest = "response_inspection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login_path: str,
                 enable_regex_in_path: Optional[bool] = None,
                 request_inspection: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspection'] = None,
                 response_inspection: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspection'] = None):
        """
        :param str login_path: The path of the login endpoint for your application.
        :param bool enable_regex_in_path: Whether or not to allow the use of regular expressions in the login page path.
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgs' request_inspection: The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage. See `request_inspection` for more details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgs' response_inspection: The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates. Note that Response Inspection is available only on web ACLs that protect CloudFront distributions. See `response_inspection` for more details.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            login_path=login_path,
            enable_regex_in_path=enable_regex_in_path,
            request_inspection=request_inspection,
            response_inspection=response_inspection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             login_path: Optional[str] = None,
             enable_regex_in_path: Optional[bool] = None,
             request_inspection: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspection'] = None,
             response_inspection: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspection'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if login_path is None and 'loginPath' in kwargs:
            login_path = kwargs['loginPath']
        if login_path is None:
            raise TypeError("Missing 'login_path' argument")
        if enable_regex_in_path is None and 'enableRegexInPath' in kwargs:
            enable_regex_in_path = kwargs['enableRegexInPath']
        if request_inspection is None and 'requestInspection' in kwargs:
            request_inspection = kwargs['requestInspection']
        if response_inspection is None and 'responseInspection' in kwargs:
            response_inspection = kwargs['responseInspection']

        _setter("login_path", login_path)
        if enable_regex_in_path is not None:
            _setter("enable_regex_in_path", enable_regex_in_path)
        if request_inspection is not None:
            _setter("request_inspection", request_inspection)
        if response_inspection is not None:
            _setter("response_inspection", response_inspection)

    @property
    @pulumi.getter(name="loginPath")
    def login_path(self) -> str:
        """
        The path of the login endpoint for your application.
        """
        return pulumi.get(self, "login_path")

    @property
    @pulumi.getter(name="enableRegexInPath")
    def enable_regex_in_path(self) -> Optional[bool]:
        """
        Whether or not to allow the use of regular expressions in the login page path.
        """
        return pulumi.get(self, "enable_regex_in_path")

    @property
    @pulumi.getter(name="requestInspection")
    def request_inspection(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspection']:
        """
        The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage. See `request_inspection` for more details.
        """
        return pulumi.get(self, "request_inspection")

    @property
    @pulumi.getter(name="responseInspection")
    def response_inspection(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspection']:
        """
        The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates. Note that Response Inspection is available only on web ACLs that protect CloudFront distributions. See `response_inspection` for more details.
        """
        return pulumi.get(self, "response_inspection")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordField":
            suggest = "password_field"
        elif key == "payloadType":
            suggest = "payload_type"
        elif key == "usernameField":
            suggest = "username_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_field: 'outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordField',
                 payload_type: str,
                 username_field: 'outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameField'):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgs' password_field: Details about your login page password field. See `password_field` for more details.
        :param str payload_type: The payload type for your login endpoint, either JSON or form encoded.
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgs' username_field: Details about your login page username field. See `username_field` for more details.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password_field=password_field,
            payload_type=payload_type,
            username_field=username_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password_field: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordField'] = None,
             payload_type: Optional[str] = None,
             username_field: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameField'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if password_field is None and 'passwordField' in kwargs:
            password_field = kwargs['passwordField']
        if password_field is None:
            raise TypeError("Missing 'password_field' argument")
        if payload_type is None and 'payloadType' in kwargs:
            payload_type = kwargs['payloadType']
        if payload_type is None:
            raise TypeError("Missing 'payload_type' argument")
        if username_field is None and 'usernameField' in kwargs:
            username_field = kwargs['usernameField']
        if username_field is None:
            raise TypeError("Missing 'username_field' argument")

        _setter("password_field", password_field)
        _setter("payload_type", payload_type)
        _setter("username_field", username_field)

    @property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordField':
        """
        Details about your login page password field. See `password_field` for more details.
        """
        return pulumi.get(self, "password_field")

    @property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> str:
        """
        The payload type for your login endpoint, either JSON or form encoded.
        """
        return pulumi.get(self, "payload_type")

    @property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameField':
        """
        Details about your login page username field. See `username_field` for more details.
        """
        return pulumi.get(self, "username_field")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordField(dict):
    def __init__(__self__, *,
                 identifier: str):
        """
        :param str identifier: The name of the password field.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identifier=identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if identifier is None:
            raise TypeError("Missing 'identifier' argument")

        _setter("identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        The name of the password field.
        """
        return pulumi.get(self, "identifier")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameField(dict):
    def __init__(__self__, *,
                 identifier: str):
        """
        :param str identifier: The name of the username field.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identifier=identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if identifier is None:
            raise TypeError("Missing 'identifier' argument")

        _setter("identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        The name of the username field.
        """
        return pulumi.get(self, "identifier")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bodyContains":
            suggest = "body_contains"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body_contains: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContains'] = None,
                 header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeader'] = None,
                 json: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJson'] = None,
                 status_code: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCode'] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgs' body_contains: Configures inspection of the response body. See `body_contains` for more details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgs' header: Configures inspection of the response header.See `header` for more details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgs' json: Configures inspection of the response JSON. See `json` for more details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgs' status_code: Configures inspection of the response status code.See `status_code` for more details.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            body_contains=body_contains,
            header=header,
            json=json,
            status_code=status_code,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             body_contains: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContains'] = None,
             header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeader'] = None,
             json: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJson'] = None,
             status_code: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCode'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if body_contains is None and 'bodyContains' in kwargs:
            body_contains = kwargs['bodyContains']
        if status_code is None and 'statusCode' in kwargs:
            status_code = kwargs['statusCode']

        if body_contains is not None:
            _setter("body_contains", body_contains)
        if header is not None:
            _setter("header", header)
        if json is not None:
            _setter("json", json)
        if status_code is not None:
            _setter("status_code", status_code)

    @property
    @pulumi.getter(name="bodyContains")
    def body_contains(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContains']:
        """
        Configures inspection of the response body. See `body_contains` for more details.
        """
        return pulumi.get(self, "body_contains")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeader']:
        """
        Configures inspection of the response header.See `header` for more details.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def json(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJson']:
        """
        Configures inspection of the response JSON. See `json` for more details.
        """
        return pulumi.get(self, "json")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCode']:
        """
        Configures inspection of the response status code.See `status_code` for more details.
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContains(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureStrings":
            suggest = "failure_strings"
        elif key == "successStrings":
            suggest = "success_strings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContains. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContains.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContains.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_strings: Sequence[str],
                 success_strings: Sequence[str]):
        """
        :param Sequence[str] failure_strings: Strings in the body of the response that indicate a failed login attempt.
        :param Sequence[str] success_strings: Strings in the body of the response that indicate a successful login attempt.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContains._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failure_strings=failure_strings,
            success_strings=success_strings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failure_strings: Optional[Sequence[str]] = None,
             success_strings: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failure_strings is None and 'failureStrings' in kwargs:
            failure_strings = kwargs['failureStrings']
        if failure_strings is None:
            raise TypeError("Missing 'failure_strings' argument")
        if success_strings is None and 'successStrings' in kwargs:
            success_strings = kwargs['successStrings']
        if success_strings is None:
            raise TypeError("Missing 'success_strings' argument")

        _setter("failure_strings", failure_strings)
        _setter("success_strings", success_strings)

    @property
    @pulumi.getter(name="failureStrings")
    def failure_strings(self) -> Sequence[str]:
        """
        Strings in the body of the response that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_strings")

    @property
    @pulumi.getter(name="successStrings")
    def success_strings(self) -> Sequence[str]:
        """
        Strings in the body of the response that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_strings")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureValues":
            suggest = "failure_values"
        elif key == "successValues":
            suggest = "success_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_values: Sequence[str],
                 name: str,
                 success_values: Sequence[str]):
        """
        :param Sequence[str] failure_values: Values in the response header with the specified name that indicate a failed login attempt.
        :param str name: The name of the header to use.
        :param Sequence[str] success_values: Values in the response header with the specified name that indicate a successful login attempt.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failure_values=failure_values,
            name=name,
            success_values=success_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failure_values: Optional[Sequence[str]] = None,
             name: Optional[str] = None,
             success_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failure_values is None and 'failureValues' in kwargs:
            failure_values = kwargs['failureValues']
        if failure_values is None:
            raise TypeError("Missing 'failure_values' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if success_values is None and 'successValues' in kwargs:
            success_values = kwargs['successValues']
        if success_values is None:
            raise TypeError("Missing 'success_values' argument")

        _setter("failure_values", failure_values)
        _setter("name", name)
        _setter("success_values", success_values)

    @property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> Sequence[str]:
        """
        Values in the response header with the specified name that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_values")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the header to use.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="successValues")
    def success_values(self) -> Sequence[str]:
        """
        Values in the response header with the specified name that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_values")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJson(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureValues":
            suggest = "failure_values"
        elif key == "successValues":
            suggest = "success_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJson. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJson.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJson.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_values: Sequence[str],
                 identifier: str,
                 success_values: Sequence[str]):
        """
        :param Sequence[str] failure_values: Values in the response header with the specified name that indicate a failed login attempt.
        :param str identifier: The identifier for the value to match against in the JSON.
        :param Sequence[str] success_values: Values in the response header with the specified name that indicate a successful login attempt.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJson._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failure_values=failure_values,
            identifier=identifier,
            success_values=success_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failure_values: Optional[Sequence[str]] = None,
             identifier: Optional[str] = None,
             success_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failure_values is None and 'failureValues' in kwargs:
            failure_values = kwargs['failureValues']
        if failure_values is None:
            raise TypeError("Missing 'failure_values' argument")
        if identifier is None:
            raise TypeError("Missing 'identifier' argument")
        if success_values is None and 'successValues' in kwargs:
            success_values = kwargs['successValues']
        if success_values is None:
            raise TypeError("Missing 'success_values' argument")

        _setter("failure_values", failure_values)
        _setter("identifier", identifier)
        _setter("success_values", success_values)

    @property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> Sequence[str]:
        """
        Values in the response header with the specified name that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_values")

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        The identifier for the value to match against in the JSON.
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter(name="successValues")
    def success_values(self) -> Sequence[str]:
        """
        Values in the response header with the specified name that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_values")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureCodes":
            suggest = "failure_codes"
        elif key == "successCodes":
            suggest = "success_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_codes: Sequence[int],
                 success_codes: Sequence[int]):
        """
        :param Sequence[int] failure_codes: Status codes in the response that indicate a failed login attempt.
        :param Sequence[int] success_codes: Status codes in the response that indicate a successful login attempt.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failure_codes=failure_codes,
            success_codes=success_codes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failure_codes: Optional[Sequence[int]] = None,
             success_codes: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failure_codes is None and 'failureCodes' in kwargs:
            failure_codes = kwargs['failureCodes']
        if failure_codes is None:
            raise TypeError("Missing 'failure_codes' argument")
        if success_codes is None and 'successCodes' in kwargs:
            success_codes = kwargs['successCodes']
        if success_codes is None:
            raise TypeError("Missing 'success_codes' argument")

        _setter("failure_codes", failure_codes)
        _setter("success_codes", success_codes)

    @property
    @pulumi.getter(name="failureCodes")
    def failure_codes(self) -> Sequence[int]:
        """
        Status codes in the response that indicate a failed login attempt.
        """
        return pulumi.get(self, "failure_codes")

    @property
    @pulumi.getter(name="successCodes")
    def success_codes(self) -> Sequence[int]:
        """
        Status codes in the response that indicate a successful login attempt.
        """
        return pulumi.get(self, "success_codes")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inspectionLevel":
            suggest = "inspection_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inspection_level: str):
        """
        :param str inspection_level: The inspection level to use for the Bot Control rule group.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            inspection_level=inspection_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             inspection_level: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if inspection_level is None and 'inspectionLevel' in kwargs:
            inspection_level = kwargs['inspectionLevel']
        if inspection_level is None:
            raise TypeError("Missing 'inspection_level' argument")

        _setter("inspection_level", inspection_level)

    @property
    @pulumi.getter(name="inspectionLevel")
    def inspection_level(self) -> str:
        """
        The inspection level to use for the Bot Control rule group.
        """
        return pulumi.get(self, "inspection_level")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordField(dict):
    def __init__(__self__, *,
                 identifier: str):
        """
        :param str identifier: The name of the password field.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identifier=identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if identifier is None:
            raise TypeError("Missing 'identifier' argument")

        _setter("identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        The name of the password field.
        """
        return pulumi.get(self, "identifier")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameField(dict):
    def __init__(__self__, *,
                 identifier: str):
        """
        :param str identifier: The name of the username field.
        """
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identifier=identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if identifier is None:
            raise TypeError("Missing 'identifier' argument")

        _setter("identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        The name of the username field.
        """
        return pulumi.get(self, "identifier")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionToUse":
            suggest = "action_to_use"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_to_use: 'outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUse',
                 name: str):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgs' action_to_use: Override action to use, in place of the configured action of the rule in the rule group. See `action` for details.
        :param str name: Name of the rule to override. See the [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-list.html) for a list of names in the appropriate rule group in use.
        """
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverride._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_to_use=action_to_use,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_to_use: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUse'] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_to_use is None and 'actionToUse' in kwargs:
            action_to_use = kwargs['actionToUse']
        if action_to_use is None:
            raise TypeError("Missing 'action_to_use' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("action_to_use", action_to_use)
        _setter("name", name)

    @property
    @pulumi.getter(name="actionToUse")
    def action_to_use(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUse':
        """
        Override action to use, in place of the configured action of the rule in the rule group. See `action` for details.
        """
        return pulumi.get(self, "action_to_use")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the rule to override. See the [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-list.html) for a list of names in the appropriate rule group in use.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUse(dict):
    def __init__(__self__, *,
                 allow: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllow'] = None,
                 block: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlock'] = None,
                 captcha: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptcha'] = None,
                 challenge: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallenge'] = None,
                 count: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCount'] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgs' allow: Instructs AWS WAF to allow the web request. See `allow` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgs' block: Instructs AWS WAF to block the web request. See `block` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgs' captcha: Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgs' challenge: Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgs' count: Instructs AWS WAF to count the web request and allow it. See `count` below for details.
        """
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow=allow,
            block=block,
            captcha=captcha,
            challenge=challenge,
            count=count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllow'] = None,
             block: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlock'] = None,
             captcha: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptcha'] = None,
             challenge: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallenge'] = None,
             count: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCount'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if allow is not None:
            _setter("allow", allow)
        if block is not None:
            _setter("block", block)
        if captcha is not None:
            _setter("captcha", captcha)
        if challenge is not None:
            _setter("challenge", challenge)
        if count is not None:
            _setter("count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllow']:
        """
        Instructs AWS WAF to allow the web request. See `allow` below for details.
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def block(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlock']:
        """
        Instructs AWS WAF to block the web request. See `block` below for details.
        """
        return pulumi.get(self, "block")

    @property
    @pulumi.getter
    def captcha(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptcha']:
        """
        Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        """
        return pulumi.get(self, "captcha")

    @property
    @pulumi.getter
    def challenge(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallenge']:
        """
        Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        """
        return pulumi.get(self, "challenge")

    @property
    @pulumi.getter
    def count(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCount']:
        """
        Instructs AWS WAF to count the web request and allow it. See `count` below for details.
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandling'] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs' custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandling']:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader']):
        """
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs'] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insert_headers=insert_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insert_headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insert_headers is None and 'insertHeaders' in kwargs:
            insert_headers = kwargs['insertHeaders']
        if insert_headers is None:
            raise TypeError("Missing 'insert_headers' argument")

        _setter("insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader']:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param str value: Value of the custom header.
        """
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlock(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customResponse":
            suggest = "custom_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlock. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlock.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlock.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_response: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponse'] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgs' custom_response: Defines a custom response for the web request. See `custom_response` below for details.
        """
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlock._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_response=custom_response,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_response: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_response is None and 'customResponse' in kwargs:
            custom_response = kwargs['customResponse']

        if custom_response is not None:
            _setter("custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponse']:
        """
        Defines a custom response for the web request. See `custom_response` below for details.
        """
        return pulumi.get(self, "custom_response")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseCode":
            suggest = "response_code"
        elif key == "customResponseBodyKey":
            suggest = "custom_response_body_key"
        elif key == "responseHeaders":
            suggest = "response_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_code: int,
                 custom_response_body_key: Optional[str] = None,
                 response_headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader']] = None):
        """
        :param int response_code: The HTTP status code to return to the client.
        :param str custom_response_body_key: References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs'] response_headers: The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            response_code=response_code,
            custom_response_body_key=custom_response_body_key,
            response_headers=response_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             response_code: Optional[int] = None,
             custom_response_body_key: Optional[str] = None,
             response_headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if response_code is None and 'responseCode' in kwargs:
            response_code = kwargs['responseCode']
        if response_code is None:
            raise TypeError("Missing 'response_code' argument")
        if custom_response_body_key is None and 'customResponseBodyKey' in kwargs:
            custom_response_body_key = kwargs['customResponseBodyKey']
        if response_headers is None and 'responseHeaders' in kwargs:
            response_headers = kwargs['responseHeaders']

        _setter("response_code", response_code)
        if custom_response_body_key is not None:
            _setter("custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            _setter("response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> int:
        """
        The HTTP status code to return to the client.
        """
        return pulumi.get(self, "response_code")

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[str]:
        """
        References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        """
        return pulumi.get(self, "custom_response_body_key")

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader']]:
        """
        The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        return pulumi.get(self, "response_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param str value: Value of the custom header.
        """
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptcha(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptcha. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptcha.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptcha.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling'] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs' custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptcha._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling']:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader']):
        """
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs'] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insert_headers=insert_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insert_headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insert_headers is None and 'insertHeaders' in kwargs:
            insert_headers = kwargs['insertHeaders']
        if insert_headers is None:
            raise TypeError("Missing 'insert_headers' argument")

        _setter("insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader']:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param str value: Value of the custom header.
        """
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallenge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallenge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallenge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallenge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling'] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs' custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallenge._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling']:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader']):
        """
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs'] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insert_headers=insert_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insert_headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insert_headers is None and 'insertHeaders' in kwargs:
            insert_headers = kwargs['insertHeaders']
        if insert_headers is None:
            raise TypeError("Missing 'insert_headers' argument")

        _setter("insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader']:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param str value: Value of the custom header.
        """
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandling'] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs' custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandling']:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader']):
        """
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs'] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insert_headers=insert_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insert_headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insert_headers is None and 'insertHeaders' in kwargs:
            insert_headers = kwargs['insertHeaders']
        if insert_headers is None:
            raise TypeError("Missing 'insert_headers' argument")

        _setter("insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader']:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param str value: Value of the custom header.
        """
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andStatement":
            suggest = "and_statement"
        elif key == "byteMatchStatement":
            suggest = "byte_match_statement"
        elif key == "geoMatchStatement":
            suggest = "geo_match_statement"
        elif key == "ipSetReferenceStatement":
            suggest = "ip_set_reference_statement"
        elif key == "labelMatchStatement":
            suggest = "label_match_statement"
        elif key == "notStatement":
            suggest = "not_statement"
        elif key == "orStatement":
            suggest = "or_statement"
        elif key == "regexMatchStatement":
            suggest = "regex_match_statement"
        elif key == "regexPatternSetReferenceStatement":
            suggest = "regex_pattern_set_reference_statement"
        elif key == "sizeConstraintStatement":
            suggest = "size_constraint_statement"
        elif key == "sqliMatchStatement":
            suggest = "sqli_match_statement"
        elif key == "xssMatchStatement":
            suggest = "xss_match_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatement'] = None,
                 byte_match_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatement'] = None,
                 geo_match_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatement'] = None,
                 ip_set_reference_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatement'] = None,
                 label_match_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatement'] = None,
                 not_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatement'] = None,
                 or_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatement'] = None,
                 regex_match_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatement'] = None,
                 regex_pattern_set_reference_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatement'] = None,
                 size_constraint_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatement'] = None,
                 sqli_match_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatement'] = None,
                 xss_match_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatement'] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgs' and_statement: Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgs' byte_match_statement: Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgs' geo_match_statement: Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgs' ip_set_reference_statement: Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgs' label_match_statement: Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgs' not_statement: Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgs' or_statement: Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgs' regex_match_statement: Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgs' regex_pattern_set_reference_statement: Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgs' size_constraint_statement: Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgs' sqli_match_statement: An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgs' xss_match_statement: Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            and_statement=and_statement,
            byte_match_statement=byte_match_statement,
            geo_match_statement=geo_match_statement,
            ip_set_reference_statement=ip_set_reference_statement,
            label_match_statement=label_match_statement,
            not_statement=not_statement,
            or_statement=or_statement,
            regex_match_statement=regex_match_statement,
            regex_pattern_set_reference_statement=regex_pattern_set_reference_statement,
            size_constraint_statement=size_constraint_statement,
            sqli_match_statement=sqli_match_statement,
            xss_match_statement=xss_match_statement,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             and_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatement'] = None,
             byte_match_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatement'] = None,
             geo_match_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatement'] = None,
             ip_set_reference_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatement'] = None,
             label_match_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatement'] = None,
             not_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatement'] = None,
             or_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatement'] = None,
             regex_match_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatement'] = None,
             regex_pattern_set_reference_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatement'] = None,
             size_constraint_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatement'] = None,
             sqli_match_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatement'] = None,
             xss_match_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatement'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if and_statement is None and 'andStatement' in kwargs:
            and_statement = kwargs['andStatement']
        if byte_match_statement is None and 'byteMatchStatement' in kwargs:
            byte_match_statement = kwargs['byteMatchStatement']
        if geo_match_statement is None and 'geoMatchStatement' in kwargs:
            geo_match_statement = kwargs['geoMatchStatement']
        if ip_set_reference_statement is None and 'ipSetReferenceStatement' in kwargs:
            ip_set_reference_statement = kwargs['ipSetReferenceStatement']
        if label_match_statement is None and 'labelMatchStatement' in kwargs:
            label_match_statement = kwargs['labelMatchStatement']
        if not_statement is None and 'notStatement' in kwargs:
            not_statement = kwargs['notStatement']
        if or_statement is None and 'orStatement' in kwargs:
            or_statement = kwargs['orStatement']
        if regex_match_statement is None and 'regexMatchStatement' in kwargs:
            regex_match_statement = kwargs['regexMatchStatement']
        if regex_pattern_set_reference_statement is None and 'regexPatternSetReferenceStatement' in kwargs:
            regex_pattern_set_reference_statement = kwargs['regexPatternSetReferenceStatement']
        if size_constraint_statement is None and 'sizeConstraintStatement' in kwargs:
            size_constraint_statement = kwargs['sizeConstraintStatement']
        if sqli_match_statement is None and 'sqliMatchStatement' in kwargs:
            sqli_match_statement = kwargs['sqliMatchStatement']
        if xss_match_statement is None and 'xssMatchStatement' in kwargs:
            xss_match_statement = kwargs['xssMatchStatement']

        if and_statement is not None:
            _setter("and_statement", and_statement)
        if byte_match_statement is not None:
            _setter("byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            _setter("geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            _setter("ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            _setter("label_match_statement", label_match_statement)
        if not_statement is not None:
            _setter("not_statement", not_statement)
        if or_statement is not None:
            _setter("or_statement", or_statement)
        if regex_match_statement is not None:
            _setter("regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            _setter("regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            _setter("size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            _setter("sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            _setter("xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatement']:
        """
        Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        """
        return pulumi.get(self, "and_statement")

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatement']:
        """
        Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        """
        return pulumi.get(self, "byte_match_statement")

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatement']:
        """
        Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        """
        return pulumi.get(self, "geo_match_statement")

    @property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatement']:
        """
        Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        """
        return pulumi.get(self, "ip_set_reference_statement")

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatement']:
        """
        Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        """
        return pulumi.get(self, "label_match_statement")

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatement']:
        """
        Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        """
        return pulumi.get(self, "not_statement")

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatement']:
        """
        Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        """
        return pulumi.get(self, "or_statement")

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatement']:
        """
        Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        """
        return pulumi.get(self, "regex_match_statement")

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatement']:
        """
        Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        """
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatement']:
        """
        Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        """
        return pulumi.get(self, "size_constraint_statement")

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatement']:
        """
        An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        """
        return pulumi.get(self, "sqli_match_statement")

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatement']:
        """
        Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
        return pulumi.get(self, "xss_match_statement")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebAclRuleStatement']):
        """
        :param Sequence['WebAclRuleStatementArgs'] statements: The statements to combine.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statements=statements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statements: Optional[Sequence['outputs.WebAclRuleStatement']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statements is None:
            raise TypeError("Missing 'statements' argument")

        _setter("statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebAclRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "positionalConstraint":
            suggest = "positional_constraint"
        elif key == "searchString":
            suggest = "search_string"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 positional_constraint: str,
                 search_string: str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatch'] = None):
        """
        :param str positional_constraint: Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        :param str search_string: String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgs' field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            positional_constraint=positional_constraint,
            search_string=search_string,
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             positional_constraint: Optional[str] = None,
             search_string: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if positional_constraint is None and 'positionalConstraint' in kwargs:
            positional_constraint = kwargs['positionalConstraint']
        if positional_constraint is None:
            raise TypeError("Missing 'positional_constraint' argument")
        if search_string is None and 'searchString' in kwargs:
            search_string = kwargs['searchString']
        if search_string is None:
            raise TypeError("Missing 'search_string' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("positional_constraint", positional_constraint)
        _setter("search_string", search_string)
        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> str:
        """
        Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        """
        return pulumi.get(self, "positional_constraint")

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> str:
        """
        String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        """
        return pulumi.get(self, "search_string")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatch']:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath'] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See `headers` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See `json_body` for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See `single_header` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCodes":
            suggest = "country_codes"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_codes: Sequence[str],
                 forwarded_ip_config: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfig'] = None):
        """
        :param Sequence[str] country_codes: Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs' forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            country_codes=country_codes,
            forwarded_ip_config=forwarded_ip_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             country_codes: Optional[Sequence[str]] = None,
             forwarded_ip_config: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfig'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if country_codes is None and 'countryCodes' in kwargs:
            country_codes = kwargs['countryCodes']
        if country_codes is None:
            raise TypeError("Missing 'country_codes' argument")
        if forwarded_ip_config is None and 'forwardedIpConfig' in kwargs:
            forwarded_ip_config = kwargs['forwardedIpConfig']

        _setter("country_codes", country_codes)
        if forwarded_ip_config is not None:
            _setter("forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Sequence[str]:
        """
        Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        """
        return pulumi.get(self, "country_codes")

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfig']:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: str,
                 header_name: str):
        """
        :param str fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param str header_name: Name of the HTTP header to use for the IP address.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fallback_behavior=fallback_behavior,
            header_name=header_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fallback_behavior: Optional[str] = None,
             header_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fallback_behavior is None and 'fallbackBehavior' in kwargs:
            fallback_behavior = kwargs['fallbackBehavior']
        if fallback_behavior is None:
            raise TypeError("Missing 'fallback_behavior' argument")
        if header_name is None and 'headerName' in kwargs:
            header_name = kwargs['headerName']
        if header_name is None:
            raise TypeError("Missing 'header_name' argument")

        _setter("fallback_behavior", fallback_behavior)
        _setter("header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> str:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipSetForwardedIpConfig":
            suggest = "ip_set_forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 ip_set_forwarded_ip_config: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig'] = None):
        """
        :param str arn: The Amazon Resource Name (ARN) of the IP Set that this statement references.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs' ip_set_forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            ip_set_forwarded_ip_config=ip_set_forwarded_ip_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             ip_set_forwarded_ip_config: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if ip_set_forwarded_ip_config is None and 'ipSetForwardedIpConfig' in kwargs:
            ip_set_forwarded_ip_config = kwargs['ipSetForwardedIpConfig']

        _setter("arn", arn)
        if ip_set_forwarded_ip_config is not None:
            _setter("ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the IP Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig']:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
        return pulumi.get(self, "ip_set_forwarded_ip_config")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: str,
                 header_name: str,
                 position: str):
        """
        :param str fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param str header_name: Name of the HTTP header to use for the IP address.
        :param str position: Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fallback_behavior=fallback_behavior,
            header_name=header_name,
            position=position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fallback_behavior: Optional[str] = None,
             header_name: Optional[str] = None,
             position: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fallback_behavior is None and 'fallbackBehavior' in kwargs:
            fallback_behavior = kwargs['fallbackBehavior']
        if fallback_behavior is None:
            raise TypeError("Missing 'fallback_behavior' argument")
        if header_name is None and 'headerName' in kwargs:
            header_name = kwargs['headerName']
        if header_name is None:
            raise TypeError("Missing 'header_name' argument")
        if position is None:
            raise TypeError("Missing 'position' argument")

        _setter("fallback_behavior", fallback_behavior)
        _setter("header_name", header_name)
        _setter("position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> str:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter
    def position(self) -> str:
        """
        Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        return pulumi.get(self, "position")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatement(dict):
    def __init__(__self__, *,
                 key: str,
                 scope: str):
        """
        :param str key: String to match against.
        :param str scope: Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            scope=scope,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             scope: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if scope is None:
            raise TypeError("Missing 'scope' argument")

        _setter("key", key)
        _setter("scope", scope)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        String to match against.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def scope(self) -> str:
        """
        Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebAclRuleStatement']):
        """
        :param Sequence['WebAclRuleStatementArgs'] statements: The statements to combine.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statements=statements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statements: Optional[Sequence['outputs.WebAclRuleStatement']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statements is None:
            raise TypeError("Missing 'statements' argument")

        _setter("statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebAclRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebAclRuleStatement']):
        """
        :param Sequence['WebAclRuleStatementArgs'] statements: The statements to combine.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statements=statements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statements: Optional[Sequence['outputs.WebAclRuleStatement']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statements is None:
            raise TypeError("Missing 'statements' argument")

        _setter("statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebAclRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regexString":
            suggest = "regex_string"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regex_string: str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatch'] = None):
        """
        :param str regex_string: String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs' field_to_match: The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            regex_string=regex_string,
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             regex_string: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if regex_string is None and 'regexString' in kwargs:
            regex_string = kwargs['regexString']
        if regex_string is None:
            raise TypeError("Missing 'regex_string' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("regex_string", regex_string)
        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> str:
        """
        String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        """
        return pulumi.get(self, "regex_string")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatch']:
        """
        The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath'] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See `headers` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See `json_body` for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See `single_header` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch'] = None):
        """
        :param str arn: The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs' field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("arn", arn)
        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch']:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath'] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See `headers` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See `json_body` for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See `single_header` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: str,
                 size: int,
                 text_transformations: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatch'] = None):
        """
        :param str comparison_operator: Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        :param int size: Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs' field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            size=size,
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             size: Optional[int] = None,
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']
        if comparison_operator is None:
            raise TypeError("Missing 'comparison_operator' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("comparison_operator", comparison_operator)
        _setter("size", size)
        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> str:
        """
        Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatch']:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath'] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See `headers` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See `json_body` for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See `single_header` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatch'] = None):
        """
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs' field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatch']:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath'] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See `headers` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See `json_body` for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See `single_header` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatch'] = None):
        """
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgs' field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatch']:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath'] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See `headers` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See `json_body` for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See `single_header` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementNotStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebAclRuleStatement']):
        """
        :param Sequence['WebAclRuleStatementArgs'] statements: The statements to combine.
        """
        WebAclRuleStatementNotStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statements=statements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statements: Optional[Sequence['outputs.WebAclRuleStatement']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statements is None:
            raise TypeError("Missing 'statements' argument")

        _setter("statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebAclRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebAclRuleStatementOrStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebAclRuleStatement']):
        """
        :param Sequence['WebAclRuleStatementArgs'] statements: The statements to combine.
        """
        WebAclRuleStatementOrStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statements=statements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statements: Optional[Sequence['outputs.WebAclRuleStatement']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statements is None:
            raise TypeError("Missing 'statements' argument")

        _setter("statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebAclRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregateKeyType":
            suggest = "aggregate_key_type"
        elif key == "customKeys":
            suggest = "custom_keys"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"
        elif key == "scopeDownStatement":
            suggest = "scope_down_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit: int,
                 aggregate_key_type: Optional[str] = None,
                 custom_keys: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKey']] = None,
                 forwarded_ip_config: Optional['outputs.WebAclRuleStatementRateBasedStatementForwardedIpConfig'] = None,
                 scope_down_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatement'] = None):
        """
        :param int limit: Limit on requests per 5-minute period for a single originating IP address.
        :param str aggregate_key_type: Setting that indicates how to aggregate the request counts. Valid values include: `CONSTANT`, `CUSTOM_KEYS`, `FORWARDED_IP`, or `IP`. Default: `IP`.
        :param Sequence['WebAclRuleStatementRateBasedStatementCustomKeyArgs'] custom_keys: Aggregate the request counts using one or more web request components as the aggregate keys. See `custom_key` below for details.
        :param 'WebAclRuleStatementRateBasedStatementForwardedIpConfigArgs' forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. If `aggregate_key_type` is set to `FORWARDED_IP`, this block is required. See `forwarded_ip_config` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementArgs' scope_down_statement: Optional nested statement that narrows the scope of the rate-based statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See `statement` above for details. If `aggregate_key_type` is set to `CONSTANT`, this block is required.
        """
        WebAclRuleStatementRateBasedStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            limit=limit,
            aggregate_key_type=aggregate_key_type,
            custom_keys=custom_keys,
            forwarded_ip_config=forwarded_ip_config,
            scope_down_statement=scope_down_statement,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             limit: Optional[int] = None,
             aggregate_key_type: Optional[str] = None,
             custom_keys: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKey']] = None,
             forwarded_ip_config: Optional['outputs.WebAclRuleStatementRateBasedStatementForwardedIpConfig'] = None,
             scope_down_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatement'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if limit is None:
            raise TypeError("Missing 'limit' argument")
        if aggregate_key_type is None and 'aggregateKeyType' in kwargs:
            aggregate_key_type = kwargs['aggregateKeyType']
        if custom_keys is None and 'customKeys' in kwargs:
            custom_keys = kwargs['customKeys']
        if forwarded_ip_config is None and 'forwardedIpConfig' in kwargs:
            forwarded_ip_config = kwargs['forwardedIpConfig']
        if scope_down_statement is None and 'scopeDownStatement' in kwargs:
            scope_down_statement = kwargs['scopeDownStatement']

        _setter("limit", limit)
        if aggregate_key_type is not None:
            _setter("aggregate_key_type", aggregate_key_type)
        if custom_keys is not None:
            _setter("custom_keys", custom_keys)
        if forwarded_ip_config is not None:
            _setter("forwarded_ip_config", forwarded_ip_config)
        if scope_down_statement is not None:
            _setter("scope_down_statement", scope_down_statement)

    @property
    @pulumi.getter
    def limit(self) -> int:
        """
        Limit on requests per 5-minute period for a single originating IP address.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="aggregateKeyType")
    def aggregate_key_type(self) -> Optional[str]:
        """
        Setting that indicates how to aggregate the request counts. Valid values include: `CONSTANT`, `CUSTOM_KEYS`, `FORWARDED_IP`, or `IP`. Default: `IP`.
        """
        return pulumi.get(self, "aggregate_key_type")

    @property
    @pulumi.getter(name="customKeys")
    def custom_keys(self) -> Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKey']]:
        """
        Aggregate the request counts using one or more web request components as the aggregate keys. See `custom_key` below for details.
        """
        return pulumi.get(self, "custom_keys")

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementForwardedIpConfig']:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. If `aggregate_key_type` is set to `FORWARDED_IP`, this block is required. See `forwarded_ip_config` below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")

    @property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatement']:
        """
        Optional nested statement that narrows the scope of the rate-based statement to matching web requests. This can be any nestable statement, and you can nest statements at any level below this scope-down statement. See `statement` above for details. If `aggregate_key_type` is set to `CONSTANT`, this block is required.
        """
        return pulumi.get(self, "scope_down_statement")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forwardedIp":
            suggest = "forwarded_ip"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "labelNamespace":
            suggest = "label_namespace"
        elif key == "queryArgument":
            suggest = "query_argument"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementCustomKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyCookie'] = None,
                 forwarded_ip: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyForwardedIp'] = None,
                 header: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyHeader'] = None,
                 http_method: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyHttpMethod'] = None,
                 ip: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyIp'] = None,
                 label_namespace: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespace'] = None,
                 query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyQueryArgument'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyQueryString'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyUriPath'] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementCustomKeyCookieArgs' cookie: Use the value of a cookie in the request as an aggregate key. See RateLimit `cookie` below for details.
        :param 'WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgs' forwarded_ip: Use the first IP address in an HTTP header as an aggregate key. See `forwarded_ip` below for details.
        :param 'WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgs' header: Use the value of a header in the request as an aggregate key. See RateLimit `header` below for details.
        :param 'WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgs' http_method: Use the request's HTTP method as an aggregate key. See RateLimit `http_method` below for details.
        :param 'WebAclRuleStatementRateBasedStatementCustomKeyIpArgs' ip: Use the request's originating IP address as an aggregate key. See `RateLimit ip` below for details.
        :param 'WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs' label_namespace: Use the specified label namespace as an aggregate key. See RateLimit `label_namespace` below for details.
        :param 'WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs' query_argument: Use the specified query argument as an aggregate key. See RateLimit `query_argument` below for details.
        :param 'WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgs' query_string: Use the request's query string as an aggregate key. See RateLimit `query_string` below for details.
        :param 'WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgs' uri_path: Use the request's URI path as an aggregate key. See RateLimit `uri_path` below for details.
        """
        WebAclRuleStatementRateBasedStatementCustomKey._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cookie=cookie,
            forwarded_ip=forwarded_ip,
            header=header,
            http_method=http_method,
            ip=ip,
            label_namespace=label_namespace,
            query_argument=query_argument,
            query_string=query_string,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cookie: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyCookie'] = None,
             forwarded_ip: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyForwardedIp'] = None,
             header: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyHeader'] = None,
             http_method: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyHttpMethod'] = None,
             ip: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyIp'] = None,
             label_namespace: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespace'] = None,
             query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyQueryArgument'] = None,
             query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyQueryString'] = None,
             uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if forwarded_ip is None and 'forwardedIp' in kwargs:
            forwarded_ip = kwargs['forwardedIp']
        if http_method is None and 'httpMethod' in kwargs:
            http_method = kwargs['httpMethod']
        if label_namespace is None and 'labelNamespace' in kwargs:
            label_namespace = kwargs['labelNamespace']
        if query_argument is None and 'queryArgument' in kwargs:
            query_argument = kwargs['queryArgument']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if cookie is not None:
            _setter("cookie", cookie)
        if forwarded_ip is not None:
            _setter("forwarded_ip", forwarded_ip)
        if header is not None:
            _setter("header", header)
        if http_method is not None:
            _setter("http_method", http_method)
        if ip is not None:
            _setter("ip", ip)
        if label_namespace is not None:
            _setter("label_namespace", label_namespace)
        if query_argument is not None:
            _setter("query_argument", query_argument)
        if query_string is not None:
            _setter("query_string", query_string)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyCookie']:
        """
        Use the value of a cookie in the request as an aggregate key. See RateLimit `cookie` below for details.
        """
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter(name="forwardedIp")
    def forwarded_ip(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyForwardedIp']:
        """
        Use the first IP address in an HTTP header as an aggregate key. See `forwarded_ip` below for details.
        """
        return pulumi.get(self, "forwarded_ip")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyHeader']:
        """
        Use the value of a header in the request as an aggregate key. See RateLimit `header` below for details.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyHttpMethod']:
        """
        Use the request's HTTP method as an aggregate key. See RateLimit `http_method` below for details.
        """
        return pulumi.get(self, "http_method")

    @property
    @pulumi.getter
    def ip(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyIp']:
        """
        Use the request's originating IP address as an aggregate key. See `RateLimit ip` below for details.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="labelNamespace")
    def label_namespace(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespace']:
        """
        Use the specified label namespace as an aggregate key. See RateLimit `label_namespace` below for details.
        """
        return pulumi.get(self, "label_namespace")

    @property
    @pulumi.getter(name="queryArgument")
    def query_argument(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyQueryArgument']:
        """
        Use the specified query argument as an aggregate key. See RateLimit `query_argument` below for details.
        """
        return pulumi.get(self, "query_argument")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyQueryString']:
        """
        Use the request's query string as an aggregate key. See RateLimit `query_string` below for details.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyUriPath']:
        """
        Use the request's URI path as an aggregate key. See RateLimit `uri_path` below for details.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyCookie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementCustomKeyCookie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyCookie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyCookie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformation']):
        """
        :param str name: The name of the cookie to use.
        :param Sequence['WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        WebAclRuleStatementRateBasedStatementCustomKeyCookie._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("name", name)
        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the cookie to use.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyForwardedIp(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementCustomKeyHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation']):
        """
        :param str name: The name of the header to use.
        :param Sequence['WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        WebAclRuleStatementRateBasedStatementCustomKeyHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("name", name)
        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the header to use.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyHttpMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyIp(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespace(dict):
    def __init__(__self__, *,
                 namespace: str):
        """
        :param str namespace: The namespace to use for aggregation
        """
        WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespace._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            namespace=namespace,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             namespace: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if namespace is None:
            raise TypeError("Missing 'namespace' argument")

        _setter("namespace", namespace)

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The namespace to use for aggregation
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyQueryArgument(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementCustomKeyQueryArgument. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyQueryArgument.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyQueryArgument.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation']):
        """
        :param str name: The name of the query argument to use.
        :param Sequence['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        WebAclRuleStatementRateBasedStatementCustomKeyQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("name", name)
        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query argument to use.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyQueryString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementCustomKeyQueryString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyQueryString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyQueryString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation']):
        """
        :param Sequence['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        WebAclRuleStatementRateBasedStatementCustomKeyQueryString._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyUriPath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementCustomKeyUriPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyUriPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyUriPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation']):
        """
        :param Sequence['WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        WebAclRuleStatementRateBasedStatementCustomKeyUriPath._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text_transformations=text_transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")

        _setter("text_transformations", text_transformations)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. They are used in rate-based rule statements, to transform request components before using them as custom aggregation keys. Atleast one transformation is required. See `text_transformation` above for details.
        """
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: str,
                 header_name: str):
        """
        :param str fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param str header_name: Name of the HTTP header to use for the IP address.
        """
        WebAclRuleStatementRateBasedStatementForwardedIpConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fallback_behavior=fallback_behavior,
            header_name=header_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fallback_behavior: Optional[str] = None,
             header_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fallback_behavior is None and 'fallbackBehavior' in kwargs:
            fallback_behavior = kwargs['fallbackBehavior']
        if fallback_behavior is None:
            raise TypeError("Missing 'fallback_behavior' argument")
        if header_name is None and 'headerName' in kwargs:
            header_name = kwargs['headerName']
        if header_name is None:
            raise TypeError("Missing 'header_name' argument")

        _setter("fallback_behavior", fallback_behavior)
        _setter("header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> str:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andStatement":
            suggest = "and_statement"
        elif key == "byteMatchStatement":
            suggest = "byte_match_statement"
        elif key == "geoMatchStatement":
            suggest = "geo_match_statement"
        elif key == "ipSetReferenceStatement":
            suggest = "ip_set_reference_statement"
        elif key == "labelMatchStatement":
            suggest = "label_match_statement"
        elif key == "notStatement":
            suggest = "not_statement"
        elif key == "orStatement":
            suggest = "or_statement"
        elif key == "regexMatchStatement":
            suggest = "regex_match_statement"
        elif key == "regexPatternSetReferenceStatement":
            suggest = "regex_pattern_set_reference_statement"
        elif key == "sizeConstraintStatement":
            suggest = "size_constraint_statement"
        elif key == "sqliMatchStatement":
            suggest = "sqli_match_statement"
        elif key == "xssMatchStatement":
            suggest = "xss_match_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatement'] = None,
                 byte_match_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement'] = None,
                 geo_match_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement'] = None,
                 ip_set_reference_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement'] = None,
                 label_match_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement'] = None,
                 not_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatement'] = None,
                 or_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatement'] = None,
                 regex_match_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement'] = None,
                 regex_pattern_set_reference_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement'] = None,
                 size_constraint_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement'] = None,
                 sqli_match_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement'] = None,
                 xss_match_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement'] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs' and_statement: Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs' byte_match_statement: Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs' geo_match_statement: Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs' ip_set_reference_statement: Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs' label_match_statement: Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs' not_statement: Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs' or_statement: Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs' regex_match_statement: Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs' regex_pattern_set_reference_statement: Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs' size_constraint_statement: Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs' sqli_match_statement: An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs' xss_match_statement: Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            and_statement=and_statement,
            byte_match_statement=byte_match_statement,
            geo_match_statement=geo_match_statement,
            ip_set_reference_statement=ip_set_reference_statement,
            label_match_statement=label_match_statement,
            not_statement=not_statement,
            or_statement=or_statement,
            regex_match_statement=regex_match_statement,
            regex_pattern_set_reference_statement=regex_pattern_set_reference_statement,
            size_constraint_statement=size_constraint_statement,
            sqli_match_statement=sqli_match_statement,
            xss_match_statement=xss_match_statement,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             and_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatement'] = None,
             byte_match_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement'] = None,
             geo_match_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement'] = None,
             ip_set_reference_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement'] = None,
             label_match_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement'] = None,
             not_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatement'] = None,
             or_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatement'] = None,
             regex_match_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement'] = None,
             regex_pattern_set_reference_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement'] = None,
             size_constraint_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement'] = None,
             sqli_match_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement'] = None,
             xss_match_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if and_statement is None and 'andStatement' in kwargs:
            and_statement = kwargs['andStatement']
        if byte_match_statement is None and 'byteMatchStatement' in kwargs:
            byte_match_statement = kwargs['byteMatchStatement']
        if geo_match_statement is None and 'geoMatchStatement' in kwargs:
            geo_match_statement = kwargs['geoMatchStatement']
        if ip_set_reference_statement is None and 'ipSetReferenceStatement' in kwargs:
            ip_set_reference_statement = kwargs['ipSetReferenceStatement']
        if label_match_statement is None and 'labelMatchStatement' in kwargs:
            label_match_statement = kwargs['labelMatchStatement']
        if not_statement is None and 'notStatement' in kwargs:
            not_statement = kwargs['notStatement']
        if or_statement is None and 'orStatement' in kwargs:
            or_statement = kwargs['orStatement']
        if regex_match_statement is None and 'regexMatchStatement' in kwargs:
            regex_match_statement = kwargs['regexMatchStatement']
        if regex_pattern_set_reference_statement is None and 'regexPatternSetReferenceStatement' in kwargs:
            regex_pattern_set_reference_statement = kwargs['regexPatternSetReferenceStatement']
        if size_constraint_statement is None and 'sizeConstraintStatement' in kwargs:
            size_constraint_statement = kwargs['sizeConstraintStatement']
        if sqli_match_statement is None and 'sqliMatchStatement' in kwargs:
            sqli_match_statement = kwargs['sqliMatchStatement']
        if xss_match_statement is None and 'xssMatchStatement' in kwargs:
            xss_match_statement = kwargs['xssMatchStatement']

        if and_statement is not None:
            _setter("and_statement", and_statement)
        if byte_match_statement is not None:
            _setter("byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            _setter("geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            _setter("ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            _setter("label_match_statement", label_match_statement)
        if not_statement is not None:
            _setter("not_statement", not_statement)
        if or_statement is not None:
            _setter("or_statement", or_statement)
        if regex_match_statement is not None:
            _setter("regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            _setter("regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            _setter("size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            _setter("sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            _setter("xss_match_statement", xss_match_statement)

    @property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatement']:
        """
        Logical rule statement used to combine other rule statements with AND logic. See `and_statement` below for details.
        """
        return pulumi.get(self, "and_statement")

    @property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement']:
        """
        Rule statement that defines a string match search for AWS WAF to apply to web requests. See `byte_match_statement` below for details.
        """
        return pulumi.get(self, "byte_match_statement")

    @property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement']:
        """
        Rule statement used to identify web requests based on country of origin. See `geo_match_statement` below for details.
        """
        return pulumi.get(self, "geo_match_statement")

    @property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement']:
        """
        Rule statement used to detect web requests coming from particular IP addresses or address ranges. See `ip_set_reference_statement` below for details.
        """
        return pulumi.get(self, "ip_set_reference_statement")

    @property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement']:
        """
        Rule statement that defines a string match search against labels that have been added to the web request by rules that have already run in the web ACL. See `label_match_statement` below for details.
        """
        return pulumi.get(self, "label_match_statement")

    @property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatement']:
        """
        Logical rule statement used to negate the results of another rule statement. See `not_statement` below for details.
        """
        return pulumi.get(self, "not_statement")

    @property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatement']:
        """
        Logical rule statement used to combine other rule statements with OR logic. See `or_statement` below for details.
        """
        return pulumi.get(self, "or_statement")

    @property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement']:
        """
        Rule statement used to search web request components for a match against a single regular expression. See `regex_match_statement` below for details.
        """
        return pulumi.get(self, "regex_match_statement")

    @property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement']:
        """
        Rule statement used to search web request components for matches with regular expressions. See `regex_pattern_set_reference_statement` below for details.
        """
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement']:
        """
        Rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). See `size_constraint_statement` below for more details.
        """
        return pulumi.get(self, "size_constraint_statement")

    @property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement']:
        """
        An SQL injection match condition identifies the part of web requests, such as the URI or the query string, that you want AWS WAF to inspect. See `sqli_match_statement` below for details.
        """
        return pulumi.get(self, "sqli_match_statement")

    @property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement']:
        """
        Rule statement that defines a cross-site scripting (XSS) match search for AWS WAF to apply to web requests. See `xss_match_statement` below for details.
        """
        return pulumi.get(self, "xss_match_statement")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebAclRuleStatement']):
        """
        :param Sequence['WebAclRuleStatementArgs'] statements: The statements to combine.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statements=statements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statements: Optional[Sequence['outputs.WebAclRuleStatement']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statements is None:
            raise TypeError("Missing 'statements' argument")

        _setter("statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebAclRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "positionalConstraint":
            suggest = "positional_constraint"
        elif key == "searchString":
            suggest = "search_string"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 positional_constraint: str,
                 search_string: str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch'] = None):
        """
        :param str positional_constraint: Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        :param str search_string: String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        :param Sequence['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs' field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            positional_constraint=positional_constraint,
            search_string=search_string,
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             positional_constraint: Optional[str] = None,
             search_string: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if positional_constraint is None and 'positionalConstraint' in kwargs:
            positional_constraint = kwargs['positionalConstraint']
        if positional_constraint is None:
            raise TypeError("Missing 'positional_constraint' argument")
        if search_string is None and 'searchString' in kwargs:
            search_string = kwargs['searchString']
        if search_string is None:
            raise TypeError("Missing 'search_string' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("positional_constraint", positional_constraint)
        _setter("search_string", search_string)
        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> str:
        """
        Area within the portion of a web request that you want AWS WAF to search for `search_string`. Valid values include the following: `EXACTLY`, `STARTS_WITH`, `ENDS_WITH`, `CONTAINS`, `CONTAINS_WORD`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_ByteMatchStatement.html) for more information.
        """
        return pulumi.get(self, "positional_constraint")

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> str:
        """
        String value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `field_to_match`. The maximum length of the value is 50 bytes.
        """
        return pulumi.get(self, "search_string")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch']:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath'] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param Sequence['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See `headers` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See `json_body` for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See `single_header` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCodes":
            suggest = "country_codes"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_codes: Sequence[str],
                 forwarded_ip_config: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig'] = None):
        """
        :param Sequence[str] country_codes: Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs' forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            country_codes=country_codes,
            forwarded_ip_config=forwarded_ip_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             country_codes: Optional[Sequence[str]] = None,
             forwarded_ip_config: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if country_codes is None and 'countryCodes' in kwargs:
            country_codes = kwargs['countryCodes']
        if country_codes is None:
            raise TypeError("Missing 'country_codes' argument")
        if forwarded_ip_config is None and 'forwardedIpConfig' in kwargs:
            forwarded_ip_config = kwargs['forwardedIpConfig']

        _setter("country_codes", country_codes)
        if forwarded_ip_config is not None:
            _setter("forwarded_ip_config", forwarded_ip_config)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Sequence[str]:
        """
        Array of two-character country codes, for example, [ "US", "CN" ], from the alpha-2 country ISO codes of the `ISO 3166` international standard. See the [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_GeoMatchStatement.html) for valid values.
        """
        return pulumi.get(self, "country_codes")

    @property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig']:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `forwarded_ip_config` below for details.
        """
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: str,
                 header_name: str):
        """
        :param str fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param str header_name: Name of the HTTP header to use for the IP address.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fallback_behavior=fallback_behavior,
            header_name=header_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fallback_behavior: Optional[str] = None,
             header_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fallback_behavior is None and 'fallbackBehavior' in kwargs:
            fallback_behavior = kwargs['fallbackBehavior']
        if fallback_behavior is None:
            raise TypeError("Missing 'fallback_behavior' argument")
        if header_name is None and 'headerName' in kwargs:
            header_name = kwargs['headerName']
        if header_name is None:
            raise TypeError("Missing 'header_name' argument")

        _setter("fallback_behavior", fallback_behavior)
        _setter("header_name", header_name)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> str:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipSetForwardedIpConfig":
            suggest = "ip_set_forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 ip_set_forwarded_ip_config: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig'] = None):
        """
        :param str arn: The Amazon Resource Name (ARN) of the IP Set that this statement references.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs' ip_set_forwarded_ip_config: Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            ip_set_forwarded_ip_config=ip_set_forwarded_ip_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             ip_set_forwarded_ip_config: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if ip_set_forwarded_ip_config is None and 'ipSetForwardedIpConfig' in kwargs:
            ip_set_forwarded_ip_config = kwargs['ipSetForwardedIpConfig']

        _setter("arn", arn)
        if ip_set_forwarded_ip_config is not None:
            _setter("ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the IP Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig']:
        """
        Configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. See `ip_set_forwarded_ip_config` below for more details.
        """
        return pulumi.get(self, "ip_set_forwarded_ip_config")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: str,
                 header_name: str,
                 position: str):
        """
        :param str fallback_behavior: Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        :param str header_name: Name of the HTTP header to use for the IP address.
        :param str position: Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fallback_behavior=fallback_behavior,
            header_name=header_name,
            position=position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fallback_behavior: Optional[str] = None,
             header_name: Optional[str] = None,
             position: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fallback_behavior is None and 'fallbackBehavior' in kwargs:
            fallback_behavior = kwargs['fallbackBehavior']
        if fallback_behavior is None:
            raise TypeError("Missing 'fallback_behavior' argument")
        if header_name is None and 'headerName' in kwargs:
            header_name = kwargs['headerName']
        if header_name is None:
            raise TypeError("Missing 'header_name' argument")
        if position is None:
            raise TypeError("Missing 'position' argument")

        _setter("fallback_behavior", fallback_behavior)
        _setter("header_name", header_name)
        _setter("position", position)

    @property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> str:
        """
        Match status to assign to the web request if the request doesn't have a valid IP address in the specified position. Valid values include: `MATCH` or `NO_MATCH`.
        """
        return pulumi.get(self, "fallback_behavior")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        Name of the HTTP header to use for the IP address.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter
    def position(self) -> str:
        """
        Position in the header to search for the IP address. Valid values include: `FIRST`, `LAST`, or `ANY`. If `ANY` is specified and the header contains more than 10 IP addresses, AWS WAFv2 inspects the last 10.
        """
        return pulumi.get(self, "position")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement(dict):
    def __init__(__self__, *,
                 key: str,
                 scope: str):
        """
        :param str key: String to match against.
        :param str scope: Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            scope=scope,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             scope: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if scope is None:
            raise TypeError("Missing 'scope' argument")

        _setter("key", key)
        _setter("scope", scope)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        String to match against.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def scope(self) -> str:
        """
        Specify whether you want to match using the label name or just the namespace. Valid values are `LABEL` or `NAMESPACE`.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebAclRuleStatement']):
        """
        :param Sequence['WebAclRuleStatementArgs'] statements: The statements to combine.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statements=statements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statements: Optional[Sequence['outputs.WebAclRuleStatement']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statements is None:
            raise TypeError("Missing 'statements' argument")

        _setter("statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebAclRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebAclRuleStatement']):
        """
        :param Sequence['WebAclRuleStatementArgs'] statements: The statements to combine.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statements=statements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statements: Optional[Sequence['outputs.WebAclRuleStatement']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if statements is None:
            raise TypeError("Missing 'statements' argument")

        _setter("statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebAclRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regexString":
            suggest = "regex_string"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regex_string: str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch'] = None):
        """
        :param str regex_string: String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        :param Sequence['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs' field_to_match: The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            regex_string=regex_string,
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             regex_string: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if regex_string is None and 'regexString' in kwargs:
            regex_string = kwargs['regexString']
        if regex_string is None:
            raise TypeError("Missing 'regex_string' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("regex_string", regex_string)
        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> str:
        """
        String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        """
        return pulumi.get(self, "regex_string")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch']:
        """
        The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath'] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param Sequence['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See `headers` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See `json_body` for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See `single_header` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch'] = None):
        """
        :param str arn: The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        :param Sequence['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs' field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("arn", arn)
        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch']:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath'] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param Sequence['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See `headers` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See `json_body` for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See `single_header` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: str,
                 size: int,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch'] = None):
        """
        :param str comparison_operator: Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        :param int size: Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        :param Sequence['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs' field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            size=size,
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             size: Optional[int] = None,
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']
        if comparison_operator is None:
            raise TypeError("Missing 'comparison_operator' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("comparison_operator", comparison_operator)
        _setter("size", size)
        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> str:
        """
        Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch']:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath'] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param Sequence['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See `headers` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See `json_body` for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See `single_header` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch'] = None):
        """
        :param Sequence['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs' field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch']:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath'] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param Sequence['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See `headers` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See `json_body` for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See `single_header` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch'] = None):
        """
        :param Sequence['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs' field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch']:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath'] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param Sequence['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See `headers` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See `json_body` for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See `single_header` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regexString":
            suggest = "regex_string"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regex_string: str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRegexMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatch'] = None):
        """
        :param str regex_string: String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        :param Sequence['WebAclRuleStatementRegexMatchStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param 'WebAclRuleStatementRegexMatchStatementFieldToMatchArgs' field_to_match: The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        WebAclRuleStatementRegexMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            regex_string=regex_string,
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             regex_string: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementRegexMatchStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if regex_string is None and 'regexString' in kwargs:
            regex_string = kwargs['regexString']
        if regex_string is None:
            raise TypeError("Missing 'regex_string' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("regex_string", regex_string)
        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> str:
        """
        String representing the regular expression. Minimum of `1` and maximum of `512` characters.
        """
        return pulumi.get(self, "regex_string")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRegexMatchStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatch']:
        """
        The part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchUriPath'] = None):
        """
        :param 'WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param 'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param Sequence['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See `headers` below for details.
        :param 'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See `json_body` for details.
        :param 'WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See `single_header` below for details.
        :param 'WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param 'WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        WebAclRuleStatementRegexMatchStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementRegexMatchStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementRegexMatchStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        WebAclRuleStatementRegexMatchStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementRegexMatchStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatch'] = None):
        """
        :param str arn: The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        :param Sequence['WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param 'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs' field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        WebAclRuleStatementRegexPatternSetReferenceStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("arn", arn)
        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the Regex Pattern Set that this statement references.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatch']:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath'] = None):
        """
        :param 'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param 'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param Sequence['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See `headers` below for details.
        :param 'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See `json_body` for details.
        :param 'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See `single_header` below for details.
        :param 'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param 'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleActionOverrides":
            suggest = "rule_action_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 rule_action_overrides: Optional[Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverride']] = None):
        """
        :param str arn: The Amazon Resource Name (ARN) of the `wafv2.RuleGroup` resource.
        :param Sequence['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgs'] rule_action_overrides: Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. See `rule_action_override` below for details.
        """
        WebAclRuleStatementRuleGroupReferenceStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            rule_action_overrides=rule_action_overrides,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             rule_action_overrides: Optional[Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverride']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if arn is None:
            raise TypeError("Missing 'arn' argument")
        if rule_action_overrides is None and 'ruleActionOverrides' in kwargs:
            rule_action_overrides = kwargs['ruleActionOverrides']

        _setter("arn", arn)
        if rule_action_overrides is not None:
            _setter("rule_action_overrides", rule_action_overrides)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the `wafv2.RuleGroup` resource.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="ruleActionOverrides")
    def rule_action_overrides(self) -> Optional[Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverride']]:
        """
        Action settings to use in the place of the rule actions that are configured inside the rule group. You specify one override for each rule whose action you want to change. See `rule_action_override` below for details.
        """
        return pulumi.get(self, "rule_action_overrides")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionToUse":
            suggest = "action_to_use"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_to_use: 'outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUse',
                 name: str):
        """
        :param 'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgs' action_to_use: Override action to use, in place of the configured action of the rule in the rule group. See `action` for details.
        :param str name: Name of the rule to override. See the [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-list.html) for a list of names in the appropriate rule group in use.
        """
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverride._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_to_use=action_to_use,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_to_use: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUse'] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_to_use is None and 'actionToUse' in kwargs:
            action_to_use = kwargs['actionToUse']
        if action_to_use is None:
            raise TypeError("Missing 'action_to_use' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("action_to_use", action_to_use)
        _setter("name", name)

    @property
    @pulumi.getter(name="actionToUse")
    def action_to_use(self) -> 'outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUse':
        """
        Override action to use, in place of the configured action of the rule in the rule group. See `action` for details.
        """
        return pulumi.get(self, "action_to_use")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the rule to override. See the [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-list.html) for a list of names in the appropriate rule group in use.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUse(dict):
    def __init__(__self__, *,
                 allow: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllow'] = None,
                 block: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlock'] = None,
                 captcha: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptcha'] = None,
                 challenge: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallenge'] = None,
                 count: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCount'] = None):
        """
        :param 'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgs' allow: Instructs AWS WAF to allow the web request. See `allow` below for details.
        :param 'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgs' block: Instructs AWS WAF to block the web request. See `block` below for details.
        :param 'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgs' captcha: Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        :param 'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgs' challenge: Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        :param 'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgs' count: Instructs AWS WAF to count the web request and allow it. See `count` below for details.
        """
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow=allow,
            block=block,
            captcha=captcha,
            challenge=challenge,
            count=count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllow'] = None,
             block: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlock'] = None,
             captcha: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptcha'] = None,
             challenge: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallenge'] = None,
             count: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCount'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if allow is not None:
            _setter("allow", allow)
        if block is not None:
            _setter("block", block)
        if captcha is not None:
            _setter("captcha", captcha)
        if challenge is not None:
            _setter("challenge", challenge)
        if count is not None:
            _setter("count", count)

    @property
    @pulumi.getter
    def allow(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllow']:
        """
        Instructs AWS WAF to allow the web request. See `allow` below for details.
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def block(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlock']:
        """
        Instructs AWS WAF to block the web request. See `block` below for details.
        """
        return pulumi.get(self, "block")

    @property
    @pulumi.getter
    def captcha(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptcha']:
        """
        Instructs AWS WAF to run a Captcha check against the web request. See `captcha` below for details.
        """
        return pulumi.get(self, "captcha")

    @property
    @pulumi.getter
    def challenge(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallenge']:
        """
        Instructs AWS WAF to run a check against the request to verify that the request is coming from a legitimate client session. See `challenge` below for details.
        """
        return pulumi.get(self, "challenge")

    @property
    @pulumi.getter
    def count(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCount']:
        """
        Instructs AWS WAF to count the web request and allow it. See `count` below for details.
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandling'] = None):
        """
        :param 'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs' custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandling']:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader']):
        """
        :param Sequence['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs'] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insert_headers=insert_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insert_headers: Optional[Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insert_headers is None and 'insertHeaders' in kwargs:
            insert_headers = kwargs['insertHeaders']
        if insert_headers is None:
            raise TypeError("Missing 'insert_headers' argument")

        _setter("insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader']:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param str value: Value of the custom header.
        """
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlock(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customResponse":
            suggest = "custom_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlock. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlock.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlock.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_response: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponse'] = None):
        """
        :param 'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgs' custom_response: Defines a custom response for the web request. See `custom_response` below for details.
        """
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlock._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_response=custom_response,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_response: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_response is None and 'customResponse' in kwargs:
            custom_response = kwargs['customResponse']

        if custom_response is not None:
            _setter("custom_response", custom_response)

    @property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponse']:
        """
        Defines a custom response for the web request. See `custom_response` below for details.
        """
        return pulumi.get(self, "custom_response")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseCode":
            suggest = "response_code"
        elif key == "customResponseBodyKey":
            suggest = "custom_response_body_key"
        elif key == "responseHeaders":
            suggest = "response_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_code: int,
                 custom_response_body_key: Optional[str] = None,
                 response_headers: Optional[Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader']] = None):
        """
        :param int response_code: The HTTP status code to return to the client.
        :param str custom_response_body_key: References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        :param Sequence['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs'] response_headers: The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            response_code=response_code,
            custom_response_body_key=custom_response_body_key,
            response_headers=response_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             response_code: Optional[int] = None,
             custom_response_body_key: Optional[str] = None,
             response_headers: Optional[Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if response_code is None and 'responseCode' in kwargs:
            response_code = kwargs['responseCode']
        if response_code is None:
            raise TypeError("Missing 'response_code' argument")
        if custom_response_body_key is None and 'customResponseBodyKey' in kwargs:
            custom_response_body_key = kwargs['customResponseBodyKey']
        if response_headers is None and 'responseHeaders' in kwargs:
            response_headers = kwargs['responseHeaders']

        _setter("response_code", response_code)
        if custom_response_body_key is not None:
            _setter("custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            _setter("response_headers", response_headers)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> int:
        """
        The HTTP status code to return to the client.
        """
        return pulumi.get(self, "response_code")

    @property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[str]:
        """
        References the response body that you want AWS WAF to return to the web request client. This must reference a `key` defined in a `custom_response_body` block of this resource.
        """
        return pulumi.get(self, "custom_response_body_key")

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader']]:
        """
        The `response_header` blocks used to define the HTTP response headers added to the response. See `response_header` below for details.
        """
        return pulumi.get(self, "response_headers")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param str value: Value of the custom header.
        """
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptcha(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptcha. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptcha.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptcha.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling'] = None):
        """
        :param 'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs' custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptcha._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling']:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader']):
        """
        :param Sequence['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs'] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insert_headers=insert_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insert_headers: Optional[Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insert_headers is None and 'insertHeaders' in kwargs:
            insert_headers = kwargs['insertHeaders']
        if insert_headers is None:
            raise TypeError("Missing 'insert_headers' argument")

        _setter("insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader']:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param str value: Value of the custom header.
        """
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallenge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallenge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallenge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallenge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling'] = None):
        """
        :param 'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs' custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallenge._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling']:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader']):
        """
        :param Sequence['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs'] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insert_headers=insert_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insert_headers: Optional[Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insert_headers is None and 'insertHeaders' in kwargs:
            insert_headers = kwargs['insertHeaders']
        if insert_headers is None:
            raise TypeError("Missing 'insert_headers' argument")

        _setter("insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader']:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param str value: Value of the custom header.
        """
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandling'] = None):
        """
        :param 'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs' custom_request_handling: Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_request_handling=custom_request_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_request_handling: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandling'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_request_handling is None and 'customRequestHandling' in kwargs:
            custom_request_handling = kwargs['customRequestHandling']

        if custom_request_handling is not None:
            _setter("custom_request_handling", custom_request_handling)

    @property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandling']:
        """
        Defines custom handling for the web request. See `custom_request_handling` below for details.
        """
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader']):
        """
        :param Sequence['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs'] insert_headers: The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            insert_headers=insert_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             insert_headers: Optional[Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if insert_headers is None and 'insertHeaders' in kwargs:
            insert_headers = kwargs['insertHeaders']
        if insert_headers is None:
            raise TypeError("Missing 'insert_headers' argument")

        _setter("insert_headers", insert_headers)

    @property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader']:
        """
        The `insert_header` blocks used to define HTTP headers added to the request. See `insert_header` below for details.
        """
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        :param str value: Value of the custom header.
        """
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the custom header. For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-`, to avoid confusion with the headers that are already in the request. For example, for the header name `sample`, AWS WAF inserts the header `x-amzn-waf-sample`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the custom header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: str,
                 size: int,
                 text_transformations: Sequence['outputs.WebAclRuleStatementSizeConstraintStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatch'] = None):
        """
        :param str comparison_operator: Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        :param int size: Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        :param Sequence['WebAclRuleStatementSizeConstraintStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param 'WebAclRuleStatementSizeConstraintStatementFieldToMatchArgs' field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        WebAclRuleStatementSizeConstraintStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            size=size,
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional[str] = None,
             size: Optional[int] = None,
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementSizeConstraintStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if comparison_operator is None and 'comparisonOperator' in kwargs:
            comparison_operator = kwargs['comparisonOperator']
        if comparison_operator is None:
            raise TypeError("Missing 'comparison_operator' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("comparison_operator", comparison_operator)
        _setter("size", size)
        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> str:
        """
        Operator to use to compare the request part to the size setting. Valid values include: `EQ`, `NE`, `LE`, `LT`, `GE`, or `GT`.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Size, in bytes, to compare to the request part, after any transformations. Valid values are integers between 0 and 21474836480, inclusive.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementSizeConstraintStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatch']:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPath'] = None):
        """
        :param 'WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param 'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param Sequence['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See `headers` below for details.
        :param 'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See `json_body` for details.
        :param 'WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See `single_header` below for details.
        :param 'WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param 'WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        WebAclRuleStatementSizeConstraintStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementSizeConstraintStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementSizeConstraintStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        WebAclRuleStatementSizeConstraintStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementSizeConstraintStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.WebAclRuleStatementSqliMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatch'] = None):
        """
        :param Sequence['WebAclRuleStatementSqliMatchStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param 'WebAclRuleStatementSqliMatchStatementFieldToMatchArgs' field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        WebAclRuleStatementSqliMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementSqliMatchStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementSqliMatchStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatch']:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchUriPath'] = None):
        """
        :param 'WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param 'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param Sequence['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See `headers` below for details.
        :param 'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See `json_body` for details.
        :param 'WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See `single_header` below for details.
        :param 'WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param 'WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        WebAclRuleStatementSqliMatchStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementSqliMatchStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementSqliMatchStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        WebAclRuleStatementSqliMatchStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementSqliMatchStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.WebAclRuleStatementXssMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatch'] = None):
        """
        :param Sequence['WebAclRuleStatementXssMatchStatementTextTransformationArgs'] text_transformations: Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        :param 'WebAclRuleStatementXssMatchStatementFieldToMatchArgs' field_to_match: Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        WebAclRuleStatementXssMatchStatement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text_transformations=text_transformations,
            field_to_match=field_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text_transformations: Optional[Sequence['outputs.WebAclRuleStatementXssMatchStatementTextTransformation']] = None,
             field_to_match: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if text_transformations is None and 'textTransformations' in kwargs:
            text_transformations = kwargs['textTransformations']
        if text_transformations is None:
            raise TypeError("Missing 'text_transformations' argument")
        if field_to_match is None and 'fieldToMatch' in kwargs:
            field_to_match = kwargs['fieldToMatch']

        _setter("text_transformations", text_transformations)
        if field_to_match is not None:
            _setter("field_to_match", field_to_match)

    @property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementXssMatchStatementTextTransformation']:
        """
        Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. At least one transformation is required. See `text_transformation` below for details.
        """
        return pulumi.get(self, "text_transformations")

    @property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatch']:
        """
        Part of a web request that you want AWS WAF to inspect. See `field_to_match` below for details.
        """
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchCookies'] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchHeader']] = None,
                 json_body: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchUriPath'] = None):
        """
        :param 'WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs' all_query_arguments: Inspect all query arguments.
        :param 'WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgs' body: Inspect the request body, which immediately follows the request headers. See `body` below for details.
        :param 'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgs' cookies: Inspect the cookies in the web request. See `cookies` below for details.
        :param Sequence['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgs'] headers: Inspect the request headers. See `headers` below for details.
        :param 'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs' json_body: Inspect the request body as JSON. See `json_body` for details.
        :param 'WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgs' method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param 'WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgs' query_string: Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        :param 'WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs' single_header: Inspect a single header. See `single_header` below for details.
        :param 'WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs' single_query_argument: Inspect a single query argument. See `single_query_argument` below for details.
        :param 'WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgs' uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        WebAclRuleStatementXssMatchStatementFieldToMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_query_arguments=all_query_arguments,
            body=body,
            cookies=cookies,
            headers=headers,
            json_body=json_body,
            method=method,
            query_string=query_string,
            single_header=single_header,
            single_query_argument=single_query_argument,
            uri_path=uri_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_query_arguments: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArguments'] = None,
             body: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchBody'] = None,
             cookies: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchCookies'] = None,
             headers: Optional[Sequence['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchHeader']] = None,
             json_body: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBody'] = None,
             method: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchMethod'] = None,
             query_string: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchQueryString'] = None,
             single_header: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeader'] = None,
             single_query_argument: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument'] = None,
             uri_path: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchUriPath'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if all_query_arguments is None and 'allQueryArguments' in kwargs:
            all_query_arguments = kwargs['allQueryArguments']
        if json_body is None and 'jsonBody' in kwargs:
            json_body = kwargs['jsonBody']
        if query_string is None and 'queryString' in kwargs:
            query_string = kwargs['queryString']
        if single_header is None and 'singleHeader' in kwargs:
            single_header = kwargs['singleHeader']
        if single_query_argument is None and 'singleQueryArgument' in kwargs:
            single_query_argument = kwargs['singleQueryArgument']
        if uri_path is None and 'uriPath' in kwargs:
            uri_path = kwargs['uriPath']

        if all_query_arguments is not None:
            _setter("all_query_arguments", all_query_arguments)
        if body is not None:
            _setter("body", body)
        if cookies is not None:
            _setter("cookies", cookies)
        if headers is not None:
            _setter("headers", headers)
        if json_body is not None:
            _setter("json_body", json_body)
        if method is not None:
            _setter("method", method)
        if query_string is not None:
            _setter("query_string", query_string)
        if single_header is not None:
            _setter("single_header", single_header)
        if single_query_argument is not None:
            _setter("single_query_argument", single_query_argument)
        if uri_path is not None:
            _setter("uri_path", uri_path)

    @property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArguments']:
        """
        Inspect all query arguments.
        """
        return pulumi.get(self, "all_query_arguments")

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchBody']:
        """
        Inspect the request body, which immediately follows the request headers. See `body` below for details.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchCookies']:
        """
        Inspect the cookies in the web request. See `cookies` below for details.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchHeader']]:
        """
        Inspect the request headers. See `headers` below for details.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBody']:
        """
        Inspect the request body as JSON. See `json_body` for details.
        """
        return pulumi.get(self, "json_body")

    @property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchMethod']:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchQueryString']:
        """
        Inspect the query string. This is the part of a URL that appears after a `?` character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeader']:
        """
        Inspect a single header. See `single_header` below for details.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument']:
        """
        Inspect a single query argument. See `single_query_argument` below for details.
        """
        return pulumi.get(self, "single_query_argument")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchUriPath']:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, `/images/daily-ad.jpg`.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[str] = None):
        """
        :param str oversize_handling: What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementXssMatchStatementFieldToMatchBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What WAF should do if the body is larger than WAF can inspect. WAF does not support inspecting the entire contents of the body of a web request when the body exceeds 8 KB (8192 bytes). Only the first 8 KB of the request body are forwarded to WAF by the underlying host service. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: str,
                 oversize_handling: str):
        """
        :param Sequence['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs'] match_patterns: The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        :param str match_scope: The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        :param str oversize_handling: What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        WebAclRuleStatementXssMatchStatementFieldToMatchCookies._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_patterns=match_patterns,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_patterns: Optional[Sequence['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern']] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_patterns is None and 'matchPatterns' in kwargs:
            match_patterns = kwargs['matchPatterns']
        if match_patterns is None:
            raise TypeError("Missing 'match_patterns' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_patterns", match_patterns)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern']:
        """
        The filter to use to identify the subset of cookies to inspect in a web request. You must specify exactly one setting: either `all`, `included_cookies` or `excluded_cookies`. More details: [CookieMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_CookieMatchPattern.html)
        """
        return pulumi.get(self, "match_patterns")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the cookies to inspect with the rule inspection criteria. If you specify All, AWS WAF inspects both keys and values. Valid values: `ALL`, `KEY`, `VALUE`
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        What AWS WAF should do if the cookies of the request are larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF. Valid values: `CONTINUE`, `MATCH`, `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[str]] = None,
                 included_cookies: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_cookies=excluded_cookies,
            included_cookies=included_cookies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
             excluded_cookies: Optional[Sequence[str]] = None,
             included_cookies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_cookies is None and 'excludedCookies' in kwargs:
            excluded_cookies = kwargs['excludedCookies']
        if included_cookies is None and 'includedCookies' in kwargs:
            included_cookies = kwargs['includedCookies']

        if all is not None:
            _setter("all", all)
        if excluded_cookies is not None:
            _setter("excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            _setter("included_cookies", included_cookies)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_cookies")

    @property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: str,
                 oversize_handling: str):
        """
        :param 'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs' match_pattern: The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        :param str match_scope: The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        :param str oversize_handling: Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        WebAclRuleStatementXssMatchStatementFieldToMatchHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern'] = None,
             match_scope: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']
        if oversize_handling is None:
            raise TypeError("Missing 'oversize_handling' argument")

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern':
        """
        The filter to use to identify the subset of headers to inspect in a web request. The `match_pattern` block supports only one of the following arguments:
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the headers to inspect with the rule inspection criteria. If you specify `All`, AWS WAF inspects both keys and values. Valid values include the following: `ALL`, `Key`, `Value`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> str:
        """
        Oversize handling tells AWS WAF what to do with a web request when the request component that the rule inspects is over the limits. Valid values include the following: `CONTINUE`, `MATCH`, `NO_MATCH`. See the AWS [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-oversize-handling.html) for more information.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[str]] = None,
                 included_headers: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        :param Sequence[str] excluded_headers: An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        :param Sequence[str] included_headers: An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            excluded_headers=excluded_headers,
            included_headers=included_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
             excluded_headers: Optional[Sequence[str]] = None,
             included_headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if excluded_headers is None and 'excludedHeaders' in kwargs:
            excluded_headers = kwargs['excludedHeaders']
        if included_headers is None and 'includedHeaders' in kwargs:
            included_headers = kwargs['includedHeaders']

        if all is not None:
            _setter("all", all)
        if excluded_headers is not None:
            _setter("excluded_headers", excluded_headers)
        if included_headers is not None:
            _setter("included_headers", included_headers)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that do not have a key that matches one of the provided values.
        """
        return pulumi.get(self, "excluded_headers")

    @property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[str]]:
        """
        An array of strings that will be used for inspecting headers that have a key that matches one of the provided values.
        """
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: str,
                 invalid_fallback_behavior: Optional[str] = None,
                 oversize_handling: Optional[str] = None):
        """
        :param 'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs' match_pattern: The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        :param str match_scope: The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        :param str invalid_fallback_behavior: What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        :param str oversize_handling: What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        WebAclRuleStatementXssMatchStatementFieldToMatchJsonBody._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_pattern=match_pattern,
            match_scope=match_scope,
            invalid_fallback_behavior=invalid_fallback_behavior,
            oversize_handling=oversize_handling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_pattern: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern'] = None,
             match_scope: Optional[str] = None,
             invalid_fallback_behavior: Optional[str] = None,
             oversize_handling: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_pattern is None and 'matchPattern' in kwargs:
            match_pattern = kwargs['matchPattern']
        if match_pattern is None:
            raise TypeError("Missing 'match_pattern' argument")
        if match_scope is None and 'matchScope' in kwargs:
            match_scope = kwargs['matchScope']
        if match_scope is None:
            raise TypeError("Missing 'match_scope' argument")
        if invalid_fallback_behavior is None and 'invalidFallbackBehavior' in kwargs:
            invalid_fallback_behavior = kwargs['invalidFallbackBehavior']
        if oversize_handling is None and 'oversizeHandling' in kwargs:
            oversize_handling = kwargs['oversizeHandling']

        _setter("match_pattern", match_pattern)
        _setter("match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            _setter("invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            _setter("oversize_handling", oversize_handling)

    @property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern':
        """
        The patterns to look for in the JSON body. You must specify exactly one setting: either `all` or `included_paths`. See [JsonMatchPattern](https://docs.aws.amazon.com/waf/latest/APIReference/API_JsonMatchPattern.html) for details.
        """
        return pulumi.get(self, "match_pattern")

    @property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> str:
        """
        The parts of the JSON to match against using the `match_pattern`. Valid values are `ALL`, `KEY` and `VALUE`.
        """
        return pulumi.get(self, "match_scope")

    @property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[str]:
        """
        What to do when JSON parsing fails. Defaults to evaluating up to the first parsing failure. Valid values are `EVALUATE_AS_STRING`, `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "invalid_fallback_behavior")

    @property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[str]:
        """
        What to do if the body is larger than can be inspected. Valid values are `CONTINUE` (default), `MATCH` and `NO_MATCH`.
        """
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[str]] = None):
        """
        :param 'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs' all: An empty configuration block that is used for inspecting all headers.
        """
        WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all=all,
            included_paths=included_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
             included_paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if included_paths is None and 'includedPaths' in kwargs:
            included_paths = kwargs['includedPaths']

        if all is not None:
            _setter("all", all)
        if included_paths is not None:
            _setter("included_paths", included_paths)

    @property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        """
        An empty configuration block that is used for inspecting all headers.
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the query header to inspect. This setting must be provided as lower case characters.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



@pulumi.output_type
class WebAclRuleStatementXssMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: int,
                 type: str):
        """
        :param int priority: Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        :param str type: Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        WebAclRuleStatementXssMatchStatementTextTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("priority", priority)
        _setter("type", type)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Relative processing order for multiple transformations that are defined for a rule statement. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Transformation to apply, please refer to the Text Transformation [documentation](https://docs.aws.amazon.com/waf/latest/APIReference/API_TextTransformation.html) for more details.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleVisibilityConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchMetricsEnabled":
            suggest = "cloudwatch_metrics_enabled"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "sampledRequestsEnabled":
            suggest = "sampled_requests_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleVisibilityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleVisibilityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleVisibilityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_metrics_enabled: bool,
                 metric_name: str,
                 sampled_requests_enabled: bool):
        """
        :param bool cloudwatch_metrics_enabled: Whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        :param str metric_name: A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (\\_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        :param bool sampled_requests_enabled: Whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        WebAclRuleVisibilityConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloudwatch_metrics_enabled=cloudwatch_metrics_enabled,
            metric_name=metric_name,
            sampled_requests_enabled=sampled_requests_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloudwatch_metrics_enabled: Optional[bool] = None,
             metric_name: Optional[str] = None,
             sampled_requests_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloudwatch_metrics_enabled is None and 'cloudwatchMetricsEnabled' in kwargs:
            cloudwatch_metrics_enabled = kwargs['cloudwatchMetricsEnabled']
        if cloudwatch_metrics_enabled is None:
            raise TypeError("Missing 'cloudwatch_metrics_enabled' argument")
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if metric_name is None:
            raise TypeError("Missing 'metric_name' argument")
        if sampled_requests_enabled is None and 'sampledRequestsEnabled' in kwargs:
            sampled_requests_enabled = kwargs['sampledRequestsEnabled']
        if sampled_requests_enabled is None:
            raise TypeError("Missing 'sampled_requests_enabled' argument")

        _setter("cloudwatch_metrics_enabled", cloudwatch_metrics_enabled)
        _setter("metric_name", metric_name)
        _setter("sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudwatchMetricsEnabled")
    def cloudwatch_metrics_enabled(self) -> bool:
        """
        Whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        """
        return pulumi.get(self, "cloudwatch_metrics_enabled")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (\\_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> bool:
        """
        Whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        return pulumi.get(self, "sampled_requests_enabled")


@pulumi.output_type
class WebAclVisibilityConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchMetricsEnabled":
            suggest = "cloudwatch_metrics_enabled"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "sampledRequestsEnabled":
            suggest = "sampled_requests_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclVisibilityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclVisibilityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclVisibilityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_metrics_enabled: bool,
                 metric_name: str,
                 sampled_requests_enabled: bool):
        """
        :param bool cloudwatch_metrics_enabled: Whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        :param str metric_name: A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (\\_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        :param bool sampled_requests_enabled: Whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        WebAclVisibilityConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloudwatch_metrics_enabled=cloudwatch_metrics_enabled,
            metric_name=metric_name,
            sampled_requests_enabled=sampled_requests_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloudwatch_metrics_enabled: Optional[bool] = None,
             metric_name: Optional[str] = None,
             sampled_requests_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cloudwatch_metrics_enabled is None and 'cloudwatchMetricsEnabled' in kwargs:
            cloudwatch_metrics_enabled = kwargs['cloudwatchMetricsEnabled']
        if cloudwatch_metrics_enabled is None:
            raise TypeError("Missing 'cloudwatch_metrics_enabled' argument")
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if metric_name is None:
            raise TypeError("Missing 'metric_name' argument")
        if sampled_requests_enabled is None and 'sampledRequestsEnabled' in kwargs:
            sampled_requests_enabled = kwargs['sampledRequestsEnabled']
        if sampled_requests_enabled is None:
            raise TypeError("Missing 'sampled_requests_enabled' argument")

        _setter("cloudwatch_metrics_enabled", cloudwatch_metrics_enabled)
        _setter("metric_name", metric_name)
        _setter("sampled_requests_enabled", sampled_requests_enabled)

    @property
    @pulumi.getter(name="cloudwatchMetricsEnabled")
    def cloudwatch_metrics_enabled(self) -> bool:
        """
        Whether the associated resource sends metrics to CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics).
        """
        return pulumi.get(self, "cloudwatch_metrics_enabled")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        A friendly name of the CloudWatch metric. The name can contain only alphanumeric characters (A-Z, a-z, 0-9) hyphen(-) and underscore (\\_), with length from one to 128 characters. It can't contain whitespace or metric names reserved for AWS WAF, for example `All` and `Default_Action`.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> bool:
        """
        Whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
        """
        return pulumi.get(self, "sampled_requests_enabled")


@pulumi.output_type
class GetRegexPatternSetRegularExpressionResult(dict):
    def __init__(__self__, *,
                 regex_string: str):
        """
        :param str regex_string: (Required) String representing the regular expression, see the AWS WAF [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-regex-pattern-set-creating.html) for more information.
        """
        GetRegexPatternSetRegularExpressionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            regex_string=regex_string,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             regex_string: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if regex_string is None and 'regexString' in kwargs:
            regex_string = kwargs['regexString']
        if regex_string is None:
            raise TypeError("Missing 'regex_string' argument")

        _setter("regex_string", regex_string)

    @property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> str:
        """
        (Required) String representing the regular expression, see the AWS WAF [documentation](https://docs.aws.amazon.com/waf/latest/developerguide/waf-regex-pattern-set-creating.html) for more information.
        """
        return pulumi.get(self, "regex_string")


