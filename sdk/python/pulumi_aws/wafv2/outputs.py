# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'RegexPatternSetRegularExpression',
    'RuleGroupCustomResponseBody',
    'RuleGroupRule',
    'RuleGroupRuleAction',
    'RuleGroupRuleActionAllow',
    'RuleGroupRuleActionAllowCustomRequestHandling',
    'RuleGroupRuleActionAllowCustomRequestHandlingInsertHeader',
    'RuleGroupRuleActionBlock',
    'RuleGroupRuleActionBlockCustomResponse',
    'RuleGroupRuleActionBlockCustomResponseResponseHeader',
    'RuleGroupRuleActionCaptcha',
    'RuleGroupRuleActionCaptchaCustomRequestHandling',
    'RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeader',
    'RuleGroupRuleActionChallenge',
    'RuleGroupRuleActionChallengeCustomRequestHandling',
    'RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeader',
    'RuleGroupRuleActionCount',
    'RuleGroupRuleActionCountCustomRequestHandling',
    'RuleGroupRuleActionCountCustomRequestHandlingInsertHeader',
    'RuleGroupRuleCaptchaConfig',
    'RuleGroupRuleCaptchaConfigImmunityTimeProperty',
    'RuleGroupRuleRuleLabel',
    'RuleGroupRuleStatement',
    'RuleGroupRuleStatementAndStatement',
    'RuleGroupRuleStatementAsnMatchStatement',
    'RuleGroupRuleStatementAsnMatchStatementForwardedIpConfig',
    'RuleGroupRuleStatementByteMatchStatement',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatch',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchBody',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookies',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeader',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrder',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3Fingerprint',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJa4Fingerprint',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchMethod',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchUriFragment',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementByteMatchStatementTextTransformation',
    'RuleGroupRuleStatementGeoMatchStatement',
    'RuleGroupRuleStatementGeoMatchStatementForwardedIpConfig',
    'RuleGroupRuleStatementIpSetReferenceStatement',
    'RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig',
    'RuleGroupRuleStatementLabelMatchStatement',
    'RuleGroupRuleStatementNotStatement',
    'RuleGroupRuleStatementOrStatement',
    'RuleGroupRuleStatementRateBasedStatement',
    'RuleGroupRuleStatementRateBasedStatementCustomKey',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyAsn',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyCookie',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformation',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIp',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHeader',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethod',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyIp',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyJa3Fingerprint',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyJa4Fingerprint',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespace',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgument',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryString',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyUriPath',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation',
    'RuleGroupRuleStatementRateBasedStatementForwardedIpConfig',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfig',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation',
    'RuleGroupRuleStatementRegexMatchStatement',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatch',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchBody',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookies',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeader',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrder',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3Fingerprint',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa4Fingerprint',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethod',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriFragment',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementRegexMatchStatementTextTransformation',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatement',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatch',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformation',
    'RuleGroupRuleStatementSizeConstraintStatement',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatch',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBody',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookies',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeader',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrder',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3Fingerprint',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa4Fingerprint',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethod',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriFragment',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementSizeConstraintStatementTextTransformation',
    'RuleGroupRuleStatementSqliMatchStatement',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatch',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchBody',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookies',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeader',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrder',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3Fingerprint',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa4Fingerprint',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethod',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriFragment',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementSqliMatchStatementTextTransformation',
    'RuleGroupRuleStatementXssMatchStatement',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatch',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArguments',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchBody',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookies',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeader',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrder',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3Fingerprint',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJa4Fingerprint',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBody',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchMethod',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryString',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeader',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchUriFragment',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPath',
    'RuleGroupRuleStatementXssMatchStatementTextTransformation',
    'RuleGroupRuleVisibilityConfig',
    'RuleGroupVisibilityConfig',
    'WebAclAssociationConfig',
    'WebAclAssociationConfigRequestBody',
    'WebAclAssociationConfigRequestBodyApiGateway',
    'WebAclAssociationConfigRequestBodyAppRunnerService',
    'WebAclAssociationConfigRequestBodyCloudfront',
    'WebAclAssociationConfigRequestBodyCognitoUserPool',
    'WebAclAssociationConfigRequestBodyVerifiedAccessInstance',
    'WebAclCaptchaConfig',
    'WebAclCaptchaConfigImmunityTimeProperty',
    'WebAclChallengeConfig',
    'WebAclChallengeConfigImmunityTimeProperty',
    'WebAclCustomResponseBody',
    'WebAclDataProtectionConfig',
    'WebAclDataProtectionConfigDataProtection',
    'WebAclDataProtectionConfigDataProtectionField',
    'WebAclDefaultAction',
    'WebAclDefaultActionAllow',
    'WebAclDefaultActionAllowCustomRequestHandling',
    'WebAclDefaultActionAllowCustomRequestHandlingInsertHeader',
    'WebAclDefaultActionBlock',
    'WebAclDefaultActionBlockCustomResponse',
    'WebAclDefaultActionBlockCustomResponseResponseHeader',
    'WebAclLoggingConfigurationLoggingFilter',
    'WebAclLoggingConfigurationLoggingFilterFilter',
    'WebAclLoggingConfigurationLoggingFilterFilterCondition',
    'WebAclLoggingConfigurationLoggingFilterFilterConditionActionCondition',
    'WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameCondition',
    'WebAclLoggingConfigurationRedactedField',
    'WebAclLoggingConfigurationRedactedFieldMethod',
    'WebAclLoggingConfigurationRedactedFieldQueryString',
    'WebAclLoggingConfigurationRedactedFieldSingleHeader',
    'WebAclLoggingConfigurationRedactedFieldUriPath',
    'WebAclRule',
    'WebAclRuleAction',
    'WebAclRuleActionAllow',
    'WebAclRuleActionAllowCustomRequestHandling',
    'WebAclRuleActionAllowCustomRequestHandlingInsertHeader',
    'WebAclRuleActionBlock',
    'WebAclRuleActionBlockCustomResponse',
    'WebAclRuleActionBlockCustomResponseResponseHeader',
    'WebAclRuleActionCaptcha',
    'WebAclRuleActionCaptchaCustomRequestHandling',
    'WebAclRuleActionCaptchaCustomRequestHandlingInsertHeader',
    'WebAclRuleActionChallenge',
    'WebAclRuleActionChallengeCustomRequestHandling',
    'WebAclRuleActionChallengeCustomRequestHandlingInsertHeader',
    'WebAclRuleActionCount',
    'WebAclRuleActionCountCustomRequestHandling',
    'WebAclRuleActionCountCustomRequestHandlingInsertHeader',
    'WebAclRuleCaptchaConfig',
    'WebAclRuleCaptchaConfigImmunityTimeProperty',
    'WebAclRuleChallengeConfig',
    'WebAclRuleChallengeConfigImmunityTimeProperty',
    'WebAclRuleGroupAssociationManagedRuleGroup',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverride',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUse',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllow',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandling',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlock',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponse',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseResponseHeader',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptcha',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandling',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallenge',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandling',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCount',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandling',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader',
    'WebAclRuleGroupAssociationRuleGroupReference',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverride',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUse',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllow',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandling',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlock',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponse',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseResponseHeader',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptcha',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandling',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallenge',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandling',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCount',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandling',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader',
    'WebAclRuleGroupAssociationTimeouts',
    'WebAclRuleOverrideAction',
    'WebAclRuleOverrideActionCount',
    'WebAclRuleOverrideActionNone',
    'WebAclRuleRuleLabel',
    'WebAclRuleStatement',
    'WebAclRuleStatementAndStatement',
    'WebAclRuleStatementAsnMatchStatement',
    'WebAclRuleStatementAsnMatchStatementForwardedIpConfig',
    'WebAclRuleStatementByteMatchStatement',
    'WebAclRuleStatementByteMatchStatementFieldToMatch',
    'WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementByteMatchStatementFieldToMatchBody',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrder',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJa3Fingerprint',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJa4Fingerprint',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementByteMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementByteMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementByteMatchStatementFieldToMatchUriFragment',
    'WebAclRuleStatementByteMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementByteMatchStatementTextTransformation',
    'WebAclRuleStatementGeoMatchStatement',
    'WebAclRuleStatementGeoMatchStatementForwardedIpConfig',
    'WebAclRuleStatementIpSetReferenceStatement',
    'WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig',
    'WebAclRuleStatementLabelMatchStatement',
    'WebAclRuleStatementManagedRuleGroupStatement',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfig',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSet',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspection',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFields',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailField',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordField',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFields',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameField',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspection',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContains',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeader',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJson',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCode',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSet',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfig',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallenge',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeExemptUriRegularExpression',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSet',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspection',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordField',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameField',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspection',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContains',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeader',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJson',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCode',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSet',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordField',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameField',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverride',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUse',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllow',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandling',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlock',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponse',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptcha',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallenge',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCount',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandling',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementForwardedIpConfig',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatch',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformation',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfig',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatch',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformation',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatch',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformation',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatch',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformation',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatement',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatch',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformation',
    'WebAclRuleStatementNotStatement',
    'WebAclRuleStatementOrStatement',
    'WebAclRuleStatementRateBasedStatement',
    'WebAclRuleStatementRateBasedStatementCustomKey',
    'WebAclRuleStatementRateBasedStatementCustomKeyAsn',
    'WebAclRuleStatementRateBasedStatementCustomKeyCookie',
    'WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformation',
    'WebAclRuleStatementRateBasedStatementCustomKeyForwardedIp',
    'WebAclRuleStatementRateBasedStatementCustomKeyHeader',
    'WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation',
    'WebAclRuleStatementRateBasedStatementCustomKeyHttpMethod',
    'WebAclRuleStatementRateBasedStatementCustomKeyIp',
    'WebAclRuleStatementRateBasedStatementCustomKeyJa3Fingerprint',
    'WebAclRuleStatementRateBasedStatementCustomKeyJa4Fingerprint',
    'WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespace',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryArgument',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryString',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation',
    'WebAclRuleStatementRateBasedStatementCustomKeyUriPath',
    'WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation',
    'WebAclRuleStatementRateBasedStatementForwardedIpConfig',
    'WebAclRuleStatementRateBasedStatementScopeDownStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfig',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation',
    'WebAclRuleStatementRegexMatchStatement',
    'WebAclRuleStatementRegexMatchStatementFieldToMatch',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchBody',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrder',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJa3Fingerprint',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJa4Fingerprint',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchUriFragment',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementRegexMatchStatementTextTransformation',
    'WebAclRuleStatementRegexPatternSetReferenceStatement',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatch',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath',
    'WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformation',
    'WebAclRuleStatementRuleGroupReferenceStatement',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverride',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUse',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllow',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandling',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlock',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponse',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptcha',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallenge',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCount',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandling',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader',
    'WebAclRuleStatementSizeConstraintStatement',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatch',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchBody',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookies',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeader',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrder',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3Fingerprint',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJa4Fingerprint',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBody',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchMethod',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryString',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchUriFragment',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPath',
    'WebAclRuleStatementSizeConstraintStatementTextTransformation',
    'WebAclRuleStatementSqliMatchStatement',
    'WebAclRuleStatementSqliMatchStatementFieldToMatch',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchBody',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrder',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJa3Fingerprint',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJa4Fingerprint',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchUriFragment',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementSqliMatchStatementTextTransformation',
    'WebAclRuleStatementXssMatchStatement',
    'WebAclRuleStatementXssMatchStatementFieldToMatch',
    'WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArguments',
    'WebAclRuleStatementXssMatchStatementFieldToMatchBody',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookies',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeader',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrder',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJa3Fingerprint',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJa4Fingerprint',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBody',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll',
    'WebAclRuleStatementXssMatchStatementFieldToMatchMethod',
    'WebAclRuleStatementXssMatchStatementFieldToMatchQueryString',
    'WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeader',
    'WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument',
    'WebAclRuleStatementXssMatchStatementFieldToMatchUriFragment',
    'WebAclRuleStatementXssMatchStatementFieldToMatchUriPath',
    'WebAclRuleStatementXssMatchStatementTextTransformation',
    'WebAclRuleVisibilityConfig',
    'WebAclVisibilityConfig',
    'GetRegexPatternSetRegularExpressionResult',
]

@pulumi.output_type
class RegexPatternSetRegularExpression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regexString":
            suggest = "regex_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegexPatternSetRegularExpression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegexPatternSetRegularExpression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegexPatternSetRegularExpression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regex_string: _builtins.str):
        pulumi.set(__self__, "regex_string", regex_string)

    @_builtins.property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> _builtins.str:
        return pulumi.get(self, "regex_string")


@pulumi.output_type
class RuleGroupCustomResponseBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupCustomResponseBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupCustomResponseBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupCustomResponseBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: _builtins.str,
                 content_type: _builtins.str,
                 key: _builtins.str):
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> _builtins.str:
        return pulumi.get(self, "content_type")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")


@pulumi.output_type
class RuleGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visibilityConfig":
            suggest = "visibility_config"
        elif key == "captchaConfig":
            suggest = "captcha_config"
        elif key == "ruleLabels":
            suggest = "rule_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: 'outputs.RuleGroupRuleAction',
                 name: _builtins.str,
                 priority: _builtins.int,
                 statement: 'outputs.RuleGroupRuleStatement',
                 visibility_config: 'outputs.RuleGroupRuleVisibilityConfig',
                 captcha_config: Optional['outputs.RuleGroupRuleCaptchaConfig'] = None,
                 rule_labels: Optional[Sequence['outputs.RuleGroupRuleRuleLabel']] = None):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "statement", statement)
        pulumi.set(__self__, "visibility_config", visibility_config)
        if captcha_config is not None:
            pulumi.set(__self__, "captcha_config", captcha_config)
        if rule_labels is not None:
            pulumi.set(__self__, "rule_labels", rule_labels)

    @_builtins.property
    @pulumi.getter
    def action(self) -> 'outputs.RuleGroupRuleAction':
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def statement(self) -> 'outputs.RuleGroupRuleStatement':
        return pulumi.get(self, "statement")

    @_builtins.property
    @pulumi.getter(name="visibilityConfig")
    def visibility_config(self) -> 'outputs.RuleGroupRuleVisibilityConfig':
        return pulumi.get(self, "visibility_config")

    @_builtins.property
    @pulumi.getter(name="captchaConfig")
    def captcha_config(self) -> Optional['outputs.RuleGroupRuleCaptchaConfig']:
        return pulumi.get(self, "captcha_config")

    @_builtins.property
    @pulumi.getter(name="ruleLabels")
    def rule_labels(self) -> Optional[Sequence['outputs.RuleGroupRuleRuleLabel']]:
        return pulumi.get(self, "rule_labels")


@pulumi.output_type
class RuleGroupRuleAction(dict):
    def __init__(__self__, *,
                 allow: Optional['outputs.RuleGroupRuleActionAllow'] = None,
                 block: Optional['outputs.RuleGroupRuleActionBlock'] = None,
                 captcha: Optional['outputs.RuleGroupRuleActionCaptcha'] = None,
                 challenge: Optional['outputs.RuleGroupRuleActionChallenge'] = None,
                 count: Optional['outputs.RuleGroupRuleActionCount'] = None):
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional['outputs.RuleGroupRuleActionAllow']:
        return pulumi.get(self, "allow")

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional['outputs.RuleGroupRuleActionBlock']:
        return pulumi.get(self, "block")

    @_builtins.property
    @pulumi.getter
    def captcha(self) -> Optional['outputs.RuleGroupRuleActionCaptcha']:
        return pulumi.get(self, "captcha")

    @_builtins.property
    @pulumi.getter
    def challenge(self) -> Optional['outputs.RuleGroupRuleActionChallenge']:
        return pulumi.get(self, "challenge")

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional['outputs.RuleGroupRuleActionCount']:
        return pulumi.get(self, "count")


@pulumi.output_type
class RuleGroupRuleActionAllow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionAllow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionAllow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionAllow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.RuleGroupRuleActionAllowCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.RuleGroupRuleActionAllowCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class RuleGroupRuleActionAllowCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionAllowCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionAllowCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionAllowCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.RuleGroupRuleActionAllowCustomRequestHandlingInsertHeader']):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.RuleGroupRuleActionAllowCustomRequestHandlingInsertHeader']:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class RuleGroupRuleActionAllowCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleGroupRuleActionBlock(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customResponse":
            suggest = "custom_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionBlock. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionBlock.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionBlock.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_response: Optional['outputs.RuleGroupRuleActionBlockCustomResponse'] = None):
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @_builtins.property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional['outputs.RuleGroupRuleActionBlockCustomResponse']:
        return pulumi.get(self, "custom_response")


@pulumi.output_type
class RuleGroupRuleActionBlockCustomResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseCode":
            suggest = "response_code"
        elif key == "customResponseBodyKey":
            suggest = "custom_response_body_key"
        elif key == "responseHeaders":
            suggest = "response_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionBlockCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionBlockCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionBlockCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_code: _builtins.int,
                 custom_response_body_key: Optional[_builtins.str] = None,
                 response_headers: Optional[Sequence['outputs.RuleGroupRuleActionBlockCustomResponseResponseHeader']] = None):
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> _builtins.int:
        return pulumi.get(self, "response_code")

    @_builtins.property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_response_body_key")

    @_builtins.property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[Sequence['outputs.RuleGroupRuleActionBlockCustomResponseResponseHeader']]:
        return pulumi.get(self, "response_headers")


@pulumi.output_type
class RuleGroupRuleActionBlockCustomResponseResponseHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleGroupRuleActionCaptcha(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionCaptcha. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionCaptcha.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionCaptcha.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.RuleGroupRuleActionCaptchaCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.RuleGroupRuleActionCaptchaCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class RuleGroupRuleActionCaptchaCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionCaptchaCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionCaptchaCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionCaptchaCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeader']):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeader']:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleGroupRuleActionChallenge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionChallenge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionChallenge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionChallenge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.RuleGroupRuleActionChallengeCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.RuleGroupRuleActionChallengeCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class RuleGroupRuleActionChallengeCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionChallengeCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionChallengeCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionChallengeCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeader']):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeader']:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleGroupRuleActionCount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionCount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionCount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionCount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.RuleGroupRuleActionCountCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.RuleGroupRuleActionCountCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class RuleGroupRuleActionCountCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleActionCountCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleActionCountCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleActionCountCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.RuleGroupRuleActionCountCustomRequestHandlingInsertHeader']):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.RuleGroupRuleActionCountCustomRequestHandlingInsertHeader']:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class RuleGroupRuleActionCountCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class RuleGroupRuleCaptchaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTimeProperty":
            suggest = "immunity_time_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleCaptchaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleCaptchaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleCaptchaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time_property: Optional['outputs.RuleGroupRuleCaptchaConfigImmunityTimeProperty'] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @_builtins.property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional['outputs.RuleGroupRuleCaptchaConfigImmunityTimeProperty']:
        return pulumi.get(self, "immunity_time_property")


@pulumi.output_type
class RuleGroupRuleCaptchaConfigImmunityTimeProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTime":
            suggest = "immunity_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleCaptchaConfigImmunityTimeProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleCaptchaConfigImmunityTimeProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleCaptchaConfigImmunityTimeProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time: Optional[_builtins.int] = None):
        if immunity_time is not None:
            pulumi.set(__self__, "immunity_time", immunity_time)

    @_builtins.property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "immunity_time")


@pulumi.output_type
class RuleGroupRuleRuleLabel(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andStatement":
            suggest = "and_statement"
        elif key == "asnMatchStatement":
            suggest = "asn_match_statement"
        elif key == "byteMatchStatement":
            suggest = "byte_match_statement"
        elif key == "geoMatchStatement":
            suggest = "geo_match_statement"
        elif key == "ipSetReferenceStatement":
            suggest = "ip_set_reference_statement"
        elif key == "labelMatchStatement":
            suggest = "label_match_statement"
        elif key == "notStatement":
            suggest = "not_statement"
        elif key == "orStatement":
            suggest = "or_statement"
        elif key == "rateBasedStatement":
            suggest = "rate_based_statement"
        elif key == "regexMatchStatement":
            suggest = "regex_match_statement"
        elif key == "regexPatternSetReferenceStatement":
            suggest = "regex_pattern_set_reference_statement"
        elif key == "sizeConstraintStatement":
            suggest = "size_constraint_statement"
        elif key == "sqliMatchStatement":
            suggest = "sqli_match_statement"
        elif key == "xssMatchStatement":
            suggest = "xss_match_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_statement: Optional['outputs.RuleGroupRuleStatementAndStatement'] = None,
                 asn_match_statement: Optional['outputs.RuleGroupRuleStatementAsnMatchStatement'] = None,
                 byte_match_statement: Optional['outputs.RuleGroupRuleStatementByteMatchStatement'] = None,
                 geo_match_statement: Optional['outputs.RuleGroupRuleStatementGeoMatchStatement'] = None,
                 ip_set_reference_statement: Optional['outputs.RuleGroupRuleStatementIpSetReferenceStatement'] = None,
                 label_match_statement: Optional['outputs.RuleGroupRuleStatementLabelMatchStatement'] = None,
                 not_statement: Optional['outputs.RuleGroupRuleStatementNotStatement'] = None,
                 or_statement: Optional['outputs.RuleGroupRuleStatementOrStatement'] = None,
                 rate_based_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatement'] = None,
                 regex_match_statement: Optional['outputs.RuleGroupRuleStatementRegexMatchStatement'] = None,
                 regex_pattern_set_reference_statement: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatement'] = None,
                 size_constraint_statement: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatement'] = None,
                 sqli_match_statement: Optional['outputs.RuleGroupRuleStatementSqliMatchStatement'] = None,
                 xss_match_statement: Optional['outputs.RuleGroupRuleStatementXssMatchStatement'] = None):
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if asn_match_statement is not None:
            pulumi.set(__self__, "asn_match_statement", asn_match_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            pulumi.set(__self__, "ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if rate_based_statement is not None:
            pulumi.set(__self__, "rate_based_statement", rate_based_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @_builtins.property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional['outputs.RuleGroupRuleStatementAndStatement']:
        return pulumi.get(self, "and_statement")

    @_builtins.property
    @pulumi.getter(name="asnMatchStatement")
    def asn_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementAsnMatchStatement']:
        return pulumi.get(self, "asn_match_statement")

    @_builtins.property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatement']:
        return pulumi.get(self, "byte_match_statement")

    @_builtins.property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementGeoMatchStatement']:
        return pulumi.get(self, "geo_match_statement")

    @_builtins.property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional['outputs.RuleGroupRuleStatementIpSetReferenceStatement']:
        return pulumi.get(self, "ip_set_reference_statement")

    @_builtins.property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementLabelMatchStatement']:
        return pulumi.get(self, "label_match_statement")

    @_builtins.property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional['outputs.RuleGroupRuleStatementNotStatement']:
        return pulumi.get(self, "not_statement")

    @_builtins.property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional['outputs.RuleGroupRuleStatementOrStatement']:
        return pulumi.get(self, "or_statement")

    @_builtins.property
    @pulumi.getter(name="rateBasedStatement")
    def rate_based_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatement']:
        return pulumi.get(self, "rate_based_statement")

    @_builtins.property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatement']:
        return pulumi.get(self, "regex_match_statement")

    @_builtins.property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatement']:
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @_builtins.property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatement']:
        return pulumi.get(self, "size_constraint_statement")

    @_builtins.property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatement']:
        return pulumi.get(self, "sqli_match_statement")

    @_builtins.property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatement']:
        return pulumi.get(self, "xss_match_statement")


@pulumi.output_type
class RuleGroupRuleStatementAndStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.RuleGroupRuleStatement']):
        """
        :param Sequence['RuleGroupRuleStatementArgs'] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.RuleGroupRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class RuleGroupRuleStatementAsnMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "asnLists":
            suggest = "asn_lists"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementAsnMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementAsnMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementAsnMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn_lists: Sequence[_builtins.int],
                 forwarded_ip_config: Optional['outputs.RuleGroupRuleStatementAsnMatchStatementForwardedIpConfig'] = None):
        pulumi.set(__self__, "asn_lists", asn_lists)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @_builtins.property
    @pulumi.getter(name="asnLists")
    def asn_lists(self) -> Sequence[_builtins.int]:
        return pulumi.get(self, "asn_lists")

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.RuleGroupRuleStatementAsnMatchStatementForwardedIpConfig']:
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class RuleGroupRuleStatementAsnMatchStatementForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementAsnMatchStatementForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementAsnMatchStatementForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementAsnMatchStatementForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str,
                 header_name: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        return pulumi.get(self, "header_name")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "positionalConstraint":
            suggest = "positional_constraint"
        elif key == "searchString":
            suggest = "search_string"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 positional_constraint: _builtins.str,
                 search_string: _builtins.str,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementByteMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatch'] = None):
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "search_string", search_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> _builtins.str:
        return pulumi.get(self, "positional_constraint")

    @_builtins.property
    @pulumi.getter(name="searchString")
    def search_string(self) -> _builtins.str:
        return pulumi.get(self, "search_string")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementByteMatchStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementByteMatchStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementByteMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementByteMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementGeoMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCodes":
            suggest = "country_codes"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementGeoMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementGeoMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementGeoMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_codes: Sequence[_builtins.str],
                 forwarded_ip_config: Optional['outputs.RuleGroupRuleStatementGeoMatchStatementForwardedIpConfig'] = None):
        pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @_builtins.property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "country_codes")

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.RuleGroupRuleStatementGeoMatchStatementForwardedIpConfig']:
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class RuleGroupRuleStatementGeoMatchStatementForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementGeoMatchStatementForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementGeoMatchStatementForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementGeoMatchStatementForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str,
                 header_name: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        return pulumi.get(self, "header_name")


@pulumi.output_type
class RuleGroupRuleStatementIpSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipSetForwardedIpConfig":
            suggest = "ip_set_forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementIpSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementIpSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementIpSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 ip_set_forwarded_ip_config: Optional['outputs.RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig'] = None):
        pulumi.set(__self__, "arn", arn)
        if ip_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional['outputs.RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig']:
        return pulumi.get(self, "ip_set_forwarded_ip_config")


@pulumi.output_type
class RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str,
                 header_name: _builtins.str,
                 position: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter
    def position(self) -> _builtins.str:
        return pulumi.get(self, "position")


@pulumi.output_type
class RuleGroupRuleStatementLabelMatchStatement(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 scope: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        return pulumi.get(self, "scope")


@pulumi.output_type
class RuleGroupRuleStatementNotStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.RuleGroupRuleStatement']):
        """
        :param Sequence['RuleGroupRuleStatementArgs'] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.RuleGroupRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class RuleGroupRuleStatementOrStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.RuleGroupRuleStatement']):
        """
        :param Sequence['RuleGroupRuleStatementArgs'] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.RuleGroupRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregateKeyType":
            suggest = "aggregate_key_type"
        elif key == "customKeys":
            suggest = "custom_keys"
        elif key == "evaluationWindowSec":
            suggest = "evaluation_window_sec"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"
        elif key == "scopeDownStatement":
            suggest = "scope_down_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit: _builtins.int,
                 aggregate_key_type: Optional[_builtins.str] = None,
                 custom_keys: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKey']] = None,
                 evaluation_window_sec: Optional[_builtins.int] = None,
                 forwarded_ip_config: Optional['outputs.RuleGroupRuleStatementRateBasedStatementForwardedIpConfig'] = None,
                 scope_down_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatement'] = None):
        pulumi.set(__self__, "limit", limit)
        if aggregate_key_type is not None:
            pulumi.set(__self__, "aggregate_key_type", aggregate_key_type)
        if custom_keys is not None:
            pulumi.set(__self__, "custom_keys", custom_keys)
        if evaluation_window_sec is not None:
            pulumi.set(__self__, "evaluation_window_sec", evaluation_window_sec)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> _builtins.int:
        return pulumi.get(self, "limit")

    @_builtins.property
    @pulumi.getter(name="aggregateKeyType")
    def aggregate_key_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aggregate_key_type")

    @_builtins.property
    @pulumi.getter(name="customKeys")
    def custom_keys(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKey']]:
        return pulumi.get(self, "custom_keys")

    @_builtins.property
    @pulumi.getter(name="evaluationWindowSec")
    def evaluation_window_sec(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "evaluation_window_sec")

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementForwardedIpConfig']:
        return pulumi.get(self, "forwarded_ip_config")

    @_builtins.property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatement']:
        return pulumi.get(self, "scope_down_statement")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forwardedIp":
            suggest = "forwarded_ip"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "labelNamespace":
            suggest = "label_namespace"
        elif key == "queryArgument":
            suggest = "query_argument"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementCustomKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyAsn'] = None,
                 cookie: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyCookie'] = None,
                 forwarded_ip: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIp'] = None,
                 header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyHeader'] = None,
                 http_method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethod'] = None,
                 ip: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyIp'] = None,
                 ja3_fingerprint: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyJa4Fingerprint'] = None,
                 label_namespace: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespace'] = None,
                 query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgument'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryString'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyUriPath'] = None):
        if asn is not None:
            pulumi.set(__self__, "asn", asn)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if forwarded_ip is not None:
            pulumi.set(__self__, "forwarded_ip", forwarded_ip)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if label_namespace is not None:
            pulumi.set(__self__, "label_namespace", label_namespace)
        if query_argument is not None:
            pulumi.set(__self__, "query_argument", query_argument)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter
    def asn(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyAsn']:
        return pulumi.get(self, "asn")

    @_builtins.property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyCookie']:
        return pulumi.get(self, "cookie")

    @_builtins.property
    @pulumi.getter(name="forwardedIp")
    def forwarded_ip(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIp']:
        return pulumi.get(self, "forwarded_ip")

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyHeader']:
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethod']:
        return pulumi.get(self, "http_method")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyIp']:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="labelNamespace")
    def label_namespace(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespace']:
        return pulumi.get(self, "label_namespace")

    @_builtins.property
    @pulumi.getter(name="queryArgument")
    def query_argument(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgument']:
        return pulumi.get(self, "query_argument")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyAsn(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyCookie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementCustomKeyCookie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyCookie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyCookie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformation']):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIp(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementCustomKeyHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation']):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyIp(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementCustomKeyJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementCustomKeyJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespace(dict):
    def __init__(__self__, *,
                 namespace: _builtins.str):
        pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        return pulumi.get(self, "namespace")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgument(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgument. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgument.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgument.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation']):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementCustomKeyQueryString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyQueryString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyQueryString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation']):
        pulumi.set(__self__, "text_transformations", text_transformations)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyUriPath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementCustomKeyUriPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyUriPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementCustomKeyUriPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation']):
        pulumi.set(__self__, "text_transformations", text_transformations)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str,
                 header_name: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        return pulumi.get(self, "header_name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andStatement":
            suggest = "and_statement"
        elif key == "asnMatchStatement":
            suggest = "asn_match_statement"
        elif key == "byteMatchStatement":
            suggest = "byte_match_statement"
        elif key == "geoMatchStatement":
            suggest = "geo_match_statement"
        elif key == "ipSetReferenceStatement":
            suggest = "ip_set_reference_statement"
        elif key == "labelMatchStatement":
            suggest = "label_match_statement"
        elif key == "notStatement":
            suggest = "not_statement"
        elif key == "orStatement":
            suggest = "or_statement"
        elif key == "regexMatchStatement":
            suggest = "regex_match_statement"
        elif key == "regexPatternSetReferenceStatement":
            suggest = "regex_pattern_set_reference_statement"
        elif key == "sizeConstraintStatement":
            suggest = "size_constraint_statement"
        elif key == "sqliMatchStatement":
            suggest = "sqli_match_statement"
        elif key == "xssMatchStatement":
            suggest = "xss_match_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatement'] = None,
                 asn_match_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatement'] = None,
                 byte_match_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement'] = None,
                 geo_match_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement'] = None,
                 ip_set_reference_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement'] = None,
                 label_match_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement'] = None,
                 not_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatement'] = None,
                 or_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatement'] = None,
                 regex_match_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement'] = None,
                 regex_pattern_set_reference_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement'] = None,
                 size_constraint_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement'] = None,
                 sqli_match_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement'] = None,
                 xss_match_statement: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement'] = None):
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if asn_match_statement is not None:
            pulumi.set(__self__, "asn_match_statement", asn_match_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            pulumi.set(__self__, "ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @_builtins.property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatement']:
        return pulumi.get(self, "and_statement")

    @_builtins.property
    @pulumi.getter(name="asnMatchStatement")
    def asn_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatement']:
        return pulumi.get(self, "asn_match_statement")

    @_builtins.property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement']:
        return pulumi.get(self, "byte_match_statement")

    @_builtins.property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement']:
        return pulumi.get(self, "geo_match_statement")

    @_builtins.property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement']:
        return pulumi.get(self, "ip_set_reference_statement")

    @_builtins.property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement']:
        return pulumi.get(self, "label_match_statement")

    @_builtins.property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatement']:
        return pulumi.get(self, "not_statement")

    @_builtins.property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatement']:
        return pulumi.get(self, "or_statement")

    @_builtins.property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement']:
        return pulumi.get(self, "regex_match_statement")

    @_builtins.property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement']:
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @_builtins.property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement']:
        return pulumi.get(self, "size_constraint_statement")

    @_builtins.property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement']:
        return pulumi.get(self, "sqli_match_statement")

    @_builtins.property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement']:
        return pulumi.get(self, "xss_match_statement")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.RuleGroupRuleStatement']):
        """
        :param Sequence['RuleGroupRuleStatementArgs'] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.RuleGroupRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "asnLists":
            suggest = "asn_lists"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn_lists: Sequence[_builtins.int],
                 forwarded_ip_config: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfig'] = None):
        pulumi.set(__self__, "asn_lists", asn_lists)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @_builtins.property
    @pulumi.getter(name="asnLists")
    def asn_lists(self) -> Sequence[_builtins.int]:
        return pulumi.get(self, "asn_lists")

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfig']:
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str,
                 header_name: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        return pulumi.get(self, "header_name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "positionalConstraint":
            suggest = "positional_constraint"
        elif key == "searchString":
            suggest = "search_string"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 positional_constraint: _builtins.str,
                 search_string: _builtins.str,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch'] = None):
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "search_string", search_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> _builtins.str:
        return pulumi.get(self, "positional_constraint")

    @_builtins.property
    @pulumi.getter(name="searchString")
    def search_string(self) -> _builtins.str:
        return pulumi.get(self, "search_string")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCodes":
            suggest = "country_codes"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_codes: Sequence[_builtins.str],
                 forwarded_ip_config: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig'] = None):
        pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @_builtins.property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "country_codes")

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig']:
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str,
                 header_name: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        return pulumi.get(self, "header_name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipSetForwardedIpConfig":
            suggest = "ip_set_forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 ip_set_forwarded_ip_config: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig'] = None):
        pulumi.set(__self__, "arn", arn)
        if ip_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig']:
        return pulumi.get(self, "ip_set_forwarded_ip_config")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str,
                 header_name: _builtins.str,
                 position: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter
    def position(self) -> _builtins.str:
        return pulumi.get(self, "position")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 scope: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        return pulumi.get(self, "scope")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.RuleGroupRuleStatement']):
        """
        :param Sequence['RuleGroupRuleStatementArgs'] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.RuleGroupRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.RuleGroupRuleStatement']):
        """
        :param Sequence['RuleGroupRuleStatementArgs'] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.RuleGroupRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regexString":
            suggest = "regex_string"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regex_string: _builtins.str,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch'] = None):
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> _builtins.str:
        return pulumi.get(self, "regex_string")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch'] = None):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: _builtins.str,
                 size: _builtins.int,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch'] = None):
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> _builtins.str:
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "sensitivityLevel":
            suggest = "sensitivity_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch'] = None,
                 sensitivity_level: Optional[_builtins.str] = None):
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")

    @_builtins.property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sensitivity_level")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch'] = None):
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regexString":
            suggest = "regex_string"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regex_string: _builtins.str,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRegexMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatch'] = None):
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> _builtins.str:
        return pulumi.get(self, "regex_string")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRegexMatchStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRegexMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatch'] = None):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: _builtins.str,
                 size: _builtins.int,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementSizeConstraintStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatch'] = None):
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> _builtins.str:
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementSizeConstraintStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementSizeConstraintStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "sensitivityLevel":
            suggest = "sensitivity_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementSqliMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatch'] = None,
                 sensitivity_level: Optional[_builtins.str] = None):
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementSqliMatchStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")

    @_builtins.property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sensitivity_level")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementSqliMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.RuleGroupRuleStatementXssMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatch'] = None):
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.RuleGroupRuleStatementXssMatchStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleStatementXssMatchStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleStatementXssMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RuleGroupRuleStatementXssMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class RuleGroupRuleVisibilityConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchMetricsEnabled":
            suggest = "cloudwatch_metrics_enabled"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "sampledRequestsEnabled":
            suggest = "sampled_requests_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupRuleVisibilityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupRuleVisibilityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupRuleVisibilityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_metrics_enabled: _builtins.bool,
                 metric_name: _builtins.str,
                 sampled_requests_enabled: _builtins.bool):
        pulumi.set(__self__, "cloudwatch_metrics_enabled", cloudwatch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @_builtins.property
    @pulumi.getter(name="cloudwatchMetricsEnabled")
    def cloudwatch_metrics_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "cloudwatch_metrics_enabled")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "sampled_requests_enabled")


@pulumi.output_type
class RuleGroupVisibilityConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchMetricsEnabled":
            suggest = "cloudwatch_metrics_enabled"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "sampledRequestsEnabled":
            suggest = "sampled_requests_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupVisibilityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupVisibilityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupVisibilityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_metrics_enabled: _builtins.bool,
                 metric_name: _builtins.str,
                 sampled_requests_enabled: _builtins.bool):
        pulumi.set(__self__, "cloudwatch_metrics_enabled", cloudwatch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @_builtins.property
    @pulumi.getter(name="cloudwatchMetricsEnabled")
    def cloudwatch_metrics_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "cloudwatch_metrics_enabled")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "sampled_requests_enabled")


@pulumi.output_type
class WebAclAssociationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestBodies":
            suggest = "request_bodies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclAssociationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclAssociationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclAssociationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_bodies: Optional[Sequence['outputs.WebAclAssociationConfigRequestBody']] = None):
        if request_bodies is not None:
            pulumi.set(__self__, "request_bodies", request_bodies)

    @_builtins.property
    @pulumi.getter(name="requestBodies")
    def request_bodies(self) -> Optional[Sequence['outputs.WebAclAssociationConfigRequestBody']]:
        return pulumi.get(self, "request_bodies")


@pulumi.output_type
class WebAclAssociationConfigRequestBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiGateway":
            suggest = "api_gateway"
        elif key == "appRunnerService":
            suggest = "app_runner_service"
        elif key == "cognitoUserPool":
            suggest = "cognito_user_pool"
        elif key == "verifiedAccessInstance":
            suggest = "verified_access_instance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclAssociationConfigRequestBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclAssociationConfigRequestBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclAssociationConfigRequestBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_gateway: Optional['outputs.WebAclAssociationConfigRequestBodyApiGateway'] = None,
                 app_runner_service: Optional['outputs.WebAclAssociationConfigRequestBodyAppRunnerService'] = None,
                 cloudfront: Optional['outputs.WebAclAssociationConfigRequestBodyCloudfront'] = None,
                 cognito_user_pool: Optional['outputs.WebAclAssociationConfigRequestBodyCognitoUserPool'] = None,
                 verified_access_instance: Optional['outputs.WebAclAssociationConfigRequestBodyVerifiedAccessInstance'] = None):
        if api_gateway is not None:
            pulumi.set(__self__, "api_gateway", api_gateway)
        if app_runner_service is not None:
            pulumi.set(__self__, "app_runner_service", app_runner_service)
        if cloudfront is not None:
            pulumi.set(__self__, "cloudfront", cloudfront)
        if cognito_user_pool is not None:
            pulumi.set(__self__, "cognito_user_pool", cognito_user_pool)
        if verified_access_instance is not None:
            pulumi.set(__self__, "verified_access_instance", verified_access_instance)

    @_builtins.property
    @pulumi.getter(name="apiGateway")
    def api_gateway(self) -> Optional['outputs.WebAclAssociationConfigRequestBodyApiGateway']:
        return pulumi.get(self, "api_gateway")

    @_builtins.property
    @pulumi.getter(name="appRunnerService")
    def app_runner_service(self) -> Optional['outputs.WebAclAssociationConfigRequestBodyAppRunnerService']:
        return pulumi.get(self, "app_runner_service")

    @_builtins.property
    @pulumi.getter
    def cloudfront(self) -> Optional['outputs.WebAclAssociationConfigRequestBodyCloudfront']:
        return pulumi.get(self, "cloudfront")

    @_builtins.property
    @pulumi.getter(name="cognitoUserPool")
    def cognito_user_pool(self) -> Optional['outputs.WebAclAssociationConfigRequestBodyCognitoUserPool']:
        return pulumi.get(self, "cognito_user_pool")

    @_builtins.property
    @pulumi.getter(name="verifiedAccessInstance")
    def verified_access_instance(self) -> Optional['outputs.WebAclAssociationConfigRequestBodyVerifiedAccessInstance']:
        return pulumi.get(self, "verified_access_instance")


@pulumi.output_type
class WebAclAssociationConfigRequestBodyApiGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultSizeInspectionLimit":
            suggest = "default_size_inspection_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclAssociationConfigRequestBodyApiGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclAssociationConfigRequestBodyApiGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclAssociationConfigRequestBodyApiGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_size_inspection_limit: _builtins.str):
        pulumi.set(__self__, "default_size_inspection_limit", default_size_inspection_limit)

    @_builtins.property
    @pulumi.getter(name="defaultSizeInspectionLimit")
    def default_size_inspection_limit(self) -> _builtins.str:
        return pulumi.get(self, "default_size_inspection_limit")


@pulumi.output_type
class WebAclAssociationConfigRequestBodyAppRunnerService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultSizeInspectionLimit":
            suggest = "default_size_inspection_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclAssociationConfigRequestBodyAppRunnerService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclAssociationConfigRequestBodyAppRunnerService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclAssociationConfigRequestBodyAppRunnerService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_size_inspection_limit: _builtins.str):
        pulumi.set(__self__, "default_size_inspection_limit", default_size_inspection_limit)

    @_builtins.property
    @pulumi.getter(name="defaultSizeInspectionLimit")
    def default_size_inspection_limit(self) -> _builtins.str:
        return pulumi.get(self, "default_size_inspection_limit")


@pulumi.output_type
class WebAclAssociationConfigRequestBodyCloudfront(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultSizeInspectionLimit":
            suggest = "default_size_inspection_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclAssociationConfigRequestBodyCloudfront. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclAssociationConfigRequestBodyCloudfront.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclAssociationConfigRequestBodyCloudfront.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_size_inspection_limit: _builtins.str):
        pulumi.set(__self__, "default_size_inspection_limit", default_size_inspection_limit)

    @_builtins.property
    @pulumi.getter(name="defaultSizeInspectionLimit")
    def default_size_inspection_limit(self) -> _builtins.str:
        return pulumi.get(self, "default_size_inspection_limit")


@pulumi.output_type
class WebAclAssociationConfigRequestBodyCognitoUserPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultSizeInspectionLimit":
            suggest = "default_size_inspection_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclAssociationConfigRequestBodyCognitoUserPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclAssociationConfigRequestBodyCognitoUserPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclAssociationConfigRequestBodyCognitoUserPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_size_inspection_limit: _builtins.str):
        pulumi.set(__self__, "default_size_inspection_limit", default_size_inspection_limit)

    @_builtins.property
    @pulumi.getter(name="defaultSizeInspectionLimit")
    def default_size_inspection_limit(self) -> _builtins.str:
        return pulumi.get(self, "default_size_inspection_limit")


@pulumi.output_type
class WebAclAssociationConfigRequestBodyVerifiedAccessInstance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultSizeInspectionLimit":
            suggest = "default_size_inspection_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclAssociationConfigRequestBodyVerifiedAccessInstance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclAssociationConfigRequestBodyVerifiedAccessInstance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclAssociationConfigRequestBodyVerifiedAccessInstance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_size_inspection_limit: _builtins.str):
        pulumi.set(__self__, "default_size_inspection_limit", default_size_inspection_limit)

    @_builtins.property
    @pulumi.getter(name="defaultSizeInspectionLimit")
    def default_size_inspection_limit(self) -> _builtins.str:
        return pulumi.get(self, "default_size_inspection_limit")


@pulumi.output_type
class WebAclCaptchaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTimeProperty":
            suggest = "immunity_time_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclCaptchaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclCaptchaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclCaptchaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time_property: Optional['outputs.WebAclCaptchaConfigImmunityTimeProperty'] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @_builtins.property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional['outputs.WebAclCaptchaConfigImmunityTimeProperty']:
        return pulumi.get(self, "immunity_time_property")


@pulumi.output_type
class WebAclCaptchaConfigImmunityTimeProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTime":
            suggest = "immunity_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclCaptchaConfigImmunityTimeProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclCaptchaConfigImmunityTimeProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclCaptchaConfigImmunityTimeProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time: Optional[_builtins.int] = None):
        if immunity_time is not None:
            pulumi.set(__self__, "immunity_time", immunity_time)

    @_builtins.property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "immunity_time")


@pulumi.output_type
class WebAclChallengeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTimeProperty":
            suggest = "immunity_time_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclChallengeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclChallengeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclChallengeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time_property: Optional['outputs.WebAclChallengeConfigImmunityTimeProperty'] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @_builtins.property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional['outputs.WebAclChallengeConfigImmunityTimeProperty']:
        return pulumi.get(self, "immunity_time_property")


@pulumi.output_type
class WebAclChallengeConfigImmunityTimeProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTime":
            suggest = "immunity_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclChallengeConfigImmunityTimeProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclChallengeConfigImmunityTimeProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclChallengeConfigImmunityTimeProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time: Optional[_builtins.int] = None):
        if immunity_time is not None:
            pulumi.set(__self__, "immunity_time", immunity_time)

    @_builtins.property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "immunity_time")


@pulumi.output_type
class WebAclCustomResponseBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclCustomResponseBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclCustomResponseBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclCustomResponseBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: _builtins.str,
                 content_type: _builtins.str,
                 key: _builtins.str):
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> _builtins.str:
        return pulumi.get(self, "content_type")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")


@pulumi.output_type
class WebAclDataProtectionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataProtections":
            suggest = "data_protections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclDataProtectionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclDataProtectionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclDataProtectionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_protections: Optional[Sequence['outputs.WebAclDataProtectionConfigDataProtection']] = None):
        if data_protections is not None:
            pulumi.set(__self__, "data_protections", data_protections)

    @_builtins.property
    @pulumi.getter(name="dataProtections")
    def data_protections(self) -> Optional[Sequence['outputs.WebAclDataProtectionConfigDataProtection']]:
        return pulumi.get(self, "data_protections")


@pulumi.output_type
class WebAclDataProtectionConfigDataProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeRateBasedDetails":
            suggest = "exclude_rate_based_details"
        elif key == "excludeRuleMatchDetails":
            suggest = "exclude_rule_match_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclDataProtectionConfigDataProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclDataProtectionConfigDataProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclDataProtectionConfigDataProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 field: 'outputs.WebAclDataProtectionConfigDataProtectionField',
                 exclude_rate_based_details: Optional[_builtins.bool] = None,
                 exclude_rule_match_details: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "field", field)
        if exclude_rate_based_details is not None:
            pulumi.set(__self__, "exclude_rate_based_details", exclude_rate_based_details)
        if exclude_rule_match_details is not None:
            pulumi.set(__self__, "exclude_rule_match_details", exclude_rule_match_details)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def field(self) -> 'outputs.WebAclDataProtectionConfigDataProtectionField':
        return pulumi.get(self, "field")

    @_builtins.property
    @pulumi.getter(name="excludeRateBasedDetails")
    def exclude_rate_based_details(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "exclude_rate_based_details")

    @_builtins.property
    @pulumi.getter(name="excludeRuleMatchDetails")
    def exclude_rule_match_details(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "exclude_rule_match_details")


@pulumi.output_type
class WebAclDataProtectionConfigDataProtectionField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldType":
            suggest = "field_type"
        elif key == "fieldKeys":
            suggest = "field_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclDataProtectionConfigDataProtectionField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclDataProtectionConfigDataProtectionField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclDataProtectionConfigDataProtectionField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_type: _builtins.str,
                 field_keys: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "field_type", field_type)
        if field_keys is not None:
            pulumi.set(__self__, "field_keys", field_keys)

    @_builtins.property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> _builtins.str:
        return pulumi.get(self, "field_type")

    @_builtins.property
    @pulumi.getter(name="fieldKeys")
    def field_keys(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "field_keys")


@pulumi.output_type
class WebAclDefaultAction(dict):
    def __init__(__self__, *,
                 allow: Optional['outputs.WebAclDefaultActionAllow'] = None,
                 block: Optional['outputs.WebAclDefaultActionBlock'] = None):
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional['outputs.WebAclDefaultActionAllow']:
        return pulumi.get(self, "allow")

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional['outputs.WebAclDefaultActionBlock']:
        return pulumi.get(self, "block")


@pulumi.output_type
class WebAclDefaultActionAllow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclDefaultActionAllow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclDefaultActionAllow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclDefaultActionAllow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclDefaultActionAllowCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclDefaultActionAllowCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclDefaultActionAllowCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclDefaultActionAllowCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclDefaultActionAllowCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclDefaultActionAllowCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclDefaultActionAllowCustomRequestHandlingInsertHeader']):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclDefaultActionAllowCustomRequestHandlingInsertHeader']:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclDefaultActionAllowCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclDefaultActionBlock(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customResponse":
            suggest = "custom_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclDefaultActionBlock. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclDefaultActionBlock.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclDefaultActionBlock.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_response: Optional['outputs.WebAclDefaultActionBlockCustomResponse'] = None):
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @_builtins.property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional['outputs.WebAclDefaultActionBlockCustomResponse']:
        return pulumi.get(self, "custom_response")


@pulumi.output_type
class WebAclDefaultActionBlockCustomResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseCode":
            suggest = "response_code"
        elif key == "customResponseBodyKey":
            suggest = "custom_response_body_key"
        elif key == "responseHeaders":
            suggest = "response_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclDefaultActionBlockCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclDefaultActionBlockCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclDefaultActionBlockCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_code: _builtins.int,
                 custom_response_body_key: Optional[_builtins.str] = None,
                 response_headers: Optional[Sequence['outputs.WebAclDefaultActionBlockCustomResponseResponseHeader']] = None):
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> _builtins.int:
        return pulumi.get(self, "response_code")

    @_builtins.property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_response_body_key")

    @_builtins.property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[Sequence['outputs.WebAclDefaultActionBlockCustomResponseResponseHeader']]:
        return pulumi.get(self, "response_headers")


@pulumi.output_type
class WebAclDefaultActionBlockCustomResponseResponseHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclLoggingConfigurationLoggingFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultBehavior":
            suggest = "default_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclLoggingConfigurationLoggingFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclLoggingConfigurationLoggingFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclLoggingConfigurationLoggingFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_behavior: _builtins.str,
                 filters: Sequence['outputs.WebAclLoggingConfigurationLoggingFilterFilter']):
        pulumi.set(__self__, "default_behavior", default_behavior)
        pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter(name="defaultBehavior")
    def default_behavior(self) -> _builtins.str:
        return pulumi.get(self, "default_behavior")

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.WebAclLoggingConfigurationLoggingFilterFilter']:
        return pulumi.get(self, "filters")


@pulumi.output_type
class WebAclLoggingConfigurationLoggingFilterFilter(dict):
    def __init__(__self__, *,
                 behavior: _builtins.str,
                 conditions: Sequence['outputs.WebAclLoggingConfigurationLoggingFilterFilterCondition'],
                 requirement: _builtins.str):
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "requirement", requirement)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> _builtins.str:
        return pulumi.get(self, "behavior")

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.WebAclLoggingConfigurationLoggingFilterFilterCondition']:
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter
    def requirement(self) -> _builtins.str:
        return pulumi.get(self, "requirement")


@pulumi.output_type
class WebAclLoggingConfigurationLoggingFilterFilterCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionCondition":
            suggest = "action_condition"
        elif key == "labelNameCondition":
            suggest = "label_name_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclLoggingConfigurationLoggingFilterFilterCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclLoggingConfigurationLoggingFilterFilterCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclLoggingConfigurationLoggingFilterFilterCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_condition: Optional['outputs.WebAclLoggingConfigurationLoggingFilterFilterConditionActionCondition'] = None,
                 label_name_condition: Optional['outputs.WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameCondition'] = None):
        if action_condition is not None:
            pulumi.set(__self__, "action_condition", action_condition)
        if label_name_condition is not None:
            pulumi.set(__self__, "label_name_condition", label_name_condition)

    @_builtins.property
    @pulumi.getter(name="actionCondition")
    def action_condition(self) -> Optional['outputs.WebAclLoggingConfigurationLoggingFilterFilterConditionActionCondition']:
        return pulumi.get(self, "action_condition")

    @_builtins.property
    @pulumi.getter(name="labelNameCondition")
    def label_name_condition(self) -> Optional['outputs.WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameCondition']:
        return pulumi.get(self, "label_name_condition")


@pulumi.output_type
class WebAclLoggingConfigurationLoggingFilterFilterConditionActionCondition(dict):
    def __init__(__self__, *,
                 action: _builtins.str):
        pulumi.set(__self__, "action", action)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        return pulumi.get(self, "action")


@pulumi.output_type
class WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelName":
            suggest = "label_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_name: _builtins.str):
        pulumi.set(__self__, "label_name", label_name)

    @_builtins.property
    @pulumi.getter(name="labelName")
    def label_name(self) -> _builtins.str:
        return pulumi.get(self, "label_name")


@pulumi.output_type
class WebAclLoggingConfigurationRedactedField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclLoggingConfigurationRedactedField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclLoggingConfigurationRedactedField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclLoggingConfigurationRedactedField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: Optional['outputs.WebAclLoggingConfigurationRedactedFieldMethod'] = None,
                 query_string: Optional['outputs.WebAclLoggingConfigurationRedactedFieldQueryString'] = None,
                 single_header: Optional['outputs.WebAclLoggingConfigurationRedactedFieldSingleHeader'] = None,
                 uri_path: Optional['outputs.WebAclLoggingConfigurationRedactedFieldUriPath'] = None):
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclLoggingConfigurationRedactedFieldMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclLoggingConfigurationRedactedFieldQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclLoggingConfigurationRedactedFieldSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclLoggingConfigurationRedactedFieldUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclLoggingConfigurationRedactedFieldMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclLoggingConfigurationRedactedFieldQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclLoggingConfigurationRedactedFieldSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclLoggingConfigurationRedactedFieldUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "visibilityConfig":
            suggest = "visibility_config"
        elif key == "captchaConfig":
            suggest = "captcha_config"
        elif key == "challengeConfig":
            suggest = "challenge_config"
        elif key == "overrideAction":
            suggest = "override_action"
        elif key == "ruleLabels":
            suggest = "rule_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 priority: _builtins.int,
                 statement: 'outputs.WebAclRuleStatement',
                 visibility_config: 'outputs.WebAclRuleVisibilityConfig',
                 action: Optional['outputs.WebAclRuleAction'] = None,
                 captcha_config: Optional['outputs.WebAclRuleCaptchaConfig'] = None,
                 challenge_config: Optional['outputs.WebAclRuleChallengeConfig'] = None,
                 override_action: Optional['outputs.WebAclRuleOverrideAction'] = None,
                 rule_labels: Optional[Sequence['outputs.WebAclRuleRuleLabel']] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "statement", statement)
        pulumi.set(__self__, "visibility_config", visibility_config)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if captcha_config is not None:
            pulumi.set(__self__, "captcha_config", captcha_config)
        if challenge_config is not None:
            pulumi.set(__self__, "challenge_config", challenge_config)
        if override_action is not None:
            pulumi.set(__self__, "override_action", override_action)
        if rule_labels is not None:
            pulumi.set(__self__, "rule_labels", rule_labels)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def statement(self) -> 'outputs.WebAclRuleStatement':
        return pulumi.get(self, "statement")

    @_builtins.property
    @pulumi.getter(name="visibilityConfig")
    def visibility_config(self) -> 'outputs.WebAclRuleVisibilityConfig':
        return pulumi.get(self, "visibility_config")

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional['outputs.WebAclRuleAction']:
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="captchaConfig")
    def captcha_config(self) -> Optional['outputs.WebAclRuleCaptchaConfig']:
        return pulumi.get(self, "captcha_config")

    @_builtins.property
    @pulumi.getter(name="challengeConfig")
    def challenge_config(self) -> Optional['outputs.WebAclRuleChallengeConfig']:
        return pulumi.get(self, "challenge_config")

    @_builtins.property
    @pulumi.getter(name="overrideAction")
    def override_action(self) -> Optional['outputs.WebAclRuleOverrideAction']:
        return pulumi.get(self, "override_action")

    @_builtins.property
    @pulumi.getter(name="ruleLabels")
    def rule_labels(self) -> Optional[Sequence['outputs.WebAclRuleRuleLabel']]:
        return pulumi.get(self, "rule_labels")


@pulumi.output_type
class WebAclRuleAction(dict):
    def __init__(__self__, *,
                 allow: Optional['outputs.WebAclRuleActionAllow'] = None,
                 block: Optional['outputs.WebAclRuleActionBlock'] = None,
                 captcha: Optional['outputs.WebAclRuleActionCaptcha'] = None,
                 challenge: Optional['outputs.WebAclRuleActionChallenge'] = None,
                 count: Optional['outputs.WebAclRuleActionCount'] = None):
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional['outputs.WebAclRuleActionAllow']:
        return pulumi.get(self, "allow")

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional['outputs.WebAclRuleActionBlock']:
        return pulumi.get(self, "block")

    @_builtins.property
    @pulumi.getter
    def captcha(self) -> Optional['outputs.WebAclRuleActionCaptcha']:
        return pulumi.get(self, "captcha")

    @_builtins.property
    @pulumi.getter
    def challenge(self) -> Optional['outputs.WebAclRuleActionChallenge']:
        return pulumi.get(self, "challenge")

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional['outputs.WebAclRuleActionCount']:
        return pulumi.get(self, "count")


@pulumi.output_type
class WebAclRuleActionAllow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionAllow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionAllow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionAllow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleActionAllowCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleActionAllowCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleActionAllowCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionAllowCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionAllowCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionAllowCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleActionAllowCustomRequestHandlingInsertHeader']):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleActionAllowCustomRequestHandlingInsertHeader']:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleActionAllowCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleActionBlock(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customResponse":
            suggest = "custom_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionBlock. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionBlock.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionBlock.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_response: Optional['outputs.WebAclRuleActionBlockCustomResponse'] = None):
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @_builtins.property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional['outputs.WebAclRuleActionBlockCustomResponse']:
        return pulumi.get(self, "custom_response")


@pulumi.output_type
class WebAclRuleActionBlockCustomResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseCode":
            suggest = "response_code"
        elif key == "customResponseBodyKey":
            suggest = "custom_response_body_key"
        elif key == "responseHeaders":
            suggest = "response_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionBlockCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionBlockCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionBlockCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_code: _builtins.int,
                 custom_response_body_key: Optional[_builtins.str] = None,
                 response_headers: Optional[Sequence['outputs.WebAclRuleActionBlockCustomResponseResponseHeader']] = None):
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> _builtins.int:
        return pulumi.get(self, "response_code")

    @_builtins.property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_response_body_key")

    @_builtins.property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[Sequence['outputs.WebAclRuleActionBlockCustomResponseResponseHeader']]:
        return pulumi.get(self, "response_headers")


@pulumi.output_type
class WebAclRuleActionBlockCustomResponseResponseHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleActionCaptcha(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionCaptcha. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionCaptcha.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionCaptcha.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleActionCaptchaCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleActionCaptchaCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleActionCaptchaCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionCaptchaCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionCaptchaCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionCaptchaCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleActionCaptchaCustomRequestHandlingInsertHeader']):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleActionCaptchaCustomRequestHandlingInsertHeader']:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleActionCaptchaCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleActionChallenge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionChallenge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionChallenge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionChallenge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleActionChallengeCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleActionChallengeCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleActionChallengeCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionChallengeCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionChallengeCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionChallengeCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleActionChallengeCustomRequestHandlingInsertHeader']):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleActionChallengeCustomRequestHandlingInsertHeader']:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleActionChallengeCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleActionCount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionCount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionCount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionCount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleActionCountCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleActionCountCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleActionCountCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleActionCountCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleActionCountCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleActionCountCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleActionCountCustomRequestHandlingInsertHeader']):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleActionCountCustomRequestHandlingInsertHeader']:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleActionCountCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleCaptchaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTimeProperty":
            suggest = "immunity_time_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleCaptchaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleCaptchaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleCaptchaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time_property: Optional['outputs.WebAclRuleCaptchaConfigImmunityTimeProperty'] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @_builtins.property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional['outputs.WebAclRuleCaptchaConfigImmunityTimeProperty']:
        return pulumi.get(self, "immunity_time_property")


@pulumi.output_type
class WebAclRuleCaptchaConfigImmunityTimeProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTime":
            suggest = "immunity_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleCaptchaConfigImmunityTimeProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleCaptchaConfigImmunityTimeProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleCaptchaConfigImmunityTimeProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time: Optional[_builtins.int] = None):
        if immunity_time is not None:
            pulumi.set(__self__, "immunity_time", immunity_time)

    @_builtins.property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "immunity_time")


@pulumi.output_type
class WebAclRuleChallengeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTimeProperty":
            suggest = "immunity_time_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleChallengeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleChallengeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleChallengeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time_property: Optional['outputs.WebAclRuleChallengeConfigImmunityTimeProperty'] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @_builtins.property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional['outputs.WebAclRuleChallengeConfigImmunityTimeProperty']:
        return pulumi.get(self, "immunity_time_property")


@pulumi.output_type
class WebAclRuleChallengeConfigImmunityTimeProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "immunityTime":
            suggest = "immunity_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleChallengeConfigImmunityTimeProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleChallengeConfigImmunityTimeProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleChallengeConfigImmunityTimeProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 immunity_time: Optional[_builtins.int] = None):
        if immunity_time is not None:
            pulumi.set(__self__, "immunity_time", immunity_time)

    @_builtins.property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "immunity_time")


@pulumi.output_type
class WebAclRuleGroupAssociationManagedRuleGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vendorName":
            suggest = "vendor_name"
        elif key == "ruleActionOverrides":
            suggest = "rule_action_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationManagedRuleGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 vendor_name: _builtins.str,
                 rule_action_overrides: Optional[Sequence['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverride']] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the managed rule group.
        :param _builtins.str vendor_name: Name of the managed rule group vendor.
        :param Sequence['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideArgs'] rule_action_overrides: Action settings to use in place of rule actions configured inside the rule group. You can specify up to 100 overrides.
        :param _builtins.str version: Version of the managed rule group. Omit this to use the default version.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vendor_name", vendor_name)
        if rule_action_overrides is not None:
            pulumi.set(__self__, "rule_action_overrides", rule_action_overrides)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the managed rule group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="vendorName")
    def vendor_name(self) -> _builtins.str:
        """
        Name of the managed rule group vendor.
        """
        return pulumi.get(self, "vendor_name")

    @_builtins.property
    @pulumi.getter(name="ruleActionOverrides")
    def rule_action_overrides(self) -> Optional[Sequence['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverride']]:
        """
        Action settings to use in place of rule actions configured inside the rule group. You can specify up to 100 overrides.
        """
        return pulumi.get(self, "rule_action_overrides")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Version of the managed rule group. Omit this to use the default version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionToUse":
            suggest = "action_to_use"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 action_to_use: Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUse'] = None):
        """
        :param _builtins.str name: Name of the rule to override.
        :param 'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseArgs' action_to_use: Action to use in place of the rule action.
        """
        pulumi.set(__self__, "name", name)
        if action_to_use is not None:
            pulumi.set(__self__, "action_to_use", action_to_use)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the rule to override.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="actionToUse")
    def action_to_use(self) -> Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUse']:
        """
        Action to use in place of the rule action.
        """
        return pulumi.get(self, "action_to_use")


@pulumi.output_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUse(dict):
    def __init__(__self__, *,
                 allow: Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllow'] = None,
                 block: Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlock'] = None,
                 captcha: Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptcha'] = None,
                 challenge: Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallenge'] = None,
                 count: Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCount'] = None):
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllow']:
        return pulumi.get(self, "allow")

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlock']:
        return pulumi.get(self, "block")

    @_builtins.property
    @pulumi.getter
    def captcha(self) -> Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptcha']:
        return pulumi.get(self, "captcha")

    @_builtins.property
    @pulumi.getter
    def challenge(self) -> Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallenge']:
        return pulumi.get(self, "challenge")

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCount']:
        return pulumi.get(self, "count")


@pulumi.output_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Optional[Sequence['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader']] = None):
        if insert_headers is not None:
            pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Optional[Sequence['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader']]:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlock(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customResponse":
            suggest = "custom_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlock. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlock.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlock.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_response: Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponse'] = None):
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @_builtins.property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponse']:
        return pulumi.get(self, "custom_response")


@pulumi.output_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseCode":
            suggest = "response_code"
        elif key == "customResponseBodyKey":
            suggest = "custom_response_body_key"
        elif key == "responseHeaders":
            suggest = "response_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_code: _builtins.int,
                 custom_response_body_key: Optional[_builtins.str] = None,
                 response_headers: Optional[Sequence['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseResponseHeader']] = None):
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> _builtins.int:
        return pulumi.get(self, "response_code")

    @_builtins.property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_response_body_key")

    @_builtins.property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[Sequence['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseResponseHeader']]:
        return pulumi.get(self, "response_headers")


@pulumi.output_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseResponseHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptcha(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptcha. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptcha.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptcha.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Optional[Sequence['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader']] = None):
        if insert_headers is not None:
            pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Optional[Sequence['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader']]:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallenge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallenge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallenge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallenge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Optional[Sequence['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader']] = None):
        if insert_headers is not None:
            pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Optional[Sequence['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader']]:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Optional[Sequence['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader']] = None):
        if insert_headers is not None:
            pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Optional[Sequence['outputs.WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader']]:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleGroupAssociationRuleGroupReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleActionOverrides":
            suggest = "rule_action_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationRuleGroupReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationRuleGroupReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationRuleGroupReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 rule_action_overrides: Optional[Sequence['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverride']] = None):
        """
        :param _builtins.str arn: ARN of the Rule Group to associate with the Web ACL.
        :param Sequence['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideArgs'] rule_action_overrides: Action settings to use in place of rule actions configured inside the rule group. You can specify up to 100 overrides.
        """
        pulumi.set(__self__, "arn", arn)
        if rule_action_overrides is not None:
            pulumi.set(__self__, "rule_action_overrides", rule_action_overrides)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the Rule Group to associate with the Web ACL.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="ruleActionOverrides")
    def rule_action_overrides(self) -> Optional[Sequence['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverride']]:
        """
        Action settings to use in place of rule actions configured inside the rule group. You can specify up to 100 overrides.
        """
        return pulumi.get(self, "rule_action_overrides")


@pulumi.output_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionToUse":
            suggest = "action_to_use"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 action_to_use: Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUse'] = None):
        """
        :param _builtins.str name: Name of the rule to override.
        :param 'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseArgs' action_to_use: Action to use in place of the rule action.
        """
        pulumi.set(__self__, "name", name)
        if action_to_use is not None:
            pulumi.set(__self__, "action_to_use", action_to_use)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the rule to override.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="actionToUse")
    def action_to_use(self) -> Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUse']:
        """
        Action to use in place of the rule action.
        """
        return pulumi.get(self, "action_to_use")


@pulumi.output_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUse(dict):
    def __init__(__self__, *,
                 allow: Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllow'] = None,
                 block: Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlock'] = None,
                 captcha: Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptcha'] = None,
                 challenge: Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallenge'] = None,
                 count: Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCount'] = None):
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllow']:
        return pulumi.get(self, "allow")

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlock']:
        return pulumi.get(self, "block")

    @_builtins.property
    @pulumi.getter
    def captcha(self) -> Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptcha']:
        return pulumi.get(self, "captcha")

    @_builtins.property
    @pulumi.getter
    def challenge(self) -> Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallenge']:
        return pulumi.get(self, "challenge")

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCount']:
        return pulumi.get(self, "count")


@pulumi.output_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Optional[Sequence['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader']] = None):
        if insert_headers is not None:
            pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Optional[Sequence['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader']]:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlock(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customResponse":
            suggest = "custom_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlock. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlock.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlock.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_response: Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponse'] = None):
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @_builtins.property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponse']:
        return pulumi.get(self, "custom_response")


@pulumi.output_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseCode":
            suggest = "response_code"
        elif key == "customResponseBodyKey":
            suggest = "custom_response_body_key"
        elif key == "responseHeaders":
            suggest = "response_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_code: _builtins.int,
                 custom_response_body_key: Optional[_builtins.str] = None,
                 response_headers: Optional[Sequence['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseResponseHeader']] = None):
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> _builtins.int:
        return pulumi.get(self, "response_code")

    @_builtins.property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_response_body_key")

    @_builtins.property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[Sequence['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseResponseHeader']]:
        return pulumi.get(self, "response_headers")


@pulumi.output_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseResponseHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptcha(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptcha. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptcha.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptcha.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Optional[Sequence['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader']] = None):
        if insert_headers is not None:
            pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Optional[Sequence['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader']]:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallenge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallenge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallenge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallenge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Optional[Sequence['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader']] = None):
        if insert_headers is not None:
            pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Optional[Sequence['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader']]:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Optional[Sequence['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader']] = None):
        if insert_headers is not None:
            pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Optional[Sequence['outputs.WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader']]:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleGroupAssociationTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class WebAclRuleOverrideAction(dict):
    def __init__(__self__, *,
                 count: Optional['outputs.WebAclRuleOverrideActionCount'] = None,
                 none: Optional['outputs.WebAclRuleOverrideActionNone'] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if none is not None:
            pulumi.set(__self__, "none", none)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional['outputs.WebAclRuleOverrideActionCount']:
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional['outputs.WebAclRuleOverrideActionNone']:
        return pulumi.get(self, "none")


@pulumi.output_type
class WebAclRuleOverrideActionCount(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleOverrideActionNone(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleRuleLabel(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andStatement":
            suggest = "and_statement"
        elif key == "asnMatchStatement":
            suggest = "asn_match_statement"
        elif key == "byteMatchStatement":
            suggest = "byte_match_statement"
        elif key == "geoMatchStatement":
            suggest = "geo_match_statement"
        elif key == "ipSetReferenceStatement":
            suggest = "ip_set_reference_statement"
        elif key == "labelMatchStatement":
            suggest = "label_match_statement"
        elif key == "managedRuleGroupStatement":
            suggest = "managed_rule_group_statement"
        elif key == "notStatement":
            suggest = "not_statement"
        elif key == "orStatement":
            suggest = "or_statement"
        elif key == "rateBasedStatement":
            suggest = "rate_based_statement"
        elif key == "regexMatchStatement":
            suggest = "regex_match_statement"
        elif key == "regexPatternSetReferenceStatement":
            suggest = "regex_pattern_set_reference_statement"
        elif key == "ruleGroupReferenceStatement":
            suggest = "rule_group_reference_statement"
        elif key == "sizeConstraintStatement":
            suggest = "size_constraint_statement"
        elif key == "sqliMatchStatement":
            suggest = "sqli_match_statement"
        elif key == "xssMatchStatement":
            suggest = "xss_match_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_statement: Optional['outputs.WebAclRuleStatementAndStatement'] = None,
                 asn_match_statement: Optional['outputs.WebAclRuleStatementAsnMatchStatement'] = None,
                 byte_match_statement: Optional['outputs.WebAclRuleStatementByteMatchStatement'] = None,
                 geo_match_statement: Optional['outputs.WebAclRuleStatementGeoMatchStatement'] = None,
                 ip_set_reference_statement: Optional['outputs.WebAclRuleStatementIpSetReferenceStatement'] = None,
                 label_match_statement: Optional['outputs.WebAclRuleStatementLabelMatchStatement'] = None,
                 managed_rule_group_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatement'] = None,
                 not_statement: Optional['outputs.WebAclRuleStatementNotStatement'] = None,
                 or_statement: Optional['outputs.WebAclRuleStatementOrStatement'] = None,
                 rate_based_statement: Optional['outputs.WebAclRuleStatementRateBasedStatement'] = None,
                 regex_match_statement: Optional['outputs.WebAclRuleStatementRegexMatchStatement'] = None,
                 regex_pattern_set_reference_statement: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatement'] = None,
                 rule_group_reference_statement: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatement'] = None,
                 size_constraint_statement: Optional['outputs.WebAclRuleStatementSizeConstraintStatement'] = None,
                 sqli_match_statement: Optional['outputs.WebAclRuleStatementSqliMatchStatement'] = None,
                 xss_match_statement: Optional['outputs.WebAclRuleStatementXssMatchStatement'] = None):
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if asn_match_statement is not None:
            pulumi.set(__self__, "asn_match_statement", asn_match_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            pulumi.set(__self__, "ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if managed_rule_group_statement is not None:
            pulumi.set(__self__, "managed_rule_group_statement", managed_rule_group_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if rate_based_statement is not None:
            pulumi.set(__self__, "rate_based_statement", rate_based_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if rule_group_reference_statement is not None:
            pulumi.set(__self__, "rule_group_reference_statement", rule_group_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @_builtins.property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional['outputs.WebAclRuleStatementAndStatement']:
        return pulumi.get(self, "and_statement")

    @_builtins.property
    @pulumi.getter(name="asnMatchStatement")
    def asn_match_statement(self) -> Optional['outputs.WebAclRuleStatementAsnMatchStatement']:
        return pulumi.get(self, "asn_match_statement")

    @_builtins.property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatement']:
        return pulumi.get(self, "byte_match_statement")

    @_builtins.property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional['outputs.WebAclRuleStatementGeoMatchStatement']:
        return pulumi.get(self, "geo_match_statement")

    @_builtins.property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional['outputs.WebAclRuleStatementIpSetReferenceStatement']:
        return pulumi.get(self, "ip_set_reference_statement")

    @_builtins.property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional['outputs.WebAclRuleStatementLabelMatchStatement']:
        return pulumi.get(self, "label_match_statement")

    @_builtins.property
    @pulumi.getter(name="managedRuleGroupStatement")
    def managed_rule_group_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatement']:
        return pulumi.get(self, "managed_rule_group_statement")

    @_builtins.property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional['outputs.WebAclRuleStatementNotStatement']:
        return pulumi.get(self, "not_statement")

    @_builtins.property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional['outputs.WebAclRuleStatementOrStatement']:
        return pulumi.get(self, "or_statement")

    @_builtins.property
    @pulumi.getter(name="rateBasedStatement")
    def rate_based_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatement']:
        return pulumi.get(self, "rate_based_statement")

    @_builtins.property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatement']:
        return pulumi.get(self, "regex_match_statement")

    @_builtins.property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatement']:
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @_builtins.property
    @pulumi.getter(name="ruleGroupReferenceStatement")
    def rule_group_reference_statement(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatement']:
        return pulumi.get(self, "rule_group_reference_statement")

    @_builtins.property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatement']:
        return pulumi.get(self, "size_constraint_statement")

    @_builtins.property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatement']:
        return pulumi.get(self, "sqli_match_statement")

    @_builtins.property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatement']:
        return pulumi.get(self, "xss_match_statement")


@pulumi.output_type
class WebAclRuleStatementAndStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebAclRuleStatement']):
        """
        :param Sequence['WebAclRuleStatementArgs'] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebAclRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebAclRuleStatementAsnMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "asnLists":
            suggest = "asn_lists"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementAsnMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementAsnMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementAsnMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn_lists: Sequence[_builtins.int],
                 forwarded_ip_config: Optional['outputs.WebAclRuleStatementAsnMatchStatementForwardedIpConfig'] = None):
        pulumi.set(__self__, "asn_lists", asn_lists)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @_builtins.property
    @pulumi.getter(name="asnLists")
    def asn_lists(self) -> Sequence[_builtins.int]:
        return pulumi.get(self, "asn_lists")

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.WebAclRuleStatementAsnMatchStatementForwardedIpConfig']:
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class WebAclRuleStatementAsnMatchStatementForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementAsnMatchStatementForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementAsnMatchStatementForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementAsnMatchStatementForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str,
                 header_name: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        return pulumi.get(self, "header_name")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "positionalConstraint":
            suggest = "positional_constraint"
        elif key == "searchString":
            suggest = "search_string"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 positional_constraint: _builtins.str,
                 search_string: _builtins.str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementByteMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatch'] = None):
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "search_string", search_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> _builtins.str:
        return pulumi.get(self, "positional_constraint")

    @_builtins.property
    @pulumi.getter(name="searchString")
    def search_string(self) -> _builtins.str:
        return pulumi.get(self, "search_string")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementByteMatchStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementByteMatchStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementByteMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementByteMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementGeoMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCodes":
            suggest = "country_codes"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementGeoMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementGeoMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementGeoMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_codes: Sequence[_builtins.str],
                 forwarded_ip_config: Optional['outputs.WebAclRuleStatementGeoMatchStatementForwardedIpConfig'] = None):
        pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @_builtins.property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "country_codes")

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.WebAclRuleStatementGeoMatchStatementForwardedIpConfig']:
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class WebAclRuleStatementGeoMatchStatementForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementGeoMatchStatementForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementGeoMatchStatementForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementGeoMatchStatementForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str,
                 header_name: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        return pulumi.get(self, "header_name")


@pulumi.output_type
class WebAclRuleStatementIpSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipSetForwardedIpConfig":
            suggest = "ip_set_forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementIpSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementIpSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementIpSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 ip_set_forwarded_ip_config: Optional['outputs.WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig'] = None):
        pulumi.set(__self__, "arn", arn)
        if ip_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional['outputs.WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig']:
        return pulumi.get(self, "ip_set_forwarded_ip_config")


@pulumi.output_type
class WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str,
                 header_name: _builtins.str,
                 position: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter
    def position(self) -> _builtins.str:
        return pulumi.get(self, "position")


@pulumi.output_type
class WebAclRuleStatementLabelMatchStatement(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 scope: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        return pulumi.get(self, "scope")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vendorName":
            suggest = "vendor_name"
        elif key == "managedRuleGroupConfigs":
            suggest = "managed_rule_group_configs"
        elif key == "ruleActionOverrides":
            suggest = "rule_action_overrides"
        elif key == "scopeDownStatement":
            suggest = "scope_down_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 vendor_name: _builtins.str,
                 managed_rule_group_configs: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfig']] = None,
                 rule_action_overrides: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverride']] = None,
                 scope_down_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatement'] = None,
                 version: Optional[_builtins.str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vendor_name", vendor_name)
        if managed_rule_group_configs is not None:
            pulumi.set(__self__, "managed_rule_group_configs", managed_rule_group_configs)
        if rule_action_overrides is not None:
            pulumi.set(__self__, "rule_action_overrides", rule_action_overrides)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="vendorName")
    def vendor_name(self) -> _builtins.str:
        return pulumi.get(self, "vendor_name")

    @_builtins.property
    @pulumi.getter(name="managedRuleGroupConfigs")
    def managed_rule_group_configs(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfig']]:
        return pulumi.get(self, "managed_rule_group_configs")

    @_builtins.property
    @pulumi.getter(name="ruleActionOverrides")
    def rule_action_overrides(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverride']]:
        return pulumi.get(self, "rule_action_overrides")

    @_builtins.property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatement']:
        return pulumi.get(self, "scope_down_statement")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsManagedRulesAcfpRuleSet":
            suggest = "aws_managed_rules_acfp_rule_set"
        elif key == "awsManagedRulesAntiDdosRuleSet":
            suggest = "aws_managed_rules_anti_ddos_rule_set"
        elif key == "awsManagedRulesAtpRuleSet":
            suggest = "aws_managed_rules_atp_rule_set"
        elif key == "awsManagedRulesBotControlRuleSet":
            suggest = "aws_managed_rules_bot_control_rule_set"
        elif key == "loginPath":
            suggest = "login_path"
        elif key == "passwordField":
            suggest = "password_field"
        elif key == "payloadType":
            suggest = "payload_type"
        elif key == "usernameField":
            suggest = "username_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_managed_rules_acfp_rule_set: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSet'] = None,
                 aws_managed_rules_anti_ddos_rule_set: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSet'] = None,
                 aws_managed_rules_atp_rule_set: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSet'] = None,
                 aws_managed_rules_bot_control_rule_set: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSet'] = None,
                 login_path: Optional[_builtins.str] = None,
                 password_field: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordField'] = None,
                 payload_type: Optional[_builtins.str] = None,
                 username_field: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameField'] = None):
        if aws_managed_rules_acfp_rule_set is not None:
            pulumi.set(__self__, "aws_managed_rules_acfp_rule_set", aws_managed_rules_acfp_rule_set)
        if aws_managed_rules_anti_ddos_rule_set is not None:
            pulumi.set(__self__, "aws_managed_rules_anti_ddos_rule_set", aws_managed_rules_anti_ddos_rule_set)
        if aws_managed_rules_atp_rule_set is not None:
            pulumi.set(__self__, "aws_managed_rules_atp_rule_set", aws_managed_rules_atp_rule_set)
        if aws_managed_rules_bot_control_rule_set is not None:
            pulumi.set(__self__, "aws_managed_rules_bot_control_rule_set", aws_managed_rules_bot_control_rule_set)
        if login_path is not None:
            pulumi.set(__self__, "login_path", login_path)
        if password_field is not None:
            pulumi.set(__self__, "password_field", password_field)
        if payload_type is not None:
            pulumi.set(__self__, "payload_type", payload_type)
        if username_field is not None:
            pulumi.set(__self__, "username_field", username_field)

    @_builtins.property
    @pulumi.getter(name="awsManagedRulesAcfpRuleSet")
    def aws_managed_rules_acfp_rule_set(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSet']:
        return pulumi.get(self, "aws_managed_rules_acfp_rule_set")

    @_builtins.property
    @pulumi.getter(name="awsManagedRulesAntiDdosRuleSet")
    def aws_managed_rules_anti_ddos_rule_set(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSet']:
        return pulumi.get(self, "aws_managed_rules_anti_ddos_rule_set")

    @_builtins.property
    @pulumi.getter(name="awsManagedRulesAtpRuleSet")
    def aws_managed_rules_atp_rule_set(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSet']:
        return pulumi.get(self, "aws_managed_rules_atp_rule_set")

    @_builtins.property
    @pulumi.getter(name="awsManagedRulesBotControlRuleSet")
    def aws_managed_rules_bot_control_rule_set(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSet']:
        return pulumi.get(self, "aws_managed_rules_bot_control_rule_set")

    @_builtins.property
    @pulumi.getter(name="loginPath")
    def login_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "login_path")

    @_builtins.property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordField']:
        return pulumi.get(self, "password_field")

    @_builtins.property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "payload_type")

    @_builtins.property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameField']:
        return pulumi.get(self, "username_field")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "creationPath":
            suggest = "creation_path"
        elif key == "registrationPagePath":
            suggest = "registration_page_path"
        elif key == "requestInspection":
            suggest = "request_inspection"
        elif key == "enableRegexInPath":
            suggest = "enable_regex_in_path"
        elif key == "responseInspection":
            suggest = "response_inspection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 creation_path: _builtins.str,
                 registration_page_path: _builtins.str,
                 request_inspection: 'outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspection',
                 enable_regex_in_path: Optional[_builtins.bool] = None,
                 response_inspection: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspection'] = None):
        pulumi.set(__self__, "creation_path", creation_path)
        pulumi.set(__self__, "registration_page_path", registration_page_path)
        pulumi.set(__self__, "request_inspection", request_inspection)
        if enable_regex_in_path is not None:
            pulumi.set(__self__, "enable_regex_in_path", enable_regex_in_path)
        if response_inspection is not None:
            pulumi.set(__self__, "response_inspection", response_inspection)

    @_builtins.property
    @pulumi.getter(name="creationPath")
    def creation_path(self) -> _builtins.str:
        return pulumi.get(self, "creation_path")

    @_builtins.property
    @pulumi.getter(name="registrationPagePath")
    def registration_page_path(self) -> _builtins.str:
        return pulumi.get(self, "registration_page_path")

    @_builtins.property
    @pulumi.getter(name="requestInspection")
    def request_inspection(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspection':
        return pulumi.get(self, "request_inspection")

    @_builtins.property
    @pulumi.getter(name="enableRegexInPath")
    def enable_regex_in_path(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_regex_in_path")

    @_builtins.property
    @pulumi.getter(name="responseInspection")
    def response_inspection(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspection']:
        return pulumi.get(self, "response_inspection")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "payloadType":
            suggest = "payload_type"
        elif key == "addressFields":
            suggest = "address_fields"
        elif key == "emailField":
            suggest = "email_field"
        elif key == "passwordField":
            suggest = "password_field"
        elif key == "phoneNumberFields":
            suggest = "phone_number_fields"
        elif key == "usernameField":
            suggest = "username_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 payload_type: _builtins.str,
                 address_fields: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFields'] = None,
                 email_field: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailField'] = None,
                 password_field: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordField'] = None,
                 phone_number_fields: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFields'] = None,
                 username_field: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameField'] = None):
        pulumi.set(__self__, "payload_type", payload_type)
        if address_fields is not None:
            pulumi.set(__self__, "address_fields", address_fields)
        if email_field is not None:
            pulumi.set(__self__, "email_field", email_field)
        if password_field is not None:
            pulumi.set(__self__, "password_field", password_field)
        if phone_number_fields is not None:
            pulumi.set(__self__, "phone_number_fields", phone_number_fields)
        if username_field is not None:
            pulumi.set(__self__, "username_field", username_field)

    @_builtins.property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> _builtins.str:
        return pulumi.get(self, "payload_type")

    @_builtins.property
    @pulumi.getter(name="addressFields")
    def address_fields(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFields']:
        return pulumi.get(self, "address_fields")

    @_builtins.property
    @pulumi.getter(name="emailField")
    def email_field(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailField']:
        return pulumi.get(self, "email_field")

    @_builtins.property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordField']:
        return pulumi.get(self, "password_field")

    @_builtins.property
    @pulumi.getter(name="phoneNumberFields")
    def phone_number_fields(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFields']:
        return pulumi.get(self, "phone_number_fields")

    @_builtins.property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameField']:
        return pulumi.get(self, "username_field")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFields(dict):
    def __init__(__self__, *,
                 identifiers: Sequence[_builtins.str]):
        pulumi.set(__self__, "identifiers", identifiers)

    @_builtins.property
    @pulumi.getter
    def identifiers(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "identifiers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailField(dict):
    def __init__(__self__, *,
                 identifier: _builtins.str):
        pulumi.set(__self__, "identifier", identifier)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> _builtins.str:
        return pulumi.get(self, "identifier")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordField(dict):
    def __init__(__self__, *,
                 identifier: _builtins.str):
        pulumi.set(__self__, "identifier", identifier)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> _builtins.str:
        return pulumi.get(self, "identifier")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFields(dict):
    def __init__(__self__, *,
                 identifiers: Sequence[_builtins.str]):
        pulumi.set(__self__, "identifiers", identifiers)

    @_builtins.property
    @pulumi.getter
    def identifiers(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "identifiers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameField(dict):
    def __init__(__self__, *,
                 identifier: _builtins.str):
        pulumi.set(__self__, "identifier", identifier)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> _builtins.str:
        return pulumi.get(self, "identifier")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bodyContains":
            suggest = "body_contains"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body_contains: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContains'] = None,
                 header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeader'] = None,
                 json: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJson'] = None,
                 status_code: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCode'] = None):
        if body_contains is not None:
            pulumi.set(__self__, "body_contains", body_contains)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @_builtins.property
    @pulumi.getter(name="bodyContains")
    def body_contains(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContains']:
        return pulumi.get(self, "body_contains")

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeader']:
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJson']:
        return pulumi.get(self, "json")

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCode']:
        return pulumi.get(self, "status_code")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContains(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureStrings":
            suggest = "failure_strings"
        elif key == "successStrings":
            suggest = "success_strings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContains. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContains.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContains.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_strings: Sequence[_builtins.str],
                 success_strings: Sequence[_builtins.str]):
        pulumi.set(__self__, "failure_strings", failure_strings)
        pulumi.set(__self__, "success_strings", success_strings)

    @_builtins.property
    @pulumi.getter(name="failureStrings")
    def failure_strings(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "failure_strings")

    @_builtins.property
    @pulumi.getter(name="successStrings")
    def success_strings(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "success_strings")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureValues":
            suggest = "failure_values"
        elif key == "successValues":
            suggest = "success_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_values: Sequence[_builtins.str],
                 name: _builtins.str,
                 success_values: Sequence[_builtins.str]):
        pulumi.set(__self__, "failure_values", failure_values)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "success_values", success_values)

    @_builtins.property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "failure_values")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="successValues")
    def success_values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "success_values")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJson(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureValues":
            suggest = "failure_values"
        elif key == "successValues":
            suggest = "success_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJson. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJson.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJson.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_values: Sequence[_builtins.str],
                 identifier: _builtins.str,
                 success_values: Sequence[_builtins.str]):
        pulumi.set(__self__, "failure_values", failure_values)
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "success_values", success_values)

    @_builtins.property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "failure_values")

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> _builtins.str:
        return pulumi.get(self, "identifier")

    @_builtins.property
    @pulumi.getter(name="successValues")
    def success_values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "success_values")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureCodes":
            suggest = "failure_codes"
        elif key == "successCodes":
            suggest = "success_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_codes: Sequence[_builtins.int],
                 success_codes: Sequence[_builtins.int]):
        pulumi.set(__self__, "failure_codes", failure_codes)
        pulumi.set(__self__, "success_codes", success_codes)

    @_builtins.property
    @pulumi.getter(name="failureCodes")
    def failure_codes(self) -> Sequence[_builtins.int]:
        return pulumi.get(self, "failure_codes")

    @_builtins.property
    @pulumi.getter(name="successCodes")
    def success_codes(self) -> Sequence[_builtins.int]:
        return pulumi.get(self, "success_codes")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientSideActionConfig":
            suggest = "client_side_action_config"
        elif key == "sensitivityToBlock":
            suggest = "sensitivity_to_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_side_action_config: 'outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfig',
                 sensitivity_to_block: Optional[_builtins.str] = None):
        pulumi.set(__self__, "client_side_action_config", client_side_action_config)
        if sensitivity_to_block is not None:
            pulumi.set(__self__, "sensitivity_to_block", sensitivity_to_block)

    @_builtins.property
    @pulumi.getter(name="clientSideActionConfig")
    def client_side_action_config(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfig':
        return pulumi.get(self, "client_side_action_config")

    @_builtins.property
    @pulumi.getter(name="sensitivityToBlock")
    def sensitivity_to_block(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sensitivity_to_block")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfig(dict):
    def __init__(__self__, *,
                 challenge: 'outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallenge'):
        pulumi.set(__self__, "challenge", challenge)

    @_builtins.property
    @pulumi.getter
    def challenge(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallenge':
        return pulumi.get(self, "challenge")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallenge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "usageOfAction":
            suggest = "usage_of_action"
        elif key == "exemptUriRegularExpressions":
            suggest = "exempt_uri_regular_expressions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallenge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallenge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallenge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 usage_of_action: _builtins.str,
                 exempt_uri_regular_expressions: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeExemptUriRegularExpression']] = None,
                 sensitivity: Optional[_builtins.str] = None):
        pulumi.set(__self__, "usage_of_action", usage_of_action)
        if exempt_uri_regular_expressions is not None:
            pulumi.set(__self__, "exempt_uri_regular_expressions", exempt_uri_regular_expressions)
        if sensitivity is not None:
            pulumi.set(__self__, "sensitivity", sensitivity)

    @_builtins.property
    @pulumi.getter(name="usageOfAction")
    def usage_of_action(self) -> _builtins.str:
        return pulumi.get(self, "usage_of_action")

    @_builtins.property
    @pulumi.getter(name="exemptUriRegularExpressions")
    def exempt_uri_regular_expressions(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeExemptUriRegularExpression']]:
        return pulumi.get(self, "exempt_uri_regular_expressions")

    @_builtins.property
    @pulumi.getter
    def sensitivity(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sensitivity")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeExemptUriRegularExpression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regexString":
            suggest = "regex_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeExemptUriRegularExpression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeExemptUriRegularExpression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeExemptUriRegularExpression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regex_string: Optional[_builtins.str] = None):
        if regex_string is not None:
            pulumi.set(__self__, "regex_string", regex_string)

    @_builtins.property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "regex_string")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loginPath":
            suggest = "login_path"
        elif key == "enableRegexInPath":
            suggest = "enable_regex_in_path"
        elif key == "requestInspection":
            suggest = "request_inspection"
        elif key == "responseInspection":
            suggest = "response_inspection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login_path: _builtins.str,
                 enable_regex_in_path: Optional[_builtins.bool] = None,
                 request_inspection: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspection'] = None,
                 response_inspection: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspection'] = None):
        pulumi.set(__self__, "login_path", login_path)
        if enable_regex_in_path is not None:
            pulumi.set(__self__, "enable_regex_in_path", enable_regex_in_path)
        if request_inspection is not None:
            pulumi.set(__self__, "request_inspection", request_inspection)
        if response_inspection is not None:
            pulumi.set(__self__, "response_inspection", response_inspection)

    @_builtins.property
    @pulumi.getter(name="loginPath")
    def login_path(self) -> _builtins.str:
        return pulumi.get(self, "login_path")

    @_builtins.property
    @pulumi.getter(name="enableRegexInPath")
    def enable_regex_in_path(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_regex_in_path")

    @_builtins.property
    @pulumi.getter(name="requestInspection")
    def request_inspection(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspection']:
        return pulumi.get(self, "request_inspection")

    @_builtins.property
    @pulumi.getter(name="responseInspection")
    def response_inspection(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspection']:
        return pulumi.get(self, "response_inspection")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordField":
            suggest = "password_field"
        elif key == "payloadType":
            suggest = "payload_type"
        elif key == "usernameField":
            suggest = "username_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_field: 'outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordField',
                 payload_type: _builtins.str,
                 username_field: 'outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameField'):
        pulumi.set(__self__, "password_field", password_field)
        pulumi.set(__self__, "payload_type", payload_type)
        pulumi.set(__self__, "username_field", username_field)

    @_builtins.property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordField':
        return pulumi.get(self, "password_field")

    @_builtins.property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> _builtins.str:
        return pulumi.get(self, "payload_type")

    @_builtins.property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameField':
        return pulumi.get(self, "username_field")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordField(dict):
    def __init__(__self__, *,
                 identifier: _builtins.str):
        pulumi.set(__self__, "identifier", identifier)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> _builtins.str:
        return pulumi.get(self, "identifier")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameField(dict):
    def __init__(__self__, *,
                 identifier: _builtins.str):
        pulumi.set(__self__, "identifier", identifier)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> _builtins.str:
        return pulumi.get(self, "identifier")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bodyContains":
            suggest = "body_contains"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body_contains: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContains'] = None,
                 header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeader'] = None,
                 json: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJson'] = None,
                 status_code: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCode'] = None):
        if body_contains is not None:
            pulumi.set(__self__, "body_contains", body_contains)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @_builtins.property
    @pulumi.getter(name="bodyContains")
    def body_contains(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContains']:
        return pulumi.get(self, "body_contains")

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeader']:
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJson']:
        return pulumi.get(self, "json")

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCode']:
        return pulumi.get(self, "status_code")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContains(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureStrings":
            suggest = "failure_strings"
        elif key == "successStrings":
            suggest = "success_strings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContains. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContains.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContains.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_strings: Sequence[_builtins.str],
                 success_strings: Sequence[_builtins.str]):
        pulumi.set(__self__, "failure_strings", failure_strings)
        pulumi.set(__self__, "success_strings", success_strings)

    @_builtins.property
    @pulumi.getter(name="failureStrings")
    def failure_strings(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "failure_strings")

    @_builtins.property
    @pulumi.getter(name="successStrings")
    def success_strings(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "success_strings")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureValues":
            suggest = "failure_values"
        elif key == "successValues":
            suggest = "success_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_values: Sequence[_builtins.str],
                 name: _builtins.str,
                 success_values: Sequence[_builtins.str]):
        pulumi.set(__self__, "failure_values", failure_values)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "success_values", success_values)

    @_builtins.property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "failure_values")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="successValues")
    def success_values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "success_values")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJson(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureValues":
            suggest = "failure_values"
        elif key == "successValues":
            suggest = "success_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJson. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJson.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJson.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_values: Sequence[_builtins.str],
                 identifier: _builtins.str,
                 success_values: Sequence[_builtins.str]):
        pulumi.set(__self__, "failure_values", failure_values)
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "success_values", success_values)

    @_builtins.property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "failure_values")

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> _builtins.str:
        return pulumi.get(self, "identifier")

    @_builtins.property
    @pulumi.getter(name="successValues")
    def success_values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "success_values")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureCodes":
            suggest = "failure_codes"
        elif key == "successCodes":
            suggest = "success_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_codes: Sequence[_builtins.int],
                 success_codes: Sequence[_builtins.int]):
        pulumi.set(__self__, "failure_codes", failure_codes)
        pulumi.set(__self__, "success_codes", success_codes)

    @_builtins.property
    @pulumi.getter(name="failureCodes")
    def failure_codes(self) -> Sequence[_builtins.int]:
        return pulumi.get(self, "failure_codes")

    @_builtins.property
    @pulumi.getter(name="successCodes")
    def success_codes(self) -> Sequence[_builtins.int]:
        return pulumi.get(self, "success_codes")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inspectionLevel":
            suggest = "inspection_level"
        elif key == "enableMachineLearning":
            suggest = "enable_machine_learning"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inspection_level: _builtins.str,
                 enable_machine_learning: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "inspection_level", inspection_level)
        if enable_machine_learning is not None:
            pulumi.set(__self__, "enable_machine_learning", enable_machine_learning)

    @_builtins.property
    @pulumi.getter(name="inspectionLevel")
    def inspection_level(self) -> _builtins.str:
        return pulumi.get(self, "inspection_level")

    @_builtins.property
    @pulumi.getter(name="enableMachineLearning")
    def enable_machine_learning(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_machine_learning")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordField(dict):
    def __init__(__self__, *,
                 identifier: _builtins.str):
        pulumi.set(__self__, "identifier", identifier)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> _builtins.str:
        return pulumi.get(self, "identifier")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameField(dict):
    def __init__(__self__, *,
                 identifier: _builtins.str):
        pulumi.set(__self__, "identifier", identifier)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> _builtins.str:
        return pulumi.get(self, "identifier")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionToUse":
            suggest = "action_to_use"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_to_use: 'outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUse',
                 name: _builtins.str):
        pulumi.set(__self__, "action_to_use", action_to_use)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="actionToUse")
    def action_to_use(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUse':
        return pulumi.get(self, "action_to_use")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUse(dict):
    def __init__(__self__, *,
                 allow: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllow'] = None,
                 block: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlock'] = None,
                 captcha: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptcha'] = None,
                 challenge: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallenge'] = None,
                 count: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCount'] = None):
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllow']:
        return pulumi.get(self, "allow")

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlock']:
        return pulumi.get(self, "block")

    @_builtins.property
    @pulumi.getter
    def captcha(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptcha']:
        return pulumi.get(self, "captcha")

    @_builtins.property
    @pulumi.getter
    def challenge(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallenge']:
        return pulumi.get(self, "challenge")

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCount']:
        return pulumi.get(self, "count")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader']):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader']:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlock(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customResponse":
            suggest = "custom_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlock. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlock.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlock.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_response: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponse'] = None):
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @_builtins.property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponse']:
        return pulumi.get(self, "custom_response")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseCode":
            suggest = "response_code"
        elif key == "customResponseBodyKey":
            suggest = "custom_response_body_key"
        elif key == "responseHeaders":
            suggest = "response_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_code: _builtins.int,
                 custom_response_body_key: Optional[_builtins.str] = None,
                 response_headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader']] = None):
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> _builtins.int:
        return pulumi.get(self, "response_code")

    @_builtins.property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_response_body_key")

    @_builtins.property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader']]:
        return pulumi.get(self, "response_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptcha(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptcha. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptcha.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptcha.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader']):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader']:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallenge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallenge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallenge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallenge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader']):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader']:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader']):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader']:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andStatement":
            suggest = "and_statement"
        elif key == "asnMatchStatement":
            suggest = "asn_match_statement"
        elif key == "byteMatchStatement":
            suggest = "byte_match_statement"
        elif key == "geoMatchStatement":
            suggest = "geo_match_statement"
        elif key == "ipSetReferenceStatement":
            suggest = "ip_set_reference_statement"
        elif key == "labelMatchStatement":
            suggest = "label_match_statement"
        elif key == "notStatement":
            suggest = "not_statement"
        elif key == "orStatement":
            suggest = "or_statement"
        elif key == "regexMatchStatement":
            suggest = "regex_match_statement"
        elif key == "regexPatternSetReferenceStatement":
            suggest = "regex_pattern_set_reference_statement"
        elif key == "sizeConstraintStatement":
            suggest = "size_constraint_statement"
        elif key == "sqliMatchStatement":
            suggest = "sqli_match_statement"
        elif key == "xssMatchStatement":
            suggest = "xss_match_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatement'] = None,
                 asn_match_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatement'] = None,
                 byte_match_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatement'] = None,
                 geo_match_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatement'] = None,
                 ip_set_reference_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatement'] = None,
                 label_match_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatement'] = None,
                 not_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatement'] = None,
                 or_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatement'] = None,
                 regex_match_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatement'] = None,
                 regex_pattern_set_reference_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatement'] = None,
                 size_constraint_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatement'] = None,
                 sqli_match_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatement'] = None,
                 xss_match_statement: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatement'] = None):
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if asn_match_statement is not None:
            pulumi.set(__self__, "asn_match_statement", asn_match_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            pulumi.set(__self__, "ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @_builtins.property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatement']:
        return pulumi.get(self, "and_statement")

    @_builtins.property
    @pulumi.getter(name="asnMatchStatement")
    def asn_match_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatement']:
        return pulumi.get(self, "asn_match_statement")

    @_builtins.property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatement']:
        return pulumi.get(self, "byte_match_statement")

    @_builtins.property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatement']:
        return pulumi.get(self, "geo_match_statement")

    @_builtins.property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatement']:
        return pulumi.get(self, "ip_set_reference_statement")

    @_builtins.property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatement']:
        return pulumi.get(self, "label_match_statement")

    @_builtins.property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatement']:
        return pulumi.get(self, "not_statement")

    @_builtins.property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatement']:
        return pulumi.get(self, "or_statement")

    @_builtins.property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatement']:
        return pulumi.get(self, "regex_match_statement")

    @_builtins.property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatement']:
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @_builtins.property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatement']:
        return pulumi.get(self, "size_constraint_statement")

    @_builtins.property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatement']:
        return pulumi.get(self, "sqli_match_statement")

    @_builtins.property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatement']:
        return pulumi.get(self, "xss_match_statement")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebAclRuleStatement']):
        """
        :param Sequence['WebAclRuleStatementArgs'] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebAclRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "asnLists":
            suggest = "asn_lists"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn_lists: Sequence[_builtins.int],
                 forwarded_ip_config: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementForwardedIpConfig'] = None):
        pulumi.set(__self__, "asn_lists", asn_lists)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @_builtins.property
    @pulumi.getter(name="asnLists")
    def asn_lists(self) -> Sequence[_builtins.int]:
        return pulumi.get(self, "asn_lists")

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementForwardedIpConfig']:
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str,
                 header_name: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        return pulumi.get(self, "header_name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "positionalConstraint":
            suggest = "positional_constraint"
        elif key == "searchString":
            suggest = "search_string"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 positional_constraint: _builtins.str,
                 search_string: _builtins.str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatch'] = None):
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "search_string", search_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> _builtins.str:
        return pulumi.get(self, "positional_constraint")

    @_builtins.property
    @pulumi.getter(name="searchString")
    def search_string(self) -> _builtins.str:
        return pulumi.get(self, "search_string")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCodes":
            suggest = "country_codes"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_codes: Sequence[_builtins.str],
                 forwarded_ip_config: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfig'] = None):
        pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @_builtins.property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "country_codes")

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfig']:
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str,
                 header_name: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        return pulumi.get(self, "header_name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipSetForwardedIpConfig":
            suggest = "ip_set_forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 ip_set_forwarded_ip_config: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig'] = None):
        pulumi.set(__self__, "arn", arn)
        if ip_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig']:
        return pulumi.get(self, "ip_set_forwarded_ip_config")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str,
                 header_name: _builtins.str,
                 position: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter
    def position(self) -> _builtins.str:
        return pulumi.get(self, "position")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatement(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 scope: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        return pulumi.get(self, "scope")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebAclRuleStatement']):
        """
        :param Sequence['WebAclRuleStatementArgs'] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebAclRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebAclRuleStatement']):
        """
        :param Sequence['WebAclRuleStatementArgs'] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebAclRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regexString":
            suggest = "regex_string"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regex_string: _builtins.str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatch'] = None):
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> _builtins.str:
        return pulumi.get(self, "regex_string")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch'] = None):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: _builtins.str,
                 size: _builtins.int,
                 text_transformations: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatch'] = None):
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> _builtins.str:
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "sensitivityLevel":
            suggest = "sensitivity_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatch'] = None,
                 sensitivity_level: Optional[_builtins.str] = None):
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")

    @_builtins.property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sensitivity_level")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatch'] = None):
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementNotStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebAclRuleStatement']):
        """
        :param Sequence['WebAclRuleStatementArgs'] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebAclRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebAclRuleStatementOrStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebAclRuleStatement']):
        """
        :param Sequence['WebAclRuleStatementArgs'] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebAclRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregateKeyType":
            suggest = "aggregate_key_type"
        elif key == "customKeys":
            suggest = "custom_keys"
        elif key == "evaluationWindowSec":
            suggest = "evaluation_window_sec"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"
        elif key == "scopeDownStatement":
            suggest = "scope_down_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit: _builtins.int,
                 aggregate_key_type: Optional[_builtins.str] = None,
                 custom_keys: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKey']] = None,
                 evaluation_window_sec: Optional[_builtins.int] = None,
                 forwarded_ip_config: Optional['outputs.WebAclRuleStatementRateBasedStatementForwardedIpConfig'] = None,
                 scope_down_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatement'] = None):
        pulumi.set(__self__, "limit", limit)
        if aggregate_key_type is not None:
            pulumi.set(__self__, "aggregate_key_type", aggregate_key_type)
        if custom_keys is not None:
            pulumi.set(__self__, "custom_keys", custom_keys)
        if evaluation_window_sec is not None:
            pulumi.set(__self__, "evaluation_window_sec", evaluation_window_sec)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> _builtins.int:
        return pulumi.get(self, "limit")

    @_builtins.property
    @pulumi.getter(name="aggregateKeyType")
    def aggregate_key_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aggregate_key_type")

    @_builtins.property
    @pulumi.getter(name="customKeys")
    def custom_keys(self) -> Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKey']]:
        return pulumi.get(self, "custom_keys")

    @_builtins.property
    @pulumi.getter(name="evaluationWindowSec")
    def evaluation_window_sec(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "evaluation_window_sec")

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementForwardedIpConfig']:
        return pulumi.get(self, "forwarded_ip_config")

    @_builtins.property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatement']:
        return pulumi.get(self, "scope_down_statement")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forwardedIp":
            suggest = "forwarded_ip"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "labelNamespace":
            suggest = "label_namespace"
        elif key == "queryArgument":
            suggest = "query_argument"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementCustomKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyAsn'] = None,
                 cookie: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyCookie'] = None,
                 forwarded_ip: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyForwardedIp'] = None,
                 header: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyHeader'] = None,
                 http_method: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyHttpMethod'] = None,
                 ip: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyIp'] = None,
                 ja3_fingerprint: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyJa4Fingerprint'] = None,
                 label_namespace: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespace'] = None,
                 query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyQueryArgument'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyQueryString'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyUriPath'] = None):
        if asn is not None:
            pulumi.set(__self__, "asn", asn)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if forwarded_ip is not None:
            pulumi.set(__self__, "forwarded_ip", forwarded_ip)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if label_namespace is not None:
            pulumi.set(__self__, "label_namespace", label_namespace)
        if query_argument is not None:
            pulumi.set(__self__, "query_argument", query_argument)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter
    def asn(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyAsn']:
        return pulumi.get(self, "asn")

    @_builtins.property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyCookie']:
        return pulumi.get(self, "cookie")

    @_builtins.property
    @pulumi.getter(name="forwardedIp")
    def forwarded_ip(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyForwardedIp']:
        return pulumi.get(self, "forwarded_ip")

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyHeader']:
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyHttpMethod']:
        return pulumi.get(self, "http_method")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyIp']:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="labelNamespace")
    def label_namespace(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespace']:
        return pulumi.get(self, "label_namespace")

    @_builtins.property
    @pulumi.getter(name="queryArgument")
    def query_argument(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyQueryArgument']:
        return pulumi.get(self, "query_argument")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementCustomKeyUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyAsn(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyCookie(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementCustomKeyCookie. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyCookie.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyCookie.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformation']):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyForwardedIp(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementCustomKeyHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation']):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyHttpMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyIp(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementCustomKeyJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementCustomKeyJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespace(dict):
    def __init__(__self__, *,
                 namespace: _builtins.str):
        pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        return pulumi.get(self, "namespace")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyQueryArgument(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementCustomKeyQueryArgument. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyQueryArgument.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyQueryArgument.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation']):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyQueryString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementCustomKeyQueryString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyQueryString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyQueryString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation']):
        pulumi.set(__self__, "text_transformations", text_transformations)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyUriPath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementCustomKeyUriPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyUriPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementCustomKeyUriPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation']):
        pulumi.set(__self__, "text_transformations", text_transformations)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation']:
        return pulumi.get(self, "text_transformations")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str,
                 header_name: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        return pulumi.get(self, "header_name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andStatement":
            suggest = "and_statement"
        elif key == "asnMatchStatement":
            suggest = "asn_match_statement"
        elif key == "byteMatchStatement":
            suggest = "byte_match_statement"
        elif key == "geoMatchStatement":
            suggest = "geo_match_statement"
        elif key == "ipSetReferenceStatement":
            suggest = "ip_set_reference_statement"
        elif key == "labelMatchStatement":
            suggest = "label_match_statement"
        elif key == "notStatement":
            suggest = "not_statement"
        elif key == "orStatement":
            suggest = "or_statement"
        elif key == "regexMatchStatement":
            suggest = "regex_match_statement"
        elif key == "regexPatternSetReferenceStatement":
            suggest = "regex_pattern_set_reference_statement"
        elif key == "sizeConstraintStatement":
            suggest = "size_constraint_statement"
        elif key == "sqliMatchStatement":
            suggest = "sqli_match_statement"
        elif key == "xssMatchStatement":
            suggest = "xss_match_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatement'] = None,
                 asn_match_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatement'] = None,
                 byte_match_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement'] = None,
                 geo_match_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement'] = None,
                 ip_set_reference_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement'] = None,
                 label_match_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement'] = None,
                 not_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatement'] = None,
                 or_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatement'] = None,
                 regex_match_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement'] = None,
                 regex_pattern_set_reference_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement'] = None,
                 size_constraint_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement'] = None,
                 sqli_match_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement'] = None,
                 xss_match_statement: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement'] = None):
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if asn_match_statement is not None:
            pulumi.set(__self__, "asn_match_statement", asn_match_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            pulumi.set(__self__, "ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @_builtins.property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatement']:
        return pulumi.get(self, "and_statement")

    @_builtins.property
    @pulumi.getter(name="asnMatchStatement")
    def asn_match_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatement']:
        return pulumi.get(self, "asn_match_statement")

    @_builtins.property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement']:
        return pulumi.get(self, "byte_match_statement")

    @_builtins.property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement']:
        return pulumi.get(self, "geo_match_statement")

    @_builtins.property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement']:
        return pulumi.get(self, "ip_set_reference_statement")

    @_builtins.property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement']:
        return pulumi.get(self, "label_match_statement")

    @_builtins.property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatement']:
        return pulumi.get(self, "not_statement")

    @_builtins.property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatement']:
        return pulumi.get(self, "or_statement")

    @_builtins.property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement']:
        return pulumi.get(self, "regex_match_statement")

    @_builtins.property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement']:
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @_builtins.property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement']:
        return pulumi.get(self, "size_constraint_statement")

    @_builtins.property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement']:
        return pulumi.get(self, "sqli_match_statement")

    @_builtins.property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement']:
        return pulumi.get(self, "xss_match_statement")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebAclRuleStatement']):
        """
        :param Sequence['WebAclRuleStatementArgs'] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebAclRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "asnLists":
            suggest = "asn_lists"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn_lists: Sequence[_builtins.int],
                 forwarded_ip_config: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfig'] = None):
        pulumi.set(__self__, "asn_lists", asn_lists)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @_builtins.property
    @pulumi.getter(name="asnLists")
    def asn_lists(self) -> Sequence[_builtins.int]:
        return pulumi.get(self, "asn_lists")

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfig']:
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str,
                 header_name: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        return pulumi.get(self, "header_name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "positionalConstraint":
            suggest = "positional_constraint"
        elif key == "searchString":
            suggest = "search_string"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 positional_constraint: _builtins.str,
                 search_string: _builtins.str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch'] = None):
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "search_string", search_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> _builtins.str:
        return pulumi.get(self, "positional_constraint")

    @_builtins.property
    @pulumi.getter(name="searchString")
    def search_string(self) -> _builtins.str:
        return pulumi.get(self, "search_string")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCodes":
            suggest = "country_codes"
        elif key == "forwardedIpConfig":
            suggest = "forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_codes: Sequence[_builtins.str],
                 forwarded_ip_config: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig'] = None):
        pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @_builtins.property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "country_codes")

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig']:
        return pulumi.get(self, "forwarded_ip_config")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str,
                 header_name: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        return pulumi.get(self, "header_name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipSetForwardedIpConfig":
            suggest = "ip_set_forwarded_ip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 ip_set_forwarded_ip_config: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig'] = None):
        pulumi.set(__self__, "arn", arn)
        if ip_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig']:
        return pulumi.get(self, "ip_set_forwarded_ip_config")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str,
                 header_name: _builtins.str,
                 position: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        return pulumi.get(self, "header_name")

    @_builtins.property
    @pulumi.getter
    def position(self) -> _builtins.str:
        return pulumi.get(self, "position")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatement(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 scope: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        return pulumi.get(self, "scope")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebAclRuleStatement']):
        """
        :param Sequence['WebAclRuleStatementArgs'] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebAclRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatement(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.WebAclRuleStatement']):
        """
        :param Sequence['WebAclRuleStatementArgs'] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.WebAclRuleStatement']:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regexString":
            suggest = "regex_string"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regex_string: _builtins.str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch'] = None):
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> _builtins.str:
        return pulumi.get(self, "regex_string")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch'] = None):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: _builtins.str,
                 size: _builtins.int,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch'] = None):
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> _builtins.str:
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "sensitivityLevel":
            suggest = "sensitivity_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch'] = None,
                 sensitivity_level: Optional[_builtins.str] = None):
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")

    @_builtins.property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sensitivity_level")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch'] = None):
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regexString":
            suggest = "regex_string"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regex_string: _builtins.str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRegexMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatch'] = None):
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> _builtins.str:
        return pulumi.get(self, "regex_string")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRegexMatchStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexMatchStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRegexMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 text_transformations: Sequence['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatch'] = None):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleActionOverrides":
            suggest = "rule_action_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 rule_action_overrides: Optional[Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverride']] = None):
        pulumi.set(__self__, "arn", arn)
        if rule_action_overrides is not None:
            pulumi.set(__self__, "rule_action_overrides", rule_action_overrides)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="ruleActionOverrides")
    def rule_action_overrides(self) -> Optional[Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverride']]:
        return pulumi.get(self, "rule_action_overrides")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionToUse":
            suggest = "action_to_use"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_to_use: 'outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUse',
                 name: _builtins.str):
        pulumi.set(__self__, "action_to_use", action_to_use)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="actionToUse")
    def action_to_use(self) -> 'outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUse':
        return pulumi.get(self, "action_to_use")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUse(dict):
    def __init__(__self__, *,
                 allow: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllow'] = None,
                 block: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlock'] = None,
                 captcha: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptcha'] = None,
                 challenge: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallenge'] = None,
                 count: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCount'] = None):
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllow']:
        return pulumi.get(self, "allow")

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlock']:
        return pulumi.get(self, "block")

    @_builtins.property
    @pulumi.getter
    def captcha(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptcha']:
        return pulumi.get(self, "captcha")

    @_builtins.property
    @pulumi.getter
    def challenge(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallenge']:
        return pulumi.get(self, "challenge")

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCount']:
        return pulumi.get(self, "count")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader']):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader']:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlock(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customResponse":
            suggest = "custom_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlock. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlock.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlock.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_response: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponse'] = None):
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @_builtins.property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponse']:
        return pulumi.get(self, "custom_response")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseCode":
            suggest = "response_code"
        elif key == "customResponseBodyKey":
            suggest = "custom_response_body_key"
        elif key == "responseHeaders":
            suggest = "response_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_code: _builtins.int,
                 custom_response_body_key: Optional[_builtins.str] = None,
                 response_headers: Optional[Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader']] = None):
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> _builtins.int:
        return pulumi.get(self, "response_code")

    @_builtins.property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_response_body_key")

    @_builtins.property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader']]:
        return pulumi.get(self, "response_headers")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptcha(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptcha. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptcha.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptcha.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader']):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader']:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallenge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallenge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallenge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallenge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader']):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader']:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customRequestHandling":
            suggest = "custom_request_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_request_handling: Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandling'] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandling']:
        return pulumi.get(self, "custom_request_handling")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insertHeaders":
            suggest = "insert_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insert_headers: Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader']):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Sequence['outputs.WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader']:
        return pulumi.get(self, "insert_headers")


@pulumi.output_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: _builtins.str,
                 size: _builtins.int,
                 text_transformations: Sequence['outputs.WebAclRuleStatementSizeConstraintStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatch'] = None):
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> _builtins.str:
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementSizeConstraintStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSizeConstraintStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSizeConstraintStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementSizeConstraintStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"
        elif key == "sensitivityLevel":
            suggest = "sensitivity_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.WebAclRuleStatementSqliMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatch'] = None,
                 sensitivity_level: Optional[_builtins.str] = None):
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementSqliMatchStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")

    @_builtins.property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sensitivity_level")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementSqliMatchStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementSqliMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementSqliMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textTransformations":
            suggest = "text_transformations"
        elif key == "fieldToMatch":
            suggest = "field_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_transformations: Sequence['outputs.WebAclRuleStatementXssMatchStatementTextTransformation'],
                 field_to_match: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatch'] = None):
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> Sequence['outputs.WebAclRuleStatementXssMatchStatementTextTransformation']:
        return pulumi.get(self, "text_transformations")

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatch']:
        return pulumi.get(self, "field_to_match")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allQueryArguments":
            suggest = "all_query_arguments"
        elif key == "headerOrders":
            suggest = "header_orders"
        elif key == "ja3Fingerprint":
            suggest = "ja3_fingerprint"
        elif key == "ja4Fingerprint":
            suggest = "ja4_fingerprint"
        elif key == "jsonBody":
            suggest = "json_body"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "singleQueryArgument":
            suggest = "single_query_argument"
        elif key == "uriFragment":
            suggest = "uri_fragment"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatementFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_query_arguments: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArguments'] = None,
                 body: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchBody'] = None,
                 cookies: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchCookies'] = None,
                 header_orders: Optional[Sequence['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrder']] = None,
                 headers: Optional[Sequence['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchHeader']] = None,
                 ja3_fingerprint: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchJa3Fingerprint'] = None,
                 ja4_fingerprint: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchJa4Fingerprint'] = None,
                 json_body: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBody'] = None,
                 method: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchMethod'] = None,
                 query_string: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchQueryString'] = None,
                 single_header: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeader'] = None,
                 single_query_argument: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument'] = None,
                 uri_fragment: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchUriFragment'] = None,
                 uri_path: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchUriPath'] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArguments']:
        return pulumi.get(self, "all_query_arguments")

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchBody']:
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchCookies']:
        return pulumi.get(self, "cookies")

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[Sequence['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrder']]:
        return pulumi.get(self, "header_orders")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchJa3Fingerprint']:
        return pulumi.get(self, "ja3_fingerprint")

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchJa4Fingerprint']:
        return pulumi.get(self, "ja4_fingerprint")

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBody']:
        return pulumi.get(self, "json_body")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchMethod']:
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchQueryString']:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument']:
        return pulumi.get(self, "single_query_argument")

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchUriFragment']:
        return pulumi.get(self, "uri_fragment")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchUriPath']:
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArguments(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatementFieldToMatchBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: Optional[_builtins.str] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPatterns":
            suggest = "match_patterns"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatementFieldToMatchCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_patterns: Sequence['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern'],
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> Sequence['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern']:
        return pulumi.get(self, "match_patterns")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCookies":
            suggest = "excluded_cookies"
        elif key == "includedCookies":
            suggest = "included_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll'] = None,
                 excluded_cookies: Optional[Sequence[_builtins.str]] = None,
                 included_cookies: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_cookies")

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_cookies")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatementFieldToMatchHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern',
                 match_scope: _builtins.str,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedHeaders":
            suggest = "excluded_headers"
        elif key == "includedHeaders":
            suggest = "included_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll'] = None,
                 excluded_headers: Optional[Sequence[_builtins.str]] = None,
                 included_headers: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_headers")

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_headers")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oversize_handling: _builtins.str):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> _builtins.str:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJa3Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatementFieldToMatchJa3Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchJa3Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJa4Fingerprint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatementFieldToMatchJa4Fingerprint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchJa4Fingerprint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: _builtins.str):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> _builtins.str:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPattern":
            suggest = "match_pattern"
        elif key == "matchScope":
            suggest = "match_scope"
        elif key == "invalidFallbackBehavior":
            suggest = "invalid_fallback_behavior"
        elif key == "oversizeHandling":
            suggest = "oversize_handling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatementFieldToMatchJsonBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchJsonBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_pattern: 'outputs.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern',
                 match_scope: _builtins.str,
                 invalid_fallback_behavior: Optional[_builtins.str] = None,
                 oversize_handling: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> 'outputs.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern':
        return pulumi.get(self, "match_pattern")

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> _builtins.str:
        return pulumi.get(self, "match_scope")

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oversize_handling")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPaths":
            suggest = "included_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all: Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll'] = None,
                 included_paths: Optional[Sequence[_builtins.str]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional['outputs.WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll']:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "included_paths")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAll(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchMethod(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchQueryString(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgument(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchUriFragment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackBehavior":
            suggest = "fallback_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleStatementXssMatchStatementFieldToMatchUriFragment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleStatementXssMatchStatementFieldToMatchUriFragment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_behavior: Optional[_builtins.str] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementFieldToMatchUriPath(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WebAclRuleStatementXssMatchStatementTextTransformation(dict):
    def __init__(__self__, *,
                 priority: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class WebAclRuleVisibilityConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchMetricsEnabled":
            suggest = "cloudwatch_metrics_enabled"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "sampledRequestsEnabled":
            suggest = "sampled_requests_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclRuleVisibilityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclRuleVisibilityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclRuleVisibilityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_metrics_enabled: _builtins.bool,
                 metric_name: _builtins.str,
                 sampled_requests_enabled: _builtins.bool):
        pulumi.set(__self__, "cloudwatch_metrics_enabled", cloudwatch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @_builtins.property
    @pulumi.getter(name="cloudwatchMetricsEnabled")
    def cloudwatch_metrics_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "cloudwatch_metrics_enabled")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "sampled_requests_enabled")


@pulumi.output_type
class WebAclVisibilityConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchMetricsEnabled":
            suggest = "cloudwatch_metrics_enabled"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "sampledRequestsEnabled":
            suggest = "sampled_requests_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebAclVisibilityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebAclVisibilityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebAclVisibilityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_metrics_enabled: _builtins.bool,
                 metric_name: _builtins.str,
                 sampled_requests_enabled: _builtins.bool):
        pulumi.set(__self__, "cloudwatch_metrics_enabled", cloudwatch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @_builtins.property
    @pulumi.getter(name="cloudwatchMetricsEnabled")
    def cloudwatch_metrics_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "cloudwatch_metrics_enabled")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "sampled_requests_enabled")


@pulumi.output_type
class GetRegexPatternSetRegularExpressionResult(dict):
    def __init__(__self__, *,
                 regex_string: _builtins.str):
        pulumi.set(__self__, "regex_string", regex_string)

    @_builtins.property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> _builtins.str:
        return pulumi.get(self, "regex_string")


