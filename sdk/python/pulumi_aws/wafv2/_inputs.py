# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'RegexPatternSetRegularExpressionArgs',
    'RegexPatternSetRegularExpressionArgsDict',
    'RuleGroupCustomResponseBodyArgs',
    'RuleGroupCustomResponseBodyArgsDict',
    'RuleGroupRuleArgs',
    'RuleGroupRuleArgsDict',
    'RuleGroupRuleActionArgs',
    'RuleGroupRuleActionArgsDict',
    'RuleGroupRuleActionAllowArgs',
    'RuleGroupRuleActionAllowArgsDict',
    'RuleGroupRuleActionAllowCustomRequestHandlingArgs',
    'RuleGroupRuleActionAllowCustomRequestHandlingArgsDict',
    'RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgs',
    'RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgsDict',
    'RuleGroupRuleActionBlockArgs',
    'RuleGroupRuleActionBlockArgsDict',
    'RuleGroupRuleActionBlockCustomResponseArgs',
    'RuleGroupRuleActionBlockCustomResponseArgsDict',
    'RuleGroupRuleActionBlockCustomResponseResponseHeaderArgs',
    'RuleGroupRuleActionBlockCustomResponseResponseHeaderArgsDict',
    'RuleGroupRuleActionCaptchaArgs',
    'RuleGroupRuleActionCaptchaArgsDict',
    'RuleGroupRuleActionCaptchaCustomRequestHandlingArgs',
    'RuleGroupRuleActionCaptchaCustomRequestHandlingArgsDict',
    'RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs',
    'RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgsDict',
    'RuleGroupRuleActionChallengeArgs',
    'RuleGroupRuleActionChallengeArgsDict',
    'RuleGroupRuleActionChallengeCustomRequestHandlingArgs',
    'RuleGroupRuleActionChallengeCustomRequestHandlingArgsDict',
    'RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgs',
    'RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgsDict',
    'RuleGroupRuleActionCountArgs',
    'RuleGroupRuleActionCountArgsDict',
    'RuleGroupRuleActionCountCustomRequestHandlingArgs',
    'RuleGroupRuleActionCountCustomRequestHandlingArgsDict',
    'RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgs',
    'RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgsDict',
    'RuleGroupRuleCaptchaConfigArgs',
    'RuleGroupRuleCaptchaConfigArgsDict',
    'RuleGroupRuleCaptchaConfigImmunityTimePropertyArgs',
    'RuleGroupRuleCaptchaConfigImmunityTimePropertyArgsDict',
    'RuleGroupRuleRuleLabelArgs',
    'RuleGroupRuleRuleLabelArgsDict',
    'RuleGroupRuleStatementArgs',
    'RuleGroupRuleStatementArgsDict',
    'RuleGroupRuleStatementAndStatementArgs',
    'RuleGroupRuleStatementAndStatementArgsDict',
    'RuleGroupRuleStatementAsnMatchStatementArgs',
    'RuleGroupRuleStatementAsnMatchStatementArgsDict',
    'RuleGroupRuleStatementAsnMatchStatementForwardedIpConfigArgs',
    'RuleGroupRuleStatementAsnMatchStatementForwardedIpConfigArgsDict',
    'RuleGroupRuleStatementByteMatchStatementArgs',
    'RuleGroupRuleStatementByteMatchStatementArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJa4FingerprintArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJa4FingerprintArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchUriFragmentArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchUriFragmentArgsDict',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementByteMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementByteMatchStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementGeoMatchStatementArgs',
    'RuleGroupRuleStatementGeoMatchStatementArgsDict',
    'RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgs',
    'RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgsDict',
    'RuleGroupRuleStatementIpSetReferenceStatementArgs',
    'RuleGroupRuleStatementIpSetReferenceStatementArgsDict',
    'RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs',
    'RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict',
    'RuleGroupRuleStatementLabelMatchStatementArgs',
    'RuleGroupRuleStatementLabelMatchStatementArgsDict',
    'RuleGroupRuleStatementNotStatementArgs',
    'RuleGroupRuleStatementNotStatementArgsDict',
    'RuleGroupRuleStatementOrStatementArgs',
    'RuleGroupRuleStatementOrStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyAsnArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyAsnArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyJa3FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyJa3FingerprintArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyJa4FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyJa4FingerprintArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgsDict',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgsDict',
    'RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgs',
    'RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementArgs',
    'RuleGroupRuleStatementRegexMatchStatementArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa4FingerprintArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriFragmentArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriFragmentArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementRegexMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementRegexMatchStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs',
    'RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementArgs',
    'RuleGroupRuleStatementSizeConstraintStatementArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriFragmentArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriFragmentArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgs',
    'RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementArgs',
    'RuleGroupRuleStatementSqliMatchStatementArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa4FingerprintArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriFragmentArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriFragmentArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementSqliMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementSqliMatchStatementTextTransformationArgsDict',
    'RuleGroupRuleStatementXssMatchStatementArgs',
    'RuleGroupRuleStatementXssMatchStatementArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJa4FingerprintArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJa4FingerprintArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchUriFragmentArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchUriFragmentArgsDict',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgs',
    'RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgsDict',
    'RuleGroupRuleStatementXssMatchStatementTextTransformationArgs',
    'RuleGroupRuleStatementXssMatchStatementTextTransformationArgsDict',
    'RuleGroupRuleVisibilityConfigArgs',
    'RuleGroupRuleVisibilityConfigArgsDict',
    'RuleGroupVisibilityConfigArgs',
    'RuleGroupVisibilityConfigArgsDict',
    'WebAclAssociationConfigArgs',
    'WebAclAssociationConfigArgsDict',
    'WebAclAssociationConfigRequestBodyArgs',
    'WebAclAssociationConfigRequestBodyArgsDict',
    'WebAclAssociationConfigRequestBodyApiGatewayArgs',
    'WebAclAssociationConfigRequestBodyApiGatewayArgsDict',
    'WebAclAssociationConfigRequestBodyAppRunnerServiceArgs',
    'WebAclAssociationConfigRequestBodyAppRunnerServiceArgsDict',
    'WebAclAssociationConfigRequestBodyCloudfrontArgs',
    'WebAclAssociationConfigRequestBodyCloudfrontArgsDict',
    'WebAclAssociationConfigRequestBodyCognitoUserPoolArgs',
    'WebAclAssociationConfigRequestBodyCognitoUserPoolArgsDict',
    'WebAclAssociationConfigRequestBodyVerifiedAccessInstanceArgs',
    'WebAclAssociationConfigRequestBodyVerifiedAccessInstanceArgsDict',
    'WebAclCaptchaConfigArgs',
    'WebAclCaptchaConfigArgsDict',
    'WebAclCaptchaConfigImmunityTimePropertyArgs',
    'WebAclCaptchaConfigImmunityTimePropertyArgsDict',
    'WebAclChallengeConfigArgs',
    'WebAclChallengeConfigArgsDict',
    'WebAclChallengeConfigImmunityTimePropertyArgs',
    'WebAclChallengeConfigImmunityTimePropertyArgsDict',
    'WebAclCustomResponseBodyArgs',
    'WebAclCustomResponseBodyArgsDict',
    'WebAclDataProtectionConfigArgs',
    'WebAclDataProtectionConfigArgsDict',
    'WebAclDataProtectionConfigDataProtectionArgs',
    'WebAclDataProtectionConfigDataProtectionArgsDict',
    'WebAclDataProtectionConfigDataProtectionFieldArgs',
    'WebAclDataProtectionConfigDataProtectionFieldArgsDict',
    'WebAclDefaultActionArgs',
    'WebAclDefaultActionArgsDict',
    'WebAclDefaultActionAllowArgs',
    'WebAclDefaultActionAllowArgsDict',
    'WebAclDefaultActionAllowCustomRequestHandlingArgs',
    'WebAclDefaultActionAllowCustomRequestHandlingArgsDict',
    'WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgs',
    'WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclDefaultActionBlockArgs',
    'WebAclDefaultActionBlockArgsDict',
    'WebAclDefaultActionBlockCustomResponseArgs',
    'WebAclDefaultActionBlockCustomResponseArgsDict',
    'WebAclDefaultActionBlockCustomResponseResponseHeaderArgs',
    'WebAclDefaultActionBlockCustomResponseResponseHeaderArgsDict',
    'WebAclLoggingConfigurationLoggingFilterArgs',
    'WebAclLoggingConfigurationLoggingFilterArgsDict',
    'WebAclLoggingConfigurationLoggingFilterFilterArgs',
    'WebAclLoggingConfigurationLoggingFilterFilterArgsDict',
    'WebAclLoggingConfigurationLoggingFilterFilterConditionArgs',
    'WebAclLoggingConfigurationLoggingFilterFilterConditionArgsDict',
    'WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgs',
    'WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgsDict',
    'WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgs',
    'WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgsDict',
    'WebAclLoggingConfigurationRedactedFieldArgs',
    'WebAclLoggingConfigurationRedactedFieldArgsDict',
    'WebAclLoggingConfigurationRedactedFieldMethodArgs',
    'WebAclLoggingConfigurationRedactedFieldMethodArgsDict',
    'WebAclLoggingConfigurationRedactedFieldQueryStringArgs',
    'WebAclLoggingConfigurationRedactedFieldQueryStringArgsDict',
    'WebAclLoggingConfigurationRedactedFieldSingleHeaderArgs',
    'WebAclLoggingConfigurationRedactedFieldSingleHeaderArgsDict',
    'WebAclLoggingConfigurationRedactedFieldUriPathArgs',
    'WebAclLoggingConfigurationRedactedFieldUriPathArgsDict',
    'WebAclRuleArgs',
    'WebAclRuleArgsDict',
    'WebAclRuleActionArgs',
    'WebAclRuleActionArgsDict',
    'WebAclRuleActionAllowArgs',
    'WebAclRuleActionAllowArgsDict',
    'WebAclRuleActionAllowCustomRequestHandlingArgs',
    'WebAclRuleActionAllowCustomRequestHandlingArgsDict',
    'WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleActionBlockArgs',
    'WebAclRuleActionBlockArgsDict',
    'WebAclRuleActionBlockCustomResponseArgs',
    'WebAclRuleActionBlockCustomResponseArgsDict',
    'WebAclRuleActionBlockCustomResponseResponseHeaderArgs',
    'WebAclRuleActionBlockCustomResponseResponseHeaderArgsDict',
    'WebAclRuleActionCaptchaArgs',
    'WebAclRuleActionCaptchaArgsDict',
    'WebAclRuleActionCaptchaCustomRequestHandlingArgs',
    'WebAclRuleActionCaptchaCustomRequestHandlingArgsDict',
    'WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleActionChallengeArgs',
    'WebAclRuleActionChallengeArgsDict',
    'WebAclRuleActionChallengeCustomRequestHandlingArgs',
    'WebAclRuleActionChallengeCustomRequestHandlingArgsDict',
    'WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleActionCountArgs',
    'WebAclRuleActionCountArgsDict',
    'WebAclRuleActionCountCustomRequestHandlingArgs',
    'WebAclRuleActionCountCustomRequestHandlingArgsDict',
    'WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleCaptchaConfigArgs',
    'WebAclRuleCaptchaConfigArgsDict',
    'WebAclRuleCaptchaConfigImmunityTimePropertyArgs',
    'WebAclRuleCaptchaConfigImmunityTimePropertyArgsDict',
    'WebAclRuleChallengeConfigArgs',
    'WebAclRuleChallengeConfigArgsDict',
    'WebAclRuleChallengeConfigImmunityTimePropertyArgs',
    'WebAclRuleChallengeConfigImmunityTimePropertyArgsDict',
    'WebAclRuleGroupAssociationManagedRuleGroupArgs',
    'WebAclRuleGroupAssociationManagedRuleGroupArgsDict',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideArgs',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideArgsDict',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseArgs',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseArgsDict',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowArgs',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowArgsDict',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockArgs',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockArgsDict',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseArgs',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseArgsDict',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaArgs',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaArgsDict',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeArgs',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeArgsDict',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountArgs',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountArgsDict',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingArgs',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleGroupAssociationRuleGroupReferenceArgs',
    'WebAclRuleGroupAssociationRuleGroupReferenceArgsDict',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideArgs',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideArgsDict',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseArgs',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseArgsDict',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowArgs',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowArgsDict',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockArgs',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockArgsDict',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseArgs',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseArgsDict',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaArgs',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaArgsDict',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeArgs',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeArgsDict',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountArgs',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountArgsDict',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingArgs',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleGroupAssociationTimeoutsArgs',
    'WebAclRuleGroupAssociationTimeoutsArgsDict',
    'WebAclRuleOverrideActionArgs',
    'WebAclRuleOverrideActionArgsDict',
    'WebAclRuleOverrideActionCountArgs',
    'WebAclRuleOverrideActionCountArgsDict',
    'WebAclRuleOverrideActionNoneArgs',
    'WebAclRuleOverrideActionNoneArgsDict',
    'WebAclRuleRuleLabelArgs',
    'WebAclRuleRuleLabelArgsDict',
    'WebAclRuleStatementArgs',
    'WebAclRuleStatementArgsDict',
    'WebAclRuleStatementAndStatementArgs',
    'WebAclRuleStatementAndStatementArgsDict',
    'WebAclRuleStatementAsnMatchStatementArgs',
    'WebAclRuleStatementAsnMatchStatementArgsDict',
    'WebAclRuleStatementAsnMatchStatementForwardedIpConfigArgs',
    'WebAclRuleStatementAsnMatchStatementForwardedIpConfigArgsDict',
    'WebAclRuleStatementByteMatchStatementArgs',
    'WebAclRuleStatementByteMatchStatementArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJa4FingerprintArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJa4FingerprintArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchUriFragmentArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchUriFragmentArgsDict',
    'WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementByteMatchStatementTextTransformationArgs',
    'WebAclRuleStatementByteMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementGeoMatchStatementArgs',
    'WebAclRuleStatementGeoMatchStatementArgsDict',
    'WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgs',
    'WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgsDict',
    'WebAclRuleStatementIpSetReferenceStatementArgs',
    'WebAclRuleStatementIpSetReferenceStatementArgsDict',
    'WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs',
    'WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict',
    'WebAclRuleStatementLabelMatchStatementArgs',
    'WebAclRuleStatementLabelMatchStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFieldsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFieldsArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFieldsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFieldsArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeExemptUriRegularExpressionArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeExemptUriRegularExpressionArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgs',
    'WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgs',
    'WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementNotStatementArgs',
    'WebAclRuleStatementNotStatementArgsDict',
    'WebAclRuleStatementOrStatementArgs',
    'WebAclRuleStatementOrStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementArgs',
    'WebAclRuleStatementRateBasedStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyAsnArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyAsnArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyCookieArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyCookieArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyIpArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyIpArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyJa3FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyJa3FingerprintArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyJa4FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyJa4FingerprintArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgsDict',
    'WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgsDict',
    'WebAclRuleStatementRateBasedStatementForwardedIpConfigArgs',
    'WebAclRuleStatementRateBasedStatementForwardedIpConfigArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs',
    'WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementRegexMatchStatementArgs',
    'WebAclRuleStatementRegexMatchStatementArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJa4FingerprintArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchUriFragmentArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchUriFragmentArgsDict',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementRegexMatchStatementTextTransformationArgs',
    'WebAclRuleStatementRegexMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs',
    'WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs',
    'WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict',
    'WebAclRuleStatementSizeConstraintStatementArgs',
    'WebAclRuleStatementSizeConstraintStatementArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchUriFragmentArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchUriFragmentArgsDict',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementSizeConstraintStatementTextTransformationArgs',
    'WebAclRuleStatementSizeConstraintStatementTextTransformationArgsDict',
    'WebAclRuleStatementSqliMatchStatementArgs',
    'WebAclRuleStatementSqliMatchStatementArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJa4FingerprintArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchUriFragmentArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchUriFragmentArgsDict',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementSqliMatchStatementTextTransformationArgs',
    'WebAclRuleStatementSqliMatchStatementTextTransformationArgsDict',
    'WebAclRuleStatementXssMatchStatementArgs',
    'WebAclRuleStatementXssMatchStatementArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJa4FingerprintArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJa4FingerprintArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchUriFragmentArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchUriFragmentArgsDict',
    'WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgs',
    'WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgsDict',
    'WebAclRuleStatementXssMatchStatementTextTransformationArgs',
    'WebAclRuleStatementXssMatchStatementTextTransformationArgsDict',
    'WebAclRuleVisibilityConfigArgs',
    'WebAclRuleVisibilityConfigArgsDict',
    'WebAclVisibilityConfigArgs',
    'WebAclVisibilityConfigArgsDict',
]

MYPY = False

if not MYPY:
    class RegexPatternSetRegularExpressionArgsDict(TypedDict):
        regex_string: pulumi.Input[_builtins.str]
elif False:
    RegexPatternSetRegularExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegexPatternSetRegularExpressionArgs:
    def __init__(__self__, *,
                 regex_string: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "regex_string", regex_string)

    @_builtins.property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "regex_string", value)


if not MYPY:
    class RuleGroupCustomResponseBodyArgsDict(TypedDict):
        content: pulumi.Input[_builtins.str]
        content_type: pulumi.Input[_builtins.str]
        key: pulumi.Input[_builtins.str]
elif False:
    RuleGroupCustomResponseBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupCustomResponseBodyArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[_builtins.str],
                 content_type: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class RuleGroupRuleArgsDict(TypedDict):
        action: pulumi.Input['RuleGroupRuleActionArgsDict']
        name: pulumi.Input[_builtins.str]
        priority: pulumi.Input[_builtins.int]
        statement: pulumi.Input['RuleGroupRuleStatementArgsDict']
        visibility_config: pulumi.Input['RuleGroupRuleVisibilityConfigArgsDict']
        captcha_config: NotRequired[pulumi.Input['RuleGroupRuleCaptchaConfigArgsDict']]
        rule_labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleRuleLabelArgsDict']]]]
elif False:
    RuleGroupRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['RuleGroupRuleActionArgs'],
                 name: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 statement: pulumi.Input['RuleGroupRuleStatementArgs'],
                 visibility_config: pulumi.Input['RuleGroupRuleVisibilityConfigArgs'],
                 captcha_config: Optional[pulumi.Input['RuleGroupRuleCaptchaConfigArgs']] = None,
                 rule_labels: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleRuleLabelArgs']]]] = None):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "statement", statement)
        pulumi.set(__self__, "visibility_config", visibility_config)
        if captcha_config is not None:
            pulumi.set(__self__, "captcha_config", captcha_config)
        if rule_labels is not None:
            pulumi.set(__self__, "rule_labels", rule_labels)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input['RuleGroupRuleActionArgs']:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['RuleGroupRuleActionArgs']):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def statement(self) -> pulumi.Input['RuleGroupRuleStatementArgs']:
        return pulumi.get(self, "statement")

    @statement.setter
    def statement(self, value: pulumi.Input['RuleGroupRuleStatementArgs']):
        pulumi.set(self, "statement", value)

    @_builtins.property
    @pulumi.getter(name="visibilityConfig")
    def visibility_config(self) -> pulumi.Input['RuleGroupRuleVisibilityConfigArgs']:
        return pulumi.get(self, "visibility_config")

    @visibility_config.setter
    def visibility_config(self, value: pulumi.Input['RuleGroupRuleVisibilityConfigArgs']):
        pulumi.set(self, "visibility_config", value)

    @_builtins.property
    @pulumi.getter(name="captchaConfig")
    def captcha_config(self) -> Optional[pulumi.Input['RuleGroupRuleCaptchaConfigArgs']]:
        return pulumi.get(self, "captcha_config")

    @captcha_config.setter
    def captcha_config(self, value: Optional[pulumi.Input['RuleGroupRuleCaptchaConfigArgs']]):
        pulumi.set(self, "captcha_config", value)

    @_builtins.property
    @pulumi.getter(name="ruleLabels")
    def rule_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleRuleLabelArgs']]]]:
        return pulumi.get(self, "rule_labels")

    @rule_labels.setter
    def rule_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleRuleLabelArgs']]]]):
        pulumi.set(self, "rule_labels", value)


if not MYPY:
    class RuleGroupRuleActionArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input['RuleGroupRuleActionAllowArgsDict']]
        block: NotRequired[pulumi.Input['RuleGroupRuleActionBlockArgsDict']]
        captcha: NotRequired[pulumi.Input['RuleGroupRuleActionCaptchaArgsDict']]
        challenge: NotRequired[pulumi.Input['RuleGroupRuleActionChallengeArgsDict']]
        count: NotRequired[pulumi.Input['RuleGroupRuleActionCountArgsDict']]
elif False:
    RuleGroupRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['RuleGroupRuleActionAllowArgs']] = None,
                 block: Optional[pulumi.Input['RuleGroupRuleActionBlockArgs']] = None,
                 captcha: Optional[pulumi.Input['RuleGroupRuleActionCaptchaArgs']] = None,
                 challenge: Optional[pulumi.Input['RuleGroupRuleActionChallengeArgs']] = None,
                 count: Optional[pulumi.Input['RuleGroupRuleActionCountArgs']] = None):
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['RuleGroupRuleActionAllowArgs']]:
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['RuleGroupRuleActionAllowArgs']]):
        pulumi.set(self, "allow", value)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['RuleGroupRuleActionBlockArgs']]:
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['RuleGroupRuleActionBlockArgs']]):
        pulumi.set(self, "block", value)

    @_builtins.property
    @pulumi.getter
    def captcha(self) -> Optional[pulumi.Input['RuleGroupRuleActionCaptchaArgs']]:
        return pulumi.get(self, "captcha")

    @captcha.setter
    def captcha(self, value: Optional[pulumi.Input['RuleGroupRuleActionCaptchaArgs']]):
        pulumi.set(self, "captcha", value)

    @_builtins.property
    @pulumi.getter
    def challenge(self) -> Optional[pulumi.Input['RuleGroupRuleActionChallengeArgs']]:
        return pulumi.get(self, "challenge")

    @challenge.setter
    def challenge(self, value: Optional[pulumi.Input['RuleGroupRuleActionChallengeArgs']]):
        pulumi.set(self, "challenge", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['RuleGroupRuleActionCountArgs']]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['RuleGroupRuleActionCountArgs']]):
        pulumi.set(self, "count", value)


if not MYPY:
    class RuleGroupRuleActionAllowArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingArgsDict']]
elif False:
    RuleGroupRuleActionAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionAllowArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class RuleGroupRuleActionAllowCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgsDict']]]
elif False:
    RuleGroupRuleActionAllowCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionAllowCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionAllowCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RuleGroupRuleActionBlockArgsDict(TypedDict):
        custom_response: NotRequired[pulumi.Input['RuleGroupRuleActionBlockCustomResponseArgsDict']]
elif False:
    RuleGroupRuleActionBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionBlockArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['RuleGroupRuleActionBlockCustomResponseArgs']] = None):
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @_builtins.property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['RuleGroupRuleActionBlockCustomResponseArgs']]:
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['RuleGroupRuleActionBlockCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


if not MYPY:
    class RuleGroupRuleActionBlockCustomResponseArgsDict(TypedDict):
        response_code: pulumi.Input[_builtins.int]
        custom_response_body_key: NotRequired[pulumi.Input[_builtins.str]]
        response_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionBlockCustomResponseResponseHeaderArgsDict']]]]
elif False:
    RuleGroupRuleActionBlockCustomResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionBlockCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[_builtins.int],
                 custom_response_body_key: Optional[pulumi.Input[_builtins.str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionBlockCustomResponseResponseHeaderArgs']]]] = None):
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "response_code", value)

    @_builtins.property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @_builtins.property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionBlockCustomResponseResponseHeaderArgs']]]]:
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionBlockCustomResponseResponseHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


if not MYPY:
    class RuleGroupRuleActionBlockCustomResponseResponseHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleActionBlockCustomResponseResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionBlockCustomResponseResponseHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RuleGroupRuleActionCaptchaArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingArgsDict']]
elif False:
    RuleGroupRuleActionCaptchaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionCaptchaArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class RuleGroupRuleActionCaptchaCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgsDict']]]
elif False:
    RuleGroupRuleActionCaptchaCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionCaptchaCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RuleGroupRuleActionChallengeArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingArgsDict']]
elif False:
    RuleGroupRuleActionChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionChallengeArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class RuleGroupRuleActionChallengeCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgsDict']]]
elif False:
    RuleGroupRuleActionChallengeCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionChallengeCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionChallengeCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RuleGroupRuleActionCountArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingArgsDict']]
elif False:
    RuleGroupRuleActionCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionCountArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class RuleGroupRuleActionCountCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgsDict']]]
elif False:
    RuleGroupRuleActionCountCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionCountCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgs']]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleActionCountCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RuleGroupRuleCaptchaConfigArgsDict(TypedDict):
        immunity_time_property: NotRequired[pulumi.Input['RuleGroupRuleCaptchaConfigImmunityTimePropertyArgsDict']]
elif False:
    RuleGroupRuleCaptchaConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleCaptchaConfigArgs:
    def __init__(__self__, *,
                 immunity_time_property: Optional[pulumi.Input['RuleGroupRuleCaptchaConfigImmunityTimePropertyArgs']] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @_builtins.property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional[pulumi.Input['RuleGroupRuleCaptchaConfigImmunityTimePropertyArgs']]:
        return pulumi.get(self, "immunity_time_property")

    @immunity_time_property.setter
    def immunity_time_property(self, value: Optional[pulumi.Input['RuleGroupRuleCaptchaConfigImmunityTimePropertyArgs']]):
        pulumi.set(self, "immunity_time_property", value)


if not MYPY:
    class RuleGroupRuleCaptchaConfigImmunityTimePropertyArgsDict(TypedDict):
        immunity_time: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    RuleGroupRuleCaptchaConfigImmunityTimePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleCaptchaConfigImmunityTimePropertyArgs:
    def __init__(__self__, *,
                 immunity_time: Optional[pulumi.Input[_builtins.int]] = None):
        if immunity_time is not None:
            pulumi.set(__self__, "immunity_time", immunity_time)

    @_builtins.property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "immunity_time")

    @immunity_time.setter
    def immunity_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "immunity_time", value)


if not MYPY:
    class RuleGroupRuleRuleLabelArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleRuleLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleRuleLabelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementArgsDict(TypedDict):
        and_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementAndStatementArgsDict']]
        asn_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementAsnMatchStatementArgsDict']]
        byte_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementArgsDict']]
        geo_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementArgsDict']]
        ip_set_reference_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementArgsDict']]
        label_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementLabelMatchStatementArgsDict']]
        not_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementNotStatementArgsDict']]
        or_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementOrStatementArgsDict']]
        rate_based_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementArgsDict']]
        regex_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementArgsDict']]
        regex_pattern_set_reference_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementArgsDict']]
        size_constraint_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementArgsDict']]
        sqli_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementArgsDict']]
        xss_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementArgsDict']]
elif False:
    RuleGroupRuleStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementArgs:
    def __init__(__self__, *,
                 and_statement: Optional[pulumi.Input['RuleGroupRuleStatementAndStatementArgs']] = None,
                 asn_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementAsnMatchStatementArgs']] = None,
                 byte_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementArgs']] = None,
                 geo_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementArgs']] = None,
                 ip_set_reference_statement: Optional[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementArgs']] = None,
                 label_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementLabelMatchStatementArgs']] = None,
                 not_statement: Optional[pulumi.Input['RuleGroupRuleStatementNotStatementArgs']] = None,
                 or_statement: Optional[pulumi.Input['RuleGroupRuleStatementOrStatementArgs']] = None,
                 rate_based_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementArgs']] = None,
                 regex_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementArgs']] = None,
                 regex_pattern_set_reference_statement: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementArgs']] = None,
                 size_constraint_statement: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementArgs']] = None,
                 sqli_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementArgs']] = None,
                 xss_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementArgs']] = None):
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if asn_match_statement is not None:
            pulumi.set(__self__, "asn_match_statement", asn_match_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            pulumi.set(__self__, "ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if rate_based_statement is not None:
            pulumi.set(__self__, "rate_based_statement", rate_based_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @_builtins.property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementAndStatementArgs']]:
        return pulumi.get(self, "and_statement")

    @and_statement.setter
    def and_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementAndStatementArgs']]):
        pulumi.set(self, "and_statement", value)

    @_builtins.property
    @pulumi.getter(name="asnMatchStatement")
    def asn_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementAsnMatchStatementArgs']]:
        return pulumi.get(self, "asn_match_statement")

    @asn_match_statement.setter
    def asn_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementAsnMatchStatementArgs']]):
        pulumi.set(self, "asn_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementArgs']]:
        return pulumi.get(self, "byte_match_statement")

    @byte_match_statement.setter
    def byte_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementArgs']]):
        pulumi.set(self, "byte_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementArgs']]:
        return pulumi.get(self, "geo_match_statement")

    @geo_match_statement.setter
    def geo_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementArgs']]):
        pulumi.set(self, "geo_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementArgs']]:
        return pulumi.get(self, "ip_set_reference_statement")

    @ip_set_reference_statement.setter
    def ip_set_reference_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementArgs']]):
        pulumi.set(self, "ip_set_reference_statement", value)

    @_builtins.property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementLabelMatchStatementArgs']]:
        return pulumi.get(self, "label_match_statement")

    @label_match_statement.setter
    def label_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementLabelMatchStatementArgs']]):
        pulumi.set(self, "label_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementNotStatementArgs']]:
        return pulumi.get(self, "not_statement")

    @not_statement.setter
    def not_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementNotStatementArgs']]):
        pulumi.set(self, "not_statement", value)

    @_builtins.property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementOrStatementArgs']]:
        return pulumi.get(self, "or_statement")

    @or_statement.setter
    def or_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementOrStatementArgs']]):
        pulumi.set(self, "or_statement", value)

    @_builtins.property
    @pulumi.getter(name="rateBasedStatement")
    def rate_based_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementArgs']]:
        return pulumi.get(self, "rate_based_statement")

    @rate_based_statement.setter
    def rate_based_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementArgs']]):
        pulumi.set(self, "rate_based_statement", value)

    @_builtins.property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementArgs']]:
        return pulumi.get(self, "regex_match_statement")

    @regex_match_statement.setter
    def regex_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementArgs']]):
        pulumi.set(self, "regex_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementArgs']]:
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @regex_pattern_set_reference_statement.setter
    def regex_pattern_set_reference_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementArgs']]):
        pulumi.set(self, "regex_pattern_set_reference_statement", value)

    @_builtins.property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementArgs']]:
        return pulumi.get(self, "size_constraint_statement")

    @size_constraint_statement.setter
    def size_constraint_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementArgs']]):
        pulumi.set(self, "size_constraint_statement", value)

    @_builtins.property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementArgs']]:
        return pulumi.get(self, "sqli_match_statement")

    @sqli_match_statement.setter
    def sqli_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementArgs']]):
        pulumi.set(self, "sqli_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementArgs']]:
        return pulumi.get(self, "xss_match_statement")

    @xss_match_statement.setter
    def xss_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementArgs']]):
        pulumi.set(self, "xss_match_statement", value)


if not MYPY:
    class RuleGroupRuleStatementAndStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    RuleGroupRuleStatementAndStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementAndStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class RuleGroupRuleStatementAsnMatchStatementArgsDict(TypedDict):
        asn_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
        forwarded_ip_config: NotRequired[pulumi.Input['RuleGroupRuleStatementAsnMatchStatementForwardedIpConfigArgsDict']]
elif False:
    RuleGroupRuleStatementAsnMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementAsnMatchStatementArgs:
    def __init__(__self__, *,
                 asn_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]],
                 forwarded_ip_config: Optional[pulumi.Input['RuleGroupRuleStatementAsnMatchStatementForwardedIpConfigArgs']] = None):
        pulumi.set(__self__, "asn_lists", asn_lists)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @_builtins.property
    @pulumi.getter(name="asnLists")
    def asn_lists(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "asn_lists")

    @asn_lists.setter
    def asn_lists(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "asn_lists", value)

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupRuleStatementAsnMatchStatementForwardedIpConfigArgs']]:
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupRuleStatementAsnMatchStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


if not MYPY:
    class RuleGroupRuleStatementAsnMatchStatementForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
        header_name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementAsnMatchStatementForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementAsnMatchStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str],
                 header_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementArgsDict(TypedDict):
        positional_constraint: pulumi.Input[_builtins.str]
        search_string: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchArgsDict']]
elif False:
    RuleGroupRuleStatementByteMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementArgs:
    def __init__(__self__, *,
                 positional_constraint: pulumi.Input[_builtins.str],
                 search_string: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "search_string", search_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "positional_constraint")

    @positional_constraint.setter
    def positional_constraint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "positional_constraint", value)

    @_builtins.property
    @pulumi.getter(name="searchString")
    def search_string(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "search_string")

    @search_string.setter
    def search_string(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "search_string", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgsDict']]
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementByteMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementByteMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementByteMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementGeoMatchStatementArgsDict(TypedDict):
        country_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        forwarded_ip_config: NotRequired[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgsDict']]
elif False:
    RuleGroupRuleStatementGeoMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementGeoMatchStatementArgs:
    def __init__(__self__, *,
                 country_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 forwarded_ip_config: Optional[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgs']] = None):
        pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @_builtins.property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "country_codes", value)

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgs']]:
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


if not MYPY:
    class RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
        header_name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementGeoMatchStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str],
                 header_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class RuleGroupRuleStatementIpSetReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        ip_set_forwarded_ip_config: NotRequired[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict']]
elif False:
    RuleGroupRuleStatementIpSetReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementIpSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 ip_set_forwarded_ip_config: Optional[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']] = None):
        pulumi.set(__self__, "arn", arn)
        if ip_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]:
        return pulumi.get(self, "ip_set_forwarded_ip_config")

    @ip_set_forwarded_ip_config.setter
    def ip_set_forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]):
        pulumi.set(self, "ip_set_forwarded_ip_config", value)


if not MYPY:
    class RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
        header_name: pulumi.Input[_builtins.str]
        position: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str],
                 header_name: pulumi.Input[_builtins.str],
                 position: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header_name", value)

    @_builtins.property
    @pulumi.getter
    def position(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "position", value)


if not MYPY:
    class RuleGroupRuleStatementLabelMatchStatementArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        scope: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementLabelMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementLabelMatchStatementArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 scope: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class RuleGroupRuleStatementNotStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    RuleGroupRuleStatementNotStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementNotStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class RuleGroupRuleStatementOrStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    RuleGroupRuleStatementOrStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementOrStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementArgsDict(TypedDict):
        limit: pulumi.Input[_builtins.int]
        aggregate_key_type: NotRequired[pulumi.Input[_builtins.str]]
        custom_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyArgsDict']]]]
        evaluation_window_sec: NotRequired[pulumi.Input[_builtins.int]]
        forwarded_ip_config: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgsDict']]
        scope_down_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgsDict']]
elif False:
    RuleGroupRuleStatementRateBasedStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementArgs:
    def __init__(__self__, *,
                 limit: pulumi.Input[_builtins.int],
                 aggregate_key_type: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_keys: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyArgs']]]] = None,
                 evaluation_window_sec: Optional[pulumi.Input[_builtins.int]] = None,
                 forwarded_ip_config: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgs']] = None,
                 scope_down_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgs']] = None):
        pulumi.set(__self__, "limit", limit)
        if aggregate_key_type is not None:
            pulumi.set(__self__, "aggregate_key_type", aggregate_key_type)
        if custom_keys is not None:
            pulumi.set(__self__, "custom_keys", custom_keys)
        if evaluation_window_sec is not None:
            pulumi.set(__self__, "evaluation_window_sec", evaluation_window_sec)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter(name="aggregateKeyType")
    def aggregate_key_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "aggregate_key_type")

    @aggregate_key_type.setter
    def aggregate_key_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aggregate_key_type", value)

    @_builtins.property
    @pulumi.getter(name="customKeys")
    def custom_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyArgs']]]]:
        return pulumi.get(self, "custom_keys")

    @custom_keys.setter
    def custom_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyArgs']]]]):
        pulumi.set(self, "custom_keys", value)

    @_builtins.property
    @pulumi.getter(name="evaluationWindowSec")
    def evaluation_window_sec(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "evaluation_window_sec")

    @evaluation_window_sec.setter
    def evaluation_window_sec(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "evaluation_window_sec", value)

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgs']]:
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)

    @_builtins.property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgs']]:
        return pulumi.get(self, "scope_down_statement")

    @scope_down_statement.setter
    def scope_down_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgs']]):
        pulumi.set(self, "scope_down_statement", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyArgsDict(TypedDict):
        asn: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyAsnArgsDict']]
        cookie: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgsDict']]
        forwarded_ip: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgsDict']]
        header: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgsDict']]
        http_method: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgsDict']]
        ip: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgsDict']]
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyJa4FingerprintArgsDict']]
        label_namespace: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgsDict']]
        query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgsDict']]
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgsDict']]
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgsDict']]
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyArgs:
    def __init__(__self__, *,
                 asn: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyAsnArgs']] = None,
                 cookie: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgs']] = None,
                 forwarded_ip: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgs']] = None,
                 header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgs']] = None,
                 http_method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgs']] = None,
                 ip: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgs']] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyJa4FingerprintArgs']] = None,
                 label_namespace: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs']] = None,
                 query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgs']] = None):
        if asn is not None:
            pulumi.set(__self__, "asn", asn)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if forwarded_ip is not None:
            pulumi.set(__self__, "forwarded_ip", forwarded_ip)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if label_namespace is not None:
            pulumi.set(__self__, "label_namespace", label_namespace)
        if query_argument is not None:
            pulumi.set(__self__, "query_argument", query_argument)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter
    def asn(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyAsnArgs']]:
        return pulumi.get(self, "asn")

    @asn.setter
    def asn(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyAsnArgs']]):
        pulumi.set(self, "asn", value)

    @_builtins.property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgs']]:
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgs']]):
        pulumi.set(self, "cookie", value)

    @_builtins.property
    @pulumi.getter(name="forwardedIp")
    def forwarded_ip(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgs']]:
        return pulumi.get(self, "forwarded_ip")

    @forwarded_ip.setter
    def forwarded_ip(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgs']]):
        pulumi.set(self, "forwarded_ip", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgs']]:
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgs']]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgs']]:
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgs']]):
        pulumi.set(self, "http_method", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="labelNamespace")
    def label_namespace(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs']]:
        return pulumi.get(self, "label_namespace")

    @label_namespace.setter
    def label_namespace(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs']]):
        pulumi.set(self, "label_namespace", value)

    @_builtins.property
    @pulumi.getter(name="queryArgument")
    def query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs']]:
        return pulumi.get(self, "query_argument")

    @query_argument.setter
    def query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs']]):
        pulumi.set(self, "query_argument", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyAsnArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyAsnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyAsnArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgsDict']]]
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyCookieArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyForwardedIpArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgsDict']]]
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyHttpMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyIpArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgsDict(TypedDict):
        namespace: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs:
    def __init__(__self__, *,
                 namespace: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgsDict']]]
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgsDict']]]
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]]):
        pulumi.set(__self__, "text_transformations", text_transformations)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgsDict']]]
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]]):
        pulumi.set(__self__, "text_transformations", text_transformations)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
        header_name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str],
                 header_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgsDict(TypedDict):
        and_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgsDict']]
        asn_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementArgsDict']]
        byte_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgsDict']]
        geo_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgsDict']]
        ip_set_reference_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgsDict']]
        label_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgsDict']]
        not_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgsDict']]
        or_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgsDict']]
        regex_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgsDict']]
        regex_pattern_set_reference_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict']]
        size_constraint_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgsDict']]
        sqli_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgsDict']]
        xss_match_statement: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgsDict']]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementArgs:
    def __init__(__self__, *,
                 and_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs']] = None,
                 asn_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementArgs']] = None,
                 byte_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs']] = None,
                 geo_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs']] = None,
                 ip_set_reference_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs']] = None,
                 label_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs']] = None,
                 not_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs']] = None,
                 or_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs']] = None,
                 regex_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs']] = None,
                 regex_pattern_set_reference_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']] = None,
                 size_constraint_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs']] = None,
                 sqli_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs']] = None,
                 xss_match_statement: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs']] = None):
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if asn_match_statement is not None:
            pulumi.set(__self__, "asn_match_statement", asn_match_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            pulumi.set(__self__, "ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @_builtins.property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs']]:
        return pulumi.get(self, "and_statement")

    @and_statement.setter
    def and_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs']]):
        pulumi.set(self, "and_statement", value)

    @_builtins.property
    @pulumi.getter(name="asnMatchStatement")
    def asn_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementArgs']]:
        return pulumi.get(self, "asn_match_statement")

    @asn_match_statement.setter
    def asn_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementArgs']]):
        pulumi.set(self, "asn_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs']]:
        return pulumi.get(self, "byte_match_statement")

    @byte_match_statement.setter
    def byte_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs']]):
        pulumi.set(self, "byte_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs']]:
        return pulumi.get(self, "geo_match_statement")

    @geo_match_statement.setter
    def geo_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs']]):
        pulumi.set(self, "geo_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs']]:
        return pulumi.get(self, "ip_set_reference_statement")

    @ip_set_reference_statement.setter
    def ip_set_reference_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs']]):
        pulumi.set(self, "ip_set_reference_statement", value)

    @_builtins.property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs']]:
        return pulumi.get(self, "label_match_statement")

    @label_match_statement.setter
    def label_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs']]):
        pulumi.set(self, "label_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs']]:
        return pulumi.get(self, "not_statement")

    @not_statement.setter
    def not_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs']]):
        pulumi.set(self, "not_statement", value)

    @_builtins.property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs']]:
        return pulumi.get(self, "or_statement")

    @or_statement.setter
    def or_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs']]):
        pulumi.set(self, "or_statement", value)

    @_builtins.property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs']]:
        return pulumi.get(self, "regex_match_statement")

    @regex_match_statement.setter
    def regex_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs']]):
        pulumi.set(self, "regex_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']]:
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @regex_pattern_set_reference_statement.setter
    def regex_pattern_set_reference_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']]):
        pulumi.set(self, "regex_pattern_set_reference_statement", value)

    @_builtins.property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs']]:
        return pulumi.get(self, "size_constraint_statement")

    @size_constraint_statement.setter
    def size_constraint_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs']]):
        pulumi.set(self, "size_constraint_statement", value)

    @_builtins.property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs']]:
        return pulumi.get(self, "sqli_match_statement")

    @sqli_match_statement.setter
    def sqli_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs']]):
        pulumi.set(self, "sqli_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs']]:
        return pulumi.get(self, "xss_match_statement")

    @xss_match_statement.setter
    def xss_match_statement(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs']]):
        pulumi.set(self, "xss_match_statement", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementArgsDict(TypedDict):
        asn_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
        forwarded_ip_config: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgsDict']]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementArgs:
    def __init__(__self__, *,
                 asn_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]],
                 forwarded_ip_config: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgs']] = None):
        pulumi.set(__self__, "asn_lists", asn_lists)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @_builtins.property
    @pulumi.getter(name="asnLists")
    def asn_lists(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "asn_lists")

    @asn_lists.setter
    def asn_lists(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "asn_lists", value)

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgs']]:
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
        header_name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str],
                 header_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgsDict(TypedDict):
        positional_constraint: pulumi.Input[_builtins.str]
        search_string: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict']]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs:
    def __init__(__self__, *,
                 positional_constraint: pulumi.Input[_builtins.str],
                 search_string: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "search_string", search_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "positional_constraint")

    @positional_constraint.setter
    def positional_constraint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "positional_constraint", value)

    @_builtins.property
    @pulumi.getter(name="searchString")
    def search_string(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "search_string")

    @search_string.setter
    def search_string(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "search_string", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict']]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgsDict(TypedDict):
        country_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        forwarded_ip_config: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict']]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs:
    def __init__(__self__, *,
                 country_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 forwarded_ip_config: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']] = None):
        pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @_builtins.property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "country_codes", value)

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']]:
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
        header_name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str],
                 header_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        ip_set_forwarded_ip_config: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict']]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 ip_set_forwarded_ip_config: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']] = None):
        pulumi.set(__self__, "arn", arn)
        if ip_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]:
        return pulumi.get(self, "ip_set_forwarded_ip_config")

    @ip_set_forwarded_ip_config.setter
    def ip_set_forwarded_ip_config(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]):
        pulumi.set(self, "ip_set_forwarded_ip_config", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
        header_name: pulumi.Input[_builtins.str]
        position: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str],
                 header_name: pulumi.Input[_builtins.str],
                 position: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header_name", value)

    @_builtins.property
    @pulumi.getter
    def position(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "position", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        scope: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 scope: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgsDict(TypedDict):
        regex_string: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict']]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs:
    def __init__(__self__, *,
                 regex_string: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "regex_string", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict']]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict']]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict']]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgsDict(TypedDict):
        comparison_operator: pulumi.Input[_builtins.str]
        size: pulumi.Input[_builtins.int]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict']]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[_builtins.str],
                 size: pulumi.Input[_builtins.int],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "comparison_operator", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict']]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict']]
        sensitivity_level: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']] = None,
                 sensitivity_level: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)

    @_builtins.property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sensitivity_level", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict']]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict']]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict']]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementArgsDict(TypedDict):
        regex_string: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgsDict']]
elif False:
    RuleGroupRuleStatementRegexMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementArgs:
    def __init__(__self__, *,
                 regex_string: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "regex_string", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgsDict']]
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRegexMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict']]
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict']]
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementArgsDict(TypedDict):
        comparison_operator: pulumi.Input[_builtins.str]
        size: pulumi.Input[_builtins.int]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgsDict']]
elif False:
    RuleGroupRuleStatementSizeConstraintStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[_builtins.str],
                 size: pulumi.Input[_builtins.int],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "comparison_operator", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgsDict']]
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSizeConstraintStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgsDict']]
        sensitivity_level: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementSqliMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgs']] = None,
                 sensitivity_level: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)

    @_builtins.property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sensitivity_level", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgsDict']]
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementSqliMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementSqliMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementSqliMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchArgsDict']]
elif False:
    RuleGroupRuleStatementXssMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgsDict']]
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RuleGroupRuleStatementXssMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    RuleGroupRuleStatementXssMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleStatementXssMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RuleGroupRuleVisibilityConfigArgsDict(TypedDict):
        cloudwatch_metrics_enabled: pulumi.Input[_builtins.bool]
        metric_name: pulumi.Input[_builtins.str]
        sampled_requests_enabled: pulumi.Input[_builtins.bool]
elif False:
    RuleGroupRuleVisibilityConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupRuleVisibilityConfigArgs:
    def __init__(__self__, *,
                 cloudwatch_metrics_enabled: pulumi.Input[_builtins.bool],
                 metric_name: pulumi.Input[_builtins.str],
                 sampled_requests_enabled: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "cloudwatch_metrics_enabled", cloudwatch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @_builtins.property
    @pulumi.getter(name="cloudwatchMetricsEnabled")
    def cloudwatch_metrics_enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "cloudwatch_metrics_enabled")

    @cloudwatch_metrics_enabled.setter
    def cloudwatch_metrics_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "cloudwatch_metrics_enabled", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "sampled_requests_enabled")

    @sampled_requests_enabled.setter
    def sampled_requests_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "sampled_requests_enabled", value)


if not MYPY:
    class RuleGroupVisibilityConfigArgsDict(TypedDict):
        cloudwatch_metrics_enabled: pulumi.Input[_builtins.bool]
        metric_name: pulumi.Input[_builtins.str]
        sampled_requests_enabled: pulumi.Input[_builtins.bool]
elif False:
    RuleGroupVisibilityConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleGroupVisibilityConfigArgs:
    def __init__(__self__, *,
                 cloudwatch_metrics_enabled: pulumi.Input[_builtins.bool],
                 metric_name: pulumi.Input[_builtins.str],
                 sampled_requests_enabled: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "cloudwatch_metrics_enabled", cloudwatch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @_builtins.property
    @pulumi.getter(name="cloudwatchMetricsEnabled")
    def cloudwatch_metrics_enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "cloudwatch_metrics_enabled")

    @cloudwatch_metrics_enabled.setter
    def cloudwatch_metrics_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "cloudwatch_metrics_enabled", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "sampled_requests_enabled")

    @sampled_requests_enabled.setter
    def sampled_requests_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "sampled_requests_enabled", value)


if not MYPY:
    class WebAclAssociationConfigArgsDict(TypedDict):
        request_bodies: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyArgsDict']]]]
elif False:
    WebAclAssociationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclAssociationConfigArgs:
    def __init__(__self__, *,
                 request_bodies: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyArgs']]]] = None):
        if request_bodies is not None:
            pulumi.set(__self__, "request_bodies", request_bodies)

    @_builtins.property
    @pulumi.getter(name="requestBodies")
    def request_bodies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyArgs']]]]:
        return pulumi.get(self, "request_bodies")

    @request_bodies.setter
    def request_bodies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclAssociationConfigRequestBodyArgs']]]]):
        pulumi.set(self, "request_bodies", value)


if not MYPY:
    class WebAclAssociationConfigRequestBodyArgsDict(TypedDict):
        api_gateway: NotRequired[pulumi.Input['WebAclAssociationConfigRequestBodyApiGatewayArgsDict']]
        app_runner_service: NotRequired[pulumi.Input['WebAclAssociationConfigRequestBodyAppRunnerServiceArgsDict']]
        cloudfront: NotRequired[pulumi.Input['WebAclAssociationConfigRequestBodyCloudfrontArgsDict']]
        cognito_user_pool: NotRequired[pulumi.Input['WebAclAssociationConfigRequestBodyCognitoUserPoolArgsDict']]
        verified_access_instance: NotRequired[pulumi.Input['WebAclAssociationConfigRequestBodyVerifiedAccessInstanceArgsDict']]
elif False:
    WebAclAssociationConfigRequestBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclAssociationConfigRequestBodyArgs:
    def __init__(__self__, *,
                 api_gateway: Optional[pulumi.Input['WebAclAssociationConfigRequestBodyApiGatewayArgs']] = None,
                 app_runner_service: Optional[pulumi.Input['WebAclAssociationConfigRequestBodyAppRunnerServiceArgs']] = None,
                 cloudfront: Optional[pulumi.Input['WebAclAssociationConfigRequestBodyCloudfrontArgs']] = None,
                 cognito_user_pool: Optional[pulumi.Input['WebAclAssociationConfigRequestBodyCognitoUserPoolArgs']] = None,
                 verified_access_instance: Optional[pulumi.Input['WebAclAssociationConfigRequestBodyVerifiedAccessInstanceArgs']] = None):
        if api_gateway is not None:
            pulumi.set(__self__, "api_gateway", api_gateway)
        if app_runner_service is not None:
            pulumi.set(__self__, "app_runner_service", app_runner_service)
        if cloudfront is not None:
            pulumi.set(__self__, "cloudfront", cloudfront)
        if cognito_user_pool is not None:
            pulumi.set(__self__, "cognito_user_pool", cognito_user_pool)
        if verified_access_instance is not None:
            pulumi.set(__self__, "verified_access_instance", verified_access_instance)

    @_builtins.property
    @pulumi.getter(name="apiGateway")
    def api_gateway(self) -> Optional[pulumi.Input['WebAclAssociationConfigRequestBodyApiGatewayArgs']]:
        return pulumi.get(self, "api_gateway")

    @api_gateway.setter
    def api_gateway(self, value: Optional[pulumi.Input['WebAclAssociationConfigRequestBodyApiGatewayArgs']]):
        pulumi.set(self, "api_gateway", value)

    @_builtins.property
    @pulumi.getter(name="appRunnerService")
    def app_runner_service(self) -> Optional[pulumi.Input['WebAclAssociationConfigRequestBodyAppRunnerServiceArgs']]:
        return pulumi.get(self, "app_runner_service")

    @app_runner_service.setter
    def app_runner_service(self, value: Optional[pulumi.Input['WebAclAssociationConfigRequestBodyAppRunnerServiceArgs']]):
        pulumi.set(self, "app_runner_service", value)

    @_builtins.property
    @pulumi.getter
    def cloudfront(self) -> Optional[pulumi.Input['WebAclAssociationConfigRequestBodyCloudfrontArgs']]:
        return pulumi.get(self, "cloudfront")

    @cloudfront.setter
    def cloudfront(self, value: Optional[pulumi.Input['WebAclAssociationConfigRequestBodyCloudfrontArgs']]):
        pulumi.set(self, "cloudfront", value)

    @_builtins.property
    @pulumi.getter(name="cognitoUserPool")
    def cognito_user_pool(self) -> Optional[pulumi.Input['WebAclAssociationConfigRequestBodyCognitoUserPoolArgs']]:
        return pulumi.get(self, "cognito_user_pool")

    @cognito_user_pool.setter
    def cognito_user_pool(self, value: Optional[pulumi.Input['WebAclAssociationConfigRequestBodyCognitoUserPoolArgs']]):
        pulumi.set(self, "cognito_user_pool", value)

    @_builtins.property
    @pulumi.getter(name="verifiedAccessInstance")
    def verified_access_instance(self) -> Optional[pulumi.Input['WebAclAssociationConfigRequestBodyVerifiedAccessInstanceArgs']]:
        return pulumi.get(self, "verified_access_instance")

    @verified_access_instance.setter
    def verified_access_instance(self, value: Optional[pulumi.Input['WebAclAssociationConfigRequestBodyVerifiedAccessInstanceArgs']]):
        pulumi.set(self, "verified_access_instance", value)


if not MYPY:
    class WebAclAssociationConfigRequestBodyApiGatewayArgsDict(TypedDict):
        default_size_inspection_limit: pulumi.Input[_builtins.str]
elif False:
    WebAclAssociationConfigRequestBodyApiGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclAssociationConfigRequestBodyApiGatewayArgs:
    def __init__(__self__, *,
                 default_size_inspection_limit: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "default_size_inspection_limit", default_size_inspection_limit)

    @_builtins.property
    @pulumi.getter(name="defaultSizeInspectionLimit")
    def default_size_inspection_limit(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "default_size_inspection_limit")

    @default_size_inspection_limit.setter
    def default_size_inspection_limit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_size_inspection_limit", value)


if not MYPY:
    class WebAclAssociationConfigRequestBodyAppRunnerServiceArgsDict(TypedDict):
        default_size_inspection_limit: pulumi.Input[_builtins.str]
elif False:
    WebAclAssociationConfigRequestBodyAppRunnerServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclAssociationConfigRequestBodyAppRunnerServiceArgs:
    def __init__(__self__, *,
                 default_size_inspection_limit: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "default_size_inspection_limit", default_size_inspection_limit)

    @_builtins.property
    @pulumi.getter(name="defaultSizeInspectionLimit")
    def default_size_inspection_limit(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "default_size_inspection_limit")

    @default_size_inspection_limit.setter
    def default_size_inspection_limit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_size_inspection_limit", value)


if not MYPY:
    class WebAclAssociationConfigRequestBodyCloudfrontArgsDict(TypedDict):
        default_size_inspection_limit: pulumi.Input[_builtins.str]
elif False:
    WebAclAssociationConfigRequestBodyCloudfrontArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclAssociationConfigRequestBodyCloudfrontArgs:
    def __init__(__self__, *,
                 default_size_inspection_limit: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "default_size_inspection_limit", default_size_inspection_limit)

    @_builtins.property
    @pulumi.getter(name="defaultSizeInspectionLimit")
    def default_size_inspection_limit(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "default_size_inspection_limit")

    @default_size_inspection_limit.setter
    def default_size_inspection_limit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_size_inspection_limit", value)


if not MYPY:
    class WebAclAssociationConfigRequestBodyCognitoUserPoolArgsDict(TypedDict):
        default_size_inspection_limit: pulumi.Input[_builtins.str]
elif False:
    WebAclAssociationConfigRequestBodyCognitoUserPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclAssociationConfigRequestBodyCognitoUserPoolArgs:
    def __init__(__self__, *,
                 default_size_inspection_limit: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "default_size_inspection_limit", default_size_inspection_limit)

    @_builtins.property
    @pulumi.getter(name="defaultSizeInspectionLimit")
    def default_size_inspection_limit(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "default_size_inspection_limit")

    @default_size_inspection_limit.setter
    def default_size_inspection_limit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_size_inspection_limit", value)


if not MYPY:
    class WebAclAssociationConfigRequestBodyVerifiedAccessInstanceArgsDict(TypedDict):
        default_size_inspection_limit: pulumi.Input[_builtins.str]
elif False:
    WebAclAssociationConfigRequestBodyVerifiedAccessInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclAssociationConfigRequestBodyVerifiedAccessInstanceArgs:
    def __init__(__self__, *,
                 default_size_inspection_limit: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "default_size_inspection_limit", default_size_inspection_limit)

    @_builtins.property
    @pulumi.getter(name="defaultSizeInspectionLimit")
    def default_size_inspection_limit(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "default_size_inspection_limit")

    @default_size_inspection_limit.setter
    def default_size_inspection_limit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_size_inspection_limit", value)


if not MYPY:
    class WebAclCaptchaConfigArgsDict(TypedDict):
        immunity_time_property: NotRequired[pulumi.Input['WebAclCaptchaConfigImmunityTimePropertyArgsDict']]
elif False:
    WebAclCaptchaConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclCaptchaConfigArgs:
    def __init__(__self__, *,
                 immunity_time_property: Optional[pulumi.Input['WebAclCaptchaConfigImmunityTimePropertyArgs']] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @_builtins.property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional[pulumi.Input['WebAclCaptchaConfigImmunityTimePropertyArgs']]:
        return pulumi.get(self, "immunity_time_property")

    @immunity_time_property.setter
    def immunity_time_property(self, value: Optional[pulumi.Input['WebAclCaptchaConfigImmunityTimePropertyArgs']]):
        pulumi.set(self, "immunity_time_property", value)


if not MYPY:
    class WebAclCaptchaConfigImmunityTimePropertyArgsDict(TypedDict):
        immunity_time: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    WebAclCaptchaConfigImmunityTimePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclCaptchaConfigImmunityTimePropertyArgs:
    def __init__(__self__, *,
                 immunity_time: Optional[pulumi.Input[_builtins.int]] = None):
        if immunity_time is not None:
            pulumi.set(__self__, "immunity_time", immunity_time)

    @_builtins.property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "immunity_time")

    @immunity_time.setter
    def immunity_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "immunity_time", value)


if not MYPY:
    class WebAclChallengeConfigArgsDict(TypedDict):
        immunity_time_property: NotRequired[pulumi.Input['WebAclChallengeConfigImmunityTimePropertyArgsDict']]
elif False:
    WebAclChallengeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclChallengeConfigArgs:
    def __init__(__self__, *,
                 immunity_time_property: Optional[pulumi.Input['WebAclChallengeConfigImmunityTimePropertyArgs']] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @_builtins.property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional[pulumi.Input['WebAclChallengeConfigImmunityTimePropertyArgs']]:
        return pulumi.get(self, "immunity_time_property")

    @immunity_time_property.setter
    def immunity_time_property(self, value: Optional[pulumi.Input['WebAclChallengeConfigImmunityTimePropertyArgs']]):
        pulumi.set(self, "immunity_time_property", value)


if not MYPY:
    class WebAclChallengeConfigImmunityTimePropertyArgsDict(TypedDict):
        immunity_time: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    WebAclChallengeConfigImmunityTimePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclChallengeConfigImmunityTimePropertyArgs:
    def __init__(__self__, *,
                 immunity_time: Optional[pulumi.Input[_builtins.int]] = None):
        if immunity_time is not None:
            pulumi.set(__self__, "immunity_time", immunity_time)

    @_builtins.property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "immunity_time")

    @immunity_time.setter
    def immunity_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "immunity_time", value)


if not MYPY:
    class WebAclCustomResponseBodyArgsDict(TypedDict):
        content: pulumi.Input[_builtins.str]
        content_type: pulumi.Input[_builtins.str]
        key: pulumi.Input[_builtins.str]
elif False:
    WebAclCustomResponseBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclCustomResponseBodyArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[_builtins.str],
                 content_type: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class WebAclDataProtectionConfigArgsDict(TypedDict):
        data_protections: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclDataProtectionConfigDataProtectionArgsDict']]]]
elif False:
    WebAclDataProtectionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclDataProtectionConfigArgs:
    def __init__(__self__, *,
                 data_protections: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclDataProtectionConfigDataProtectionArgs']]]] = None):
        if data_protections is not None:
            pulumi.set(__self__, "data_protections", data_protections)

    @_builtins.property
    @pulumi.getter(name="dataProtections")
    def data_protections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclDataProtectionConfigDataProtectionArgs']]]]:
        return pulumi.get(self, "data_protections")

    @data_protections.setter
    def data_protections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclDataProtectionConfigDataProtectionArgs']]]]):
        pulumi.set(self, "data_protections", value)


if not MYPY:
    class WebAclDataProtectionConfigDataProtectionArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        field: pulumi.Input['WebAclDataProtectionConfigDataProtectionFieldArgsDict']
        exclude_rate_based_details: NotRequired[pulumi.Input[_builtins.bool]]
        exclude_rule_match_details: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    WebAclDataProtectionConfigDataProtectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclDataProtectionConfigDataProtectionArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 field: pulumi.Input['WebAclDataProtectionConfigDataProtectionFieldArgs'],
                 exclude_rate_based_details: Optional[pulumi.Input[_builtins.bool]] = None,
                 exclude_rule_match_details: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "field", field)
        if exclude_rate_based_details is not None:
            pulumi.set(__self__, "exclude_rate_based_details", exclude_rate_based_details)
        if exclude_rule_match_details is not None:
            pulumi.set(__self__, "exclude_rule_match_details", exclude_rule_match_details)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> pulumi.Input['WebAclDataProtectionConfigDataProtectionFieldArgs']:
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input['WebAclDataProtectionConfigDataProtectionFieldArgs']):
        pulumi.set(self, "field", value)

    @_builtins.property
    @pulumi.getter(name="excludeRateBasedDetails")
    def exclude_rate_based_details(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "exclude_rate_based_details")

    @exclude_rate_based_details.setter
    def exclude_rate_based_details(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exclude_rate_based_details", value)

    @_builtins.property
    @pulumi.getter(name="excludeRuleMatchDetails")
    def exclude_rule_match_details(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "exclude_rule_match_details")

    @exclude_rule_match_details.setter
    def exclude_rule_match_details(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exclude_rule_match_details", value)


if not MYPY:
    class WebAclDataProtectionConfigDataProtectionFieldArgsDict(TypedDict):
        field_type: pulumi.Input[_builtins.str]
        field_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclDataProtectionConfigDataProtectionFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclDataProtectionConfigDataProtectionFieldArgs:
    def __init__(__self__, *,
                 field_type: pulumi.Input[_builtins.str],
                 field_keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "field_type", field_type)
        if field_keys is not None:
            pulumi.set(__self__, "field_keys", field_keys)

    @_builtins.property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "field_type")

    @field_type.setter
    def field_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_type", value)

    @_builtins.property
    @pulumi.getter(name="fieldKeys")
    def field_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "field_keys")

    @field_keys.setter
    def field_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "field_keys", value)


if not MYPY:
    class WebAclDefaultActionArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input['WebAclDefaultActionAllowArgsDict']]
        block: NotRequired[pulumi.Input['WebAclDefaultActionBlockArgsDict']]
elif False:
    WebAclDefaultActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclDefaultActionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['WebAclDefaultActionAllowArgs']] = None,
                 block: Optional[pulumi.Input['WebAclDefaultActionBlockArgs']] = None):
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['WebAclDefaultActionAllowArgs']]:
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['WebAclDefaultActionAllowArgs']]):
        pulumi.set(self, "allow", value)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['WebAclDefaultActionBlockArgs']]:
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['WebAclDefaultActionBlockArgs']]):
        pulumi.set(self, "block", value)


if not MYPY:
    class WebAclDefaultActionAllowArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingArgsDict']]
elif False:
    WebAclDefaultActionAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclDefaultActionAllowArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclDefaultActionAllowCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgsDict']]]
elif False:
    WebAclDefaultActionAllowCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclDefaultActionAllowCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgs']]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclDefaultActionAllowCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclDefaultActionBlockArgsDict(TypedDict):
        custom_response: NotRequired[pulumi.Input['WebAclDefaultActionBlockCustomResponseArgsDict']]
elif False:
    WebAclDefaultActionBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclDefaultActionBlockArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['WebAclDefaultActionBlockCustomResponseArgs']] = None):
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @_builtins.property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['WebAclDefaultActionBlockCustomResponseArgs']]:
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['WebAclDefaultActionBlockCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


if not MYPY:
    class WebAclDefaultActionBlockCustomResponseArgsDict(TypedDict):
        response_code: pulumi.Input[_builtins.int]
        custom_response_body_key: NotRequired[pulumi.Input[_builtins.str]]
        response_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionBlockCustomResponseResponseHeaderArgsDict']]]]
elif False:
    WebAclDefaultActionBlockCustomResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclDefaultActionBlockCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[_builtins.int],
                 custom_response_body_key: Optional[pulumi.Input[_builtins.str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionBlockCustomResponseResponseHeaderArgs']]]] = None):
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "response_code", value)

    @_builtins.property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @_builtins.property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionBlockCustomResponseResponseHeaderArgs']]]]:
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclDefaultActionBlockCustomResponseResponseHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


if not MYPY:
    class WebAclDefaultActionBlockCustomResponseResponseHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclDefaultActionBlockCustomResponseResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclDefaultActionBlockCustomResponseResponseHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclLoggingConfigurationLoggingFilterArgsDict(TypedDict):
        default_behavior: pulumi.Input[_builtins.str]
        filters: pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterArgsDict']]]
elif False:
    WebAclLoggingConfigurationLoggingFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclLoggingConfigurationLoggingFilterArgs:
    def __init__(__self__, *,
                 default_behavior: pulumi.Input[_builtins.str],
                 filters: pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterArgs']]]):
        pulumi.set(__self__, "default_behavior", default_behavior)
        pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter(name="defaultBehavior")
    def default_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "default_behavior")

    @default_behavior.setter
    def default_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_behavior", value)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterArgs']]]:
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterArgs']]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class WebAclLoggingConfigurationLoggingFilterFilterArgsDict(TypedDict):
        behavior: pulumi.Input[_builtins.str]
        conditions: pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionArgsDict']]]
        requirement: pulumi.Input[_builtins.str]
elif False:
    WebAclLoggingConfigurationLoggingFilterFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclLoggingConfigurationLoggingFilterFilterArgs:
    def __init__(__self__, *,
                 behavior: pulumi.Input[_builtins.str],
                 conditions: pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionArgs']]],
                 requirement: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "behavior", behavior)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "requirement", requirement)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "behavior", value)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionArgs']]]:
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter
    def requirement(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "requirement")

    @requirement.setter
    def requirement(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "requirement", value)


if not MYPY:
    class WebAclLoggingConfigurationLoggingFilterFilterConditionArgsDict(TypedDict):
        action_condition: NotRequired[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgsDict']]
        label_name_condition: NotRequired[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgsDict']]
elif False:
    WebAclLoggingConfigurationLoggingFilterFilterConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclLoggingConfigurationLoggingFilterFilterConditionArgs:
    def __init__(__self__, *,
                 action_condition: Optional[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgs']] = None,
                 label_name_condition: Optional[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgs']] = None):
        if action_condition is not None:
            pulumi.set(__self__, "action_condition", action_condition)
        if label_name_condition is not None:
            pulumi.set(__self__, "label_name_condition", label_name_condition)

    @_builtins.property
    @pulumi.getter(name="actionCondition")
    def action_condition(self) -> Optional[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgs']]:
        return pulumi.get(self, "action_condition")

    @action_condition.setter
    def action_condition(self, value: Optional[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgs']]):
        pulumi.set(self, "action_condition", value)

    @_builtins.property
    @pulumi.getter(name="labelNameCondition")
    def label_name_condition(self) -> Optional[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgs']]:
        return pulumi.get(self, "label_name_condition")

    @label_name_condition.setter
    def label_name_condition(self, value: Optional[pulumi.Input['WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgs']]):
        pulumi.set(self, "label_name_condition", value)


if not MYPY:
    class WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
elif False:
    WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclLoggingConfigurationLoggingFilterFilterConditionActionConditionArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "action", action)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)


if not MYPY:
    class WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgsDict(TypedDict):
        label_name: pulumi.Input[_builtins.str]
elif False:
    WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclLoggingConfigurationLoggingFilterFilterConditionLabelNameConditionArgs:
    def __init__(__self__, *,
                 label_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "label_name", label_name)

    @_builtins.property
    @pulumi.getter(name="labelName")
    def label_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "label_name")

    @label_name.setter
    def label_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "label_name", value)


if not MYPY:
    class WebAclLoggingConfigurationRedactedFieldArgsDict(TypedDict):
        method: NotRequired[pulumi.Input['WebAclLoggingConfigurationRedactedFieldMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['WebAclLoggingConfigurationRedactedFieldQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['WebAclLoggingConfigurationRedactedFieldSingleHeaderArgsDict']]
        uri_path: NotRequired[pulumi.Input['WebAclLoggingConfigurationRedactedFieldUriPathArgsDict']]
elif False:
    WebAclLoggingConfigurationRedactedFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclLoggingConfigurationRedactedFieldArgs:
    def __init__(__self__, *,
                 method: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldSingleHeaderArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldUriPathArgs']] = None):
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclLoggingConfigurationRedactedFieldUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclLoggingConfigurationRedactedFieldMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclLoggingConfigurationRedactedFieldMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclLoggingConfigurationRedactedFieldMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclLoggingConfigurationRedactedFieldQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclLoggingConfigurationRedactedFieldQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclLoggingConfigurationRedactedFieldQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclLoggingConfigurationRedactedFieldSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclLoggingConfigurationRedactedFieldSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclLoggingConfigurationRedactedFieldSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclLoggingConfigurationRedactedFieldUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclLoggingConfigurationRedactedFieldUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclLoggingConfigurationRedactedFieldUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        priority: pulumi.Input[_builtins.int]
        statement: pulumi.Input['WebAclRuleStatementArgsDict']
        visibility_config: pulumi.Input['WebAclRuleVisibilityConfigArgsDict']
        action: NotRequired[pulumi.Input['WebAclRuleActionArgsDict']]
        captcha_config: NotRequired[pulumi.Input['WebAclRuleCaptchaConfigArgsDict']]
        challenge_config: NotRequired[pulumi.Input['WebAclRuleChallengeConfigArgsDict']]
        override_action: NotRequired[pulumi.Input['WebAclRuleOverrideActionArgsDict']]
        rule_labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleRuleLabelArgsDict']]]]
elif False:
    WebAclRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 statement: pulumi.Input['WebAclRuleStatementArgs'],
                 visibility_config: pulumi.Input['WebAclRuleVisibilityConfigArgs'],
                 action: Optional[pulumi.Input['WebAclRuleActionArgs']] = None,
                 captcha_config: Optional[pulumi.Input['WebAclRuleCaptchaConfigArgs']] = None,
                 challenge_config: Optional[pulumi.Input['WebAclRuleChallengeConfigArgs']] = None,
                 override_action: Optional[pulumi.Input['WebAclRuleOverrideActionArgs']] = None,
                 rule_labels: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleRuleLabelArgs']]]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "statement", statement)
        pulumi.set(__self__, "visibility_config", visibility_config)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if captcha_config is not None:
            pulumi.set(__self__, "captcha_config", captcha_config)
        if challenge_config is not None:
            pulumi.set(__self__, "challenge_config", challenge_config)
        if override_action is not None:
            pulumi.set(__self__, "override_action", override_action)
        if rule_labels is not None:
            pulumi.set(__self__, "rule_labels", rule_labels)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def statement(self) -> pulumi.Input['WebAclRuleStatementArgs']:
        return pulumi.get(self, "statement")

    @statement.setter
    def statement(self, value: pulumi.Input['WebAclRuleStatementArgs']):
        pulumi.set(self, "statement", value)

    @_builtins.property
    @pulumi.getter(name="visibilityConfig")
    def visibility_config(self) -> pulumi.Input['WebAclRuleVisibilityConfigArgs']:
        return pulumi.get(self, "visibility_config")

    @visibility_config.setter
    def visibility_config(self, value: pulumi.Input['WebAclRuleVisibilityConfigArgs']):
        pulumi.set(self, "visibility_config", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['WebAclRuleActionArgs']]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['WebAclRuleActionArgs']]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="captchaConfig")
    def captcha_config(self) -> Optional[pulumi.Input['WebAclRuleCaptchaConfigArgs']]:
        return pulumi.get(self, "captcha_config")

    @captcha_config.setter
    def captcha_config(self, value: Optional[pulumi.Input['WebAclRuleCaptchaConfigArgs']]):
        pulumi.set(self, "captcha_config", value)

    @_builtins.property
    @pulumi.getter(name="challengeConfig")
    def challenge_config(self) -> Optional[pulumi.Input['WebAclRuleChallengeConfigArgs']]:
        return pulumi.get(self, "challenge_config")

    @challenge_config.setter
    def challenge_config(self, value: Optional[pulumi.Input['WebAclRuleChallengeConfigArgs']]):
        pulumi.set(self, "challenge_config", value)

    @_builtins.property
    @pulumi.getter(name="overrideAction")
    def override_action(self) -> Optional[pulumi.Input['WebAclRuleOverrideActionArgs']]:
        return pulumi.get(self, "override_action")

    @override_action.setter
    def override_action(self, value: Optional[pulumi.Input['WebAclRuleOverrideActionArgs']]):
        pulumi.set(self, "override_action", value)

    @_builtins.property
    @pulumi.getter(name="ruleLabels")
    def rule_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleRuleLabelArgs']]]]:
        return pulumi.get(self, "rule_labels")

    @rule_labels.setter
    def rule_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleRuleLabelArgs']]]]):
        pulumi.set(self, "rule_labels", value)


if not MYPY:
    class WebAclRuleActionArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input['WebAclRuleActionAllowArgsDict']]
        block: NotRequired[pulumi.Input['WebAclRuleActionBlockArgsDict']]
        captcha: NotRequired[pulumi.Input['WebAclRuleActionCaptchaArgsDict']]
        challenge: NotRequired[pulumi.Input['WebAclRuleActionChallengeArgsDict']]
        count: NotRequired[pulumi.Input['WebAclRuleActionCountArgsDict']]
elif False:
    WebAclRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['WebAclRuleActionAllowArgs']] = None,
                 block: Optional[pulumi.Input['WebAclRuleActionBlockArgs']] = None,
                 captcha: Optional[pulumi.Input['WebAclRuleActionCaptchaArgs']] = None,
                 challenge: Optional[pulumi.Input['WebAclRuleActionChallengeArgs']] = None,
                 count: Optional[pulumi.Input['WebAclRuleActionCountArgs']] = None):
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['WebAclRuleActionAllowArgs']]:
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['WebAclRuleActionAllowArgs']]):
        pulumi.set(self, "allow", value)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['WebAclRuleActionBlockArgs']]:
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['WebAclRuleActionBlockArgs']]):
        pulumi.set(self, "block", value)

    @_builtins.property
    @pulumi.getter
    def captcha(self) -> Optional[pulumi.Input['WebAclRuleActionCaptchaArgs']]:
        return pulumi.get(self, "captcha")

    @captcha.setter
    def captcha(self, value: Optional[pulumi.Input['WebAclRuleActionCaptchaArgs']]):
        pulumi.set(self, "captcha", value)

    @_builtins.property
    @pulumi.getter
    def challenge(self) -> Optional[pulumi.Input['WebAclRuleActionChallengeArgs']]:
        return pulumi.get(self, "challenge")

    @challenge.setter
    def challenge(self, value: Optional[pulumi.Input['WebAclRuleActionChallengeArgs']]):
        pulumi.set(self, "challenge", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['WebAclRuleActionCountArgs']]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['WebAclRuleActionCountArgs']]):
        pulumi.set(self, "count", value)


if not MYPY:
    class WebAclRuleActionAllowArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingArgsDict']]
elif False:
    WebAclRuleActionAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionAllowArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleActionAllowCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgsDict']]]
elif False:
    WebAclRuleActionAllowCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionAllowCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionAllowCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleActionBlockArgsDict(TypedDict):
        custom_response: NotRequired[pulumi.Input['WebAclRuleActionBlockCustomResponseArgsDict']]
elif False:
    WebAclRuleActionBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionBlockArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['WebAclRuleActionBlockCustomResponseArgs']] = None):
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @_builtins.property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['WebAclRuleActionBlockCustomResponseArgs']]:
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['WebAclRuleActionBlockCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


if not MYPY:
    class WebAclRuleActionBlockCustomResponseArgsDict(TypedDict):
        response_code: pulumi.Input[_builtins.int]
        custom_response_body_key: NotRequired[pulumi.Input[_builtins.str]]
        response_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionBlockCustomResponseResponseHeaderArgsDict']]]]
elif False:
    WebAclRuleActionBlockCustomResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionBlockCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[_builtins.int],
                 custom_response_body_key: Optional[pulumi.Input[_builtins.str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionBlockCustomResponseResponseHeaderArgs']]]] = None):
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "response_code", value)

    @_builtins.property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @_builtins.property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionBlockCustomResponseResponseHeaderArgs']]]]:
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionBlockCustomResponseResponseHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


if not MYPY:
    class WebAclRuleActionBlockCustomResponseResponseHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleActionBlockCustomResponseResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionBlockCustomResponseResponseHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleActionCaptchaArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingArgsDict']]
elif False:
    WebAclRuleActionCaptchaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionCaptchaArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleActionCaptchaCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgsDict']]]
elif False:
    WebAclRuleActionCaptchaCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionCaptchaCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionCaptchaCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleActionChallengeArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingArgsDict']]
elif False:
    WebAclRuleActionChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionChallengeArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleActionChallengeCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgsDict']]]
elif False:
    WebAclRuleActionChallengeCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionChallengeCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionChallengeCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleActionCountArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingArgsDict']]
elif False:
    WebAclRuleActionCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionCountArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleActionCountCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgsDict']]]
elif False:
    WebAclRuleActionCountCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionCountCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgs']]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleActionCountCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleCaptchaConfigArgsDict(TypedDict):
        immunity_time_property: NotRequired[pulumi.Input['WebAclRuleCaptchaConfigImmunityTimePropertyArgsDict']]
elif False:
    WebAclRuleCaptchaConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleCaptchaConfigArgs:
    def __init__(__self__, *,
                 immunity_time_property: Optional[pulumi.Input['WebAclRuleCaptchaConfigImmunityTimePropertyArgs']] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @_builtins.property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional[pulumi.Input['WebAclRuleCaptchaConfigImmunityTimePropertyArgs']]:
        return pulumi.get(self, "immunity_time_property")

    @immunity_time_property.setter
    def immunity_time_property(self, value: Optional[pulumi.Input['WebAclRuleCaptchaConfigImmunityTimePropertyArgs']]):
        pulumi.set(self, "immunity_time_property", value)


if not MYPY:
    class WebAclRuleCaptchaConfigImmunityTimePropertyArgsDict(TypedDict):
        immunity_time: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    WebAclRuleCaptchaConfigImmunityTimePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleCaptchaConfigImmunityTimePropertyArgs:
    def __init__(__self__, *,
                 immunity_time: Optional[pulumi.Input[_builtins.int]] = None):
        if immunity_time is not None:
            pulumi.set(__self__, "immunity_time", immunity_time)

    @_builtins.property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "immunity_time")

    @immunity_time.setter
    def immunity_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "immunity_time", value)


if not MYPY:
    class WebAclRuleChallengeConfigArgsDict(TypedDict):
        immunity_time_property: NotRequired[pulumi.Input['WebAclRuleChallengeConfigImmunityTimePropertyArgsDict']]
elif False:
    WebAclRuleChallengeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleChallengeConfigArgs:
    def __init__(__self__, *,
                 immunity_time_property: Optional[pulumi.Input['WebAclRuleChallengeConfigImmunityTimePropertyArgs']] = None):
        if immunity_time_property is not None:
            pulumi.set(__self__, "immunity_time_property", immunity_time_property)

    @_builtins.property
    @pulumi.getter(name="immunityTimeProperty")
    def immunity_time_property(self) -> Optional[pulumi.Input['WebAclRuleChallengeConfigImmunityTimePropertyArgs']]:
        return pulumi.get(self, "immunity_time_property")

    @immunity_time_property.setter
    def immunity_time_property(self, value: Optional[pulumi.Input['WebAclRuleChallengeConfigImmunityTimePropertyArgs']]):
        pulumi.set(self, "immunity_time_property", value)


if not MYPY:
    class WebAclRuleChallengeConfigImmunityTimePropertyArgsDict(TypedDict):
        immunity_time: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    WebAclRuleChallengeConfigImmunityTimePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleChallengeConfigImmunityTimePropertyArgs:
    def __init__(__self__, *,
                 immunity_time: Optional[pulumi.Input[_builtins.int]] = None):
        if immunity_time is not None:
            pulumi.set(__self__, "immunity_time", immunity_time)

    @_builtins.property
    @pulumi.getter(name="immunityTime")
    def immunity_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "immunity_time")

    @immunity_time.setter
    def immunity_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "immunity_time", value)


if not MYPY:
    class WebAclRuleGroupAssociationManagedRuleGroupArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the managed rule group.
        """
        vendor_name: pulumi.Input[_builtins.str]
        """
        Name of the managed rule group vendor.
        """
        rule_action_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideArgsDict']]]]
        """
        Action settings to use in place of rule actions configured inside the rule group. You can specify up to 100 overrides.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version of the managed rule group. Omit this to use the default version.
        """
elif False:
    WebAclRuleGroupAssociationManagedRuleGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationManagedRuleGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 vendor_name: pulumi.Input[_builtins.str],
                 rule_action_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideArgs']]]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the managed rule group.
        :param pulumi.Input[_builtins.str] vendor_name: Name of the managed rule group vendor.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideArgs']]] rule_action_overrides: Action settings to use in place of rule actions configured inside the rule group. You can specify up to 100 overrides.
        :param pulumi.Input[_builtins.str] version: Version of the managed rule group. Omit this to use the default version.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vendor_name", vendor_name)
        if rule_action_overrides is not None:
            pulumi.set(__self__, "rule_action_overrides", rule_action_overrides)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the managed rule group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="vendorName")
    def vendor_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the managed rule group vendor.
        """
        return pulumi.get(self, "vendor_name")

    @vendor_name.setter
    def vendor_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vendor_name", value)

    @_builtins.property
    @pulumi.getter(name="ruleActionOverrides")
    def rule_action_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideArgs']]]]:
        """
        Action settings to use in place of rule actions configured inside the rule group. You can specify up to 100 overrides.
        """
        return pulumi.get(self, "rule_action_overrides")

    @rule_action_overrides.setter
    def rule_action_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideArgs']]]]):
        pulumi.set(self, "rule_action_overrides", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version of the managed rule group. Omit this to use the default version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the rule to override.
        """
        action_to_use: NotRequired[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseArgsDict']]
        """
        Action to use in place of the rule action.
        """
elif False:
    WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 action_to_use: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the rule to override.
        :param pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseArgs'] action_to_use: Action to use in place of the rule action.
        """
        pulumi.set(__self__, "name", name)
        if action_to_use is not None:
            pulumi.set(__self__, "action_to_use", action_to_use)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the rule to override.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="actionToUse")
    def action_to_use(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseArgs']]:
        """
        Action to use in place of the rule action.
        """
        return pulumi.get(self, "action_to_use")

    @action_to_use.setter
    def action_to_use(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseArgs']]):
        pulumi.set(self, "action_to_use", value)


if not MYPY:
    class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowArgsDict']]
        block: NotRequired[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockArgsDict']]
        captcha: NotRequired[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaArgsDict']]
        challenge: NotRequired[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeArgsDict']]
        count: NotRequired[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountArgsDict']]
elif False:
    WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowArgs']] = None,
                 block: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockArgs']] = None,
                 captcha: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaArgs']] = None,
                 challenge: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeArgs']] = None,
                 count: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountArgs']] = None):
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowArgs']]:
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowArgs']]):
        pulumi.set(self, "allow", value)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockArgs']]:
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockArgs']]):
        pulumi.set(self, "block", value)

    @_builtins.property
    @pulumi.getter
    def captcha(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaArgs']]:
        return pulumi.get(self, "captcha")

    @captcha.setter
    def captcha(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaArgs']]):
        pulumi.set(self, "captcha", value)

    @_builtins.property
    @pulumi.getter
    def challenge(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeArgs']]:
        return pulumi.get(self, "challenge")

    @challenge.setter
    def challenge(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeArgs']]):
        pulumi.set(self, "challenge", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountArgs']]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountArgs']]):
        pulumi.set(self, "count", value)


if not MYPY:
    class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict']]
elif False:
    WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict']]]]
elif False:
    WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]] = None):
        if insert_headers is not None:
            pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockArgsDict(TypedDict):
        custom_response: NotRequired[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseArgsDict']]
elif False:
    WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseArgs']] = None):
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @_builtins.property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseArgs']]:
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


if not MYPY:
    class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseArgsDict(TypedDict):
        response_code: pulumi.Input[_builtins.int]
        custom_response_body_key: NotRequired[pulumi.Input[_builtins.str]]
        response_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict']]]]
elif False:
    WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[_builtins.int],
                 custom_response_body_key: Optional[pulumi.Input[_builtins.str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]] = None):
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "response_code", value)

    @_builtins.property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @_builtins.property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]]:
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


if not MYPY:
    class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict']]
elif False:
    WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict']]]]
elif False:
    WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]] = None):
        if insert_headers is not None:
            pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict']]
elif False:
    WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict']]]]
elif False:
    WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]] = None):
        if insert_headers is not None:
            pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict']]
elif False:
    WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict']]]]
elif False:
    WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]] = None):
        if insert_headers is not None:
            pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationManagedRuleGroupRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleGroupAssociationRuleGroupReferenceArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        ARN of the Rule Group to associate with the Web ACL.
        """
        rule_action_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideArgsDict']]]]
        """
        Action settings to use in place of rule actions configured inside the rule group. You can specify up to 100 overrides.
        """
elif False:
    WebAclRuleGroupAssociationRuleGroupReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationRuleGroupReferenceArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 rule_action_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] arn: ARN of the Rule Group to associate with the Web ACL.
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideArgs']]] rule_action_overrides: Action settings to use in place of rule actions configured inside the rule group. You can specify up to 100 overrides.
        """
        pulumi.set(__self__, "arn", arn)
        if rule_action_overrides is not None:
            pulumi.set(__self__, "rule_action_overrides", rule_action_overrides)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Rule Group to associate with the Web ACL.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="ruleActionOverrides")
    def rule_action_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideArgs']]]]:
        """
        Action settings to use in place of rule actions configured inside the rule group. You can specify up to 100 overrides.
        """
        return pulumi.get(self, "rule_action_overrides")

    @rule_action_overrides.setter
    def rule_action_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideArgs']]]]):
        pulumi.set(self, "rule_action_overrides", value)


if not MYPY:
    class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the rule to override.
        """
        action_to_use: NotRequired[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseArgsDict']]
        """
        Action to use in place of the rule action.
        """
elif False:
    WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 action_to_use: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the rule to override.
        :param pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseArgs'] action_to_use: Action to use in place of the rule action.
        """
        pulumi.set(__self__, "name", name)
        if action_to_use is not None:
            pulumi.set(__self__, "action_to_use", action_to_use)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the rule to override.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="actionToUse")
    def action_to_use(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseArgs']]:
        """
        Action to use in place of the rule action.
        """
        return pulumi.get(self, "action_to_use")

    @action_to_use.setter
    def action_to_use(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseArgs']]):
        pulumi.set(self, "action_to_use", value)


if not MYPY:
    class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowArgsDict']]
        block: NotRequired[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockArgsDict']]
        captcha: NotRequired[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaArgsDict']]
        challenge: NotRequired[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeArgsDict']]
        count: NotRequired[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountArgsDict']]
elif False:
    WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowArgs']] = None,
                 block: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockArgs']] = None,
                 captcha: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaArgs']] = None,
                 challenge: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeArgs']] = None,
                 count: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountArgs']] = None):
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowArgs']]:
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowArgs']]):
        pulumi.set(self, "allow", value)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockArgs']]:
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockArgs']]):
        pulumi.set(self, "block", value)

    @_builtins.property
    @pulumi.getter
    def captcha(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaArgs']]:
        return pulumi.get(self, "captcha")

    @captcha.setter
    def captcha(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaArgs']]):
        pulumi.set(self, "captcha", value)

    @_builtins.property
    @pulumi.getter
    def challenge(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeArgs']]:
        return pulumi.get(self, "challenge")

    @challenge.setter
    def challenge(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeArgs']]):
        pulumi.set(self, "challenge", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountArgs']]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountArgs']]):
        pulumi.set(self, "count", value)


if not MYPY:
    class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict']]
elif False:
    WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict']]]]
elif False:
    WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]] = None):
        if insert_headers is not None:
            pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockArgsDict(TypedDict):
        custom_response: NotRequired[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseArgsDict']]
elif False:
    WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseArgs']] = None):
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @_builtins.property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseArgs']]:
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


if not MYPY:
    class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseArgsDict(TypedDict):
        response_code: pulumi.Input[_builtins.int]
        custom_response_body_key: NotRequired[pulumi.Input[_builtins.str]]
        response_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict']]]]
elif False:
    WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[_builtins.int],
                 custom_response_body_key: Optional[pulumi.Input[_builtins.str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]] = None):
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "response_code", value)

    @_builtins.property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @_builtins.property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]]:
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


if not MYPY:
    class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict']]
elif False:
    WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict']]]]
elif False:
    WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]] = None):
        if insert_headers is not None:
            pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict']]
elif False:
    WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict']]]]
elif False:
    WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]] = None):
        if insert_headers is not None:
            pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict']]
elif False:
    WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict']]]]
elif False:
    WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]] = None):
        if insert_headers is not None:
            pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationRuleGroupReferenceRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleGroupAssociationTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    WebAclRuleGroupAssociationTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleGroupAssociationTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class WebAclRuleOverrideActionArgsDict(TypedDict):
        count: NotRequired[pulumi.Input['WebAclRuleOverrideActionCountArgsDict']]
        none: NotRequired[pulumi.Input['WebAclRuleOverrideActionNoneArgsDict']]
elif False:
    WebAclRuleOverrideActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleOverrideActionArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input['WebAclRuleOverrideActionCountArgs']] = None,
                 none: Optional[pulumi.Input['WebAclRuleOverrideActionNoneArgs']] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if none is not None:
            pulumi.set(__self__, "none", none)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['WebAclRuleOverrideActionCountArgs']]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['WebAclRuleOverrideActionCountArgs']]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['WebAclRuleOverrideActionNoneArgs']]:
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['WebAclRuleOverrideActionNoneArgs']]):
        pulumi.set(self, "none", value)


if not MYPY:
    class WebAclRuleOverrideActionCountArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleOverrideActionCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleOverrideActionCountArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleOverrideActionNoneArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleOverrideActionNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleOverrideActionNoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleRuleLabelArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleRuleLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleRuleLabelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementArgsDict(TypedDict):
        and_statement: NotRequired[pulumi.Input['WebAclRuleStatementAndStatementArgsDict']]
        asn_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementAsnMatchStatementArgsDict']]
        byte_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementArgsDict']]
        geo_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementGeoMatchStatementArgsDict']]
        ip_set_reference_statement: NotRequired[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementArgsDict']]
        label_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementLabelMatchStatementArgsDict']]
        managed_rule_group_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementArgsDict']]
        not_statement: NotRequired[pulumi.Input['WebAclRuleStatementNotStatementArgsDict']]
        or_statement: NotRequired[pulumi.Input['WebAclRuleStatementOrStatementArgsDict']]
        rate_based_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementArgsDict']]
        regex_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementArgsDict']]
        regex_pattern_set_reference_statement: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementArgsDict']]
        rule_group_reference_statement: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementArgsDict']]
        size_constraint_statement: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementArgsDict']]
        sqli_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementArgsDict']]
        xss_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementArgsDict']]
elif False:
    WebAclRuleStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementArgs:
    def __init__(__self__, *,
                 and_statement: Optional[pulumi.Input['WebAclRuleStatementAndStatementArgs']] = None,
                 asn_match_statement: Optional[pulumi.Input['WebAclRuleStatementAsnMatchStatementArgs']] = None,
                 byte_match_statement: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementArgs']] = None,
                 geo_match_statement: Optional[pulumi.Input['WebAclRuleStatementGeoMatchStatementArgs']] = None,
                 ip_set_reference_statement: Optional[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementArgs']] = None,
                 label_match_statement: Optional[pulumi.Input['WebAclRuleStatementLabelMatchStatementArgs']] = None,
                 managed_rule_group_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementArgs']] = None,
                 not_statement: Optional[pulumi.Input['WebAclRuleStatementNotStatementArgs']] = None,
                 or_statement: Optional[pulumi.Input['WebAclRuleStatementOrStatementArgs']] = None,
                 rate_based_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementArgs']] = None,
                 regex_match_statement: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementArgs']] = None,
                 regex_pattern_set_reference_statement: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementArgs']] = None,
                 rule_group_reference_statement: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementArgs']] = None,
                 size_constraint_statement: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementArgs']] = None,
                 sqli_match_statement: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementArgs']] = None,
                 xss_match_statement: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementArgs']] = None):
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if asn_match_statement is not None:
            pulumi.set(__self__, "asn_match_statement", asn_match_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            pulumi.set(__self__, "ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if managed_rule_group_statement is not None:
            pulumi.set(__self__, "managed_rule_group_statement", managed_rule_group_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if rate_based_statement is not None:
            pulumi.set(__self__, "rate_based_statement", rate_based_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if rule_group_reference_statement is not None:
            pulumi.set(__self__, "rule_group_reference_statement", rule_group_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @_builtins.property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementAndStatementArgs']]:
        return pulumi.get(self, "and_statement")

    @and_statement.setter
    def and_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementAndStatementArgs']]):
        pulumi.set(self, "and_statement", value)

    @_builtins.property
    @pulumi.getter(name="asnMatchStatement")
    def asn_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementAsnMatchStatementArgs']]:
        return pulumi.get(self, "asn_match_statement")

    @asn_match_statement.setter
    def asn_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementAsnMatchStatementArgs']]):
        pulumi.set(self, "asn_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementArgs']]:
        return pulumi.get(self, "byte_match_statement")

    @byte_match_statement.setter
    def byte_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementArgs']]):
        pulumi.set(self, "byte_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementGeoMatchStatementArgs']]:
        return pulumi.get(self, "geo_match_statement")

    @geo_match_statement.setter
    def geo_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementGeoMatchStatementArgs']]):
        pulumi.set(self, "geo_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementArgs']]:
        return pulumi.get(self, "ip_set_reference_statement")

    @ip_set_reference_statement.setter
    def ip_set_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementArgs']]):
        pulumi.set(self, "ip_set_reference_statement", value)

    @_builtins.property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementLabelMatchStatementArgs']]:
        return pulumi.get(self, "label_match_statement")

    @label_match_statement.setter
    def label_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementLabelMatchStatementArgs']]):
        pulumi.set(self, "label_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="managedRuleGroupStatement")
    def managed_rule_group_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementArgs']]:
        return pulumi.get(self, "managed_rule_group_statement")

    @managed_rule_group_statement.setter
    def managed_rule_group_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementArgs']]):
        pulumi.set(self, "managed_rule_group_statement", value)

    @_builtins.property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementNotStatementArgs']]:
        return pulumi.get(self, "not_statement")

    @not_statement.setter
    def not_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementNotStatementArgs']]):
        pulumi.set(self, "not_statement", value)

    @_builtins.property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementOrStatementArgs']]:
        return pulumi.get(self, "or_statement")

    @or_statement.setter
    def or_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementOrStatementArgs']]):
        pulumi.set(self, "or_statement", value)

    @_builtins.property
    @pulumi.getter(name="rateBasedStatement")
    def rate_based_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementArgs']]:
        return pulumi.get(self, "rate_based_statement")

    @rate_based_statement.setter
    def rate_based_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementArgs']]):
        pulumi.set(self, "rate_based_statement", value)

    @_builtins.property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementArgs']]:
        return pulumi.get(self, "regex_match_statement")

    @regex_match_statement.setter
    def regex_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementArgs']]):
        pulumi.set(self, "regex_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementArgs']]:
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @regex_pattern_set_reference_statement.setter
    def regex_pattern_set_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementArgs']]):
        pulumi.set(self, "regex_pattern_set_reference_statement", value)

    @_builtins.property
    @pulumi.getter(name="ruleGroupReferenceStatement")
    def rule_group_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementArgs']]:
        return pulumi.get(self, "rule_group_reference_statement")

    @rule_group_reference_statement.setter
    def rule_group_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementArgs']]):
        pulumi.set(self, "rule_group_reference_statement", value)

    @_builtins.property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementArgs']]:
        return pulumi.get(self, "size_constraint_statement")

    @size_constraint_statement.setter
    def size_constraint_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementArgs']]):
        pulumi.set(self, "size_constraint_statement", value)

    @_builtins.property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementArgs']]:
        return pulumi.get(self, "sqli_match_statement")

    @sqli_match_statement.setter
    def sqli_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementArgs']]):
        pulumi.set(self, "sqli_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementArgs']]:
        return pulumi.get(self, "xss_match_statement")

    @xss_match_statement.setter
    def xss_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementArgs']]):
        pulumi.set(self, "xss_match_statement", value)


if not MYPY:
    class WebAclRuleStatementAndStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    WebAclRuleStatementAndStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementAndStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class WebAclRuleStatementAsnMatchStatementArgsDict(TypedDict):
        asn_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
        forwarded_ip_config: NotRequired[pulumi.Input['WebAclRuleStatementAsnMatchStatementForwardedIpConfigArgsDict']]
elif False:
    WebAclRuleStatementAsnMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementAsnMatchStatementArgs:
    def __init__(__self__, *,
                 asn_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]],
                 forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementAsnMatchStatementForwardedIpConfigArgs']] = None):
        pulumi.set(__self__, "asn_lists", asn_lists)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @_builtins.property
    @pulumi.getter(name="asnLists")
    def asn_lists(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "asn_lists")

    @asn_lists.setter
    def asn_lists(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "asn_lists", value)

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementAsnMatchStatementForwardedIpConfigArgs']]:
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementAsnMatchStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


if not MYPY:
    class WebAclRuleStatementAsnMatchStatementForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
        header_name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementAsnMatchStatementForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementAsnMatchStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str],
                 header_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementArgsDict(TypedDict):
        positional_constraint: pulumi.Input[_builtins.str]
        search_string: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchArgsDict']]
elif False:
    WebAclRuleStatementByteMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementArgs:
    def __init__(__self__, *,
                 positional_constraint: pulumi.Input[_builtins.str],
                 search_string: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "search_string", search_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "positional_constraint")

    @positional_constraint.setter
    def positional_constraint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "positional_constraint", value)

    @_builtins.property
    @pulumi.getter(name="searchString")
    def search_string(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "search_string")

    @search_string.setter
    def search_string(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "search_string", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgsDict']]
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementByteMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementByteMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementByteMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementGeoMatchStatementArgsDict(TypedDict):
        country_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        forwarded_ip_config: NotRequired[pulumi.Input['WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgsDict']]
elif False:
    WebAclRuleStatementGeoMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementGeoMatchStatementArgs:
    def __init__(__self__, *,
                 country_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgs']] = None):
        pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @_builtins.property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "country_codes", value)

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgs']]:
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


if not MYPY:
    class WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
        header_name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementGeoMatchStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str],
                 header_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class WebAclRuleStatementIpSetReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        ip_set_forwarded_ip_config: NotRequired[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict']]
elif False:
    WebAclRuleStatementIpSetReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementIpSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 ip_set_forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']] = None):
        pulumi.set(__self__, "arn", arn)
        if ip_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]:
        return pulumi.get(self, "ip_set_forwarded_ip_config")

    @ip_set_forwarded_ip_config.setter
    def ip_set_forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]):
        pulumi.set(self, "ip_set_forwarded_ip_config", value)


if not MYPY:
    class WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
        header_name: pulumi.Input[_builtins.str]
        position: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str],
                 header_name: pulumi.Input[_builtins.str],
                 position: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header_name", value)

    @_builtins.property
    @pulumi.getter
    def position(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "position", value)


if not MYPY:
    class WebAclRuleStatementLabelMatchStatementArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        scope: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementLabelMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementLabelMatchStatementArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 scope: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        vendor_name: pulumi.Input[_builtins.str]
        managed_rule_group_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgsDict']]]]
        rule_action_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgsDict']]]]
        scope_down_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgsDict']]
        version: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 vendor_name: pulumi.Input[_builtins.str],
                 managed_rule_group_configs: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgs']]]] = None,
                 rule_action_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgs']]]] = None,
                 scope_down_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgs']] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "vendor_name", vendor_name)
        if managed_rule_group_configs is not None:
            pulumi.set(__self__, "managed_rule_group_configs", managed_rule_group_configs)
        if rule_action_overrides is not None:
            pulumi.set(__self__, "rule_action_overrides", rule_action_overrides)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="vendorName")
    def vendor_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "vendor_name")

    @vendor_name.setter
    def vendor_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vendor_name", value)

    @_builtins.property
    @pulumi.getter(name="managedRuleGroupConfigs")
    def managed_rule_group_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgs']]]]:
        return pulumi.get(self, "managed_rule_group_configs")

    @managed_rule_group_configs.setter
    def managed_rule_group_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgs']]]]):
        pulumi.set(self, "managed_rule_group_configs", value)

    @_builtins.property
    @pulumi.getter(name="ruleActionOverrides")
    def rule_action_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgs']]]]:
        return pulumi.get(self, "rule_action_overrides")

    @rule_action_overrides.setter
    def rule_action_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgs']]]]):
        pulumi.set(self, "rule_action_overrides", value)

    @_builtins.property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgs']]:
        return pulumi.get(self, "scope_down_statement")

    @scope_down_statement.setter
    def scope_down_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgs']]):
        pulumi.set(self, "scope_down_statement", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgsDict(TypedDict):
        aws_managed_rules_acfp_rule_set: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgsDict']]
        aws_managed_rules_anti_ddos_rule_set: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetArgsDict']]
        aws_managed_rules_atp_rule_set: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgsDict']]
        aws_managed_rules_bot_control_rule_set: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgsDict']]
        login_path: NotRequired[pulumi.Input[_builtins.str]]
        password_field: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgsDict']]
        payload_type: NotRequired[pulumi.Input[_builtins.str]]
        username_field: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigArgs:
    def __init__(__self__, *,
                 aws_managed_rules_acfp_rule_set: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgs']] = None,
                 aws_managed_rules_anti_ddos_rule_set: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetArgs']] = None,
                 aws_managed_rules_atp_rule_set: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgs']] = None,
                 aws_managed_rules_bot_control_rule_set: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgs']] = None,
                 login_path: Optional[pulumi.Input[_builtins.str]] = None,
                 password_field: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgs']] = None,
                 payload_type: Optional[pulumi.Input[_builtins.str]] = None,
                 username_field: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgs']] = None):
        if aws_managed_rules_acfp_rule_set is not None:
            pulumi.set(__self__, "aws_managed_rules_acfp_rule_set", aws_managed_rules_acfp_rule_set)
        if aws_managed_rules_anti_ddos_rule_set is not None:
            pulumi.set(__self__, "aws_managed_rules_anti_ddos_rule_set", aws_managed_rules_anti_ddos_rule_set)
        if aws_managed_rules_atp_rule_set is not None:
            pulumi.set(__self__, "aws_managed_rules_atp_rule_set", aws_managed_rules_atp_rule_set)
        if aws_managed_rules_bot_control_rule_set is not None:
            pulumi.set(__self__, "aws_managed_rules_bot_control_rule_set", aws_managed_rules_bot_control_rule_set)
        if login_path is not None:
            pulumi.set(__self__, "login_path", login_path)
        if password_field is not None:
            pulumi.set(__self__, "password_field", password_field)
        if payload_type is not None:
            pulumi.set(__self__, "payload_type", payload_type)
        if username_field is not None:
            pulumi.set(__self__, "username_field", username_field)

    @_builtins.property
    @pulumi.getter(name="awsManagedRulesAcfpRuleSet")
    def aws_managed_rules_acfp_rule_set(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgs']]:
        return pulumi.get(self, "aws_managed_rules_acfp_rule_set")

    @aws_managed_rules_acfp_rule_set.setter
    def aws_managed_rules_acfp_rule_set(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgs']]):
        pulumi.set(self, "aws_managed_rules_acfp_rule_set", value)

    @_builtins.property
    @pulumi.getter(name="awsManagedRulesAntiDdosRuleSet")
    def aws_managed_rules_anti_ddos_rule_set(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetArgs']]:
        return pulumi.get(self, "aws_managed_rules_anti_ddos_rule_set")

    @aws_managed_rules_anti_ddos_rule_set.setter
    def aws_managed_rules_anti_ddos_rule_set(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetArgs']]):
        pulumi.set(self, "aws_managed_rules_anti_ddos_rule_set", value)

    @_builtins.property
    @pulumi.getter(name="awsManagedRulesAtpRuleSet")
    def aws_managed_rules_atp_rule_set(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgs']]:
        return pulumi.get(self, "aws_managed_rules_atp_rule_set")

    @aws_managed_rules_atp_rule_set.setter
    def aws_managed_rules_atp_rule_set(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgs']]):
        pulumi.set(self, "aws_managed_rules_atp_rule_set", value)

    @_builtins.property
    @pulumi.getter(name="awsManagedRulesBotControlRuleSet")
    def aws_managed_rules_bot_control_rule_set(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgs']]:
        return pulumi.get(self, "aws_managed_rules_bot_control_rule_set")

    @aws_managed_rules_bot_control_rule_set.setter
    def aws_managed_rules_bot_control_rule_set(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgs']]):
        pulumi.set(self, "aws_managed_rules_bot_control_rule_set", value)

    @_builtins.property
    @pulumi.getter(name="loginPath")
    def login_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "login_path")

    @login_path.setter
    def login_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "login_path", value)

    @_builtins.property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgs']]:
        return pulumi.get(self, "password_field")

    @password_field.setter
    def password_field(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgs']]):
        pulumi.set(self, "password_field", value)

    @_builtins.property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "payload_type")

    @payload_type.setter
    def payload_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload_type", value)

    @_builtins.property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgs']]:
        return pulumi.get(self, "username_field")

    @username_field.setter
    def username_field(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgs']]):
        pulumi.set(self, "username_field", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgsDict(TypedDict):
        creation_path: pulumi.Input[_builtins.str]
        registration_page_path: pulumi.Input[_builtins.str]
        request_inspection: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgsDict']
        enable_regex_in_path: NotRequired[pulumi.Input[_builtins.bool]]
        response_inspection: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetArgs:
    def __init__(__self__, *,
                 creation_path: pulumi.Input[_builtins.str],
                 registration_page_path: pulumi.Input[_builtins.str],
                 request_inspection: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgs'],
                 enable_regex_in_path: Optional[pulumi.Input[_builtins.bool]] = None,
                 response_inspection: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgs']] = None):
        pulumi.set(__self__, "creation_path", creation_path)
        pulumi.set(__self__, "registration_page_path", registration_page_path)
        pulumi.set(__self__, "request_inspection", request_inspection)
        if enable_regex_in_path is not None:
            pulumi.set(__self__, "enable_regex_in_path", enable_regex_in_path)
        if response_inspection is not None:
            pulumi.set(__self__, "response_inspection", response_inspection)

    @_builtins.property
    @pulumi.getter(name="creationPath")
    def creation_path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "creation_path")

    @creation_path.setter
    def creation_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "creation_path", value)

    @_builtins.property
    @pulumi.getter(name="registrationPagePath")
    def registration_page_path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "registration_page_path")

    @registration_page_path.setter
    def registration_page_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "registration_page_path", value)

    @_builtins.property
    @pulumi.getter(name="requestInspection")
    def request_inspection(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgs']:
        return pulumi.get(self, "request_inspection")

    @request_inspection.setter
    def request_inspection(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgs']):
        pulumi.set(self, "request_inspection", value)

    @_builtins.property
    @pulumi.getter(name="enableRegexInPath")
    def enable_regex_in_path(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enable_regex_in_path")

    @enable_regex_in_path.setter
    def enable_regex_in_path(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_regex_in_path", value)

    @_builtins.property
    @pulumi.getter(name="responseInspection")
    def response_inspection(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgs']]:
        return pulumi.get(self, "response_inspection")

    @response_inspection.setter
    def response_inspection(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgs']]):
        pulumi.set(self, "response_inspection", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgsDict(TypedDict):
        payload_type: pulumi.Input[_builtins.str]
        address_fields: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFieldsArgsDict']]
        email_field: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgsDict']]
        password_field: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgsDict']]
        phone_number_fields: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFieldsArgsDict']]
        username_field: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionArgs:
    def __init__(__self__, *,
                 payload_type: pulumi.Input[_builtins.str],
                 address_fields: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFieldsArgs']] = None,
                 email_field: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgs']] = None,
                 password_field: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgs']] = None,
                 phone_number_fields: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFieldsArgs']] = None,
                 username_field: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgs']] = None):
        pulumi.set(__self__, "payload_type", payload_type)
        if address_fields is not None:
            pulumi.set(__self__, "address_fields", address_fields)
        if email_field is not None:
            pulumi.set(__self__, "email_field", email_field)
        if password_field is not None:
            pulumi.set(__self__, "password_field", password_field)
        if phone_number_fields is not None:
            pulumi.set(__self__, "phone_number_fields", phone_number_fields)
        if username_field is not None:
            pulumi.set(__self__, "username_field", username_field)

    @_builtins.property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "payload_type")

    @payload_type.setter
    def payload_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "payload_type", value)

    @_builtins.property
    @pulumi.getter(name="addressFields")
    def address_fields(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFieldsArgs']]:
        return pulumi.get(self, "address_fields")

    @address_fields.setter
    def address_fields(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFieldsArgs']]):
        pulumi.set(self, "address_fields", value)

    @_builtins.property
    @pulumi.getter(name="emailField")
    def email_field(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgs']]:
        return pulumi.get(self, "email_field")

    @email_field.setter
    def email_field(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgs']]):
        pulumi.set(self, "email_field", value)

    @_builtins.property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgs']]:
        return pulumi.get(self, "password_field")

    @password_field.setter
    def password_field(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgs']]):
        pulumi.set(self, "password_field", value)

    @_builtins.property
    @pulumi.getter(name="phoneNumberFields")
    def phone_number_fields(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFieldsArgs']]:
        return pulumi.get(self, "phone_number_fields")

    @phone_number_fields.setter
    def phone_number_fields(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFieldsArgs']]):
        pulumi.set(self, "phone_number_fields", value)

    @_builtins.property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgs']]:
        return pulumi.get(self, "username_field")

    @username_field.setter
    def username_field(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgs']]):
        pulumi.set(self, "username_field", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFieldsArgsDict(TypedDict):
        identifiers: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionAddressFieldsArgs:
    def __init__(__self__, *,
                 identifiers: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "identifiers", identifiers)

    @_builtins.property
    @pulumi.getter
    def identifiers(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "identifiers")

    @identifiers.setter
    def identifiers(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "identifiers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgsDict(TypedDict):
        identifier: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionEmailFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "identifier", identifier)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identifier", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgsDict(TypedDict):
        identifier: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPasswordFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "identifier", identifier)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identifier", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFieldsArgsDict(TypedDict):
        identifiers: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionPhoneNumberFieldsArgs:
    def __init__(__self__, *,
                 identifiers: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "identifiers", identifiers)

    @_builtins.property
    @pulumi.getter
    def identifiers(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "identifiers")

    @identifiers.setter
    def identifiers(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "identifiers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgsDict(TypedDict):
        identifier: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetRequestInspectionUsernameFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "identifier", identifier)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identifier", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgsDict(TypedDict):
        body_contains: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgsDict']]
        header: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgsDict']]
        json: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgsDict']]
        status_code: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionArgs:
    def __init__(__self__, *,
                 body_contains: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgs']] = None,
                 header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgs']] = None,
                 json: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgs']] = None,
                 status_code: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgs']] = None):
        if body_contains is not None:
            pulumi.set(__self__, "body_contains", body_contains)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @_builtins.property
    @pulumi.getter(name="bodyContains")
    def body_contains(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgs']]:
        return pulumi.get(self, "body_contains")

    @body_contains.setter
    def body_contains(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgs']]):
        pulumi.set(self, "body_contains", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgs']]:
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgs']]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgs']]:
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgs']]):
        pulumi.set(self, "json", value)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgs']]:
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgs']]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgsDict(TypedDict):
        failure_strings: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        success_strings: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionBodyContainsArgs:
    def __init__(__self__, *,
                 failure_strings: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 success_strings: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "failure_strings", failure_strings)
        pulumi.set(__self__, "success_strings", success_strings)

    @_builtins.property
    @pulumi.getter(name="failureStrings")
    def failure_strings(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "failure_strings")

    @failure_strings.setter
    def failure_strings(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "failure_strings", value)

    @_builtins.property
    @pulumi.getter(name="successStrings")
    def success_strings(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "success_strings")

    @success_strings.setter
    def success_strings(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "success_strings", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgsDict(TypedDict):
        failure_values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        name: pulumi.Input[_builtins.str]
        success_values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionHeaderArgs:
    def __init__(__self__, *,
                 failure_values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 name: pulumi.Input[_builtins.str],
                 success_values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "failure_values", failure_values)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "success_values", success_values)

    @_builtins.property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "failure_values")

    @failure_values.setter
    def failure_values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "failure_values", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="successValues")
    def success_values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "success_values")

    @success_values.setter
    def success_values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "success_values", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgsDict(TypedDict):
        failure_values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        identifier: pulumi.Input[_builtins.str]
        success_values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionJsonArgs:
    def __init__(__self__, *,
                 failure_values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 identifier: pulumi.Input[_builtins.str],
                 success_values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "failure_values", failure_values)
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "success_values", success_values)

    @_builtins.property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "failure_values")

    @failure_values.setter
    def failure_values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "failure_values", value)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identifier", value)

    @_builtins.property
    @pulumi.getter(name="successValues")
    def success_values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "success_values")

    @success_values.setter
    def success_values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "success_values", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgsDict(TypedDict):
        failure_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
        success_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAcfpRuleSetResponseInspectionStatusCodeArgs:
    def __init__(__self__, *,
                 failure_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]],
                 success_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(__self__, "failure_codes", failure_codes)
        pulumi.set(__self__, "success_codes", success_codes)

    @_builtins.property
    @pulumi.getter(name="failureCodes")
    def failure_codes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "failure_codes")

    @failure_codes.setter
    def failure_codes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "failure_codes", value)

    @_builtins.property
    @pulumi.getter(name="successCodes")
    def success_codes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "success_codes")

    @success_codes.setter
    def success_codes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "success_codes", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetArgsDict(TypedDict):
        client_side_action_config: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigArgsDict']
        sensitivity_to_block: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetArgs:
    def __init__(__self__, *,
                 client_side_action_config: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigArgs'],
                 sensitivity_to_block: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "client_side_action_config", client_side_action_config)
        if sensitivity_to_block is not None:
            pulumi.set(__self__, "sensitivity_to_block", sensitivity_to_block)

    @_builtins.property
    @pulumi.getter(name="clientSideActionConfig")
    def client_side_action_config(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigArgs']:
        return pulumi.get(self, "client_side_action_config")

    @client_side_action_config.setter
    def client_side_action_config(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigArgs']):
        pulumi.set(self, "client_side_action_config", value)

    @_builtins.property
    @pulumi.getter(name="sensitivityToBlock")
    def sensitivity_to_block(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sensitivity_to_block")

    @sensitivity_to_block.setter
    def sensitivity_to_block(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sensitivity_to_block", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigArgsDict(TypedDict):
        challenge: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeArgsDict']
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigArgs:
    def __init__(__self__, *,
                 challenge: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeArgs']):
        pulumi.set(__self__, "challenge", challenge)

    @_builtins.property
    @pulumi.getter
    def challenge(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeArgs']:
        return pulumi.get(self, "challenge")

    @challenge.setter
    def challenge(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeArgs']):
        pulumi.set(self, "challenge", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeArgsDict(TypedDict):
        usage_of_action: pulumi.Input[_builtins.str]
        exempt_uri_regular_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeExemptUriRegularExpressionArgsDict']]]]
        sensitivity: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeArgs:
    def __init__(__self__, *,
                 usage_of_action: pulumi.Input[_builtins.str],
                 exempt_uri_regular_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeExemptUriRegularExpressionArgs']]]] = None,
                 sensitivity: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "usage_of_action", usage_of_action)
        if exempt_uri_regular_expressions is not None:
            pulumi.set(__self__, "exempt_uri_regular_expressions", exempt_uri_regular_expressions)
        if sensitivity is not None:
            pulumi.set(__self__, "sensitivity", sensitivity)

    @_builtins.property
    @pulumi.getter(name="usageOfAction")
    def usage_of_action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "usage_of_action")

    @usage_of_action.setter
    def usage_of_action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "usage_of_action", value)

    @_builtins.property
    @pulumi.getter(name="exemptUriRegularExpressions")
    def exempt_uri_regular_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeExemptUriRegularExpressionArgs']]]]:
        return pulumi.get(self, "exempt_uri_regular_expressions")

    @exempt_uri_regular_expressions.setter
    def exempt_uri_regular_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeExemptUriRegularExpressionArgs']]]]):
        pulumi.set(self, "exempt_uri_regular_expressions", value)

    @_builtins.property
    @pulumi.getter
    def sensitivity(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sensitivity")

    @sensitivity.setter
    def sensitivity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sensitivity", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeExemptUriRegularExpressionArgsDict(TypedDict):
        regex_string: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeExemptUriRegularExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAntiDdosRuleSetClientSideActionConfigChallengeExemptUriRegularExpressionArgs:
    def __init__(__self__, *,
                 regex_string: Optional[pulumi.Input[_builtins.str]] = None):
        if regex_string is not None:
            pulumi.set(__self__, "regex_string", regex_string)

    @_builtins.property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex_string", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgsDict(TypedDict):
        login_path: pulumi.Input[_builtins.str]
        enable_regex_in_path: NotRequired[pulumi.Input[_builtins.bool]]
        request_inspection: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgsDict']]
        response_inspection: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetArgs:
    def __init__(__self__, *,
                 login_path: pulumi.Input[_builtins.str],
                 enable_regex_in_path: Optional[pulumi.Input[_builtins.bool]] = None,
                 request_inspection: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgs']] = None,
                 response_inspection: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgs']] = None):
        pulumi.set(__self__, "login_path", login_path)
        if enable_regex_in_path is not None:
            pulumi.set(__self__, "enable_regex_in_path", enable_regex_in_path)
        if request_inspection is not None:
            pulumi.set(__self__, "request_inspection", request_inspection)
        if response_inspection is not None:
            pulumi.set(__self__, "response_inspection", response_inspection)

    @_builtins.property
    @pulumi.getter(name="loginPath")
    def login_path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "login_path")

    @login_path.setter
    def login_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "login_path", value)

    @_builtins.property
    @pulumi.getter(name="enableRegexInPath")
    def enable_regex_in_path(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enable_regex_in_path")

    @enable_regex_in_path.setter
    def enable_regex_in_path(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_regex_in_path", value)

    @_builtins.property
    @pulumi.getter(name="requestInspection")
    def request_inspection(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgs']]:
        return pulumi.get(self, "request_inspection")

    @request_inspection.setter
    def request_inspection(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgs']]):
        pulumi.set(self, "request_inspection", value)

    @_builtins.property
    @pulumi.getter(name="responseInspection")
    def response_inspection(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgs']]:
        return pulumi.get(self, "response_inspection")

    @response_inspection.setter
    def response_inspection(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgs']]):
        pulumi.set(self, "response_inspection", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgsDict(TypedDict):
        password_field: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgsDict']
        payload_type: pulumi.Input[_builtins.str]
        username_field: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgsDict']
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionArgs:
    def __init__(__self__, *,
                 password_field: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgs'],
                 payload_type: pulumi.Input[_builtins.str],
                 username_field: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgs']):
        pulumi.set(__self__, "password_field", password_field)
        pulumi.set(__self__, "payload_type", payload_type)
        pulumi.set(__self__, "username_field", username_field)

    @_builtins.property
    @pulumi.getter(name="passwordField")
    def password_field(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgs']:
        return pulumi.get(self, "password_field")

    @password_field.setter
    def password_field(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgs']):
        pulumi.set(self, "password_field", value)

    @_builtins.property
    @pulumi.getter(name="payloadType")
    def payload_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "payload_type")

    @payload_type.setter
    def payload_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "payload_type", value)

    @_builtins.property
    @pulumi.getter(name="usernameField")
    def username_field(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgs']:
        return pulumi.get(self, "username_field")

    @username_field.setter
    def username_field(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgs']):
        pulumi.set(self, "username_field", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgsDict(TypedDict):
        identifier: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionPasswordFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "identifier", identifier)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identifier", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgsDict(TypedDict):
        identifier: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetRequestInspectionUsernameFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "identifier", identifier)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identifier", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgsDict(TypedDict):
        body_contains: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgsDict']]
        header: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgsDict']]
        json: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgsDict']]
        status_code: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionArgs:
    def __init__(__self__, *,
                 body_contains: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgs']] = None,
                 header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgs']] = None,
                 json: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgs']] = None,
                 status_code: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgs']] = None):
        if body_contains is not None:
            pulumi.set(__self__, "body_contains", body_contains)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @_builtins.property
    @pulumi.getter(name="bodyContains")
    def body_contains(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgs']]:
        return pulumi.get(self, "body_contains")

    @body_contains.setter
    def body_contains(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgs']]):
        pulumi.set(self, "body_contains", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgs']]:
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgs']]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgs']]:
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgs']]):
        pulumi.set(self, "json", value)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgs']]:
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgs']]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgsDict(TypedDict):
        failure_strings: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        success_strings: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionBodyContainsArgs:
    def __init__(__self__, *,
                 failure_strings: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 success_strings: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "failure_strings", failure_strings)
        pulumi.set(__self__, "success_strings", success_strings)

    @_builtins.property
    @pulumi.getter(name="failureStrings")
    def failure_strings(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "failure_strings")

    @failure_strings.setter
    def failure_strings(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "failure_strings", value)

    @_builtins.property
    @pulumi.getter(name="successStrings")
    def success_strings(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "success_strings")

    @success_strings.setter
    def success_strings(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "success_strings", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgsDict(TypedDict):
        failure_values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        name: pulumi.Input[_builtins.str]
        success_values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionHeaderArgs:
    def __init__(__self__, *,
                 failure_values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 name: pulumi.Input[_builtins.str],
                 success_values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "failure_values", failure_values)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "success_values", success_values)

    @_builtins.property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "failure_values")

    @failure_values.setter
    def failure_values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "failure_values", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="successValues")
    def success_values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "success_values")

    @success_values.setter
    def success_values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "success_values", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgsDict(TypedDict):
        failure_values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        identifier: pulumi.Input[_builtins.str]
        success_values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionJsonArgs:
    def __init__(__self__, *,
                 failure_values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 identifier: pulumi.Input[_builtins.str],
                 success_values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "failure_values", failure_values)
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "success_values", success_values)

    @_builtins.property
    @pulumi.getter(name="failureValues")
    def failure_values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "failure_values")

    @failure_values.setter
    def failure_values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "failure_values", value)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identifier", value)

    @_builtins.property
    @pulumi.getter(name="successValues")
    def success_values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "success_values")

    @success_values.setter
    def success_values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "success_values", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgsDict(TypedDict):
        failure_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
        success_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesAtpRuleSetResponseInspectionStatusCodeArgs:
    def __init__(__self__, *,
                 failure_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]],
                 success_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(__self__, "failure_codes", failure_codes)
        pulumi.set(__self__, "success_codes", success_codes)

    @_builtins.property
    @pulumi.getter(name="failureCodes")
    def failure_codes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "failure_codes")

    @failure_codes.setter
    def failure_codes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "failure_codes", value)

    @_builtins.property
    @pulumi.getter(name="successCodes")
    def success_codes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "success_codes")

    @success_codes.setter
    def success_codes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "success_codes", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgsDict(TypedDict):
        inspection_level: pulumi.Input[_builtins.str]
        enable_machine_learning: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigAwsManagedRulesBotControlRuleSetArgs:
    def __init__(__self__, *,
                 inspection_level: pulumi.Input[_builtins.str],
                 enable_machine_learning: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "inspection_level", inspection_level)
        if enable_machine_learning is not None:
            pulumi.set(__self__, "enable_machine_learning", enable_machine_learning)

    @_builtins.property
    @pulumi.getter(name="inspectionLevel")
    def inspection_level(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "inspection_level")

    @inspection_level.setter
    def inspection_level(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "inspection_level", value)

    @_builtins.property
    @pulumi.getter(name="enableMachineLearning")
    def enable_machine_learning(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enable_machine_learning")

    @enable_machine_learning.setter
    def enable_machine_learning(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_machine_learning", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgsDict(TypedDict):
        identifier: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigPasswordFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "identifier", identifier)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identifier", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgsDict(TypedDict):
        identifier: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementManagedRuleGroupConfigUsernameFieldArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "identifier", identifier)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identifier", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgsDict(TypedDict):
        action_to_use: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgsDict']
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideArgs:
    def __init__(__self__, *,
                 action_to_use: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgs'],
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "action_to_use", action_to_use)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="actionToUse")
    def action_to_use(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgs']:
        return pulumi.get(self, "action_to_use")

    @action_to_use.setter
    def action_to_use(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgs']):
        pulumi.set(self, "action_to_use", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgsDict']]
        block: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgsDict']]
        captcha: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgsDict']]
        challenge: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgsDict']]
        count: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgs']] = None,
                 block: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgs']] = None,
                 captcha: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgs']] = None,
                 challenge: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgs']] = None,
                 count: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgs']] = None):
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgs']]:
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgs']]):
        pulumi.set(self, "allow", value)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgs']]:
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgs']]):
        pulumi.set(self, "block", value)

    @_builtins.property
    @pulumi.getter
    def captcha(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgs']]:
        return pulumi.get(self, "captcha")

    @captcha.setter
    def captcha(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgs']]):
        pulumi.set(self, "captcha", value)

    @_builtins.property
    @pulumi.getter
    def challenge(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgs']]:
        return pulumi.get(self, "challenge")

    @challenge.setter
    def challenge(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgs']]):
        pulumi.set(self, "challenge", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgs']]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgs']]):
        pulumi.set(self, "count", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict']]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgsDict(TypedDict):
        custom_response: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgs']] = None):
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @_builtins.property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgs']]:
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgsDict(TypedDict):
        response_code: pulumi.Input[_builtins.int]
        custom_response_body_key: NotRequired[pulumi.Input[_builtins.str]]
        response_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict']]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[_builtins.int],
                 custom_response_body_key: Optional[pulumi.Input[_builtins.str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]] = None):
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "response_code", value)

    @_builtins.property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @_builtins.property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]]:
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict']]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict']]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict']]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgsDict(TypedDict):
        and_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgsDict']]
        asn_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementArgsDict']]
        byte_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgsDict']]
        geo_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgsDict']]
        ip_set_reference_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgsDict']]
        label_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgsDict']]
        not_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgsDict']]
        or_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgsDict']]
        regex_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgsDict']]
        regex_pattern_set_reference_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict']]
        size_constraint_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgsDict']]
        sqli_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgsDict']]
        xss_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementArgs:
    def __init__(__self__, *,
                 and_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgs']] = None,
                 asn_match_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementArgs']] = None,
                 byte_match_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgs']] = None,
                 geo_match_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgs']] = None,
                 ip_set_reference_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgs']] = None,
                 label_match_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgs']] = None,
                 not_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgs']] = None,
                 or_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgs']] = None,
                 regex_match_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgs']] = None,
                 regex_pattern_set_reference_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']] = None,
                 size_constraint_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgs']] = None,
                 sqli_match_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgs']] = None,
                 xss_match_statement: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgs']] = None):
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if asn_match_statement is not None:
            pulumi.set(__self__, "asn_match_statement", asn_match_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            pulumi.set(__self__, "ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @_builtins.property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgs']]:
        return pulumi.get(self, "and_statement")

    @and_statement.setter
    def and_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgs']]):
        pulumi.set(self, "and_statement", value)

    @_builtins.property
    @pulumi.getter(name="asnMatchStatement")
    def asn_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementArgs']]:
        return pulumi.get(self, "asn_match_statement")

    @asn_match_statement.setter
    def asn_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementArgs']]):
        pulumi.set(self, "asn_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgs']]:
        return pulumi.get(self, "byte_match_statement")

    @byte_match_statement.setter
    def byte_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgs']]):
        pulumi.set(self, "byte_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgs']]:
        return pulumi.get(self, "geo_match_statement")

    @geo_match_statement.setter
    def geo_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgs']]):
        pulumi.set(self, "geo_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgs']]:
        return pulumi.get(self, "ip_set_reference_statement")

    @ip_set_reference_statement.setter
    def ip_set_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgs']]):
        pulumi.set(self, "ip_set_reference_statement", value)

    @_builtins.property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgs']]:
        return pulumi.get(self, "label_match_statement")

    @label_match_statement.setter
    def label_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgs']]):
        pulumi.set(self, "label_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgs']]:
        return pulumi.get(self, "not_statement")

    @not_statement.setter
    def not_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgs']]):
        pulumi.set(self, "not_statement", value)

    @_builtins.property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgs']]:
        return pulumi.get(self, "or_statement")

    @or_statement.setter
    def or_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgs']]):
        pulumi.set(self, "or_statement", value)

    @_builtins.property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgs']]:
        return pulumi.get(self, "regex_match_statement")

    @regex_match_statement.setter
    def regex_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgs']]):
        pulumi.set(self, "regex_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']]:
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @regex_pattern_set_reference_statement.setter
    def regex_pattern_set_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']]):
        pulumi.set(self, "regex_pattern_set_reference_statement", value)

    @_builtins.property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgs']]:
        return pulumi.get(self, "size_constraint_statement")

    @size_constraint_statement.setter
    def size_constraint_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgs']]):
        pulumi.set(self, "size_constraint_statement", value)

    @_builtins.property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgs']]:
        return pulumi.get(self, "sqli_match_statement")

    @sqli_match_statement.setter
    def sqli_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgs']]):
        pulumi.set(self, "sqli_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgs']]:
        return pulumi.get(self, "xss_match_statement")

    @xss_match_statement.setter
    def xss_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgs']]):
        pulumi.set(self, "xss_match_statement", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAndStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementArgsDict(TypedDict):
        asn_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
        forwarded_ip_config: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementArgs:
    def __init__(__self__, *,
                 asn_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]],
                 forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgs']] = None):
        pulumi.set(__self__, "asn_lists", asn_lists)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @_builtins.property
    @pulumi.getter(name="asnLists")
    def asn_lists(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "asn_lists")

    @asn_lists.setter
    def asn_lists(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "asn_lists", value)

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgs']]:
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
        header_name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str],
                 header_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgsDict(TypedDict):
        positional_constraint: pulumi.Input[_builtins.str]
        search_string: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementArgs:
    def __init__(__self__, *,
                 positional_constraint: pulumi.Input[_builtins.str],
                 search_string: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "search_string", search_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "positional_constraint")

    @positional_constraint.setter
    def positional_constraint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "positional_constraint", value)

    @_builtins.property
    @pulumi.getter(name="searchString")
    def search_string(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "search_string")

    @search_string.setter
    def search_string(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "search_string", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementByteMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgsDict(TypedDict):
        country_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        forwarded_ip_config: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementArgs:
    def __init__(__self__, *,
                 country_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']] = None):
        pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @_builtins.property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "country_codes", value)

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']]:
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
        header_name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str],
                 header_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        ip_set_forwarded_ip_config: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 ip_set_forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']] = None):
        pulumi.set(__self__, "arn", arn)
        if ip_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]:
        return pulumi.get(self, "ip_set_forwarded_ip_config")

    @ip_set_forwarded_ip_config.setter
    def ip_set_forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]):
        pulumi.set(self, "ip_set_forwarded_ip_config", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
        header_name: pulumi.Input[_builtins.str]
        position: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str],
                 header_name: pulumi.Input[_builtins.str],
                 position: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header_name", value)

    @_builtins.property
    @pulumi.getter
    def position(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "position", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        scope: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementLabelMatchStatementArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 scope: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementNotStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementOrStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgsDict(TypedDict):
        regex_string: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementArgs:
    def __init__(__self__, *,
                 regex_string: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "regex_string", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgsDict(TypedDict):
        comparison_operator: pulumi.Input[_builtins.str]
        size: pulumi.Input[_builtins.int]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[_builtins.str],
                 size: pulumi.Input[_builtins.int],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "comparison_operator", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict']]
        sensitivity_level: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']] = None,
                 sensitivity_level: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)

    @_builtins.property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sensitivity_level", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementSqliMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict']]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementManagedRuleGroupStatementScopeDownStatementXssMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementNotStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    WebAclRuleStatementNotStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementNotStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class WebAclRuleStatementOrStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    WebAclRuleStatementOrStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementOrStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementArgsDict(TypedDict):
        limit: pulumi.Input[_builtins.int]
        aggregate_key_type: NotRequired[pulumi.Input[_builtins.str]]
        custom_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyArgsDict']]]]
        evaluation_window_sec: NotRequired[pulumi.Input[_builtins.int]]
        forwarded_ip_config: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementForwardedIpConfigArgsDict']]
        scope_down_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementArgsDict']]
elif False:
    WebAclRuleStatementRateBasedStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementArgs:
    def __init__(__self__, *,
                 limit: pulumi.Input[_builtins.int],
                 aggregate_key_type: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_keys: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyArgs']]]] = None,
                 evaluation_window_sec: Optional[pulumi.Input[_builtins.int]] = None,
                 forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementForwardedIpConfigArgs']] = None,
                 scope_down_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementArgs']] = None):
        pulumi.set(__self__, "limit", limit)
        if aggregate_key_type is not None:
            pulumi.set(__self__, "aggregate_key_type", aggregate_key_type)
        if custom_keys is not None:
            pulumi.set(__self__, "custom_keys", custom_keys)
        if evaluation_window_sec is not None:
            pulumi.set(__self__, "evaluation_window_sec", evaluation_window_sec)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)
        if scope_down_statement is not None:
            pulumi.set(__self__, "scope_down_statement", scope_down_statement)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter(name="aggregateKeyType")
    def aggregate_key_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "aggregate_key_type")

    @aggregate_key_type.setter
    def aggregate_key_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aggregate_key_type", value)

    @_builtins.property
    @pulumi.getter(name="customKeys")
    def custom_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyArgs']]]]:
        return pulumi.get(self, "custom_keys")

    @custom_keys.setter
    def custom_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyArgs']]]]):
        pulumi.set(self, "custom_keys", value)

    @_builtins.property
    @pulumi.getter(name="evaluationWindowSec")
    def evaluation_window_sec(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "evaluation_window_sec")

    @evaluation_window_sec.setter
    def evaluation_window_sec(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "evaluation_window_sec", value)

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementForwardedIpConfigArgs']]:
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)

    @_builtins.property
    @pulumi.getter(name="scopeDownStatement")
    def scope_down_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementArgs']]:
        return pulumi.get(self, "scope_down_statement")

    @scope_down_statement.setter
    def scope_down_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementArgs']]):
        pulumi.set(self, "scope_down_statement", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyArgsDict(TypedDict):
        asn: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyAsnArgsDict']]
        cookie: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieArgsDict']]
        forwarded_ip: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgsDict']]
        header: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgsDict']]
        http_method: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgsDict']]
        ip: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyIpArgsDict']]
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyJa4FingerprintArgsDict']]
        label_namespace: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgsDict']]
        query_argument: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgsDict']]
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgsDict']]
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgsDict']]
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyArgs:
    def __init__(__self__, *,
                 asn: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyAsnArgs']] = None,
                 cookie: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieArgs']] = None,
                 forwarded_ip: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgs']] = None,
                 header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgs']] = None,
                 http_method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgs']] = None,
                 ip: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyIpArgs']] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyJa4FingerprintArgs']] = None,
                 label_namespace: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs']] = None,
                 query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgs']] = None):
        if asn is not None:
            pulumi.set(__self__, "asn", asn)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if forwarded_ip is not None:
            pulumi.set(__self__, "forwarded_ip", forwarded_ip)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if label_namespace is not None:
            pulumi.set(__self__, "label_namespace", label_namespace)
        if query_argument is not None:
            pulumi.set(__self__, "query_argument", query_argument)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter
    def asn(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyAsnArgs']]:
        return pulumi.get(self, "asn")

    @asn.setter
    def asn(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyAsnArgs']]):
        pulumi.set(self, "asn", value)

    @_builtins.property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieArgs']]:
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieArgs']]):
        pulumi.set(self, "cookie", value)

    @_builtins.property
    @pulumi.getter(name="forwardedIp")
    def forwarded_ip(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgs']]:
        return pulumi.get(self, "forwarded_ip")

    @forwarded_ip.setter
    def forwarded_ip(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgs']]):
        pulumi.set(self, "forwarded_ip", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgs']]:
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgs']]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgs']]:
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgs']]):
        pulumi.set(self, "http_method", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="labelNamespace")
    def label_namespace(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs']]:
        return pulumi.get(self, "label_namespace")

    @label_namespace.setter
    def label_namespace(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs']]):
        pulumi.set(self, "label_namespace", value)

    @_builtins.property
    @pulumi.getter(name="queryArgument")
    def query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs']]:
        return pulumi.get(self, "query_argument")

    @query_argument.setter
    def query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs']]):
        pulumi.set(self, "query_argument", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyAsnArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyAsnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyAsnArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyCookieArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgsDict']]]
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyCookieArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyCookieArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyCookieTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyForwardedIpArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgsDict']]]
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyHeaderTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyHttpMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyIpArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyIpArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgsDict(TypedDict):
        namespace: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyLabelNamespaceArgs:
    def __init__(__self__, *,
                 namespace: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgsDict']]]
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "text_transformations", text_transformations)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyQueryArgumentTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgsDict']]]
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyQueryStringArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]]):
        pulumi.set(__self__, "text_transformations", text_transformations)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyQueryStringTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgsDict']]]
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyUriPathArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]]):
        pulumi.set(__self__, "text_transformations", text_transformations)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementCustomKeyUriPathTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
        header_name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str],
                 header_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementArgsDict(TypedDict):
        and_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgsDict']]
        asn_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementArgsDict']]
        byte_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgsDict']]
        geo_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgsDict']]
        ip_set_reference_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgsDict']]
        label_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgsDict']]
        not_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgsDict']]
        or_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgsDict']]
        regex_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgsDict']]
        regex_pattern_set_reference_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict']]
        size_constraint_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgsDict']]
        sqli_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgsDict']]
        xss_match_statement: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgsDict']]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementArgs:
    def __init__(__self__, *,
                 and_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs']] = None,
                 asn_match_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementArgs']] = None,
                 byte_match_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs']] = None,
                 geo_match_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs']] = None,
                 ip_set_reference_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs']] = None,
                 label_match_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs']] = None,
                 not_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs']] = None,
                 or_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs']] = None,
                 regex_match_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs']] = None,
                 regex_pattern_set_reference_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']] = None,
                 size_constraint_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs']] = None,
                 sqli_match_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs']] = None,
                 xss_match_statement: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs']] = None):
        if and_statement is not None:
            pulumi.set(__self__, "and_statement", and_statement)
        if asn_match_statement is not None:
            pulumi.set(__self__, "asn_match_statement", asn_match_statement)
        if byte_match_statement is not None:
            pulumi.set(__self__, "byte_match_statement", byte_match_statement)
        if geo_match_statement is not None:
            pulumi.set(__self__, "geo_match_statement", geo_match_statement)
        if ip_set_reference_statement is not None:
            pulumi.set(__self__, "ip_set_reference_statement", ip_set_reference_statement)
        if label_match_statement is not None:
            pulumi.set(__self__, "label_match_statement", label_match_statement)
        if not_statement is not None:
            pulumi.set(__self__, "not_statement", not_statement)
        if or_statement is not None:
            pulumi.set(__self__, "or_statement", or_statement)
        if regex_match_statement is not None:
            pulumi.set(__self__, "regex_match_statement", regex_match_statement)
        if regex_pattern_set_reference_statement is not None:
            pulumi.set(__self__, "regex_pattern_set_reference_statement", regex_pattern_set_reference_statement)
        if size_constraint_statement is not None:
            pulumi.set(__self__, "size_constraint_statement", size_constraint_statement)
        if sqli_match_statement is not None:
            pulumi.set(__self__, "sqli_match_statement", sqli_match_statement)
        if xss_match_statement is not None:
            pulumi.set(__self__, "xss_match_statement", xss_match_statement)

    @_builtins.property
    @pulumi.getter(name="andStatement")
    def and_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs']]:
        return pulumi.get(self, "and_statement")

    @and_statement.setter
    def and_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs']]):
        pulumi.set(self, "and_statement", value)

    @_builtins.property
    @pulumi.getter(name="asnMatchStatement")
    def asn_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementArgs']]:
        return pulumi.get(self, "asn_match_statement")

    @asn_match_statement.setter
    def asn_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementArgs']]):
        pulumi.set(self, "asn_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="byteMatchStatement")
    def byte_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs']]:
        return pulumi.get(self, "byte_match_statement")

    @byte_match_statement.setter
    def byte_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs']]):
        pulumi.set(self, "byte_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="geoMatchStatement")
    def geo_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs']]:
        return pulumi.get(self, "geo_match_statement")

    @geo_match_statement.setter
    def geo_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs']]):
        pulumi.set(self, "geo_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="ipSetReferenceStatement")
    def ip_set_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs']]:
        return pulumi.get(self, "ip_set_reference_statement")

    @ip_set_reference_statement.setter
    def ip_set_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs']]):
        pulumi.set(self, "ip_set_reference_statement", value)

    @_builtins.property
    @pulumi.getter(name="labelMatchStatement")
    def label_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs']]:
        return pulumi.get(self, "label_match_statement")

    @label_match_statement.setter
    def label_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs']]):
        pulumi.set(self, "label_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="notStatement")
    def not_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs']]:
        return pulumi.get(self, "not_statement")

    @not_statement.setter
    def not_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs']]):
        pulumi.set(self, "not_statement", value)

    @_builtins.property
    @pulumi.getter(name="orStatement")
    def or_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs']]:
        return pulumi.get(self, "or_statement")

    @or_statement.setter
    def or_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs']]):
        pulumi.set(self, "or_statement", value)

    @_builtins.property
    @pulumi.getter(name="regexMatchStatement")
    def regex_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs']]:
        return pulumi.get(self, "regex_match_statement")

    @regex_match_statement.setter
    def regex_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs']]):
        pulumi.set(self, "regex_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="regexPatternSetReferenceStatement")
    def regex_pattern_set_reference_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']]:
        return pulumi.get(self, "regex_pattern_set_reference_statement")

    @regex_pattern_set_reference_statement.setter
    def regex_pattern_set_reference_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs']]):
        pulumi.set(self, "regex_pattern_set_reference_statement", value)

    @_builtins.property
    @pulumi.getter(name="sizeConstraintStatement")
    def size_constraint_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs']]:
        return pulumi.get(self, "size_constraint_statement")

    @size_constraint_statement.setter
    def size_constraint_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs']]):
        pulumi.set(self, "size_constraint_statement", value)

    @_builtins.property
    @pulumi.getter(name="sqliMatchStatement")
    def sqli_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs']]:
        return pulumi.get(self, "sqli_match_statement")

    @sqli_match_statement.setter
    def sqli_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs']]):
        pulumi.set(self, "sqli_match_statement", value)

    @_builtins.property
    @pulumi.getter(name="xssMatchStatement")
    def xss_match_statement(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs']]:
        return pulumi.get(self, "xss_match_statement")

    @xss_match_statement.setter
    def xss_match_statement(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs']]):
        pulumi.set(self, "xss_match_statement", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementAndStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementArgsDict(TypedDict):
        asn_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
        forwarded_ip_config: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgsDict']]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementArgs:
    def __init__(__self__, *,
                 asn_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]],
                 forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgs']] = None):
        pulumi.set(__self__, "asn_lists", asn_lists)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @_builtins.property
    @pulumi.getter(name="asnLists")
    def asn_lists(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "asn_lists")

    @asn_lists.setter
    def asn_lists(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "asn_lists", value)

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgs']]:
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
        header_name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementAsnMatchStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str],
                 header_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgsDict(TypedDict):
        positional_constraint: pulumi.Input[_builtins.str]
        search_string: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict']]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementArgs:
    def __init__(__self__, *,
                 positional_constraint: pulumi.Input[_builtins.str],
                 search_string: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "positional_constraint", positional_constraint)
        pulumi.set(__self__, "search_string", search_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="positionalConstraint")
    def positional_constraint(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "positional_constraint")

    @positional_constraint.setter
    def positional_constraint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "positional_constraint", value)

    @_builtins.property
    @pulumi.getter(name="searchString")
    def search_string(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "search_string")

    @search_string.setter
    def search_string(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "search_string", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict']]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementByteMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgsDict(TypedDict):
        country_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        forwarded_ip_config: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict']]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementArgs:
    def __init__(__self__, *,
                 country_codes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']] = None):
        pulumi.set(__self__, "country_codes", country_codes)
        if forwarded_ip_config is not None:
            pulumi.set(__self__, "forwarded_ip_config", forwarded_ip_config)

    @_builtins.property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "country_codes", value)

    @_builtins.property
    @pulumi.getter(name="forwardedIpConfig")
    def forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']]:
        return pulumi.get(self, "forwarded_ip_config")

    @forwarded_ip_config.setter
    def forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs']]):
        pulumi.set(self, "forwarded_ip_config", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
        header_name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementGeoMatchStatementForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str],
                 header_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        ip_set_forwarded_ip_config: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict']]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 ip_set_forwarded_ip_config: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']] = None):
        pulumi.set(__self__, "arn", arn)
        if ip_set_forwarded_ip_config is not None:
            pulumi.set(__self__, "ip_set_forwarded_ip_config", ip_set_forwarded_ip_config)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="ipSetForwardedIpConfig")
    def ip_set_forwarded_ip_config(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]:
        return pulumi.get(self, "ip_set_forwarded_ip_config")

    @ip_set_forwarded_ip_config.setter
    def ip_set_forwarded_ip_config(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs']]):
        pulumi.set(self, "ip_set_forwarded_ip_config", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
        header_name: pulumi.Input[_builtins.str]
        position: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementIpSetReferenceStatementIpSetForwardedIpConfigArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str],
                 header_name: pulumi.Input[_builtins.str],
                 position: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "position", position)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header_name", value)

    @_builtins.property
    @pulumi.getter
    def position(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "position", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        scope: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementLabelMatchStatementArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 scope: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementNotStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgsDict']]]
        """
        The statements to combine.
        """
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementOrStatementArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]] statements: The statements to combine.
        """
        pulumi.set(__self__, "statements", statements)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]:
        """
        The statements to combine.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgsDict(TypedDict):
        regex_string: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict']]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementArgs:
    def __init__(__self__, *,
                 regex_string: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "regex_string", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict']]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict']]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict']]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementRegexPatternSetReferenceStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgsDict(TypedDict):
        comparison_operator: pulumi.Input[_builtins.str]
        size: pulumi.Input[_builtins.int]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict']]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[_builtins.str],
                 size: pulumi.Input[_builtins.int],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "comparison_operator", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict']]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSizeConstraintStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict']]
        sensitivity_level: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']] = None,
                 sensitivity_level: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)

    @_builtins.property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sensitivity_level", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict']]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementSqliMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict']]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict']]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRateBasedStatementScopeDownStatementXssMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementArgsDict(TypedDict):
        regex_string: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchArgsDict']]
elif False:
    WebAclRuleStatementRegexMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementArgs:
    def __init__(__self__, *,
                 regex_string: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "regex_string", regex_string)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="regexString")
    def regex_string(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "regex_string")

    @regex_string.setter
    def regex_string(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "regex_string", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgsDict']]
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRegexMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict']]
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict']]
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRegexPatternSetReferenceStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        rule_action_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgsDict']]]]
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str],
                 rule_action_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgs']]]] = None):
        pulumi.set(__self__, "arn", arn)
        if rule_action_overrides is not None:
            pulumi.set(__self__, "rule_action_overrides", rule_action_overrides)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter(name="ruleActionOverrides")
    def rule_action_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgs']]]]:
        return pulumi.get(self, "rule_action_overrides")

    @rule_action_overrides.setter
    def rule_action_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgs']]]]):
        pulumi.set(self, "rule_action_overrides", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgsDict(TypedDict):
        action_to_use: pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgsDict']
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideArgs:
    def __init__(__self__, *,
                 action_to_use: pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgs'],
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "action_to_use", action_to_use)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="actionToUse")
    def action_to_use(self) -> pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgs']:
        return pulumi.get(self, "action_to_use")

    @action_to_use.setter
    def action_to_use(self, value: pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgs']):
        pulumi.set(self, "action_to_use", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgsDict(TypedDict):
        allow: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgsDict']]
        block: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgsDict']]
        captcha: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgsDict']]
        challenge: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgsDict']]
        count: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgsDict']]
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgs']] = None,
                 block: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgs']] = None,
                 captcha: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgs']] = None,
                 challenge: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgs']] = None,
                 count: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgs']] = None):
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if captcha is not None:
            pulumi.set(__self__, "captcha", captcha)
        if challenge is not None:
            pulumi.set(__self__, "challenge", challenge)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgs']]:
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgs']]):
        pulumi.set(self, "allow", value)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgs']]:
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgs']]):
        pulumi.set(self, "block", value)

    @_builtins.property
    @pulumi.getter
    def captcha(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgs']]:
        return pulumi.get(self, "captcha")

    @captcha.setter
    def captcha(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgs']]):
        pulumi.set(self, "captcha", value)

    @_builtins.property
    @pulumi.getter
    def challenge(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgs']]:
        return pulumi.get(self, "challenge")

    @challenge.setter
    def challenge(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgs']]):
        pulumi.set(self, "challenge", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgs']]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgs']]):
        pulumi.set(self, "count", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict']]
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict']]]
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseAllowCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgsDict(TypedDict):
        custom_response: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgsDict']]
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockArgs:
    def __init__(__self__, *,
                 custom_response: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgs']] = None):
        if custom_response is not None:
            pulumi.set(__self__, "custom_response", custom_response)

    @_builtins.property
    @pulumi.getter(name="customResponse")
    def custom_response(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgs']]:
        return pulumi.get(self, "custom_response")

    @custom_response.setter
    def custom_response(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgs']]):
        pulumi.set(self, "custom_response", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgsDict(TypedDict):
        response_code: pulumi.Input[_builtins.int]
        custom_response_body_key: NotRequired[pulumi.Input[_builtins.str]]
        response_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict']]]]
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseArgs:
    def __init__(__self__, *,
                 response_code: pulumi.Input[_builtins.int],
                 custom_response_body_key: Optional[pulumi.Input[_builtins.str]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]] = None):
        pulumi.set(__self__, "response_code", response_code)
        if custom_response_body_key is not None:
            pulumi.set(__self__, "custom_response_body_key", custom_response_body_key)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "response_code", value)

    @_builtins.property
    @pulumi.getter(name="customResponseBodyKey")
    def custom_response_body_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "custom_response_body_key")

    @custom_response_body_key.setter
    def custom_response_body_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_response_body_key", value)

    @_builtins.property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]]:
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseBlockCustomResponseResponseHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict']]
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict']]]
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCaptchaCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict']]
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict']]]
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseChallengeCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgsDict(TypedDict):
        custom_request_handling: NotRequired[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict']]
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountArgs:
    def __init__(__self__, *,
                 custom_request_handling: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']] = None):
        if custom_request_handling is not None:
            pulumi.set(__self__, "custom_request_handling", custom_request_handling)

    @_builtins.property
    @pulumi.getter(name="customRequestHandling")
    def custom_request_handling(self) -> Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']]:
        return pulumi.get(self, "custom_request_handling")

    @custom_request_handling.setter
    def custom_request_handling(self, value: Optional[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs']]):
        pulumi.set(self, "custom_request_handling", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict(TypedDict):
        insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict']]]
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingArgs:
    def __init__(__self__, *,
                 insert_headers: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(__self__, "insert_headers", insert_headers)

    @_builtins.property
    @pulumi.getter(name="insertHeaders")
    def insert_headers(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]:
        return pulumi.get(self, "insert_headers")

    @insert_headers.setter
    def insert_headers(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs']]]):
        pulumi.set(self, "insert_headers", value)


if not MYPY:
    class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementRuleGroupReferenceStatementRuleActionOverrideActionToUseCountCustomRequestHandlingInsertHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementArgsDict(TypedDict):
        comparison_operator: pulumi.Input[_builtins.str]
        size: pulumi.Input[_builtins.int]
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchArgsDict']]
elif False:
    WebAclRuleStatementSizeConstraintStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[_builtins.str],
                 size: pulumi.Input[_builtins.int],
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "comparison_operator", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgsDict']]
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSizeConstraintStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementSizeConstraintStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSizeConstraintStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchArgsDict']]
        sensitivity_level: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementSqliMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchArgs']] = None,
                 sensitivity_level: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)

    @_builtins.property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sensitivity_level", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgsDict']]
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementSqliMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementSqliMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementSqliMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementArgsDict(TypedDict):
        text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementTextTransformationArgsDict']]]
        field_to_match: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchArgsDict']]
elif False:
    WebAclRuleStatementXssMatchStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementArgs:
    def __init__(__self__, *,
                 text_transformations: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementTextTransformationArgs']]],
                 field_to_match: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchArgs']] = None):
        pulumi.set(__self__, "text_transformations", text_transformations)
        if field_to_match is not None:
            pulumi.set(__self__, "field_to_match", field_to_match)

    @_builtins.property
    @pulumi.getter(name="textTransformations")
    def text_transformations(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementTextTransformationArgs']]]:
        return pulumi.get(self, "text_transformations")

    @text_transformations.setter
    def text_transformations(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementTextTransformationArgs']]]):
        pulumi.set(self, "text_transformations", value)

    @_builtins.property
    @pulumi.getter(name="fieldToMatch")
    def field_to_match(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchArgs']]:
        return pulumi.get(self, "field_to_match")

    @field_to_match.setter
    def field_to_match(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchArgs']]):
        pulumi.set(self, "field_to_match", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchArgsDict(TypedDict):
        all_query_arguments: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict']]
        body: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgsDict']]
        cookies: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgsDict']]
        header_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict']]]]
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgsDict']]]]
        ja3_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict']]
        ja4_fingerprint: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJa4FingerprintArgsDict']]
        json_body: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgsDict']]
        method: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgsDict']]
        query_string: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgsDict']]
        single_header: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict']]
        single_query_argument: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict']]
        uri_fragment: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchUriFragmentArgsDict']]
        uri_path: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgsDict']]
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchArgs:
    def __init__(__self__, *,
                 all_query_arguments: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']] = None,
                 body: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgs']] = None,
                 cookies: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgs']] = None,
                 header_orders: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]]] = None,
                 ja3_fingerprint: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']] = None,
                 ja4_fingerprint: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJa4FingerprintArgs']] = None,
                 json_body: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs']] = None,
                 method: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgs']] = None,
                 query_string: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgs']] = None,
                 single_header: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs']] = None,
                 single_query_argument: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']] = None,
                 uri_fragment: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchUriFragmentArgs']] = None,
                 uri_path: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgs']] = None):
        if all_query_arguments is not None:
            pulumi.set(__self__, "all_query_arguments", all_query_arguments)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if header_orders is not None:
            pulumi.set(__self__, "header_orders", header_orders)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ja3_fingerprint is not None:
            pulumi.set(__self__, "ja3_fingerprint", ja3_fingerprint)
        if ja4_fingerprint is not None:
            pulumi.set(__self__, "ja4_fingerprint", ja4_fingerprint)
        if json_body is not None:
            pulumi.set(__self__, "json_body", json_body)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if single_query_argument is not None:
            pulumi.set(__self__, "single_query_argument", single_query_argument)
        if uri_fragment is not None:
            pulumi.set(__self__, "uri_fragment", uri_fragment)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter(name="allQueryArguments")
    def all_query_arguments(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]:
        return pulumi.get(self, "all_query_arguments")

    @all_query_arguments.setter
    def all_query_arguments(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs']]):
        pulumi.set(self, "all_query_arguments", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgs']]:
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgs']]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def cookies(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgs']]:
        return pulumi.get(self, "cookies")

    @cookies.setter
    def cookies(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgs']]):
        pulumi.set(self, "cookies", value)

    @_builtins.property
    @pulumi.getter(name="headerOrders")
    def header_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]:
        return pulumi.get(self, "header_orders")

    @header_orders.setter
    def header_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs']]]]):
        pulumi.set(self, "header_orders", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="ja3Fingerprint")
    def ja3_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]:
        return pulumi.get(self, "ja3_fingerprint")

    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs']]):
        pulumi.set(self, "ja3_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="ja4Fingerprint")
    def ja4_fingerprint(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJa4FingerprintArgs']]:
        return pulumi.get(self, "ja4_fingerprint")

    @ja4_fingerprint.setter
    def ja4_fingerprint(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJa4FingerprintArgs']]):
        pulumi.set(self, "ja4_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="jsonBody")
    def json_body(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs']]:
        return pulumi.get(self, "json_body")

    @json_body.setter
    def json_body(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs']]):
        pulumi.set(self, "json_body", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgs']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgs']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="singleQueryArgument")
    def single_query_argument(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]:
        return pulumi.get(self, "single_query_argument")

    @single_query_argument.setter
    def single_query_argument(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs']]):
        pulumi.set(self, "single_query_argument", value)

    @_builtins.property
    @pulumi.getter(name="uriFragment")
    def uri_fragment(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchUriFragmentArgs']]:
        return pulumi.get(self, "uri_fragment")

    @uri_fragment.setter
    def uri_fragment(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchUriFragmentArgs']]):
        pulumi.set(self, "uri_fragment", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgs']]:
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgs']]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchAllQueryArgumentsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgsDict(TypedDict):
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchBodyArgs:
    def __init__(__self__, *,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgsDict(TypedDict):
        match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict']]]
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchCookiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs']]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict']]
        excluded_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_cookies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']] = None,
                 excluded_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_cookies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_cookies is not None:
            pulumi.set(__self__, "excluded_cookies", excluded_cookies)
        if included_cookies is not None:
            pulumi.set(__self__, "included_cookies", included_cookies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedCookies")
    def excluded_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_cookies")

    @excluded_cookies.setter
    def excluded_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_cookies", value)

    @_builtins.property
    @pulumi.getter(name="includedCookies")
    def included_cookies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_cookies")

    @included_cookies.setter
    def included_cookies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_cookies", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchCookiesMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict']]
        excluded_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        included_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']] = None,
                 excluded_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 included_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if excluded_headers is not None:
            pulumi.set(__self__, "excluded_headers", excluded_headers)
        if included_headers is not None:
            pulumi.set(__self__, "included_headers", included_headers)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="excludedHeaders")
    def excluded_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_headers")

    @excluded_headers.setter
    def excluded_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_headers", value)

    @_builtins.property
    @pulumi.getter(name="includedHeaders")
    def included_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_headers")

    @included_headers.setter
    def included_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_headers", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict(TypedDict):
        oversize_handling: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchHeaderOrderArgs:
    def __init__(__self__, *,
                 oversize_handling: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJa3FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchJa4FingerprintArgsDict(TypedDict):
        fallback_behavior: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchJa4FingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJa4FingerprintArgs:
    def __init__(__self__, *,
                 fallback_behavior: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgsDict(TypedDict):
        match_pattern: pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict']
        match_scope: pulumi.Input[_builtins.str]
        invalid_fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
        oversize_handling: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyArgs:
    def __init__(__self__, *,
                 match_pattern: pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs'],
                 match_scope: pulumi.Input[_builtins.str],
                 invalid_fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 oversize_handling: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_pattern", match_pattern)
        pulumi.set(__self__, "match_scope", match_scope)
        if invalid_fallback_behavior is not None:
            pulumi.set(__self__, "invalid_fallback_behavior", invalid_fallback_behavior)
        if oversize_handling is not None:
            pulumi.set(__self__, "oversize_handling", oversize_handling)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs']):
        pulumi.set(self, "match_pattern", value)

    @_builtins.property
    @pulumi.getter(name="matchScope")
    def match_scope(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_scope")

    @match_scope.setter
    def match_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_scope", value)

    @_builtins.property
    @pulumi.getter(name="invalidFallbackBehavior")
    def invalid_fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "invalid_fallback_behavior")

    @invalid_fallback_behavior.setter
    def invalid_fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_fallback_behavior", value)

    @_builtins.property
    @pulumi.getter(name="oversizeHandling")
    def oversize_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oversize_handling")

    @oversize_handling.setter
    def oversize_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oversize_handling", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict(TypedDict):
        all: NotRequired[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict']]
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input['WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs']]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_paths", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchJsonBodyMatchPatternAllArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchMethodArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchQueryStringArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchSingleQueryArgumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchUriFragmentArgsDict(TypedDict):
        fallback_behavior: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchUriFragmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchUriFragmentArgs:
    def __init__(__self__, *,
                 fallback_behavior: Optional[pulumi.Input[_builtins.str]] = None):
        if fallback_behavior is not None:
            pulumi.set(__self__, "fallback_behavior", fallback_behavior)

    @_builtins.property
    @pulumi.getter(name="fallbackBehavior")
    def fallback_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fallback_behavior")

    @fallback_behavior.setter
    def fallback_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_behavior", value)


if not MYPY:
    class WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgsDict(TypedDict):
        pass
elif False:
    WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementFieldToMatchUriPathArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WebAclRuleStatementXssMatchStatementTextTransformationArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
elif False:
    WebAclRuleStatementXssMatchStatementTextTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleStatementXssMatchStatementTextTransformationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebAclRuleVisibilityConfigArgsDict(TypedDict):
        cloudwatch_metrics_enabled: pulumi.Input[_builtins.bool]
        metric_name: pulumi.Input[_builtins.str]
        sampled_requests_enabled: pulumi.Input[_builtins.bool]
elif False:
    WebAclRuleVisibilityConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclRuleVisibilityConfigArgs:
    def __init__(__self__, *,
                 cloudwatch_metrics_enabled: pulumi.Input[_builtins.bool],
                 metric_name: pulumi.Input[_builtins.str],
                 sampled_requests_enabled: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "cloudwatch_metrics_enabled", cloudwatch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @_builtins.property
    @pulumi.getter(name="cloudwatchMetricsEnabled")
    def cloudwatch_metrics_enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "cloudwatch_metrics_enabled")

    @cloudwatch_metrics_enabled.setter
    def cloudwatch_metrics_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "cloudwatch_metrics_enabled", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "sampled_requests_enabled")

    @sampled_requests_enabled.setter
    def sampled_requests_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "sampled_requests_enabled", value)


if not MYPY:
    class WebAclVisibilityConfigArgsDict(TypedDict):
        cloudwatch_metrics_enabled: pulumi.Input[_builtins.bool]
        metric_name: pulumi.Input[_builtins.str]
        sampled_requests_enabled: pulumi.Input[_builtins.bool]
elif False:
    WebAclVisibilityConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAclVisibilityConfigArgs:
    def __init__(__self__, *,
                 cloudwatch_metrics_enabled: pulumi.Input[_builtins.bool],
                 metric_name: pulumi.Input[_builtins.str],
                 sampled_requests_enabled: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "cloudwatch_metrics_enabled", cloudwatch_metrics_enabled)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "sampled_requests_enabled", sampled_requests_enabled)

    @_builtins.property
    @pulumi.getter(name="cloudwatchMetricsEnabled")
    def cloudwatch_metrics_enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "cloudwatch_metrics_enabled")

    @cloudwatch_metrics_enabled.setter
    def cloudwatch_metrics_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "cloudwatch_metrics_enabled", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter(name="sampledRequestsEnabled")
    def sampled_requests_enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "sampled_requests_enabled")

    @sampled_requests_enabled.setter
    def sampled_requests_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "sampled_requests_enabled", value)


